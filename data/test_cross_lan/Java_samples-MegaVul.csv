function,label
"public void run() {
                // clean up the session's bookkeeping
                synchronized (mSession) {
                    mSession.mRestoreTransport = null;
                    mSession.mEnded = true;
                }

                // clean up the BackupManagerImpl side of the bookkeeping
                // and cancel any pending timeout message
                mBackupManager.clearRestoreSession(mSession);
            }",0
"void initPrivateFields(ObjectStreamClass desc) {
        methodWriteReplace = desc.methodWriteReplace;
        methodReadResolve = desc.methodReadResolve;
        methodWriteObject = desc.methodWriteObject;
        methodReadObject = desc.methodReadObject;
        methodReadObjectNoData = desc.methodReadObjectNoData;
    }",0
"@Override
    public int setErrorParameter(BeforeEnterEvent event,
            ErrorParameter<NotFoundException> parameter) {
        String path = event.getLocation().getPath();
        String additionalInfo = """";
        if (parameter.hasCustomMessage()) {
            additionalInfo = ""Reason: "" + parameter.getCustomMessage();
        }
        path = Jsoup.clean(path, Whitelist.none());
        additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());

        boolean productionMode = event.getUI().getSession().getConfiguration()
                .isProductionMode();

        String template = getErrorHtml(productionMode);
        // {{routes}} should be replaced first so that it's not possible to
        // insert {{routes}} snippet via other template values which may result
        // in the listing of all available routes when this shouldn't not happen
        if (template.contains(""{{routes}}"")) {
            template = template.replace(""{{routes}}"", getRoutes(event));
        }
        template = template.replace(""{{additionalInfo}}"", additionalInfo);
        template = template.replace(""{{path}}"", path);

        getElement().appendChild(new Html(template).getElement());
        return HttpServletResponse.SC_NOT_FOUND;
    }",1
"@Override
    protected void bindListener() {
        final Class bgListenerClass = getBackgroundLocationListener();
        Thread t = new Thread(new Runnable() {

            @Override
            public void run() {
                //wait until the client is connected, otherwise the call to
                //requestLocationUpdates will fail
                while (!getmGoogleApiClient().isConnected()) {
                    try {
                        Thread.sleep(300);
                    } catch (Exception ex) {
                    }
                }
                Handler mHandler = new Handler(Looper.getMainLooper());
                mHandler.post(new Runnable() {

                    public void run() {
                        LocationRequest r = locationRequest;

                        com.codename1.location.LocationRequest request = getRequest();
                        if (request != null) {
                            LocationRequest lr = LocationRequest.create();
                            if (request.getPriority() == com.codename1.location.LocationRequest.PRIORITY_HIGH_ACCUARCY) {
                                lr.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);
                            } else if (request.getPriority() == com.codename1.location.LocationRequest.PRIORITY_MEDIUM_ACCUARCY) {
                                lr.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY);
                            } else {
                                lr.setPriority(LocationRequest.PRIORITY_LOW_POWER);
                            }
                            lr.setInterval(request.getInterval());
                            r = lr;
                        }
                        if (AndroidImplementation.getActivity() == null) {
                            // we are in the background
                            // Sometimes using regular locations in the background causes a crash
                            // so we need to use the pending intent version.
                            Context context = AndroidNativeUtil.getContext();

                            Intent intent = new Intent(context, BackgroundLocationHandler.class);
                            //there is an bug that causes this to not to workhttps://code.google.com/p/android/issues/detail?id=81812
                            //intent.putExtra(""backgroundClass"", getBackgroundLocationListener().getName());
                            //an ugly workaround to the putExtra bug 
                            if (bgListenerClass != null) {
                                intent.setData(Uri.parse(""http://codenameone.com/a?"" + bgListenerClass.getName()));
                            }
                            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,
                                    intent);
                            inMemoryBackgroundLocationListener = AndroidLocationPlayServiceManager.this;


                            //LocationServices.FusedLocationApi.requestLocationUpdates(getmGoogleApiClient(), r, pendingIntent);
                            requestLocationUpdates(context, r, pendingIntent);
                        } else {
                            //LocationServices.FusedLocationApi.requestLocationUpdates(getmGoogleApiClient(), r, AndroidLocationPlayServiceManager.this);
                            requestLocationUpdates(AndroidNativeUtil.getContext(), r, AndroidLocationPlayServiceManager.this);
                        }
                    }
                });
            }
        });
        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);
        t.start();
    }",1
"private boolean updateUserPictureAndName(Profile showUser, String picture, String name) {
		boolean updateProfile = false;
		boolean updateUser = false;
		User u = showUser.getUser();

		if (CONF.avatarEditsEnabled() && !StringUtils.isBlank(picture)) {
			updateProfile = avatarRepository.store(showUser, picture);
		}

		if (CONF.nameEditsEnabled() && !StringUtils.isBlank(name)) {
			showUser.setName(StringUtils.abbreviate(name, 256));
			if (StringUtils.isBlank(showUser.getOriginalName())) {
				showUser.setOriginalName(name);
			}
			if (!u.getName().equals(name)) {
				u.setName(name);
				updateUser = true;
			}
			updateProfile = true;
		}

		if (updateUser) {
			utils.getParaClient().update(u);
		}
		return updateProfile;
	}",1
"@Override
        public void onPlay() {
            //super.onPlay();
            if( !successfullyRetrievedAudioFocus() ) {
                return;
            }

            mMediaSessionCompat.setActive(true);
            setMediaPlaybackState(PlaybackStateCompat.STATE_PLAYING);


            //mMediaPlayer.start();
            RemoteControlCallback.play();
            initMediaSessionMetadata();
            showPlayingNotification();
        }",0
"public void restoreStarting(int userId) {
            if (DEBUG) {
                Slog.i(TAG, ""Restore starting for user: "" + userId);
            }

            synchronized (mLock) {
                // We're starting a new ""system"" restore operation, so any widget restore
                // state that we see from here on is intended to replace the current
                // widget configuration of any/all of the affected apps.
                mPrunedApps.clear();
                mUpdatesByProvider.clear();
                mUpdatesByHost.clear();
            }
        }",0
"protected Message getRegisteredMessage(Instance instance, EvaluationContext context) {
		String activitySubtitle = evaluateExpression(context, registerActivitySubtitle);
		return createMessage(instance, registeredTitle, activitySubtitle, context);
	}",1
"public void showNotifyPublic() {
        super.showNotify();
    }",0
"@Override
    public void onSelectMenuInteraction(@NotNull SelectMenuInteractionEvent event) {
        super.onSelectMenuInteraction(event);

        if (event.getInteraction().getComponent().getId() == null ||
                event.getGuild() == null)
            return;

        if (event.getMessage().getEmbeds().isEmpty() ||
                event.getMessage().getEmbeds().get(0) == null ||
                event.getInteraction().getSelectedOptions().isEmpty())
            return;

        if (event.getInteraction().getValues().isEmpty())
            return;

        switch (event.getInteraction().getComponent().getId()) {
            case ""setupActionMenu"" -> {

                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                List<SelectOption> optionList = new ArrayList<>();

                switch (event.getInteraction().getValues().get(0)) {
                    case ""log"" -> {
                        optionList.add(SelectOption.of(""Setup"", ""logSetup""));

                        if (Main.getInstance().getSqlConnector().getSqlWorker().isLogSetup(event.getGuild().getId()))
                            optionList.add(SelectOption.of(""Delete"", ""logDelete""));

                        optionList.add(SelectOption.of(""Back to Menu"", ""backToSetupMenu""));

                        embedBuilder.setDescription(""You can set up our own Audit-Logging which provides all the Information over and Webhook into the Channel of your desire! "" + ""But ours is not the same as the default Auditions, ours gives your the ability to set what you want to be logged and what not! "" + ""We also allow you to log Voice Events!"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(new SelectMenuImpl(""setupLogMenu"", ""Select your Action"", 1, 1, false, optionList)).queue();
                    }

                    case ""welcome"" -> {
                        optionList.add(SelectOption.of(""Setup"", ""welcomeSetup""));

                        if (Main.getInstance().getSqlConnector().getSqlWorker().isWelcomeSetup(event.getGuild().getId()))
                            optionList.add(SelectOption.of(""Delete"", ""welcomeDelete""));

                        optionList.add(SelectOption.of(""Back to Menu"", ""backToSetupMenu""));

                        embedBuilder.setDescription(""You can set up our own Welcome-Messages!\nYou can choice the Welcome-Channel by your own and even configure the Message!"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(new SelectMenuImpl(""setupWelcomeMenu"", ""Select your Action"", 1, 1, false, optionList)).queue();
                    }

                    case ""autorole"" -> {
                        embedBuilder.setDescription(""You can set up our own Autorole-System!\nYou can select Roles that Users should get upon joining the Server!"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(Button.link(""https://cp.ree6.de"", ""Webinterface"")).queue();
                    }

                    case ""tempvoice"" -> {
                        optionList.add(SelectOption.of(""Setup"", ""tempVoiceSetup""));

                        if (Main.getInstance().getSqlConnector().getSqlWorker().getEntity(TemporalVoicechannel.class, ""SELECT * FROM TemporalVoicechannel WHERE GID=?"", event.getGuild().getId()).isSuccess())
                            optionList.add(SelectOption.of(""Delete"", ""tempVoiceDelete""));

                        optionList.add(SelectOption.of(""Back to Menu"", ""backToSetupMenu""));

                        embedBuilder.setDescription(""You can set up your own Temporal Voicechannel!\nBy setting up Temporal Voicechannel on a specific channel which will be used to create a new Voicechannel when ever someones joins into it!"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(new SelectMenuImpl(""setupTempVoiceMenu"", ""Select your Action"", 1, 1, false, optionList)).queue();
                    }

                    case ""statistics"" -> {
                        optionList.add(SelectOption.of(""Setup Member Statistics"", ""statisticsSetupMember""));
                        optionList.add(SelectOption.of(""Setup Twitch Statistics"", ""statisticsSetupTwitch""));
                        optionList.add(SelectOption.of(""Setup YouTube Statistics"", ""statisticsSetupYouTube""));
                        optionList.add(SelectOption.of(""Setup Reddit Statistics"", ""statisticsSetupReddit""));
                        optionList.add(SelectOption.of(""Setup Twitter Statistics"", ""statisticsSetupTwitter""));
                        optionList.add(SelectOption.of(""Setup Instagram Statistics"", ""statisticsSetupInstagram""));

                        optionList.add(SelectOption.of(""Back to Menu"", ""backToSetupMenu""));

                        embedBuilder.setDescription(""You can set up your own Statistic-channels!\nBy setting up Statistic-channels Ree6 will create new channels for each Statistic-Type that you setup!\nIf you want to get rid of a Statistic-Channel, just delete it!"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(new SelectMenuImpl(""setupStatisticsMenu"", ""Select your Action"", 1, 1, false, optionList)).queue();
                    }

                    default -> {
                        embedBuilder.setDescription(""You somehow selected a Invalid Option? Are you a Wizard?"");
                        event.editMessageEmbeds(embedBuilder.build()).queue();
                    }
                }
            }

            case ""setupStatisticsMenu"" -> {

                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                switch (event.getInteraction().getValues().get(0)) {

                    case ""backToSetupMenu"" -> sendDefaultChoice(event);

                    case ""statisticsSetupMember"" -> {
                        embedBuilder.setDescription(""Successfully setup the statistics channels for Member statistics!"");
                        embedBuilder.setColor(Color.GREEN);
                        event.editMessageEmbeds(embedBuilder.build()).setComponents(new ArrayList<>()).queue();
                        List<Category> categories = event.getGuild().getCategoriesByName(""Statistics"", true);

                        Category category;

                        if (categories.isEmpty()) {
                            category = event.getGuild().createCategory(""Statistics"").complete();
                        } else {
                            category = categories.get(0);
                        }

                        event.getGuild().loadMembers().onSuccess(members -> event.getGuild().createVoiceChannel(""Overall Members: "" + event.getGuild().getMemberCount(), category).queue(voiceChannel -> {
                            voiceChannel.getManager().setUserLimit(0).queue();
                            event.getGuild().createVoiceChannel(""Real Members: "" + members.stream().filter(member -> !member.getUser().isBot()).count(), category).queue(voiceChannel1 -> {
                                voiceChannel1.getManager().setUserLimit(0).queue();
                                event.getGuild().createVoiceChannel(""Bot Members: "" + members.stream().filter(member -> member.getUser().isBot()).count(), category).queue(voiceChannel2 -> {
                                    voiceChannel2.getManager().setUserLimit(0).queue();
                                    SQLResponse sqlResponse = Main.getInstance().getSqlConnector().getSqlWorker().getEntity(ChannelStats.class, ""SELECT * FROM ChannelStats WHERE GID=?"", event.getGuild().getId());
                                    ChannelStats channelStats;

                                    if (sqlResponse.isSuccess()) {
                                        channelStats = (ChannelStats) sqlResponse.getEntity();
                                        ChannelStats oldChannelStats = (ChannelStats) SQLUtil.cloneEntity(ChannelStats.class, channelStats);
                                        if (channelStats.getMemberStatsChannelId() != null) {
                                            VoiceChannel voiceChannel3 = event.getGuild().getVoiceChannelById(channelStats.getMemberStatsChannelId());

                                            if (voiceChannel3 != null)
                                                voiceChannel3.delete().queue();
                                        }
                                        if (channelStats.getRealMemberStatsChannelId() != null) {
                                            VoiceChannel voiceChannel3 = event.getGuild().getVoiceChannelById(channelStats.getRealMemberStatsChannelId());

                                            if (voiceChannel3 != null)
                                                voiceChannel3.delete().queue();
                                        }
                                        if (channelStats.getBotMemberStatsChannelId() != null) {
                                            VoiceChannel voiceChannel3 = event.getGuild().getVoiceChannelById(channelStats.getBotMemberStatsChannelId());

                                            if (voiceChannel3 != null)
                                                voiceChannel3.delete().queue();
                                        }
                                        channelStats.setMemberStatsChannelId(voiceChannel.getId());
                                        channelStats.setRealMemberStatsChannelId(voiceChannel1.getId());
                                        channelStats.setBotMemberStatsChannelId(voiceChannel2.getId());
                                        Main.getInstance().getSqlConnector().getSqlWorker().updateEntity(oldChannelStats, channelStats, false);
                                    } else {
                                        channelStats = new ChannelStats(event.getGuild().getId(),
                                                voiceChannel.getId(),
                                                voiceChannel1.getId(),
                                                voiceChannel2.getId(),
                                                null,
                                                null,
                                                null,
                                                null,
                                                null,
                                                null,
                                                null,
                                                null,
                                                null,
                                                null);
                                        Main.getInstance().getSqlConnector().getSqlWorker().saveEntity(channelStats);
                                    }
                                });
                            });
                        }));
                    }

                    case ""statisticsSetupTwitch"" -> {
                        TextInput input = TextInput.create(""twitchChannelName"", ""Twitch Channel Name"", TextInputStyle.SHORT).setMinLength(1).setMaxLength(50).setRequired(true).setPlaceholder(""Enter the Twitch Channel name here!"").build();

                        Modal modal = Modal.create(""statisticsSetupTwitchModal"", ""Twitch Statistic Channel"").addActionRow(input).build();

                        event.replyModal(modal).queue();
                    }

                    case ""statisticsSetupYouTube"" -> {
                        TextInput input = TextInput.create(""youtubeChannelName"", ""YouTube Channel Name"", TextInputStyle.SHORT).setMinLength(1).setMaxLength(50).setRequired(true).setPlaceholder(""Enter the YouTube Channel name here!"").build();

                        Modal modal = Modal.create(""statisticsSetupYouTubeModal"", ""YouTube Statistic Channel"").addActionRow(input).build();

                        event.replyModal(modal).queue();
                    }

                    case ""statisticsSetupReddit"" -> {
                        TextInput input = TextInput.create(""subredditName"", ""Subreddit Name"", TextInputStyle.SHORT).setMinLength(1).setMaxLength(50).setRequired(true).setPlaceholder(""Enter the Subreddit name here!"").build();

                        Modal modal = Modal.create(""statisticsSetupRedditModal"", ""Reddit Statistic Channel"").addActionRow(input).build();

                        event.replyModal(modal).queue();
                    }

                    case ""statisticsSetupTwitter"" -> {
                        TextInput input = TextInput.create(""twitterName"", ""Twitter Name"", TextInputStyle.SHORT).setMinLength(1).setMaxLength(50).setRequired(true).setPlaceholder(""Enter the Twitter name here!"").build();

                        Modal modal = Modal.create(""statisticsSetupTwitterModal"", ""Twitter Statistic Channel"").addActionRow(input).build();

                        event.replyModal(modal).queue();
                    }

                    case ""statisticsSetupInstagram"" -> {
                        TextInput input = TextInput.create(""instagramName"", ""Instagram Name"", TextInputStyle.SHORT).setMinLength(1).setMaxLength(50).setRequired(true).setPlaceholder(""Enter the Instagram name here!"").build();

                        Modal modal = Modal.create(""statisticsSetupInstagramModal"", ""Instagram Statistic Channel"").addActionRow(input).build();

                        event.replyModal(modal).queue();
                    }

                    default -> {
                        if (event.getMessage().getEmbeds().isEmpty() || event.getMessage().getEmbeds().get(0) == null)
                            return;

                        embedBuilder.setDescription(""You somehow selected a Invalid Option? Are you a Wizard?"");
                        event.editMessageEmbeds(embedBuilder.build()).queue();
                    }
                }
            }

            case ""setupTempVoicechannel"" -> {
                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                VoiceChannel voiceChannel = event.getGuild().getVoiceChannelById(event.getInteraction().getValues().get(0));

                if (voiceChannel != null) {
                    Main.getInstance().getSqlConnector().getSqlWorker().saveEntity(new TemporalVoicechannel(event.getGuild().getId(), voiceChannel.getId()));
                    embedBuilder.setDescription(""Successfully changed the Temporal Voicechannel, nice work!"");
                    embedBuilder.setColor(Color.GREEN);
                    event.editMessageEmbeds(embedBuilder.build()).setComponents(new ArrayList<>()).queue();
                } else {
                    embedBuilder.setDescription(""The given Channel doesn't exists, how did you select it? Are you a Wizard?"");
                    event.editMessageEmbeds(embedBuilder.build()).queue();
                }
            }

            case ""setupTempVoiceMenu"" -> {

                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                List<SelectOption> optionList = new ArrayList<>();

                switch (event.getInteraction().getValues().get(0)) {

                    case ""backToSetupMenu"" -> sendDefaultChoice(event);

                    case ""tempVoiceSetup"" -> {
                        for (VoiceChannel channel : event.getGuild().getVoiceChannels()) {
                            optionList.add(SelectOption.of(channel.getName(), channel.getId()));
                        }

                        embedBuilder.setDescription(""Which Channel do you want to use as Temporal-Voicechannel?"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(new SelectMenuImpl(""setupTempVoicechannel"", ""Select a Channel!"", 1, 1, false, optionList)).queue();
                    }

                    default -> {
                        if (event.getMessage().getEmbeds().isEmpty() || event.getMessage().getEmbeds().get(0) == null)
                            return;

                        embedBuilder.setDescription(""You somehow selected a Invalid Option? Are you a Wizard?"");
                        event.editMessageEmbeds(embedBuilder.build()).queue();
                    }
                }
            }

            case ""setupLogMenu"" -> {

                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                List<SelectOption> optionList = new ArrayList<>();

                switch (event.getInteraction().getValues().get(0)) {

                    case ""backToSetupMenu"" -> sendDefaultChoice(event);

                    case ""logSetup"" -> {
                        for (TextChannel channel : event.getGuild().getTextChannels()) {
                            optionList.add(SelectOption.of(channel.getName(), channel.getId()));
                        }

                        embedBuilder.setDescription(""Which Channel do you want to use as Logging-Channel?"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(new SelectMenuImpl(""setupLogChannel"", ""Select a Channel!"", 1, 1, false, optionList)).queue();
                    }

                    default -> {
                        if (event.getMessage().getEmbeds().isEmpty() || event.getMessage().getEmbeds().get(0) == null)
                            return;

                        embedBuilder.setDescription(""You somehow selected a Invalid Option? Are you a Wizard?"");
                        event.editMessageEmbeds(embedBuilder.build()).queue();
                    }
                }
            }

            case ""setupLogChannel"" -> {

                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                TextChannel textChannel = event.getGuild().getTextChannelById(event.getInteraction().getValues().get(0));

                if (textChannel != null) {
                    textChannel.createWebhook(""Ree6-Logs"").queue(webhook -> {
                        Main.getInstance().getSqlConnector().getSqlWorker().setLogWebhook(event.getGuild().getId(), webhook.getId(), webhook.getToken());
                        embedBuilder.setDescription(""Successfully changed the Logging Channel, nice work!"");
                        embedBuilder.setColor(Color.GREEN);
                        event.editMessageEmbeds(embedBuilder.build()).setComponents(new ArrayList<>()).queue();
                    });
                } else {
                    embedBuilder.setDescription(""The given Channel doesn't exists, how did you select it? Are you a Wizard?"");
                    event.editMessageEmbeds(embedBuilder.build()).queue();
                }

            }

            case ""setupWelcomeMenu"" -> {

                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                List<SelectOption> optionList = new ArrayList<>();

                switch (event.getInteraction().getValues().get(0)) {

                    case ""backToSetupMenu"" -> sendDefaultChoice(event);

                    case ""welcomeSetup"" -> {
                        for (TextChannel channel : event.getGuild().getTextChannels()) {
                            optionList.add(SelectOption.of(channel.getName(), channel.getId()));
                        }

                        embedBuilder.setDescription(""Which Channel do you want to use as Welcome-Channel?"");

                        event.editMessageEmbeds(embedBuilder.build()).setActionRow(new SelectMenuImpl(""setupWelcomeChannel"", ""Select a Channel!"", 1, 1, false, optionList)).queue();
                    }

                    default -> {
                        if (event.getMessage().getEmbeds().isEmpty() || event.getMessage().getEmbeds().get(0) == null)
                            return;

                        embedBuilder.setDescription(""You somehow selected a Invalid Option? Are you a Wizard?"");
                        event.editMessageEmbeds(embedBuilder.build()).queue();
                    }
                }
            }

            case ""setupWelcomeChannel"" -> {

                if (checkPerms(event.getMember(), event.getChannel())) {
                    return;
                }

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                TextChannel textChannel = event.getGuild().getTextChannelById(event.getInteraction().getValues().get(0));

                if (textChannel != null) {
                    textChannel.createWebhook(""Ree6-Welcome"").queue(webhook -> {
                        Main.getInstance().getSqlConnector().getSqlWorker().setWelcomeWebhook(event.getGuild().getId(), webhook.getId(), webhook.getToken());
                        embedBuilder.setDescription(""Successfully changed the Welcome-Channel, nice work!"");
                        embedBuilder.setColor(Color.GREEN);
                        event.editMessageEmbeds(embedBuilder.build()).setComponents(new ArrayList<>()).queue();
                    });
                } else {
                    embedBuilder.setDescription(""The given Channel doesn't exists, how did you select it? Are you a Wizard?"");
                    event.editMessageEmbeds(embedBuilder.build()).queue();
                }

            }

            default -> {
                if (event.getMessage().getEmbeds().isEmpty() || event.getMessage().getEmbeds().get(0) == null) return;

                EmbedBuilder embedBuilder = new EmbedBuilder(event.getMessage().getEmbeds().get(0));

                embedBuilder.setDescription(""You somehow selected a Invalid Option? Are you a Wizard?"");
                event.editMessageEmbeds(embedBuilder.build()).queue();
            }
        }
    }",1
"public Stream<Class<? extends NodeFeature>> getAllFeatures() {
            return Stream.concat(nonReportableFeatures.stream(),
                    reportedFeatures.stream());
        }",0
"private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> certificates) {
    certificates.forEach(cert -> {
      KeyDescriptorType key = new KeyDescriptorType();
      key.setUse(KeyTypes.SIGNING);
      KeyInfoType info = new KeyInfoType();
      key.setKeyInfo(info);
      X509DataType data = new X509DataType();
      info.getContent().add(DSIG_OBJECT_FACTORY.createX509Data(data));

      try {
        JAXBElement<byte[]> certElement = DSIG_OBJECT_FACTORY.createX509DataTypeX509Certificate(cert.getEncoded());
        data.getX509IssuerSerialOrX509SKIOrX509SubjectName().add(certElement);
        descriptor.getKeyDescriptor().add(key);
      } catch (Exception e) {
        // Rethrow
        throw new IllegalArgumentException(e);
      }
    });
  }",0
"private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {
    if (!nettyRequest.decoderResult().isSuccess()) {
      LOGGER.debug(""Failed to decode HTTP request."", nettyRequest.decoderResult().cause());
      sendError(ctx, HttpResponseStatus.BAD_REQUEST);
      return;
    }

    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());

    //Find the content length we will use this as an indicator of a body
    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);
    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);

    //If there is a content length or transfer encoding that indicates there is a body
    boolean hasBody = (contentLength > 0) || (transferEncoding != null);

    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;

    Channel channel = ctx.channel();

    if (requestBody != null) {
      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);
    }
    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();
    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();

    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);

    DefaultRequest request = new DefaultRequest(
      clock.instant(),
      requestHeaders,
      nettyRequest.method(),
      nettyRequest.protocolVersion(),
      nettyRequest.uri(),
      remoteAddress,
      socketAddress,
      serverRegistry.get(ServerConfig.class),
      requestBody,
      connectionIdleTimeout,
      channel.attr(CLIENT_CERT_KEY).get()
    );

    HttpHeaders nettyHeaders = new DefaultHttpHeaders();
    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);
    AtomicBoolean transmitted = new AtomicBoolean(false);

    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);

    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);

    Action<Action<Object>> subscribeHandler = thing -> {
      transmitted.set(true);
      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);
    };

    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(
      applicationConstants,
      request,
      channel,
      responseTransmitter,
      subscribeHandler
    );

    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);
    requestConstants.response = response;

    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {
      if (!transmitted.get()) {
        Handler lastHandler = requestConstants.handler;
        StringBuilder description = new StringBuilder();
        description
          .append(""No response sent for "")
          .append(request.getMethod().getName())
          .append("" request to "")
          .append(request.getUri());

        if (lastHandler != null) {
          description.append("" (last handler: "");

          if (lastHandler instanceof DescribingHandler) {
            ((DescribingHandler) lastHandler).describeTo(description);
          } else {
            DescribingHandlers.describeTo(lastHandler, description);
          }
          description.append("")"");
        }

        String message = description.toString();
        LOGGER.warn(message);

        response.getHeaders().clear();

        ByteBuf body;
        if (development) {
          CharBuffer charBuffer = CharBuffer.wrap(message);
          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);
          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);
        } else {
          body = Unpooled.EMPTY_BUFFER;
        }

        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());
        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);
      }
    });
  }",1
"private void checkQuota() {
        QuotaService quotaService = CommonBeanFactory.getBean(QuotaService.class);
        if (quotaService != null) {
            quotaService.checkAPIAutomationQuota();
        }
    }",0
"private String readBody(RoutingContext ctx) {
        if (ctx.body() != null) {
            return ctx.body().asString();
        }
        return null;
    }",1
"public static void dumpCursor(Cursor cursor, StringBuilder sb) {
        sb.append("">>>>> Dumping cursor "").append(cursor).append('\n');
        if (cursor != null) {
            int startPos = cursor.getPosition();

            cursor.moveToPosition(-1);
            while (cursor.moveToNext()) {
                dumpCurrentRow(cursor, sb);
            }
            cursor.moveToPosition(startPos);
        }
        sb.append(""<<<<<\n"");
    }",0
"@Override
    public boolean isKeyguardSecure() {
        if (mKeyguardDelegate == null) return false;
        return mKeyguardDelegate.isSecure();
    }",0
"@RequestMapping(""doUpload"")
    @Csrf
    public String upload(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, MultipartFile[] files, String path,
            boolean privatefile, boolean overwrite, HttpServletRequest request, ModelMap model) {
        if (null != files) {
            try {
                for (MultipartFile file : files) {
                    String originalName = file.getOriginalFilename();
                    String suffix = CmsFileUtils.getSuffix(originalName);
                    String filepath = CommonUtils.joinString(path, Constants.SEPARATOR, originalName);
                    String fuleFilePath = siteComponent.getWebFilePath(site.getId(), filepath);
                    if (ArrayUtils.contains(safeConfigComponent.getSafeSuffix(site), suffix)) {
                        if (overwrite || !CmsFileUtils.exists(fuleFilePath)) {
                            if (CmsFileUtils.exists(fuleFilePath)) {
                                String historyFilePath = siteComponent.getWebHistoryFilePath(site.getId(), filepath, true);
                                try {
                                    CmsFileUtils.copyFileToFile(historyFilePath, historyFilePath);
                                } catch (IOException e1) {
                                }
                            }
                            CmsFileUtils.upload(file, fuleFilePath);
                            if (CmsFileUtils.isSafe(fuleFilePath, suffix)) {
                                FileUploadResult uploadResult = CmsFileUtils.getFileSize(fuleFilePath, originalName, suffix);
                                logUploadService.save(new LogUpload(site.getId(), admin.getId(),
                                        LogLoginService.CHANNEL_WEB_MANAGER, originalName, privatefile,
                                        CmsFileUtils.getFileType(CmsFileUtils.getSuffix(originalName)), file.getSize(),
                                        uploadResult.getWidth(), uploadResult.getHeight(), RequestUtils.getIpAddress(request),
                                        CommonUtils.getDate(), filepath));
                            } else {
                                CmsFileUtils.delete(fuleFilePath);
                                model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(
                                        CommonConstants.applicationContext, request.getLocale(), ""verify.custom.file.unsafe""));
                                return CommonConstants.TEMPLATE_ERROR;
                            }
                        }
                    } else {
                        model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(CommonConstants.applicationContext,
                                request.getLocale(), ""verify.custom.fileType""));
                        return CommonConstants.TEMPLATE_ERROR;
                    }
                }
            } catch (IOException e) {
                model.addAttribute(CommonConstants.ERROR, e.getMessage());
                log.error(e.getMessage(), e);
                return CommonConstants.TEMPLATE_ERROR;
            }
        }
        return CommonConstants.TEMPLATE_DONE;
    }",1
"@Override
    public boolean resetPwd(ResetPwdRequest request, UserDto currentUser) {
        Optional.ofNullable(currentUser).orElseThrow(() -> new RuntimeException(""当前用户为空""));
        User user = this.getUserById(currentUser.getId());
        Optional.ofNullable(user).orElseThrow(() -> new RuntimeException(""当前登录用户不存在""));

        // 非本地创建用户不允许修改密码
        if (!""local"".equalsIgnoreCase(user.getSource())) {
            throw new RuntimeException(""非云管本地创建的用户无法修改密码"");
        }
        if (StringUtils.equals(request.getOldPassword(), request.getNewPassword())) {
            throw new RuntimeException(""新旧密码相同"");
        }
        if (!MD5Util.md5(request.getOldPassword()).equalsIgnoreCase(user.getPassword())) {
            throw new RuntimeException(""旧密码错误"");
        }

        if (!request.getNewPassword().matches(""^(?!.*\\s)(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[\\W_]).{8,30}$"")) {
            throw new RuntimeException(""有效密码：8-30位，英文大小写字母+数字+特殊字符"");
        }

        user.setPassword(MD5Util.md5(request.getNewPassword()));
        user.setUpdateTime(null);
        this.updateById(user);
        return true;
    }",1
"public void setDisabledStatus(boolean disabledStatus)
    {
        if (hasAdminRights()) {
            this.user.setDisabled(disabledStatus, getXWikiContext());
        }
    }",1
"private void assignMinimumTTL(List<? extends DnsAnswer> dnsAnswers, LookupResult.Builder builder) {

        if (config.hasOverrideTTL()) {
            builder.cacheTTL(config.getCacheTTLOverrideMillis());
        } else {
            // Deduce minimum TTL on all TXT records. A TTL will always be returned by DNS server.
            builder.cacheTTL(dnsAnswers.stream()
                                       .map(DnsAnswer::dnsTTL)
                                       .min(Comparator.comparing(Long::valueOf)).get() * 1000);
        }
    }",0
"public static @NonNull ActivityOptions makeCustomAnimation(@NonNull Context context,
            int enterResId, int exitResId, int backgroundColor) {
        return makeCustomAnimation(context, enterResId, exitResId, backgroundColor, null, null);
    }",0
"public void updateActiveState() {
        setInactive(getDisallowFeatures().count() != 0);
    }",0
"public int getTimeout() {
        return mTimeout;
    }",0
"@Override
        public void play(String packageName) {
            mSessionCb.play(packageName, Binder.getCallingPid(), Binder.getCallingUid());
        }",0
"protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		// to get values from the login page
		String userName = request.getParameter(""aname"");
		String password = request.getParameter(""pass"");
		// String password = request.getParameter(""pass"");
		String rememberMe = request.getParameter(""remember-me"");

		// validation

		if (adminDao.loginValidate(userName, password)) {

			if (rememberMe != null) {
				Cookie cookie1 = new Cookie(""uname"", userName);
				Cookie cookie2 = new Cookie(""pass"", password);

				cookie1.setMaxAge(24 * 60 * 60);
				cookie2.setMaxAge(24 * 60 * 60);

				response.addCookie(cookie1);
				response.addCookie(cookie2);
			}

			// to display the name of logged-in person in home page
			HttpSession session = request.getSession();
			session.setAttribute(""username"", userName);

			/*
			 * RequestDispatcher rd =
			 * request.getRequestDispatcher(""AdminController?actions=admin_list"");
			 * rd.forward(request, response);
			 */

			response.sendRedirect(""AdminController?actions=admin_list"");
		} else {
			RequestDispatcher rd = request.getRequestDispatcher(""adminlogin.jsp"");
			request.setAttribute(""loginFailMsg"", ""Invalid Username or Password !!"");
			rd.include(request, response);
		}
	}",1
"void handle3GAuthRequest(SimAuthRequestData requestData) {
        WifiConfiguration requestingWifiConfiguration = null;
        if (mTargetWifiConfiguration != null
                && mTargetWifiConfiguration.networkId
                == requestData.networkId) {
            requestingWifiConfiguration = mTargetWifiConfiguration;
            logd(""id matches targetWifiConfiguration"");
        } else if (mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID
                && mLastNetworkId == requestData.networkId) {
            requestingWifiConfiguration = getConnectedWifiConfigurationInternal();
            logd(""id matches currentWifiConfiguration"");
        }

        if (requestingWifiConfiguration == null) {
            logd(""3GAuthRequest received with null target/current WifiConfiguration."");
            return;
        }

        SimAuthResponseData response = mWifiCarrierInfoManager
                .get3GAuthResponse(requestData, requestingWifiConfiguration);
        if (response != null) {
            mWifiNative.simAuthResponse(
                    mInterfaceName, response.type, response.response);
        } else {
            mWifiNative.umtsAuthFailedResponse(mInterfaceName);
        }
    }",0
"Class<? extends Fragment> getFragmentClass() {
        return ChooseLockPasswordFragment.class;
    }",0
"private static void writeLastDonePreBootReceivers(ArrayList<ComponentName> list) {
        File file = getCalledPreBootReceiversFile();
        FileOutputStream fos = null;
        DataOutputStream dos = null;
        try {
            fos = new FileOutputStream(file);
            dos = new DataOutputStream(new BufferedOutputStream(fos, 2048));
            dos.writeInt(LAST_PREBOOT_DELIVERED_FILE_VERSION);
            dos.writeUTF(android.os.Build.VERSION.RELEASE);
            dos.writeUTF(android.os.Build.VERSION.CODENAME);
            dos.writeUTF(android.os.Build.VERSION.INCREMENTAL);
            dos.writeInt(list.size());
            for (int i=0; i<list.size(); i++) {
                dos.writeUTF(list.get(i).getPackageName());
                dos.writeUTF(list.get(i).getClassName());
            }
        } catch (IOException e) {
            Slog.w(TAG, ""Failure writing last done pre-boot receivers"", e);
            file.delete();
        } finally {
            FileUtils.sync(fos);
            if (dos != null) {
                try {
                    dos.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }",0
"@Override
    public int countDocuments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)
        throws XWikiException
    {
        String sql = createSQLQuery(""select count(distinct doc.fullName)"", parametrizedSqlClause);
        List l = search(sql, 0, 0, parameterValues, context);
        return ((Number) l.get(0)).intValue();
    }",0
"@Override
    public double getDoubleProperty(String name) throws JMSException {
        Object o = this.getObjectProperty(name);
        if (o == null)
            throw new NumberFormatException(""Null is not a valid double"");
        else if (o instanceof String) {
            return Double.parseDouble((String) o);
        } else if (o instanceof Float) {
            return (Float) o;
        } else if (o instanceof Double) {
            return (Double) o;
        } else
            throw new MessageFormatException(String.format(""Unable to convert from class [%s]"", o.getClass().getName()));
    }",0
"private Publisher<Object> buildCacheablePublisher(
            MethodInvocationContext<Object, Object> context,
            ReturnType returnTypeObject,
            CacheOperation cacheOperation,
            AnnotationValue<Cacheable> cacheable) {
        AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();
        CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);
        Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));
        Object key = keyGenerator.generateKey(context, params);
        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);

        Maybe<Object> maybe = Maybe.create(emitter -> {
            asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {
               if (throwable != null) {
                   if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {
                       emitter.onError(throwable);
                   } else {
                       emitter.onComplete();
                   }
                   emitter.onError(throwable);
               } else if (opt.isPresent()) {
                   if (LOG.isDebugEnabled()) {
                       LOG.debug(""Value found in cache ["" + asyncCache.getName() + ""] for invocation: "" + context);
                   }
                   emitter.onSuccess(opt.get());
               } else {
                   emitter.onComplete();
               }
            });
        });

        return maybe.isEmpty().flatMapPublisher(empty -> {
            if (empty) {
               return Publishers.convertPublisher(
                       context.proceed(), Flowable.class)
                       .flatMap(o -> {
                           return Single.create(emitter -> {
                               asyncCache.put(key, o).whenComplete((aBoolean, throwable1) -> {
                                   if (throwable1 == null) {
                                       emitter.onSuccess(o);
                                   } else {
                                       if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable1))) {

                                           emitter.onError(throwable1);
                                       } else {
                                           emitter.onSuccess(o);
                                       }
                                   }
                               });
                           }).toFlowable();
                       });
            } else {
                return maybe.toFlowable();
            }
        });
    }",1
"public ApiClient setClientConfig(ClientConfig clientConfig) {
    this.clientConfig = clientConfig;
    // Rebuild HTTP Client according to the new ""clientConfig"" value.
    this.httpClient = buildHttpClient();
    return this;
  }",0
"private static boolean isExternal(ApplicationInfo info) {
        return (info.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0;
    }",0
"@Override
    public void initialize() throws InitializationException
    {
        ListenerChain chain = new ListenerChain();
        setListenerChain(chain);

        // Construct the listener chain in the right order. Listeners early in the chain are called before listeners
        // placed later in the chain.
        chain.addListener(this);
        chain.addListener(new BlockStateChainingListener(chain));
        chain.addListener(new EmptyBlockChainingListener(chain));
        chain.addListener(new MetaDataStateChainingListener(chain));
        chain.addListener(new AnnotatedXHTMLChainingRenderer(this.linkRenderer, this.imageRenderer,
            this.htmlElementSanitizer, chain));
    }",1
"@Beta
  @Deprecated
  public static File createTempDir() {
    File baseDir = new File(System.getProperty(""java.io.tmpdir""));
    @SuppressWarnings(""GoodTime"") // reading system time without TimeSource
    String baseName = System.currentTimeMillis() + ""-"";

    for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {
      File tempDir = new File(baseDir, baseName + counter);
      if (tempDir.mkdir()) {
        return tempDir;
      }
    }
    throw new IllegalStateException(
        ""Failed to create directory within ""
            + TEMP_DIR_ATTEMPTS
            + "" attempts (tried ""
            + baseName
            + ""0 to ""
            + baseName
            + (TEMP_DIR_ATTEMPTS - 1)
            + ')');
  }",1
"public Map<DocumentReference, List<BaseObject>> getXObjects()
    {
        return (Map) this.xObjects;
    }",1
"public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection)
            throws DatabaseServiceException {
        try {

            // logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);

            if (connection != null && !forceNewConnection) {
                // logger.info(""connection closed::{}"", connection.isClosed());
                if (!connection.isClosed()) {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""Returning existing connection::{}"", connection);
                    }
                    return connection;
                }
            }

            Class.forName(type.getClassPath());
            DriverManager.setLoginTimeout(10);
            String dbURL = databaseConfiguration.toURI().toString();
            connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(),
                    databaseConfiguration.getDatabasePassword());

            logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);

            return connection;

        } catch (ClassNotFoundException e) {
            logger.error(""Jdbc Driver not found"", e);
            throw new DatabaseServiceException(e.getMessage());
        } catch (SQLException e) {
            logger.error(""SQLException::Couldn't get a Connection!"", e);
            throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
        }
    }",1
"@Override
	public SaReactorFilter addExclude(String... paths) {
		excludeList.addAll(Arrays.asList(paths));
		return this;
	}",0
"private void doGraph(final TSDB tsdb, final HttpQuery query)
    throws IOException {
    final String basepath = getGnuplotBasePath(tsdb, query);
    long start_time = DateTime.parseDateTimeString(
      query.getRequiredQueryStringParam(""start""),
      query.getQueryStringParam(""tz""));
    final boolean nocache = query.hasQueryStringParam(""nocache"");
    if (start_time == -1) {
      throw BadRequestException.missingParameter(""start"");
    } else {
      // temp fixup to seconds from ms until the rest of TSDB supports ms
      // Note you can't append this to the DateTime.parseDateTimeString() call as
      // it clobbers -1 results
      start_time /= 1000;
    }
    long end_time = DateTime.parseDateTimeString(
        query.getQueryStringParam(""end""),
        query.getQueryStringParam(""tz""));
    final long now = System.currentTimeMillis() / 1000;
    if (end_time == -1) {
      end_time = now;
    } else {
      // temp fixup to seconds from ms until the rest of TSDB supports ms
      // Note you can't append this to the DateTime.parseDateTimeString() call as
      // it clobbers -1 results
      end_time /= 1000;
    }
    final int max_age = computeMaxAge(query, start_time, end_time, now);
    if (!nocache && isDiskCacheHit(query, end_time, max_age, basepath)) {
      return;
    }

    // Parse TSQuery from HTTP query
    final TSQuery tsquery = QueryRpc.parseQuery(tsdb, query);
    tsquery.validateAndSetQuery();

    // Build the queries for the parsed TSQuery
    Query[] tsdbqueries = tsquery.buildQueries(tsdb);

    List<String> options = null;
    final String options_allow_list = tsdb.getConfig().getString(
        ""tsd.gnuplot.options.allowlist"");
    if (!Strings.isNullOrEmpty(options_allow_list)) {
      String[] allow_list_strings = options_allow_list.split("";"");
      Set<String> allow_list = Sets.newHashSet();
      for (int i = 0; i < allow_list_strings.length; i++) {
        String allow = allow_list_strings[i];
        if (allow != null) {
          allow = URLDecoder.decode(allow.trim());
          allow_list.add(allow);
        }
      }
      
      options = query.getQueryStringParams(""o"");
      for (int i = 0; i < options.size(); i++) {
        if (!allow_list.contains(options.get(i))) {
          throw new BadRequestException(""Query option at index "" + i 
              + "" was not in the allow list."");
        }
      }
    }
    
    if (options == null) {
      options = new ArrayList<String>(tsdbqueries.length);
      for (int i = 0; i < tsdbqueries.length; i++) {
        options.add("""");
      }
    } else if (options.size() != tsdbqueries.length) {
      throw new BadRequestException(options.size() + "" `o' parameters, but ""
        + tsdbqueries.length + "" `m' parameters."");
    }
    for (final Query tsdbquery : tsdbqueries) {
      try {
        tsdbquery.setStartTime(start_time);
      } catch (IllegalArgumentException e) {
        throw new BadRequestException(""start time: "" + e.getMessage());
      }
      try {
        tsdbquery.setEndTime(end_time);
      } catch (IllegalArgumentException e) {
        throw new BadRequestException(""end time: "" + e.getMessage());
      }
    }
    final Plot plot = new Plot(start_time, end_time,
          DateTime.timezones.get(query.getQueryStringParam(""tz"")));
    setPlotDimensions(query, plot);
    setPlotParams(query, plot);
    final int nqueries = tsdbqueries.length;
    @SuppressWarnings(""unchecked"")
    final HashSet<String>[] aggregated_tags = new HashSet[nqueries];
    int npoints = 0;
    for (int i = 0; i < nqueries; i++) {
      try {  // execute the TSDB query!
        // XXX This is slow and will block Netty.  TODO(tsuna): Don't block.
        // TODO(tsuna): Optimization: run each query in parallel.
        final DataPoints[] series = tsdbqueries[i].run();
        for (final DataPoints datapoints : series) {
          plot.add(datapoints, options.get(i));
          aggregated_tags[i] = new HashSet<String>();
          aggregated_tags[i].addAll(datapoints.getAggregatedTags());
          npoints += datapoints.aggregatedSize();
        }
      } catch (RuntimeException e) {
        logInfo(query, ""Query failed (stack trace coming): ""
                + tsdbqueries[i]);
        throw e;
      }
      tsdbqueries[i] = null;  // free()
    }
    tsdbqueries = null;  // free()

    if (query.hasQueryStringParam(""ascii"")) {
      respondAsciiQuery(query, max_age, basepath, plot);
      return;
    }

    final RunGnuplot rungnuplot = new RunGnuplot(query, max_age, plot, basepath,
            aggregated_tags, npoints);

    class ErrorCB implements Callback<Object, Exception> {
      public Object call(final Exception e) throws Exception {
        LOG.warn(""Failed to retrieve global annotations: "", e);
        throw e;
      }
    }

    class GlobalCB implements Callback<Object, List<Annotation>> {
      public Object call(final List<Annotation> global_annotations) throws Exception {
        rungnuplot.plot.setGlobals(global_annotations);
        execGnuplot(rungnuplot, query);

        return null;
      }
    }

    // Fetch global annotations, if needed
    if (!tsquery.getNoAnnotations() && tsquery.getGlobalAnnotations()) {
      Annotation.getGlobalAnnotations(tsdb, start_time, end_time)
              .addCallback(new GlobalCB()).addErrback(new ErrorCB());
    } else {
      execGnuplot(rungnuplot, query);
    }
  }",1
"public void sweepCache() {
        mAnqpCache.sweep();
    }",0
"public Frame readFrame() throws IOException {
        while (somethingToRead()) {
            if (bytesRead == 0) {
                // type
                frameType = readFromBuffer();
                if (frameType == 'A') {
                    handleProtocolVersionMismatch();
                }
            } else if (bytesRead == 1) {
                // channel 1/2
                frameBuffer[0] = readFromBuffer();
            } else if (bytesRead == 2) {
                // channel 2/2
                frameChannel = (frameBuffer[0] << 8) + readFromBuffer();
            } else if (bytesRead == 3) {
                // payload size 1/4
                frameBuffer[0] = readFromBuffer();
            } else if (bytesRead == 4) {
                // payload size 2/4
                frameBuffer[1] = readFromBuffer();
            } else if (bytesRead == 5) {
                // payload size 3/4
                frameBuffer[2] = readFromBuffer();
            } else if (bytesRead == 6) {
                // payload size 4/4
                int framePayloadSize = (frameBuffer[0] << 24) + (frameBuffer[1] << 16) + (frameBuffer[2] << 8) + readFromBuffer();
                if (framePayloadSize >= maxPayloadSize) {
                    throw new IllegalStateException(format(
                        ""Frame body is too large (%d), maximum size is %d"",
                        framePayloadSize, maxPayloadSize
                    ));
                }
                framePayload = new byte[framePayloadSize];
            } else if (bytesRead >= PAYLOAD_OFFSET && bytesRead < framePayload.length + PAYLOAD_OFFSET) {
                framePayload[bytesRead - PAYLOAD_OFFSET] = (byte) readFromBuffer();
            } else if (bytesRead == framePayload.length + PAYLOAD_OFFSET) {
                int frameEndMarker = readFromBuffer();
                if (frameEndMarker != AMQP.FRAME_END) {
                    throw new MalformedFrameException(""Bad frame end marker: "" + frameEndMarker);
                }
                bytesRead = 0;
                return new Frame(frameType, frameChannel, framePayload);
            } else {
                throw new IllegalStateException(""Number of read bytes incorrect: "" + bytesRead);
            }
            bytesRead++;
        }
        return null;
    }",1
"public Authentication getAuthentication(String authName) {
    return authentications.get(authName);
  }",0
"public void destroy() {
        if (mNativeContentViewCore != 0) {
            nativeOnJavaContentViewCoreDestroyed(mNativeContentViewCore);
        }
        mWebContentsObserver.detachFromWebContents();
        mWebContentsObserver = null;
        setSmartClipDataListener(null);
        setZoomControlsDelegate(null);
        // TODO(igsolla): address TODO in ContentViewClient because ContentViewClient is not
        // currently a real Null Object.
        //
        // Instead of deleting the client we use the Null Object pattern to avoid null checks
        // in this class.
        mContentViewClient = new ContentViewClient();
        mWebContents = null;
        if (mViewAndroid != null) mViewAndroid.destroy();
        mNativeContentViewCore = 0;
        mContentSettings = null;
        mJavaScriptInterfaces.clear();
        mRetainedJavaScriptObjects.clear();
        unregisterAccessibilityContentObserver();
        mGestureStateListeners.clear();
        ScreenOrientationListener.getInstance().removeObserver(this);
        mPositionObserver.clearListener();
        mContainerViewObservers.clear();
    }",0
"public void writeToStream(byte[] param) {
            try {
                OutputStream os = getOutput();
                os.write(param);
                os.flush();
            } catch(IOException err) {
                errorMessage = err.toString();
                err.printStackTrace();
            }
        }",0
"protected void doHandleMessage(Buffer buffer) throws Exception {
        int cmd = buffer.getUByte();
        if (log.isDebugEnabled()) {
            log.debug(""doHandleMessage({}) process #{} {}"", this, seqi - 1,
                    SshConstants.getCommandMessageName(cmd));
        }

        switch (cmd) {
            case SshConstants.SSH_MSG_DISCONNECT:
                handleDisconnect(buffer);
                break;
            case SshConstants.SSH_MSG_IGNORE:
                failStrictKex(cmd);
                handleIgnore(buffer);
                break;
            case SshConstants.SSH_MSG_UNIMPLEMENTED:
                failStrictKex(cmd);
                handleUnimplemented(buffer);
                break;
            case SshConstants.SSH_MSG_DEBUG:
                // Fail after handling -- by default a message will be logged, which might be helpful.
                handleDebug(buffer);
                failStrictKex(cmd);
                break;
            case SshConstants.SSH_MSG_SERVICE_REQUEST:
                failStrictKex(cmd);
                handleServiceRequest(buffer);
                break;
            case SshConstants.SSH_MSG_SERVICE_ACCEPT:
                failStrictKex(cmd);
                handleServiceAccept(buffer);
                break;
            case SshConstants.SSH_MSG_KEXINIT:
                handleKexInit(buffer);
                break;
            case SshConstants.SSH_MSG_NEWKEYS:
                handleNewKeys(cmd, buffer);
                break;
            case KexExtensions.SSH_MSG_EXT_INFO:
                failStrictKex(cmd);
                handleKexExtension(cmd, buffer);
                break;
            case KexExtensions.SSH_MSG_NEWCOMPRESS:
                failStrictKex(cmd);
                handleNewCompression(cmd, buffer);
                break;
            default:
                if ((cmd >= SshConstants.SSH_MSG_KEX_FIRST) && (cmd <= SshConstants.SSH_MSG_KEX_LAST)) {
                    if (firstKexPacketFollows != null) {
                        try {
                            if (!handleFirstKexPacketFollows(cmd, buffer, firstKexPacketFollows)) {
                                break;
                            }
                        } finally {
                            firstKexPacketFollows = null; // avoid re-checking
                        }
                    }

                    handleKexMessage(cmd, buffer);
                } else {
                    failStrictKex(cmd);
                    if (currentService.process(cmd, buffer)) {
                        resetIdleTimeout();
                    } else {
                        /*
                         * According to https://tools.ietf.org/html/rfc4253#section-11.4
                         *
                         * An implementation MUST respond to all unrecognized messages with an SSH_MSG_UNIMPLEMENTED
                         * message in the order in which the messages were received.
                         */
                        if (log.isDebugEnabled()) {
                            log.debug(""process({}) Unsupported command: {}"", this, SshConstants.getCommandMessageName(cmd));
                        }
                        notImplemented(cmd, buffer);
                    }
                }
                break;
        }
        checkRekey();
    }",1
"public CreateCommentResponse save(CreateCommentRequest createCommentRequest) {
        CreateCommentResponse createCommentResponse = new CreateCommentResponse();
        if (createCommentRequest.getLogId() != null && createCommentRequest.getComment() != null) {
            if (isAllowComment(Integer.parseInt(createCommentRequest.getLogId()))) {
                String comment = Jsoup.clean(createCommentRequest.getComment(), Whitelist.basic());
                String email = createCommentRequest.getMail();
                if (StringUtils.isNotEmpty(email) || !isValidEmailAddress(email)) {
                    throw new IllegalArgumentException(email + ""not email address"");
                }
                String nickname = Jsoup.clean(createCommentRequest.getUserName(), Whitelist.basic());
                String userHome = Jsoup.clean(createCommentRequest.getUserHome(), Whitelist.basic());
                if (comment.length() > 0 && !ParseUtil.isGarbageComment(comment)) {
                    new Comment().set(""userHome"", userHome)
                            .set(""userMail"", email)
                            .set(""userIp"", createCommentRequest.getIp())
                            .set(""userName"", nickname)
                            .set(""logId"", createCommentRequest.getLogId())
                            .set(""userComment"", comment)
                            .set(""user_agent"", createCommentRequest.getUserAgent())
                            .set(""reply_id"", createCommentRequest.getReplyId())
                            .set(""commTime"", new Date()).set(""hide"", 1).save();
                } else {
                    createCommentResponse.setError(1);
                    createCommentResponse.setMessage("""");
                }
            } else {
                createCommentResponse.setError(1);
                createCommentResponse.setMessage("""");
            }
        } else {
            createCommentResponse.setError(1);
            createCommentResponse.setMessage("""");
        }
        Log log = new Log().findByIdOrAlias(createCommentRequest.getLogId());
        if (log != null) {
            createCommentResponse.setAlias(log.getStr(""alias""));
        }
        return createCommentResponse;
    }",1
"@Override
    protected void doGet( HttpServletRequest request,
                          HttpServletResponse response )
            throws ServletException, IOException {

        try {

            final URI uri = new URI( request.getParameter( ""path"" ) );

            if ( !validateAccess( uri, response ) ) {
                return;
            }

            final Path path = ioService.get( uri );

            byte[] bytes = ioService.readAllBytes( path );

            response.setHeader( ""Content-Disposition"",
                                format( ""attachment; filename=%s;"", path.getFileName().toString() ) );

            response.setContentType( ""application/octet-stream"" );

            response.getOutputStream().write(
                    bytes,
                    0,
                    bytes.length );

        } catch ( final Exception e ) {
            logger.error( ""Failed to download a file."", e );
        }

    }",1
"public static byte[] shuffle(short[] input) throws IOException {
        if (input.length * 2 < input.length) {
            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, ""input array size is too large: "" + input.length);
        }
        byte[] output = new byte[input.length * 2];
        int numProcessed = impl.shuffle(input, 0, 2, input.length * 2, output, 0);
        assert(numProcessed == input.length * 2);
        return output;
    }",1
"public static String sanitizePath(String path) {
        return sanitizePath(path, SANITIZED_CHAR);
    }",0
"private State readHeaders(ByteBuf buffer) {
        final HttpMessage message = this.message;
        final HttpHeaders headers = message.headers();

        AppendableCharSequence line = headerParser.parse(buffer);
        if (line == null) {
            return null;
        }
        if (line.length() > 0) {
            do {
                char firstChar = line.charAtUnsafe(0);
                if (name != null && (firstChar == ' ' || firstChar == '\t')) {
                    //please do not make one line from below code
                    //as it breaks +XX:OptimizeStringConcat optimization
                    String trimmedLine = line.toString().trim();
                    String valueStr = String.valueOf(value);
                    value = valueStr + ' ' + trimmedLine;
                } else {
                    if (name != null) {
                        headers.add(name, value);
                    }
                    splitHeader(line);
                }

                line = headerParser.parse(buffer);
                if (line == null) {
                    return null;
                }
            } while (line.length() > 0);
        }

        // Add the last header.
        if (name != null) {
            headers.add(name, value);
        }

        // reset name and value fields
        name = null;
        value = null;

        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);
        if (!contentLengthFields.isEmpty()) {
            HttpVersion version = message.protocolVersion();
            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1
                    && version.minorVersion() == 0);
            // Guard against multiple Content-Length headers as stated in
            // https://tools.ietf.org/html/rfc7230#section-3.3.2:
            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,
                    isHttp10OrEarlier, allowDuplicateContentLengths);
            if (contentLength != -1) {
                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);
            }
        }

        if (isContentAlwaysEmpty(message)) {
            HttpUtil.setTransferEncodingChunked(message, false);
            return State.SKIP_CONTROL_CHARS;
        } else if (HttpUtil.isTransferEncodingChunked(message)) {
            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {
                handleTransferEncodingChunkedWithContentLength(message);
            }
            return State.READ_CHUNK_SIZE;
        } else if (contentLength() >= 0) {
            return State.READ_FIXED_LENGTH_CONTENT;
        } else {
            return State.READ_VARIABLE_LENGTH_CONTENT;
        }
    }",1
"private boolean initializeRights(XWikiDocument document, List<Right> rights)
    {
        boolean updated = false;

        try {
            BaseObject object = document.newXObject(LOCAL_CLASS_REFERENCE, this.xcontextProvider.get());
            setRights(object, rights);
            updated = true;
        } catch (XWikiException e) {
            this.logger.error(String.format(""Error adding a [%s] object to the document [%s]"", LOCAL_CLASS_REFERENCE,
                document.getDocumentReference()));
        }

        return updated;
    }",1
"protected String[] getEnabledCipherSuites() {
        return enabledCipherSuites.clone();
    }",0
"public final JsonFactory getJsonFactory() {
      return jsonFactory;
    }",0
"private void updateActionViews(int menuState, Rect stackBounds) {
        ViewGroup expandContainer = findViewById(R.id.expand_container);
        ViewGroup actionsContainer = findViewById(R.id.actions_container);
        actionsContainer.setOnTouchListener((v, ev) -> {
            // Do nothing, prevent click through to parent
            return true;
        });

        // Update the expand button only if it should show with the menu
        expandContainer.setVisibility(menuState == MENU_STATE_FULL
                ? View.VISIBLE
                : View.INVISIBLE);

        FrameLayout.LayoutParams expandedLp =
                (FrameLayout.LayoutParams) expandContainer.getLayoutParams();
        if (mActions.isEmpty() || menuState == MENU_STATE_NONE) {
            actionsContainer.setVisibility(View.INVISIBLE);

            // Update the expand container margin to adjust the center of the expand button to
            // account for the existence of the action container
            expandedLp.topMargin = 0;
            expandedLp.bottomMargin = 0;
        } else {
            actionsContainer.setVisibility(View.VISIBLE);
            if (mActionsGroup != null) {
                // Ensure we have as many buttons as actions
                final LayoutInflater inflater = LayoutInflater.from(mContext);
                while (mActionsGroup.getChildCount() < mActions.size()) {
                    final PipMenuActionView actionView = (PipMenuActionView) inflater.inflate(
                            R.layout.pip_menu_action, mActionsGroup, false);
                    mActionsGroup.addView(actionView);
                }

                // Update the visibility of all views
                for (int i = 0; i < mActionsGroup.getChildCount(); i++) {
                    mActionsGroup.getChildAt(i).setVisibility(i < mActions.size()
                            ? View.VISIBLE
                            : View.GONE);
                }

                // Recreate the layout
                final boolean isLandscapePip = stackBounds != null
                        && (stackBounds.width() > stackBounds.height());
                for (int i = 0; i < mActions.size(); i++) {
                    final RemoteAction action = mActions.get(i);
                    final PipMenuActionView actionView =
                            (PipMenuActionView) mActionsGroup.getChildAt(i);
                    final boolean isCloseAction = mCloseAction != null && Objects.equals(
                            mCloseAction.getActionIntent(), action.getActionIntent());

                    final int iconType = action.getIcon().getType();
                    if (iconType == Icon.TYPE_URI || iconType == Icon.TYPE_URI_ADAPTIVE_BITMAP) {
                        // Disallow loading icon from content URI
                        actionView.setImageDrawable(null);
                    } else {
                        // TODO: Check if the action drawable has changed before we reload it
                        action.getIcon().loadDrawableAsync(mContext, d -> {
                            if (d != null) {
                                d.setTint(Color.WHITE);
                                actionView.setImageDrawable(d);
                            }
                        }, mMainHandler);
                    }
                    actionView.setCustomCloseBackgroundVisibility(
                            isCloseAction ? View.VISIBLE : View.GONE);
                    actionView.setContentDescription(action.getContentDescription());
                    if (action.isEnabled()) {
                        actionView.setOnClickListener(
                                v -> onActionViewClicked(action.getActionIntent(), isCloseAction));
                    }
                    actionView.setEnabled(action.isEnabled());
                    actionView.setAlpha(action.isEnabled() ? 1f : DISABLED_ACTION_ALPHA);

                    // Update the margin between actions
                    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                            actionView.getLayoutParams();
                    lp.leftMargin = (isLandscapePip && i > 0) ? mBetweenActionPaddingLand : 0;
                }
            }

            // Update the expand container margin to adjust the center of the expand button to
            // account for the existence of the action container
            expandedLp.topMargin = getResources().getDimensionPixelSize(
                    R.dimen.pip_action_padding);
            expandedLp.bottomMargin = getResources().getDimensionPixelSize(
                    R.dimen.pip_expand_container_edge_margin);
        }
        expandContainer.requestLayout();
    }",1
"private void simpleAuthenticationGenerator(XmlGenerator gen, SimpleAuthenticationConfig c) {
        if (c == null) {
            return;
        }
        XmlGenerator simpleGen = gen.open(""simple"");
        addClusterLoginElements(simpleGen, c).nodeIfContents(""role-separator"", c.getRoleSeparator());
        for (String username : c.getUsernames()) {
            simpleGen.open(""user"", ""username"", username, ""password"", getOrMaskValue(c.getPassword(username)));
            for (String role : c.getRoles(username)) {
                simpleGen.node(""role"", role);
            }
            // close <user> node
            simpleGen.close();
        }
        simpleGen.close();
    }",1
"private boolean readBracketPropertyToken(PathTokenAppender appender) {
        if (!path.currentCharIs(OPEN_SQUARE_BRACKET)) {
            return false;
        }
        char potentialStringDelimiter = path.nextSignificantChar();
        if (potentialStringDelimiter != SINGLE_QUOTE && potentialStringDelimiter != DOUBLE_QUOTE) {
          return false;
        }

        List<String> properties = new ArrayList<String>();

        int startPosition = path.position() + 1;
        int readPosition = startPosition;
        int endPosition = 0;
        boolean inProperty = false;
        boolean inEscape = false;
        boolean lastSignificantWasComma = false;

        while (path.inBounds(readPosition)) {
            char c = path.charAt(readPosition);

            if(inEscape){
                inEscape = false;
            } else if('\\' == c){
                inEscape = true;
            } else if (c == CLOSE_SQUARE_BRACKET && !inProperty) {
                if (lastSignificantWasComma){
                  fail(""Found empty property at index ""+readPosition);
                }
                break;
            } else if (c == potentialStringDelimiter) {
                if (inProperty) {
                    char nextSignificantChar = path.nextSignificantChar(readPosition);
                    if (nextSignificantChar != CLOSE_SQUARE_BRACKET && nextSignificantChar != COMMA) {
                        fail(""Property must be separated by comma or Property must be terminated close square bracket at index ""+readPosition);
                    }
                    endPosition = readPosition;
                    String prop = path.subSequence(startPosition, endPosition).toString();
                    properties.add(Utils.unescape(prop));
                    inProperty = false;
                } else {
                    startPosition = readPosition + 1;
                    inProperty = true;
                    lastSignificantWasComma = false;
                }
            } else if (c == COMMA && !inProperty) {
                if (lastSignificantWasComma){
                    fail(""Found empty property at index ""+readPosition);
                }
                lastSignificantWasComma = true;
            }
            readPosition++;
        }

        if (inProperty){
            fail(""Property has not been closed - missing closing "" + potentialStringDelimiter);
        }

        int endBracketIndex = path.indexOfNextSignificantChar(endPosition, CLOSE_SQUARE_BRACKET);
        if(endBracketIndex == -1) {
            fail(""Property has not been closed - missing closing ]"");
        }
        endBracketIndex++;

        path.setPosition(endBracketIndex);

        appender.appendPathToken(PathTokenFactory.createPropertyPathToken(properties, potentialStringDelimiter));

        return path.currentIsTail() || readNextToken(appender);
    }",1
"public static void unpackJar(File fjar, File fout) throws IOException {
    
      JarFile jf = new JarFile(fjar);
      Enumeration<JarEntry> en = jf.entries();

      while (en.hasMoreElements()) {
         JarEntry je = en.nextElement();
         java.io.File f = new File(fout,  je.getName());
							if (!f.toPath().normalize().startsWith(fout.toPath().normalize())) {
								throw new RuntimeException(""Bad zip entry"");
							}
         if (je.isDirectory()) {
            f.mkdirs();
            continue;

         } else {
            // f.getParentFile().mkdirs();

            if (f.getPath().indexOf(""META-INF"") >= 0) {
               // skip it
            } else {
            f.getParentFile().mkdirs();
            java.io.InputStream is = jf.getInputStream(je);
            java.io.FileOutputStream fos = new FileOutputStream(f);

            // EFF - buffering, file channels??
            while (is.available() > 0) {
               fos.write(is.read());
            }
            fos.close();
            is.close();
         }
         }
      }

    //  E.info(""unpacked jar to "" + fout);

       
   }",1
"public File prepareDownloadFile(Response response) throws IOException {
    String filename = null;
    String contentDisposition = (String) response.getHeaders().getFirst(""Content-Disposition"");
    if (contentDisposition != null && !"""".equals(contentDisposition)) {
      // Get filename from the Content-Disposition header.
      Pattern pattern = Pattern.compile(""filename=['\""]?([^'\""\\s]+)['\""]?"");
      Matcher matcher = pattern.matcher(contentDisposition);
      if (matcher.find())
        filename = matcher.group(1);
    }

    String prefix;
    String suffix = null;
    if (filename == null) {
      prefix = ""download-"";
      suffix = """";
    } else {
      int pos = filename.lastIndexOf('.');
      if (pos == -1) {
        prefix = filename + ""-"";
      } else {
        prefix = filename.substring(0, pos) + ""-"";
        suffix = filename.substring(pos);
      }
      // Files.createTempFile requires the prefix to be at least three characters long
      if (prefix.length() < 3)
        prefix = ""download-"";
    }

    if (tempFolderPath == null)
      return Files.createTempFile(prefix, suffix).toFile();
    else
      return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
  }",1
"public static void addFieldsFromContext(ApplicationInfo ai, Notification notification) {
        notification.extras.putParcelable(EXTRA_BUILDER_APPLICATION_INFO, ai);
    }",0
"@Override
    public int setErrorParameter(BeforeEnterEvent event,
            ErrorParameter<NotFoundException> parameter) {
        String path = event.getLocation().getPath();
        String additionalInfo = """";
        if (parameter.hasCustomMessage()) {
            additionalInfo = ""Reason: "" + parameter.getCustomMessage();
        }
        path = Jsoup.clean(path, Whitelist.none());
        additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());

        boolean productionMode = event.getUI().getSession().getConfiguration()
                .isProductionMode();

        String template = getErrorHtml(productionMode);
        template = template.replace(""{{path}}"", path);
        template = template.replace(""{{additionalInfo}}"", additionalInfo);
        if (template.contains(""{{routes}}"")) {
            template = template.replace(""{{routes}}"", getRoutes(event));
        }

        getElement().appendChild(new Html(template).getElement());
        return HttpServletResponse.SC_NOT_FOUND;
    }",1
"@ProxyFromPrimaryToCurrentUser
    public void onPreloadRecents() {
        // Ensure the device has been provisioned before allowing the user to interact with
        // recents
        if (!isDeviceProvisioned()) {
            return;
        }

        if (mSystemServicesProxy.isForegroundUserOwner()) {
            preloadRecents();
        } else {
            Intent intent = createLocalBroadcastIntent(mContext,
                    RecentsUserEventProxyReceiver.ACTION_PROXY_PRELOAD_RECENTS_TO_USER);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT);
        }
    }",1
"private boolean setUrlText(OmniboxResultItem result) {
        OmniboxSuggestion suggestion = result.getSuggestion();
        Spannable str = SpannableString.valueOf(suggestion.getDisplayText());
        boolean hasMatch = applyHighlightToMatchRegions(
                str, suggestion.getDisplayTextClassifications());
        showDescriptionLine(str, true);
        return hasMatch;
    }",1
"private ArrayList<ViewItem> createDatasetItems(FillResponse response,
            AutofillId focusedViewId) {
        final int datasetCount = response.getDatasets().size();
        if (sVerbose) {
            Slog.v(TAG, ""Number datasets: "" + datasetCount + "" max visible: ""
                    + mVisibleDatasetsMaxCount);
        }

        final RemoteViews.InteractionHandler interceptionHandler = (view, pendingIntent, r) -> {
            if (pendingIntent != null) {
                mCallback.startIntentSender(pendingIntent.getIntentSender());
            }
            return true;
        };

        final ArrayList<ViewItem> items = new ArrayList<>(datasetCount);
        for (int i = 0; i < datasetCount; i++) {
            final Dataset dataset = response.getDatasets().get(i);
            final int index = dataset.getFieldIds().indexOf(focusedViewId);
            if (index >= 0) {
                RemoteViews presentation = Helper.sanitizeRemoteView(
                        dataset.getFieldDialogPresentation(index));
                if (presentation == null) {
                    if (sDebug) {
                        Slog.w(TAG, ""not displaying UI on field "" + focusedViewId + "" because ""
                                + ""service didn't provide a presentation for it on "" + dataset);
                    }
                    continue;
                }
                final View view;
                try {
                    if (sVerbose) Slog.v(TAG, ""setting remote view for "" + focusedViewId);
                    view = presentation.applyWithTheme(
                            mContext, null, interceptionHandler, mThemeId);
                } catch (RuntimeException e) {
                    Slog.e(TAG, ""Error inflating remote views"", e);
                    continue;
                }
                // TODO: Extract the shared filtering logic here and in FillUi to a common
                //  method.
                final Dataset.DatasetFieldFilter filter = dataset.getFilter(index);
                Pattern filterPattern = null;
                String valueText = null;
                boolean filterable = true;
                if (filter == null) {
                    final AutofillValue value = dataset.getFieldValues().get(index);
                    if (value != null && value.isText()) {
                        valueText = value.getTextValue().toString().toLowerCase();
                    }
                } else {
                    filterPattern = filter.pattern;
                    if (filterPattern == null) {
                        if (sVerbose) {
                            Slog.v(TAG, ""Explicitly disabling filter at id "" + focusedViewId
                                    + "" for dataset #"" + index);
                        }
                        filterable = false;
                    }
                }

                items.add(new ViewItem(dataset, filterPattern, filterable, valueText, view));
            }
        }
        return items;
    }",1
"public void updateSQLXML(String columnName, @Nullable SQLXML xmlObject) throws SQLException {
    updateSQLXML(findColumn(columnName), xmlObject);
  }",0
"public void addResourceProvider(String key, ResourceProvider provider) {
		if (resourceProviders == null) {
			resourceProviders = new LinkedHashMap<String, ResourceProvider>();
		}

		boolean addedInDevMode = UiFrameworkUtil.checkAndSetDevelopmentModeForProvider(key, provider);
		if (addedInDevMode) {
			resourceProvidersInDevelopmentMode.add(key);
		}

		resourceProviders.put(key, provider);
	}",1
"void cleanupRestoredProject(ProjectLocator projectLocator) {

		ProjectManager projectManager = tool.getProjectManager();

		// delete the project at the given project location
		if (!projectManager.deleteProject(projectLocator)) {
			Msg.showError(this, null, ""All Files in Project not Removed"",
				""Not all files have been deleted from project "" + projectLocator.getName());
		}
	}",1
"public boolean navigateUpTo(IBinder token, Intent target, int resultCode, Intent resultData)
            throws RemoteException;",0
"@Override
    public boolean isRotationDrawingSupported() {
        return false;
    }",0
"private X509Certificate[] cleanupCertChainAndFindTrustAnchors(X509Certificate[] chain,
                                                                  Set<TrustAnchor> trustAnchors) {
        X509Certificate[] original = chain;

        // 1. Clean the received certificates chain.
        int currIndex;
        // Start with the first certificate in the chain, assuming it
        // is the leaf certificate (server or client cert).
        for (currIndex = 0; currIndex < chain.length; currIndex++) {
            // Walk the chain to find a ""subject"" matching
            // the ""issuer"" of the current certificate. In a properly
            // ordered chain this should be the next cert and be fast.
            // If not, we reorder things to be as the validator will
            // expect.
            boolean foundNext = false;
            for (int nextIndex = currIndex + 1; nextIndex < chain.length; nextIndex++) {
                if (chain[currIndex].getIssuerDN().equals(chain[nextIndex].getSubjectDN())) {
                    foundNext = true;
                    // Exchange certificates so that 0 through currIndex + 1 are in proper order
                    if (nextIndex != currIndex + 1) {
                        // don't mutuate original chain, which may be directly from an SSLSession
                        if (chain == original) {
                            chain = original.clone();
                        }
                        X509Certificate tempCertificate = chain[nextIndex];
                        chain[nextIndex] = chain[currIndex + 1];
                        chain[currIndex + 1] = tempCertificate;
                    }
                    break;
                }
            }
            // If we can't find the next in the chain, just give up
            // and use what we found so far. This drops unrelated
            // certificates that have nothing to do with the cert
            // chain.
            if (!foundNext) {
                break;
            }
        }

        // 2. Add any missing intermediates to the chain
        while (true) {
            TrustAnchor nextIntermediate =
                    intermediateIndex.findByIssuerAndSignature(chain[currIndex]);
            if (nextIntermediate == null) {
                break;
            }
            // Append intermediate
            X509Certificate cert = nextIntermediate.getTrustedCert();
            // don't mutate original chain, which may be directly from an SSLSession
            if (chain == original) {
                chain = original.clone();
            }
            // Grow the chain if needed
            if (currIndex == chain.length - 1) {
                chain = Arrays.copyOf(chain, chain.length * 2);
            }
            chain[currIndex + 1] = cert;
            currIndex++;
        }

        // 3. Find the trust anchor in the chain, if any
        int anchorIndex;
        for (anchorIndex = 0; anchorIndex <= currIndex; anchorIndex++) {
            // If the current cert is a TrustAnchor, we can ignore the rest of the chain.
            // This avoids including ""bridge"" CA certs that added for legacy compatibility.
            TrustAnchor trustAnchor = findTrustAnchorBySubjectAndPublicKey(chain[anchorIndex]);
            if (trustAnchor != null) {
                trustAnchors.add(trustAnchor);
                break;
            }
        }

        // 4. If the chain is now shorter, copy to an appropriately sized array.
        int chainLength = anchorIndex;
        X509Certificate[] newChain = ((chainLength == chain.length)
                                      ? chain
                                      : Arrays.copyOf(chain, chainLength));

        // 5. If we didn't find a trust anchor earlier, look for one now
        if (trustAnchors.isEmpty()) {
            TrustAnchor trustAnchor = findTrustAnchorByIssuerAndSignature(newChain[anchorIndex-1]);
            if (trustAnchor != null) {
                trustAnchors.add(trustAnchor);
            }
        }
        return newChain;
    }",1
"protected void filterResponse(QueryResponse response, List<DocumentReference> usersToCheck)
    {
        SolrDocumentList results = response.getResults();
        long numResults = results.size();

        results.removeIf(result -> {
            boolean keep = false;
            try {
                DocumentReference resultDocumentReference = this.solrDocumentReferenceResolver.resolve(result);

                keep = isAllowed(resultDocumentReference, usersToCheck);
            } catch (Exception e) {
                // Don't take any risk of including a result for which we cannot determine the document reference and
                // thus cannot determine if the given users have access to it or not.
                this.logger.warn(""Removing bad result: {}"", result, e);
            }

            // FIXME: We should update maxScore as well when removing the top scored item. How do we do that?
            // Sorting based on score might be a not so expensive option.

            // FIXME: What about highlighting, facets and all the other data inside the QueryResponse?

            return !keep;
        });

        long numFilteredResults = numResults - results.size();

        // Update the number of results, excluding the filtered ones.
        // Lower bound guard for the total number of results.
        long numFound = Math.max(0, response.getResults().getNumFound() - numFilteredResults);

        results.setNumFound(numFound);
    }",1
"private int getBigBaseLayoutResource() {
            return R.layout.notification_template_material_big_base;
        }",0
"@Override
        protected void sanityCheck() throws IllegalStateException {
            super.sanityCheck();
        }",0
"private IdProviders getSortedIdProviders()
    {
        IdProviders idProviders = securityService.get().getIdProviders();
        return IdProviders.from(
            idProviders.stream().sorted( Comparator.comparing( u -> u.getKey().toString() ) ).collect( Collectors.toList() ) );
    }",1
"@SuppressWarnings(""checkstyle:emptyblock"")
    private static List<Region> internalParse(
            final InputStream input,
            final boolean endpointVerification) throws IOException {

        Document document;
        try {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
            factory.setXIncludeAware(false);
            factory.setExpandEntityReferences(false);
            DocumentBuilder documentBuilder = factory.newDocumentBuilder();
            document = documentBuilder.parse(input);

        } catch (IOException exception) {
            throw exception;
        } catch (Exception exception) {
            throw new IOException(""Unable to parse region metadata file: ""
                    + exception.getMessage(),
                    exception);
        } finally {
            try {
                input.close();
            } catch (IOException exception) {
            }
        }

        NodeList regionNodes = document.getElementsByTagName(REGION_TAG);
        List<Region> regions = new ArrayList<Region>();
        for (int i = 0; i < regionNodes.getLength(); i++) {
            Node node = regionNodes.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element element = (Element) node;
                regions.add(parseRegionElement(element, endpointVerification));
            }
        }

        return regions;
    }",1
"public static String createCriticalNotificationJSON(String caption,
            String message, String details, String url) {
        String returnString = """";
        try {
            JsonObject appError = Json.createObject();
            putValueOrJsonNull(appError, ""caption"", caption);
            putValueOrJsonNull(appError, ""url"", url);
            putValueOrJsonNull(appError, ""message"", message);
            putValueOrJsonNull(appError, ""details"", details);

            JsonObject meta = Json.createObject();
            meta.put(""appError"", appError);

            JsonObject json = Json.createObject();
            json.put(""changes"", Json.createObject());
            json.put(""resources"", Json.createObject());
            json.put(""locales"", Json.createObject());
            json.put(""meta"", meta);
            json.put(ApplicationConstants.SERVER_SYNC_ID, -1);
            returnString = JsonUtil.stringify(json);
        } catch (JsonException e) {
            getLogger().log(Level.WARNING,
                    ""Error creating critical notification JSON message"", e);
        }

        return ""for(;;);["" + returnString + ""]"";
    }",0
"public String createEmbedJavaScript(HttpServletRequest request)
			throws IOException
	{
		String sparam = request.getParameter(""s"");
		String dev = request.getParameter(""dev"");
		StringBuffer result = new StringBuffer(""["");
		StringBuffer js = new StringBuffer("""");

		// Processes each stencil only once
		HashSet<String> done = new HashSet<String>();

		// Processes each lib only once
		HashSet<String> libsLoaded = new HashSet<String>();

		if (sparam != null)
		{
			String[] names = sparam.split("";"");

			for (int i = 0; i < names.length; i++)
			{
				if (names[i].indexOf("".."") < 0 && !done.contains(names[i]) && names[i].length() > 0)
				{
					if (names[i].equals(""*""))
					{
						js.append(readXmlFile(""/js/shapes-14-6-5.min.js"", false));
						result.append(
								""'"" + readXmlFile(""/stencils.xml"", true) + ""'"");
					}
					else
					{
						// Makes name canonical
						names[i] = new File(""/"" + names[i]).getCanonicalPath().substring(1);

						// Checks if any JS files are associated with the library
						// name and injects the JS into the page
						String[] libs = libraries.get(names[i]);

						if (libs != null)
						{
							for (int j = 0; j < libs.length; j++)
							{
								if (!libsLoaded.contains(libs[j]))
								{
									String tmp = stencils.get(libs[j]);
									libsLoaded.add(libs[j]);

									if (tmp == null)
									{
										try
										{
											tmp = readXmlFile(libs[j],
													!libs[j].toLowerCase()
															.endsWith("".js""));

											// Cache for later use
											if (tmp != null)
											{
												stencils.put(libs[j], tmp);
											}
										}
										catch (NullPointerException e)
										{
											// This seems possible according to access log so ignore stencil
										}
									}

									if (tmp != null)
									{
										// TODO: Add JS to Javascript code inline. This had to be done to quickly
										// add JS-based dynamic loading to the existing embed setup where everything
										// dynamic is passed via function call, so an indirection via eval must be
										// used even though the JS could be parsed directly by adding it to JS.
										if (libs[j].toLowerCase()
												.endsWith("".js""))
										{
											js.append(tmp);
										}
										else
										{
											if (result.length() > 1)
											{
												result.append("","");
											}

											result.append(""'"" + tmp + ""'"");
										}
									}
								}
							}
						}
						else
						{
							String tmp = stencils.get(names[i]);

							if (tmp == null)
							{
								try
								{
									tmp = readXmlFile(
											""/stencils/"" + names[i] + "".xml"",
											true);

									// Cache for later use
									if (tmp != null)
									{
										stencils.put(names[i], tmp);
									}
								}
								catch (NullPointerException e)
								{
									// This seems possible according to access log so ignore stencil
								}
							}

							if (tmp != null)
							{
								if (result.length() > 1)
								{
									result.append("","");
								}

								result.append(""'"" + tmp + ""'"");
							}
						}
					}

					done.add(names[i]);
				}
			}
		}

		result.append(""]"");

		// LATER: Detect protocol of request in dev
		// mode to avoid security errors
		String proto = ""https://"";

		String setCachedUrls = """";
		String[] urls = request.getParameterValues(""fetch"");

		if (urls != null)
		{
			HashSet<String> completed = new HashSet<String>();
			int sizeLimit = MAX_FETCH_SIZE;

			for (int i = 0; i < urls.length; i++)
			{
				try
				{
					// Checks if URL already fetched to avoid duplicates
					if (!completed.contains(urls[i]) && Utils.sanitizeUrl(urls[i]))
					{
						completed.add(urls[i]);
						URL url = new URL(urls[i]);
						URLConnection connection = url.openConnection();
						((HttpURLConnection) connection).setInstanceFollowRedirects(false);
						ByteArrayOutputStream stream = new ByteArrayOutputStream();
						String contentLength = connection.getHeaderField(""Content-Length"");

						// If content length is available, use it to enforce maximum size
						if (contentLength != null && Long.parseLong(contentLength) > sizeLimit)
						{
							break;
						}

						sizeLimit -= Utils.copyRestricted(connection.getInputStream(), stream, sizeLimit);
						setCachedUrls += ""GraphViewer.cachedUrls['""
								+ StringEscapeUtils.escapeEcmaScript(urls[i])
								+ ""'] = decodeURIComponent('""
								+ StringEscapeUtils.escapeEcmaScript(
										Utils.encodeURIComponent(
												stream.toString(""UTF-8""),
												Utils.CHARSET_FOR_URL_ENCODING))
								+ ""');"";
					}
				}
				catch (Exception e)
				{
					// ignore
				}
			}
		}

		// Installs a callback to load the stencils after the viewer was injected
		return ""window.onDrawioViewerLoad = function() {"" + setCachedUrls
				+ ""mxStencilRegistry.parseStencilSets("" + result.toString()
				+ "");"" + js + ""GraphViewer.processElements(); };""
				+ ""var t = document.getElementsByTagName('script');""
				+ ""if (t != null && t.length > 0) {""
				+ ""var script = document.createElement('script');""
				+ ""script.type = 'text/javascript';"" + ""script.src = '"" + proto
				+ ((dev != null && dev.equals(""1"")) ? ""test"" : ""www"")
				+ "".draw.io/js/viewer-static.min.js';""
				+ ""t[0].parentNode.appendChild(script);}"";
	}",1
"private BigInteger[] derDecode(
        byte[]  encoding)
        throws IOException
    {
        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);
        if (s.size() != 2)
        {
            throw new IOException(""malformed signature"");
        }
        if (!Arrays.areEqual(encoding, s.getEncoded(ASN1Encoding.DER)))
        {
            throw new IOException(""malformed signature"");
        }

        return new BigInteger[]{
            ((ASN1Integer)s.getObjectAt(0)).getValue(),
            ((ASN1Integer)s.getObjectAt(1)).getValue()
        };
    }",1
"@Override
    public File readFrom(Class<File> type, Type genericType,
            Annotation[] annotations, MediaType mediaType,
            MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException {
        File downloadedFile = Files.createTempFile(PREFIX, SUFFIX).toFile();
        if (HeaderUtil.isContentLengthZero(httpHeaders)) {
            return downloadedFile;
        }

        try (OutputStream output = new BufferedOutputStream(new FileOutputStream(downloadedFile))) {
            entityStream.transferTo(output);
        }

        return downloadedFile;
    }",1
"@SuppressWarnings(""AndroidFrameworkPendingIntentMutability"")
        PendingIntent pendingIntentGetActivityAsUser(Context context, int requestCode,
                @NonNull Intent intent, int flags, Bundle options, UserHandle user) {
            return PendingIntent.getActivityAsUser(
                    context, requestCode, intent, flags, options, user);
        }",0
"public String getContactInfo(final String userID, final String command) throws IOException {
        update();

        m_readLock.lock();
        try {
            final User user = m_users.get(userID);
            return _getContactInfo(user, command);
        } finally {
            m_readLock.unlock();
        }
    }",0
"public int pushBackInputStreamIfNecessary(PushbackInputStream pushbackInputStream) throws IOException {
    // Do nothing by default
    return 0;
  }",1
"private String getLocalePrefix(FacesContext context) {

        String localePrefix = null;
        
        localePrefix = context.getExternalContext().getRequestParameterMap().get(""loc"");
        
        if(localePrefix != null && !nameContainsForbiddenSequence(localePrefix)){
            return localePrefix;
        }
        
        String appBundleName = context.getApplication().getMessageBundle();
        if (null != appBundleName) {
        	
            Locale locale = null;
            if (context.getViewRoot() != null) {
                locale = context.getViewRoot().getLocale();
            } else {
                locale = context.getApplication().getViewHandler().calculateLocale(context);
            }
            
                try {
                    ResourceBundle appBundle =
                          ResourceBundle.getBundle(appBundleName,
                                                   locale,
                                                   Util.getCurrentLoader(ResourceManager.class));
                    localePrefix =
                          appBundle
                                .getString(ResourceHandler.LOCALE_PREFIX);
                } catch (MissingResourceException mre) { 
                    if (LOGGER.isLoggable(Level.FINEST)) {
                        LOGGER.log(Level.FINEST, ""Ignoring missing resource"", mre);
                    }
                }
        }
        return localePrefix;

    }",1
"native boolean createBondNative(byte[] address, int transport);",0
"public int startActivityIntentSender(IApplicationThread caller,
            IntentSender intent, Intent fillInIntent, String resolvedType,
            IBinder resultTo, String resultWho, int requestCode,
            int flagsMask, int flagsValues, Bundle options) throws RemoteException;",0
"public UpdateSection addField(String field){
    if (! fieldPattern.matcher(field).matches()) {
      throw new IllegalArgumentException(""Field name with illegal character: '"" + field + ""'"");
    }
    fieldHierarchy.add(field);
    return this;
  }",1
"protected JSONArray newJSONArray() throws JSONException {
        checkRecursionDepth();
    	return new JSONArray(this);
    }",1
"@Override
    public @ProcessCapability int getUidProcessCapabilities(int uid, String callingPackage) {
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission(android.Manifest.permission.PACKAGE_USAGE_STATS,
                    ""getUidProcessState"");
        }
        // In case the caller is requesting processCapabilities of an app in a different user,
        // then verify the caller has INTERACT_ACROSS_USERS_FULL permission
        mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                UserHandle.getUserId(uid), false /* allowAll */, ALLOW_FULL_ONLY,
                ""getUidProcessCapabilities"", callingPackage); // Ignore return value

        synchronized (mProcLock) {
            return mProcessList.getUidProcessCapabilityLOSP(uid);
        }
    }",0
"public static boolean zipAll(File rootFile, File targetZipFile, boolean withMetadata) {
		Set<String> fileSet = new HashSet<>();
		String[] files = rootFile.list();
		for (int i = 0; i < files.length; i++) {
			fileSet.add(files[i]);
		}		
		return zip(fileSet, rootFile, targetZipFile, VFSAllItemsFilter.ACCEPT_ALL, withMetadata);
	}",0
"@RequiresPermission(value = android.Manifest.permission.INTERACT_ACROSS_USERS,
            conditional = true)
    public @Nullable ComponentName getProfileOwnerAsUser(@NonNull UserHandle user) {
        if (mService != null) {
            try {
                return mService.getProfileOwnerAsUser(user.getIdentifier());
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
        }
        return null;
    }",0
"public boolean hasBacklinks(XWikiContext context)
    {
        if (this.hasBacklinks == null) {
            this.hasBacklinks = ""1"".equals(getXWikiPreference(""backlinks"", ""xwiki.backlinks"", ""0"", context));
        }
        return this.hasBacklinks;
    }",0
"public byte[] toByteArray() throws TransformerConfigurationException, TransformerException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        TransformerFactory tranFactory = TransformerFactory.newInstance();
        tranFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
        tranFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
        Transformer aTransformer = tranFactory.newTransformer();
        Source src = new DOMSource(mDoc);
        Result dest = new StreamResult(bos);
        aTransformer.transform(src, dest);
        return bos.toByteArray();
    }",1
"public Authentication getAuthentication(HttpServletRequest request, byte[] key, String alias) {
        // verify:
        String identity = request.getParameter(""openid.identity"");
        if (identity==null)
            throw new OpenIdException(""Missing 'openid.identity'."");
        if (request.getParameter(""openid.invalidate_handle"")!=null)
            throw new OpenIdException(""Invalidate handle."");
        String sig = request.getParameter(""openid.sig"");
        if (sig==null)
            throw new OpenIdException(""Missing 'openid.sig'."");
        String signed = request.getParameter(""openid.signed"");
        if (signed==null)
            throw new OpenIdException(""Missing 'openid.signed'."");
        if (!returnTo.equals(request.getParameter(""openid.return_to"")))
            throw new OpenIdException(""Bad 'openid.return_to'."");
        // check sig:
        String[] params = signed.split(""[\\,]+"");
        StringBuilder sb = new StringBuilder(1024);
        for (String param : params) {
            sb.append(param)
              .append(':');
            String value = request.getParameter(""openid."" + param);
            if (value!=null)
                sb.append(value);
            sb.append('\n');
        }
        String hmac = getHmacSha1(sb.toString(), key);
        if (!safeEquals(sig, hmac))
            throw new OpenIdException(""Verify signature failed."");

        // set auth:
        Authentication auth = new Authentication();
        auth.setIdentity(identity);
        auth.setEmail(request.getParameter(""openid."" + alias + "".value.email""));
        auth.setLanguage(request.getParameter(""openid."" + alias + "".value.language""));
        auth.setGender(request.getParameter(""openid."" + alias + "".value.gender""));
        auth.setFullname(getFullname(request, alias));
        auth.setFirstname(getFirstname(request, alias));
        auth.setLastname(getLastname(request, alias));
        return auth;
    }",1
"boolean isBuildDebuggable() {
            return Build.IS_DEBUGGABLE;
        }",0
"@Override
    public String encodeRedirectURL(String s)
    {
        return this.response.encodeRedirectURL(s);
    }",0
"public static void main(String[] args) {

        // Will serve all static file are under ""/public"" in classpath if the route isn't consumed by others routes.
        staticFiles.location(""/public"");

        get(""/hello"", (request, response) -> {
            return ""Hello World!"";
        });
    }",1
"@Override
   public void save(MapSession session) {
      if (!session.getId().equals(session.getOriginalId())) {
         removeFromCacheWithoutNotifications(session.getOriginalId());
      }
      cache.put(session.getId(), session, session.getMaxInactiveInterval().getSeconds(), TimeUnit.SECONDS);
   }",1
"private List<Gadget> prepareGadgets(List<BaseObject> objects, Syntax sourceSyntax,
        MacroTransformationContext context) throws Exception
    {
        List<Gadget> gadgets = new ArrayList<>();

        // prepare velocity tools to render title
        VelocityContext velocityContext = velocityManager.getVelocityContext();
        // Use the Transformation id as the name passed to the Velocity Engine. This name is used internally
        // by Velocity as a cache index key for caching macros.
        String key = context.getTransformationContext().getId();
        if (key == null) {
            key = ""unknown namespace"";
        }
        VelocityEngine velocityEngine = velocityManager.getVelocityEngine();

        for (BaseObject xObject : objects) {
            if (xObject != null) {
                this.progress.startStep(this, ""dashboard.progress.prepareGadget"", ""Prepare gadget [{}:{}]"",
                    xObject.getDocumentReference(), xObject.getNumber());

                // get the data about the gadget from the object
                // TODO: filter for dashboard name when that field will be in
                String title = xObject.getStringValue(""title"");
                String content = xObject.getLargeStringValue(""content"");
                String position = xObject.getStringValue(""position"");
                String id = xObject.getNumber() + """";

                String gadgetTitle;

                XWikiDocument ownerDocument = xObject.getOwnerDocument();
                if (this.authorizationManager.hasAccess(Right.SCRIPT, ownerDocument.getAuthorReference(), ownerDocument.getDocumentReference())) {
                    gadgetTitle =
                        this.evaluateVelocityTitle(velocityContext, velocityEngine, key, title, ownerDocument);
                } else {
                    gadgetTitle = title;
                }

                // parse both the title and content in the syntax of the transformation context
                List<Block> titleBlocks =
                    renderGadgetProperty(gadgetTitle, sourceSyntax, xObject.getDocumentReference(),
                        ownerDocument, context);
                List<Block> contentBlocks =
                    renderGadgetProperty(content, sourceSyntax, xObject.getDocumentReference(),
                        ownerDocument, context);

                // create a gadget will all these and add the gadget to the container of gadgets
                Gadget gadget = new Gadget(id, titleBlocks, contentBlocks, position);
                gadget.setTitleSource(title);
                gadgets.add(gadget);
            } else {
                this.progress.startStep(this, ""dashboard.progress.skipNullGadget"", ""Null gadget object"");
            }

            this.progress.endStep(this);
        }

        return gadgets;
    }",1
"@Override
	public Object forward(String path) {
		ServerWebExchange exchange = SaReactorSyncHolder.getContext();
		WebFilterChain chain = exchange.getAttribute(SaReactorHolder.CHAIN_KEY);
		
		ServerHttpRequest newRequest = request.mutate().path(path).build();
		ServerWebExchange newExchange = exchange.mutate().request(newRequest).build();
		
		return chain.filter(newExchange); 
	}",0
"@Override
    protected List<Object> getCommandConfigurationBeans() {
        return Arrays.asList(configuration,
                httpConfiguration,
                elasticsearchConfiguration,
                elasticsearchClientConfiguration,
                emailConfiguration,
                mongoDbConfiguration,
                versionCheckConfiguration,
                kafkaJournalConfiguration,
                nettyTransportConfiguration,
                pipelineConfiguration,
                viewsConfiguration,
                processingStatusConfig,
                jobSchedulerConfiguration,
                prometheusExporterConfiguration,
                tlsConfiguration,
                geoIpProcessorConfig,
                dnsLookupAdapterConfiguration);
    }",1
"protected void writeToHttpSession(WrappedSession wrappedSession,
            VaadinSession session) {
        wrappedSession.setAttribute(getSessionAttributeName(), session);
    }",0
"public static void doDiagnostics(DOMDocument document, XMLEntityResolver entityResolver,
			List<Diagnostic> diagnostics, ContentModelSettings contentModelSettings, CancelChecker monitor) {
		try {
			XMLValidationSettings validationSettings = contentModelSettings != null
					? contentModelSettings.getValidation()
					: null;
			LSPXMLParserConfiguration configuration = new LSPXMLParserConfiguration(
					isDisableOnlyDTDValidation(document), validationSettings);

			if (entityResolver != null) {
				configuration.setProperty(""http://apache.org/xml/properties/internal/entity-resolver"", entityResolver); //$NON-NLS-1$
			}

			final LSPErrorReporterForXML reporter = new LSPErrorReporterForXML(document, diagnostics);
			boolean externalDTDValid = checkExternalDTD(document, reporter, configuration);
			SAXParser parser = new SAXParser(configuration);
			// Add LSP error reporter to fill LSP diagnostics from Xerces errors
			parser.setProperty(""http://apache.org/xml/properties/internal/error-reporter"", reporter);
			parser.setFeature(""http://apache.org/xml/features/continue-after-fatal-error"", false); //$NON-NLS-1$
			parser.setFeature(""http://xml.org/sax/features/namespace-prefixes"", true /* document.hasNamespaces() */); //$NON-NLS-1$
			parser.setFeature(""http://xml.org/sax/features/namespaces"", true /* document.hasNamespaces() */); //$NON-NLS-1$

			// Add LSP content handler to stop XML parsing if monitor is canceled.
			parser.setContentHandler(new LSPContentHandler(monitor));

			boolean hasGrammar = document.hasGrammar();

			// If diagnostics for Schema preference is enabled
			if ((validationSettings == null) || validationSettings.isSchema()) {

				checkExternalSchema(document.getExternalSchemaLocation(), parser);

				parser.setFeature(""http://apache.org/xml/features/validation/schema"", hasGrammar); //$NON-NLS-1$

				// warn if XML document is not bound to a grammar according the settings
				warnNoGrammar(document, diagnostics, contentModelSettings);
			} else {
				hasGrammar = false; // validation for Schema was disabled
			}

			parser.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", externalDTDValid);
			parser.setFeature(""http://xml.org/sax/features/validation"", hasGrammar && externalDTDValid); //$NON-NLS-1$

			// Parse XML
			String content = document.getText();
			String uri = document.getDocumentURI();
			InputSource inputSource = new InputSource();
			inputSource.setByteStream(new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8)));
			inputSource.setSystemId(uri);
			parser.parse(inputSource);

		} catch (IOException | SAXException | CancellationException exception) {
			// ignore error
		} catch (CacheResourceDownloadingException e) {
			throw e;
		} catch (Exception e) {
			LOGGER.log(Level.SEVERE, ""Unexpected XMLValidator error"", e);
		}
	}",1
"public void runWhenAttached(SerializableConsumer<UI> command) {

        if (isAttached()) {
            command.accept(getUI());
        } else {
            addAttachListener(new Command() {
                @Override
                public void execute() {
                    command.accept(getUI());
                    removeAttachListener(this);
                }
            });
        }
    }",0
"protected void updateParamsForAuth(String[] authNames, List<Pair> queryParams, Map<String, String> headerParams,
                                     Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
    for (String authName : authNames) {
      Authentication auth = authentications.get(authName);
      if (auth == null) {
        continue;
      }
      auth.applyToParams(queryParams, headerParams, cookieParams, payload, method, uri);
    }
  }",0
"private static File createFile() {
        java.nio.file.Path file = null;
        try {
            file = Files.createTempFile(""tmp"", ""tmp"");
            try (BufferedWriter writer = Files.newBufferedWriter(file)) {
                for (int i = 0; i < 1000; i++) {
                    writer.write(""hello"");
                }
                writer.write(""1234"");
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return file.toFile();
    }",1
"@Test
  public void setStyleParams() throws Exception {
    assertPlotParam(""style"", ""linespoint"");
    assertPlotParam(""style"", ""points"");
    assertPlotParam(""style"", ""circles"");
    assertPlotParam(""style"", ""dots"");
    assertInvalidPlotParam(""style"", ""dots%20%0a[33:system(%20"");
    assertInvalidPlotParam(""style"", ""%3Bsystem%20%22cat%20/home/ubuntuvm/secret.txt%20%3E/tmp/secret.txt%22%20%22\"""");
  }",1
"@Override
    public void backup(File targetDir, DataSource dataSource, DbProperties dbProperties) throws InterruptedException, TimeoutException, IOException {
        try {
            ProcessResult processResult = createProcessExecutor(targetDir, dbProperties).execute();

            if (processResult.getExitValue() == 0) {
                log.info(""MySQL backup finished successfully."");
            } else {
                throwBackupError(COMMAND, processResult.getExitValue());
            }
        } catch (ProcessInitException e) {
            throwBackupError(COMMAND, e.getErrorCode(), e.getCause());
        }
    }",1
public abstract BaseXMLBuilder ns(String namespaceURI);,0
"public static UnsafeAccess getInstance() {
        SecurityCheck.AccessLimiter accessLimiter = SecurityCheck.getInstance().getLimiter();
        if (accessLimiter != null) accessLimiter.preGetUnsafeAccess();
        return INSTANCE;
    }",1
"@SuppressWarnings(""unchecked"")
    static NameValidator<CharSequence> nameValidator(boolean validate) {
        return validate ? HttpNameValidator : NameValidator.NOT_NULL;
    }",0
"public synchronized void configure(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!staticResourcesSet) {
            try {
                ClassPathResource resource = new ClassPathResource(folder);

                if (configureJarCase(folder, resource)) {
                    return;
                }

                if (!resource.getFile().isDirectory()) {
                    LOG.error(""Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }

                staticResourceHandlers.add(new ClassPathResourceHandler(folder, ""index.html""));
                LOG.info(""StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating StaticResourceHandler"", e);
            }

            StaticFilesFolder.localConfiguredTo(folder);
            staticResourcesSet = true;
        }

    }",1
"public static boolean isCertUnderestimated() {
        return Boolean.valueOf(JNLPRuntime.getConfiguration().getProperty(ConfigurationConstants.KEY_SECURITY_ITW_IGNORECERTISSUES))
                && !JNLPRuntime.isSecurityEnabled();
    }",0
"@SuppressWarnings(""deprecation"")
    @Override
    public BiomeType getBiome(BlockVector3 position) {
        //FAWE start - safe edit region
        testCoords(position);
        //FAWE end
        if (HAS_3D_BIOMES) {
            return BukkitAdapter.adapt(getWorld().getBiome(position.getBlockX(), position.getBlockY(), position.getBlockZ()));
        } else {
            return BukkitAdapter.adapt(getWorld().getBiome(position.getBlockX(), position.getBlockZ()));
        }
    }",1
"@Override
        public void addExistingConnection(String callId, ParcelableConnection connection,
                Session.Info sessionInfo) {
            Log.startSession(sessionInfo, ""CSW.aEC"", mPackageAbbreviation);
            UserHandle userHandle = Binder.getCallingUserHandle();
            // Check that the Calling Package matches PhoneAccountHandle's Component Package
            PhoneAccountHandle callingPhoneAccountHandle = connection.getPhoneAccount();
            if (callingPhoneAccountHandle != null) {
                mAppOpsManager.checkPackage(Binder.getCallingUid(),
                        callingPhoneAccountHandle.getComponentName().getPackageName());
            }

            long token = Binder.clearCallingIdentity();
            try {
                synchronized (mLock) {
                    // Make sure that the PhoneAccount associated with the incoming
                    // ParcelableConnection is in fact registered to Telecom and is being called
                    // from the correct user.
                    List<PhoneAccountHandle> accountHandles =
                    // Include CAPABILITY_EMERGENCY_CALLS_ONLY in this list in case we are adding
                    // an emergency call.
                            mPhoneAccountRegistrar.getCallCapablePhoneAccounts(null /*uriScheme*/,
                            false /*includeDisabledAccounts*/, userHandle, 0 /*capabilities*/,
                            0 /*excludedCapabilities*/);
                    PhoneAccountHandle phoneAccountHandle = null;
                    for (PhoneAccountHandle accountHandle : accountHandles) {
                        if(accountHandle.equals(callingPhoneAccountHandle)) {
                            phoneAccountHandle = accountHandle;
                        }
                    }
                    // Allow the Sim call manager account as well, even if its disabled.
                    if (phoneAccountHandle == null && callingPhoneAccountHandle != null) {
                        // Search all SIM PhoneAccounts to see if there is a SIM call manager
                        // associated with any of them and verify that the calling handle matches.
                        for (PhoneAccountHandle handle :
                                mPhoneAccountRegistrar.getSimPhoneAccounts(userHandle)) {
                            int subId = mPhoneAccountRegistrar.getSubscriptionIdForPhoneAccount(
                                    handle);
                            PhoneAccountHandle connectionMgrHandle =
                                    mPhoneAccountRegistrar.getSimCallManager(subId, userHandle);
                            if (callingPhoneAccountHandle.equals(connectionMgrHandle)) {
                                phoneAccountHandle = connectionMgrHandle;
                                break;
                            }
                        }
                    }
                    if (phoneAccountHandle != null) {
                        logIncoming(""addExistingConnection %s %s"", callId, connection);

                        Bundle connectionExtras = connection.getExtras();
                        String connectIdToCheck = null;
                        if (connectionExtras != null && connectionExtras
                                .containsKey(Connection.EXTRA_ORIGINAL_CONNECTION_ID)) {
                            connectIdToCheck = connectionExtras
                                    .getString(Connection.EXTRA_ORIGINAL_CONNECTION_ID);
                        } else {
                            connectIdToCheck = callId;
                        }

                        // Handle the case where an existing connection was added by Telephony via
                        // a connection manager.  The remote connection service API does not include
                        // the ability to specify a parent connection when adding an existing
                        // connection, so we stash the desired parent in the connection extras.
                        if (connectionExtras != null
                                && connectionExtras.containsKey(
                                        Connection.EXTRA_ADD_TO_CONFERENCE_ID)
                                && connection.getParentCallId() == null) {
                            String parentId = connectionExtras.getString(
                                    Connection.EXTRA_ADD_TO_CONFERENCE_ID);
                            Log.i(ConnectionServiceWrapper.this, ""addExistingConnection: remote ""
                                    + ""connection will auto-add to parent %s"", parentId);
                            // Replace parcelable connection instance, swapping the new desired
                            // parent in.
                            connection = new ParcelableConnection(
                                    connection.getPhoneAccount(),
                                    connection.getState(),
                                    connection.getConnectionCapabilities(),
                                    connection.getConnectionProperties(),
                                    connection.getSupportedAudioRoutes(),
                                    connection.getHandle(),
                                    connection.getHandlePresentation(),
                                    connection.getCallerDisplayName(),
                                    connection.getCallerDisplayNamePresentation(),
                                    connection.getVideoProvider(),
                                    connection.getVideoState(),
                                    connection.isRingbackRequested(),
                                    connection.getIsVoipAudioMode(),
                                    connection.getConnectTimeMillis(),
                                    connection.getConnectElapsedTimeMillis(),
                                    connection.getStatusHints(),
                                    connection.getDisconnectCause(),
                                    connection.getConferenceableConnectionIds(),
                                    connection.getExtras(),
                                    parentId,
                                    connection.getCallDirection(),
                                    connection.getCallerNumberVerificationStatus());
                        }

                        // Check status hints image for cross user access
                        if (connection.getStatusHints() != null) {
                            Icon icon = connection.getStatusHints().getIcon();
                            connection.getStatusHints().setIcon(StatusHints.
                                    validateAccountIconUserBoundary(icon, userHandle));
                        }

                        // Check to see if this Connection has already been added.
                        Call alreadyAddedConnection = mCallsManager
                                .getAlreadyAddedConnection(connectIdToCheck);

                        if (alreadyAddedConnection != null
                                && mCallIdMapper.getCall(callId) == null) {
                            if (!Objects.equals(connection.getHandle(),
                                    alreadyAddedConnection.getHandle())) {
                                alreadyAddedConnection.setHandle(connection.getHandle());
                            }
                            if (connection.getHandlePresentation() !=
                                    alreadyAddedConnection.getHandlePresentation()) {
                                alreadyAddedConnection.setHandle(connection.getHandle(),
                                        connection.getHandlePresentation());
                            }
                            if (!Objects.equals(connection.getCallerDisplayName(),
                                    alreadyAddedConnection.getCallerDisplayName())) {
                                alreadyAddedConnection.setCallerDisplayName(connection
                                                .getCallerDisplayName(),
                                        connection.getCallerDisplayNamePresentation());
                            }
                            if (connection.getConnectionCapabilities() !=
                                    alreadyAddedConnection.getConnectionCapabilities()) {
                                alreadyAddedConnection.setConnectionCapabilities(connection
                                        .getConnectionCapabilities());
                            }
                            if (connection.getConnectionProperties() !=
                                    alreadyAddedConnection.getConnectionProperties()) {
                                alreadyAddedConnection.setConnectionCapabilities(connection
                                        .getConnectionProperties());
                            }
                            mCallIdMapper.addCall(alreadyAddedConnection, callId);
                            alreadyAddedConnection
                                    .replaceConnectionService(ConnectionServiceWrapper.this);
                            return;
                        }

                        Call existingCall = mCallsManager
                                .createCallForExistingConnection(callId, connection);
                        mCallIdMapper.addCall(existingCall, callId);
                        existingCall.setConnectionService(ConnectionServiceWrapper.this);
                    } else {
                        Log.e(this, new RemoteException(""The PhoneAccount being used is not "" +
                                ""currently registered with Telecom.""), ""Unable to "" +
                                ""addExistingConnection."");
                    }
                }
            } catch (Throwable t) {
                Log.e(ConnectionServiceWrapper.this, t, """");
                throw t;
            } finally {
                Binder.restoreCallingIdentity(token);
                Log.endSession();
            }
        }",1
"private boolean patternMatches(EasyField easyField, Object val) {
        if (!(easyField instanceof EasyText)) return true;

        Pattern patt = ((EasyText) easyField).getPattern();
        return patt == null || patt.matcher((CharSequence) val).matches();
    }",1
"protected void onRequestRows(int firstRowIndex, int numberOfRows,
            int firstCachedRowIndex, int cacheSize) {
        if (numberOfRows > getMaximumAllowedRows()) {
            throw new IllegalStateException(
                    ""Client tried fetch more rows than allowed. This is denied to prevent denial of service."");
        }
        setPushRows(Range.withLength(firstRowIndex, numberOfRows));
        markAsDirty();
    }",1
"private void setLong(String secureSettingKey, long value, int userHandle) {
        try {
            getLockSettings().setLong(secureSettingKey, value, userHandle);
        } catch (RemoteException re) {
            // What can we do?
            Log.e(TAG, ""Couldn't write long "" + secureSettingKey + re);
        }
    }",0
"public void deleteById(Integer id) {
        databaseTypeDao.selectOptionalById(id).ifPresent(data -> {
            if (DatabaseTypes.has(data.getDatabaseType())) {
                throw DomainErrors.MUST_NOT_MODIFY_SYSTEM_DEFAULT_DATABASE_TYPE.exception();
            }
            databaseTypeDao.deleteById(id);
            driverResources.deleteByDatabaseType(data.getDatabaseType());
        });
    }",1
"public void decode(ResResource res, Directory inDir, Directory outDir, Map<String, String> resFileMapping)
            throws AndrolibException {

        ResFileValue fileValue = (ResFileValue) res.getValue();
        String inFilePath = fileValue.toString();
        String inFileName = fileValue.getStrippedPath();
        String typeName = res.getResSpec().getType().getName();
        String outResName = res.getFilePath();

        if (BrutIO.detectPossibleDirectoryTraversal(outResName)) {
            outResName = inFileName;
            LOGGER.warning(String.format(
                ""Potentially malicious file path: %s, using instead %s"", res.getFilePath(), outResName
            ));
        }

        String ext = null;
        String outFileName;
        int extPos = inFileName.lastIndexOf(""."");
        if (extPos == -1) {
            outFileName = outResName;
        } else {
            ext = inFileName.substring(extPos).toLowerCase();
            outFileName = outResName + ext;
        }

        String outFilePath = ""res/"" + outFileName;
        if (!inFilePath.equals(outFilePath)) {
            resFileMapping.put(inFilePath, outFilePath);
        }

        LOGGER.fine(""Decoding file "" + inFilePath + "" to "" + outFilePath);

        try {
            if (typeName.equals(""raw"")) {
                decode(inDir, inFilePath, outDir, outFileName, ""raw"");
                return;
            }
            if (typeName.equals(""font"") && !"".xml"".equals(ext)) {
                decode(inDir, inFilePath, outDir, outFileName, ""raw"");
                return;
            }
            if (typeName.equals(""drawable"") || typeName.equals(""mipmap"")) {
                if (inFileName.toLowerCase().endsWith("".9"" + ext)) {
                    outFileName = outResName + "".9"" + ext;

                    // check for htc .r.9.png
                    if (inFileName.toLowerCase().endsWith("".r.9"" + ext)) {
                        outFileName = outResName + "".r.9"" + ext;
                    }

                    // check for raw 9patch images
                    for (String extension : RAW_9PATCH_IMAGE_EXTENSIONS) {
                        if (inFileName.toLowerCase().endsWith(""."" + extension)) {
                            copyRaw(inDir, outDir, inFilePath, outFileName);
                            return;
                        }
                    }

                    // check for xml 9 patches which are just xml files
                    if (inFileName.toLowerCase().endsWith("".xml"")) {
                        decode(inDir, inFilePath, outDir, outFileName, ""xml"");
                        return;
                    }

                    try {
                        decode(inDir, inFilePath, outDir, outFileName, ""9patch"");
                        return;
                    } catch (CantFind9PatchChunkException ex) {
                        LOGGER.log(Level.WARNING, String.format(
                            ""Cant find 9patch chunk in file: \""%s\"". Renaming it to *.png."", inFileName
                        ), ex);
                        outDir.removeFile(outFileName);
                        outFileName = outResName + ext;
                    }
                }

                // check for raw image
                for (String extension : RAW_IMAGE_EXTENSIONS) {
                    if (inFileName.toLowerCase().endsWith(""."" + extension)) {
                        copyRaw(inDir, outDir, inFilePath, outFileName);
                        return;
                    }
                }

                if (!"".xml"".equals(ext)) {
                    decode(inDir, inFilePath, outDir, outFileName, ""raw"");
                    return;
                }
            }

            decode(inDir, inFilePath, outDir, outFileName, ""xml"");
        } catch (RawXmlEncounteredException ex) {
            // If we got an error to decode XML, lets assume the file is in raw format.
            // This is a large assumption, that might increase runtime, but will save us for situations where
            // XSD files are AXML`d on aapt1, but left in plaintext in aapt2.
            decode(inDir, inFilePath, outDir, outFileName, ""raw"");
        } catch (AndrolibException ex) {
            LOGGER.log(Level.SEVERE, String.format(
                ""Could not decode file, replacing by FALSE value: %s"",
            inFileName), ex);
            res.replace(new ResBoolValue(false, 0, null));
        }
    }",1
"public String serializeToString(Object obj, Map<String, Object> formParams, String contentType, boolean isBodyNullable) throws ApiException {
    try {
      if (contentType.startsWith(""multipart/form-data"")) {
        throw new ApiException(""multipart/form-data not yet supported for serializeToString (http signature authentication)"");
      } else if (contentType.startsWith(""application/x-www-form-urlencoded"")) {
        String formString = """";
        for (Entry<String, Object> param : formParams.entrySet()) {
          formString = param.getKey() + ""="" + URLEncoder.encode(parameterToString(param.getValue()), ""UTF-8"") + ""&"";
        }

        if (formString.length() == 0) { // empty string
          return formString;
        } else {
          return formString.substring(0, formString.length() - 1);
        }
      } else {
        if (isBodyNullable) {
          return obj == null ? ""null"" : json.getMapper().writeValueAsString(obj);
        } else {
          return obj == null ? """" : json.getMapper().writeValueAsString(obj);
        }
      }
    } catch (Exception ex) {
      throw new ApiException(""Failed to perform serializeToString: "" + ex.toString());
    }
  }",0
"public void destroy() {

        if (log.isDebugEnabled()) {
            log.debug(internal.getMessage(""finalizing""));
        }

        destroyModules();
        destroyInternal();
        getServletContext().removeAttribute(Globals.ACTION_SERVLET_KEY);

        // Release our LogFactory and Log instances (if any)
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        if (classLoader == null) {
            classLoader = ActionServlet.class.getClassLoader();
        }
        try {
            LogFactory.release(classLoader);
        } catch (Throwable t) {
            ; // Servlet container doesn't have the latest version
            ; // of commons-logging-api.jar installed

            // :FIXME: Why is this dependent on the container's version of commons-logging?
            // Shouldn't this depend on the version packaged with Struts?
            /*
              Reason: LogFactory.release(classLoader); was added as
              an attempt to investigate the OutOfMemory error reported on Bugzilla #14042.
              It was committed for version 1.136 by craigmcc
            */
        }

        PropertyUtils.clearDescriptors();

    }",0
"@Override
    public boolean equals(java.lang.Object arg0)
    {
        if (!(arg0 instanceof Document)) {
            return false;
        }
        Document d = (Document) arg0;
        return d.getXWikiContext().equals(getXWikiContext()) && this.doc.equals(d.doc);
    }",0
"private int runSetInstallLocation() {
        int loc;

        String arg = nextArg();
        if (arg == null) {
            System.err.println(""Error: no install location specified."");
            return 1;
        }
        try {
            loc = Integer.parseInt(arg);
        } catch (NumberFormatException e) {
            System.err.println(""Error: install location has to be a number."");
            return 1;
        }
        try {
            if (!mPm.setInstallLocation(loc)) {
                System.err.println(""Error: install location has to be a number."");
                return 1;
            }
            return 0;
        } catch (RemoteException e) {
            System.err.println(e.toString());
            System.err.println(PM_NOT_RUNNING_ERR);
            return 1;
        }
    }",0
"private JsonObject readObject(int depth) throws IOException {
    read();
    JsonObject object=new JsonObject();
    skipWhiteSpace();
    if (readIf('}')) {
      return object;
    }
    do {
      skipWhiteSpace();
      String name=readName();
      skipWhiteSpace();
      if (!readIf(':')) {
        throw expected(""':'"");
      }
      skipWhiteSpace();
      object.add(name, readValue(depth));
      skipWhiteSpace();
    } while (readIf(','));
    if (!readIf('}')) {
      throw expected(""',' or '}'"");
    }
    return object;
  }",1
"@Override
    public String toString() {
        return toNiceString(this.getClass(), ""clientId"", clientId, ""secret"", ""[protected]"",
            ""discoveryURI"", discoveryURI, ""scope"", scope, ""customParams"", customParams,
            ""clientAuthenticationMethod"", clientAuthenticationMethod, ""useNonce"", useNonce,
            ""preferredJwsAlgorithm"", preferredJwsAlgorithm, ""maxAge"", maxAge, ""maxClockSkew"", maxClockSkew,
            ""connectTimeout"", connectTimeout, ""readTimeout"", readTimeout, ""resourceRetriever"", resourceRetriever,
            ""responseType"", responseType, ""responseMode"", responseMode, ""logoutUrl"", logoutUrl,
            ""withState"", withState, ""stateGenerator"", stateGenerator, ""logoutHandler"", logoutHandler,
            ""tokenValidator"", tokenValidator, ""mappedClaims"", mappedClaims, ""allowUnsignedIdTokens"", allowUnsignedIdTokens);
    }",1
"public int getXWikiPreferenceAsInt(String preference, int defaultValue)
    {
        return this.xwiki.getXWikiPreferenceAsInt(preference, defaultValue, getXWikiContext());
    }",0
"@Test
  public void v1AuthUnauthorized() throws Exception {
    final TSDB tsdb = NettyMocks.getMockedHTTPTSDBWithAuthEnabled(AuthStatus.UNAUTHORIZED);
    final DataPoints[] datapoints = new DataPoints[1];
    datapoints[0] = new MockDataPoints().getMock();
    when(query_result.runAsync()).thenReturn(
        Deferred.fromResult(datapoints));

    final HttpQuery query = NettyMocks.getQuery(tsdb,""/api/query?start=1h-ago&m=sum:sys.cpu.user"");

    try {
      TestHttpQuery.mockChannelFuture(query);
      rpc.execute(tsdb, query);
      fail(""Expected BadRequestException"");
    } catch (BadRequestException e) {
      assertEquals(HttpResponseStatus.UNAUTHORIZED, e.getStatus());
    }
  }",0
"public @SemanticAction int getSemanticAction() {
            return mSemanticAction;
        }",0
public abstract String getMimeType(String resourceName);,0
"@Override
    public List<ActionReturnValue> runMultipleActions(ActionType actionType,
            ArrayList<ActionParametersBase> multipleParams, boolean isRunOnlyIfAllValidationPass, boolean isWaitForResult) {
        log.debug(""Server: RunMultipleAction invoked! [amount of actions: {}]"", multipleParams.size()); //$NON-NLS-1$

        // CreateUserSession should never be invoked from GWT code
        if (actionType == ActionType.CreateUserSession) {
            ActionReturnValue error = new ActionReturnValue();
            error.setSucceeded(false);
            error.setFault(new EngineFault(new RuntimeException(""Command cannot be executed from client""))); //$NON-NLS-1$
            return Arrays.asList(error);
        }

        String correlationId = CorrelationIdTracker.getCorrelationId();
        for (ActionParametersBase params : multipleParams) {
            params.setSessionId(getEngineSessionId());
            if (params.getCorrelationId() == null) {
                params.setCorrelationId(correlationId);
            }

        }

        List<ActionReturnValue> returnValues =
                getBackend().runMultipleActions(actionType, multipleParams, isRunOnlyIfAllValidationPass, isWaitForResult);

        return returnValues;
    }",1
"public final CredentialCreatedListener getCredentialCreatedListener() {
      return credentialCreatedListener;
    }",0
"private String findPathConsideringContracts(LibraryInfo library,
                                     String resourceName,
                                     String localePrefix,
                                     ContractInfo [] outContract,
                                     FacesContext ctx) {
        UIViewRoot root = ctx.getViewRoot();
        List<String> contracts = null;

        if (library != null) {
            if(library.getContract() == null) {
                contracts = Collections.emptyList();
            } else {
                contracts = new ArrayList<String>(1);
                contracts.add(library.getContract());
            }
        } else if (root == null) {
            String contractName = ctx.getExternalContext().getRequestParameterMap()
                  .get(""con"");
            if (null != contractName && 0 < contractName.length() && !ResourceManager.nameContainsForbiddenSequence(contractName)) {
                contracts = new ArrayList<>();
                contracts.add(contractName);
            } else {
                return null;
            }
        } else {
        	contracts = ctx.getResourceLibraryContracts();
        }

        String basePath = null;
        
        for (String curContract : contracts) {
        
            if (library != null) {
                // PENDING(fcaputo) no need to iterate over the contracts, if we have a library
                basePath = library.getPath(localePrefix) + '/' + resourceName;
            } else {
                if (localePrefix == null) {
                    basePath = getBaseContractsPath() + '/' + curContract + '/' + resourceName;
                } else {
                    basePath = getBaseContractsPath()
                            + '/' + curContract 
                            + '/'
                            + localePrefix
                            + '/'
                            + resourceName;
                }
            }
            
            try {
                if (ctx.getExternalContext().getResource(basePath) != null) {
                    outContract[0] = new ContractInfo(curContract);
                    break;
                } else {
                    basePath = null;
                }
            } catch (MalformedURLException e) {
                throw new FacesException(e);
            }
        }
            
        return basePath;
    }",1
"@VisibleForTesting
	public void setSearchCoordinatorSvcForUnitTest(ISearchCoordinatorSvc theSearchCoordinatorSvc) {
		mySearchCoordinatorSvc = theSearchCoordinatorSvc;
	}",0
"@Override
        public long getCreationTime() {
            synchronized (OpenSslEngine.this) {
                if (creationTime == 0 && !isDestroyed()) {
                    creationTime = SSL.getTime(ssl) * 1000L;
                }
            }
            return creationTime;
        }",0
"public static Secret decrypt(String data) {
        if (data == null) return null;

        if (data.startsWith(""{"") && data.endsWith(""}"")) { //likely CBC encrypted/containing metadata but could be plain text
            byte[] payload;
            try {
                payload = Base64.decode(data.substring(1, data.length()-1).toCharArray());
            } catch (IOException e) {
                return null;
            }
            switch (payload[0]) {
                case PAYLOAD_V1:
                    // For PAYLOAD_V1 we use this byte shifting model, V2 probably will need DataOutput
                    int ivLength = ((payload[1] & 0xff) << 24)
                            | ((payload[2] & 0xff) << 16)
                            | ((payload[3] & 0xff) << 8)
                            | (payload[4] & 0xff);
                    int dataLength = ((payload[5] & 0xff) << 24)
                            | ((payload[6] & 0xff) << 16)
                            | ((payload[7] & 0xff) << 8)
                            | (payload[8] & 0xff);
                    if (payload.length != 1 + 8 + ivLength + dataLength) {
                        // not valid v1
                        return null;
                    }
                    byte[] iv = Arrays.copyOfRange(payload, 9, 9 + ivLength);
                    byte[] code = Arrays.copyOfRange(payload, 9+ivLength, payload.length);
                    String text;
                    try {
                        text = new String(KEY.decrypt(iv).doFinal(code), UTF_8);
                    } catch (GeneralSecurityException e) {
                        // it's v1 which cannot be historical, but not decrypting
                        return null;
                    }
                    return new Secret(text, iv);
                default:
                    return null;
            }
        } else {
            try {
                return HistoricalSecrets.decrypt(data, KEY);
            } catch (GeneralSecurityException e) {
                return null;
            } catch (UnsupportedEncodingException e) {
                throw new Error(e); // impossible
            } catch (IOException e) {
                return null;
            }
        }
    }",1
"final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {
        XMLInputFactory factory = XMLInputFactory.newInstance();
        factory.setProperty(XMLInputFactory.IS_COALESCING, true);
        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);
        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
        
        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));
    }",1
"public Cursor query(SQLiteDatabase db, String[] projectionIn,
            String selection, String[] selectionArgs, String groupBy,
            String having, String sortOrder, String limit, CancellationSignal cancellationSignal) {
        if (mTables == null) {
            return null;
        }

        final String sql;
        final String unwrappedSql = buildQuery(
                projectionIn, selection, groupBy, having,
                sortOrder, limit);

        if (mStrict && selection != null && selection.length() > 0) {
            // Validate the user-supplied selection to detect syntactic anomalies
            // in the selection string that could indicate a SQL injection attempt.
            // The idea is to ensure that the selection clause is a valid SQL expression
            // by compiling it twice: once wrapped in parentheses and once as
            // originally specified. An attacker cannot create an expression that
            // would escape the SQL expression while maintaining balanced parentheses
            // in both the wrapped and original forms.

            // NOTE: The ordering of the below operations is important; we must
            // execute the wrapped query to ensure the untrusted clause has been
            // fully isolated.

            // Validate the unwrapped query
            db.validateSql(unwrappedSql, cancellationSignal); // will throw if query is invalid

            // Execute wrapped query for extra protection
            final String wrappedSql = buildQuery(projectionIn, wrap(selection), groupBy,
                    having, sortOrder, limit);
            sql = wrappedSql;
        } else {
            // Execute unwrapped query
            sql = unwrappedSql;
        }

        final String[] sqlArgs = selectionArgs;
        if (Log.isLoggable(TAG, Log.DEBUG)) {
            if (Build.IS_DEBUGGABLE) {
                Log.d(TAG, sql + "" with args "" + Arrays.toString(sqlArgs));
            } else {
                Log.d(TAG, sql);
            }
        }
        return db.rawQueryWithFactory(
                mFactory, sql, sqlArgs,
                SQLiteDatabase.findEditTable(mTables),
                cancellationSignal); // will throw if query is invalid
    }",1
"public Object getInterface( Class clas )
	{
		return getInterface( new Class[] { clas } );
	}",1
"public @Nullable WifiConfiguration getConfiguredNetworkWithoutMasking(int networkId) {
        WifiConfiguration config = getInternalConfiguredNetwork(networkId);
        if (config == null) {
            return null;
        }
        return new WifiConfiguration(config);
    }",0
"@Override
  public byte[] encrypt(final byte[] input) throws CryptoException
  {
    return process(header(), true, input);
  }",1
"public static String concat(String ... dbColumns) throws DotRuntimeException{
		if (dbColumns == null){
			throw new DotRuntimeException(""the column list being concated are null"");
		}
		StringBuilder bob = new StringBuilder();
		boolean first = true;
		for (String col : dbColumns) {
			if(DbConnectionFactory.isMsSql()){
				if(!first){
					bob.append("" + "");
				}
				bob.append(""cast( "" ).append( col ).append( "" as varchar(512))"");
			}else if(DbConnectionFactory.isMySql()){
				if(first){
					bob.append(""CONCAT("");
				}else{
					bob.append("","");
				}
				bob.append(col);
			}else{
				if(!first){
					bob.append("" || "");
				}
				bob.append(col);
			}
			first = false;
		}
		if(DbConnectionFactory.isMySql()){
			bob.append("")"");
		}
		return bob.toString();
	}",0
"@Override
    public void execute() throws MojoExecutionException {
        File inputSpecFile = new File(inputSpec);
        addCompileSourceRootIfConfigured();

        try {
            if (Boolean.TRUE.equals(skip)) {
                getLog().info(""Code generation is skipped."");
                return;
            }

            if (buildContext != null && inputSpec != null ) {
                if (buildContext.isIncremental() &&
                        inputSpecFile.exists() &&
                        !buildContext.hasDelta(inputSpecFile)) {
                    getLog().info(
                            ""Code generation is skipped in delta-build because source-json was not modified."");
                    return;
                }
            }

            if (Boolean.TRUE.equals(skipIfSpecIsUnchanged) && inputSpecFile.exists()) {
                File storedInputSpecHashFile = getHashFile(inputSpecFile);
                if (storedInputSpecHashFile.exists()) {
                    String inputSpecHash = null;
                    try {
                        inputSpecHash = calculateInputSpecHash(inputSpecFile);
                    } catch (IOException ex) {
                        ex.printStackTrace();
                    }
                    @SuppressWarnings(""UnstableApiUsage"")
                    String storedInputSpecHash = Files.asCharSource(storedInputSpecHashFile, StandardCharsets.UTF_8).read();
                    if (storedInputSpecHash.equals(inputSpecHash)) {
                        getLog().info(
                                ""Code generation is skipped because input was unchanged"");
                        return;
                    }
                }
            }

            // attempt to read from config file
            CodegenConfigurator configurator = CodegenConfigurator.fromFile(configurationFile);

            // if a config file wasn't specified or we were unable to read it
            if (configurator == null) {
                configurator = new CodegenConfigurator();
            }

            configurator.setVerbose(verbose);

            if (skipOverwrite != null) {
                configurator.setSkipOverwrite(skipOverwrite);
            }

            if (removeOperationIdPrefix != null) {
                configurator.setRemoveOperationIdPrefix(removeOperationIdPrefix);
            }

            if (skipOperationExample != null) {
                configurator.setSkipOperationExample(skipOperationExample);
            }

            if (isNotEmpty(inputSpec)) {
                configurator.setInputSpec(inputSpec);
            }

            if (isNotEmpty(gitHost)) {
                configurator.setGitHost(gitHost);
            }

            if (isNotEmpty(gitUserId)) {
                configurator.setGitUserId(gitUserId);
            }

            if (isNotEmpty(gitRepoId)) {
                configurator.setGitRepoId(gitRepoId);
            }

            if (isNotEmpty(ignoreFileOverride)) {
                configurator.setIgnoreFileOverride(ignoreFileOverride);
            }

            if (isNotEmpty(httpUserAgent)) {
                configurator.setHttpUserAgent(httpUserAgent);
            }

            if (skipValidateSpec != null) {
                configurator.setValidateSpec(!skipValidateSpec);
            }

            if (strictSpec != null) {
                configurator.setStrictSpecBehavior(strictSpec);
            }

            if (logToStderr != null) {
                configurator.setLogToStderr(logToStderr);
            }

            if (enablePostProcessFile != null) {
                configurator.setEnablePostProcessFile(enablePostProcessFile);
            }

            if (generateAliasAsModel  != null) {
                configurator.setGenerateAliasAsModel(generateAliasAsModel);
            }

            if (isNotEmpty(generatorName)) {
                configurator.setGeneratorName(generatorName);
            } else {
                LOGGER.error(""A generator name (generatorName) is required."");
                throw new MojoExecutionException(""The generator requires 'generatorName'. Refer to documentation for a list of options."");
            }

            configurator.setOutputDir(output.getAbsolutePath());

            if (isNotEmpty(auth)) {
                configurator.setAuth(auth);
            }

            if (isNotEmpty(apiPackage)) {
                configurator.setApiPackage(apiPackage);
            }

            if (isNotEmpty(modelPackage)) {
                configurator.setModelPackage(modelPackage);
            }

            if (isNotEmpty(invokerPackage)) {
                configurator.setInvokerPackage(invokerPackage);
            }

            if (isNotEmpty(packageName)) {
                configurator.setPackageName(packageName);
            }

            if (isNotEmpty(groupId)) {
                configurator.setGroupId(groupId);
            }

            if (isNotEmpty(artifactId)) {
                configurator.setArtifactId(artifactId);
            }

            if (isNotEmpty(artifactVersion)) {
                configurator.setArtifactVersion(artifactVersion);
            }

            if (isNotEmpty(library)) {
                configurator.setLibrary(library);
            }

            if (isNotEmpty(modelNamePrefix)) {
                configurator.setModelNamePrefix(modelNamePrefix);
            }

            if (isNotEmpty(modelNameSuffix)) {
                configurator.setModelNameSuffix(modelNameSuffix);
            }

            if (null != templateDirectory) {
                configurator.setTemplateDir(templateDirectory.getAbsolutePath());
            }

            if (StringUtils.isNotEmpty(templateResourcePath)) {
                if (null != templateDirectory) {
                    LOGGER.warn(""Both templateDirectory and templateResourcePath were configured. templateResourcePath overwrites templateDirectory."");
                }
                configurator.setTemplateDir(templateResourcePath);
            }

            if (null != engine) {
                configurator.setTemplatingEngineName(engine);
            }

            // Set generation options
            if (null != generateApis && generateApis) {
                GlobalSettings.setProperty(CodegenConstants.APIS, apisToGenerate);
            } else {
                GlobalSettings.clearProperty(CodegenConstants.APIS);
            }

            if (null != generateModels && generateModels) {
                GlobalSettings.setProperty(CodegenConstants.MODELS, modelsToGenerate);
            } else {
                GlobalSettings.clearProperty(CodegenConstants.MODELS);
            }

            if (null != generateSupportingFiles && generateSupportingFiles) {
                GlobalSettings.setProperty(CodegenConstants.SUPPORTING_FILES, supportingFilesToGenerate);
            } else {
                GlobalSettings.clearProperty(CodegenConstants.SUPPORTING_FILES);
            }

            GlobalSettings.setProperty(CodegenConstants.MODEL_TESTS, generateModelTests.toString());
            GlobalSettings.setProperty(CodegenConstants.MODEL_DOCS, generateModelDocumentation.toString());
            GlobalSettings.setProperty(CodegenConstants.API_TESTS, generateApiTests.toString());
            GlobalSettings.setProperty(CodegenConstants.API_DOCS, generateApiDocumentation.toString());
            GlobalSettings.setProperty(CodegenConstants.WITH_XML, withXml.toString());

            if (configOptions != null) {
                // Retained for backwards-compataibility with configOptions -> instantiation-types
                if (instantiationTypes == null && configOptions.containsKey(""instantiation-types"")) {
                    applyInstantiationTypesKvp(configOptions.get(""instantiation-types"").toString(),
                            configurator);
                }

                // Retained for backwards-compatibility with configOptions -> import-mappings
                if (importMappings == null && configOptions.containsKey(""import-mappings"")) {
                    applyImportMappingsKvp(configOptions.get(""import-mappings"").toString(),
                            configurator);
                }

                // Retained for backwards-compataibility with configOptions -> type-mappings
                if (typeMappings == null && configOptions.containsKey(""type-mappings"")) {
                    applyTypeMappingsKvp(configOptions.get(""type-mappings"").toString(), configurator);
                }

                // Retained for backwards-compataibility with configOptions -> language-specific-primitives
                if (languageSpecificPrimitives == null && configOptions.containsKey(""language-specific-primitives"")) {
                    applyLanguageSpecificPrimitivesCsv(configOptions
                            .get(""language-specific-primitives"").toString(), configurator);
                }

                // Retained for backwards-compataibility with configOptions -> additional-properties
                if (additionalProperties == null && configOptions.containsKey(""additional-properties"")) {
                    applyAdditionalPropertiesKvp(configOptions.get(""additional-properties"").toString(),
                            configurator);
                }

                if (serverVariableOverrides == null && configOptions.containsKey(""server-variables"")) {
                    applyServerVariablesKvp(configOptions.get(""server-variables"").toString(), configurator);
                }

                // Retained for backwards-compataibility with configOptions -> reserved-words-mappings
                if (reservedWordsMappings == null && configOptions.containsKey(""reserved-words-mappings"")) {
                    applyReservedWordsMappingsKvp(configOptions.get(""reserved-words-mappings"")
                            .toString(), configurator);
                }
            }

            // Apply Instantiation Types
            if (instantiationTypes != null && (configOptions == null || !configOptions.containsKey(""instantiation-types""))) {
                applyInstantiationTypesKvpList(instantiationTypes, configurator);
            }

            // Apply Import Mappings
            if (importMappings != null && (configOptions == null || !configOptions.containsKey(""import-mappings""))) {
                applyImportMappingsKvpList(importMappings, configurator);
            }

            // Apply Type Mappings
            if (typeMappings != null && (configOptions == null || !configOptions.containsKey(""type-mappings""))) {
                applyTypeMappingsKvpList(typeMappings, configurator);
            }

            // Apply Language Specific Primitives
            if (languageSpecificPrimitives != null
                    && (configOptions == null || !configOptions.containsKey(""language-specific-primitives""))) {
                applyLanguageSpecificPrimitivesCsvList(languageSpecificPrimitives, configurator);
            }

            // Apply Additional Properties
            if (additionalProperties != null && (configOptions == null || !configOptions.containsKey(""additional-properties""))) {
                applyAdditionalPropertiesKvpList(additionalProperties, configurator);
            }

            if (serverVariableOverrides != null && (configOptions == null || !configOptions.containsKey(""server-variables""))) {
                applyServerVariablesKvpList(serverVariableOverrides, configurator);
            }

            // Apply Reserved Words Mappings
            if (reservedWordsMappings != null && (configOptions == null || !configOptions.containsKey(""reserved-words-mappings""))) {
                applyReservedWordsMappingsKvpList(reservedWordsMappings, configurator);
            }

            if (globalProperties == null) {
                globalProperties = new HashMap<>();
            }

            if (environmentVariables != null && environmentVariables.size() > 0) {
                globalProperties.putAll(environmentVariables);
                getLog().warn(""environmentVariables is deprecated and will be removed in version 5.1. Use globalProperties instead."");
            }

            for (String key : globalProperties.keySet()) {
                String value = globalProperties.get(key);
                if (value != null) {
                    configurator.addGlobalProperty(key, value);
                }
            }

            final ClientOptInput input = configurator.toClientOptInput();
            final CodegenConfig config = input.getConfig();

            if (configOptions != null) {
                for (CliOption langCliOption : config.cliOptions()) {
                    if (configOptions.containsKey(langCliOption.getOpt())) {
                        input.getConfig().additionalProperties()
                                .put(langCliOption.getOpt(), configOptions.get(langCliOption.getOpt()));
                    }
                }
            }

            if (configHelp) {
                for (CliOption langCliOption : config.cliOptions()) {
                    System.out.println(""\t"" + langCliOption.getOpt());
                    System.out.println(""\t    ""
                            + langCliOption.getOptionHelp().replaceAll(""\n"", ""\n\t    ""));
                    System.out.println();
                }
                return;
            }
            adjustAdditionalProperties(config);
            new DefaultGenerator().opts(input).generate();

            if (buildContext != null) {
                buildContext.refresh(new File(getCompileSourceRoot()));
            }

            // Store a checksum of the input spec
            File storedInputSpecHashFile = getHashFile(inputSpecFile);
            String inputSpecHash = calculateInputSpecHash(inputSpecFile);

            if (storedInputSpecHashFile.getParent() != null && !new File(storedInputSpecHashFile.getParent()).exists()) {
                File parent = new File(storedInputSpecHashFile.getParent());
                if (!parent.mkdirs()) {
                    throw new RuntimeException(""Failed to create the folder "" + parent.getAbsolutePath() +
                                               "" to store the checksum of the input spec."");
                }
            }
            Files.asCharSink(storedInputSpecHashFile, StandardCharsets.UTF_8).write(inputSpecHash);

        } catch (Exception e) {
            // Maven logs exceptions thrown by plugins only if invoked with -e
            // I find it annoying to jump through hoops to get basic diagnostic information,
            // so let's log it in any case:
            if (buildContext != null) {
                buildContext.addMessage(inputSpecFile, 0, 0, ""unexpected error in Open-API generation"", BuildContext.SEVERITY_WARNING, e);
            }
            getLog().error(e);
            throw new MojoExecutionException(
                    ""Code generation failed. See above for the full exception."");
        }
    }",1
"public static void setClassLoader(ClassLoader classLoader) {
        MappingUtil.classLoader = classLoader;
    }",0
"public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection)
            throws DatabaseServiceException {
        try {

            // logger.info(""connection::{}, forceNewConnection: {}"", connection, forceNewConnection);

            if (connection != null && !forceNewConnection) {
                // logger.info(""connection closed::{}"", connection.isClosed());
                if (!connection.isClosed()) {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""Returning existing connection::{}"", connection);
                    }
                    return connection;
                }
            }

            Class.forName(type.getClassPath());
            DriverManager.setLoginTimeout(10);
            String dbURL = databaseConfiguration.toURI().toString();
            connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(),
                    databaseConfiguration.getDatabasePassword());

            logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);

            return connection;

        } catch (ClassNotFoundException e) {
            logger.error(""Jdbc Driver not found"", e);
            throw new DatabaseServiceException(e.getMessage());
        } catch (SQLException e) {
            logger.error(""SQLException::Couldn't get a Connection!"", e);
            throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
        }
    }",1
"protected List<String> getRawCommandLine( String executable, String[] arguments )
    {
        List<String> commandLine = new ArrayList<String>();
        StringBuilder sb = new StringBuilder();

        if ( executable != null )
        {
            String preamble = getExecutionPreamble();
            if ( preamble != null )
            {
                sb.append( preamble );
            }

            if ( isQuotedExecutableEnabled() )
            {
                sb.append( quoteOneItem( getOriginalExecutable(), true ) );
            }
            else
            {
                sb.append( getExecutable() );
            }
        }
        for ( int i = 0; i < arguments.length; i++ )
        {
            if ( sb.length() > 0 )
            {
                sb.append( "" "" );
            }

            if ( isQuotedArgumentsEnabled() )
            {
                sb.append( quoteOneItem( arguments[i], false ) );
            }
            else
            {
                sb.append( arguments[i] );
            }
        }

        commandLine.add( sb.toString() );

        return commandLine;
    }",1
"@POST
	@Path(""test/{nodeId}"")
	@Operation(summary = ""Update a Test Element onto a given course"", description = ""This updates a Test Element onto a given course"")
	@ApiResponse(responseCode = ""200"", description = ""The test node metadatas"", content = {
			@Content(mediaType = ""application/json"", schema = @Schema(implementation = CourseNodeVO.class)),
			@Content(mediaType = ""application/xml"", schema = @Schema(implementation = CourseNodeVO.class)) })
	@ApiResponse(responseCode = ""401"", description = ""The roles of the authenticated user are not sufficient"")
	@ApiResponse(responseCode = ""404"", description = ""The course or parentNode not found"")
	@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
	@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
	public Response updateTest(@PathParam(""courseId"") Long courseId, @PathParam(""nodeId"") String nodeId,
			@FormParam(""shortTitle"") @DefaultValue(""undefined"") String shortTitle, 
			@FormParam(""longTitle"") @DefaultValue(""undefined"") String longTitle, @FormParam(""objectives"") @DefaultValue(""undefined"") String objectives,
			@FormParam(""visibilityExpertRules"") String visibilityExpertRules, @FormParam(""accessExpertRules"") String accessExpertRules,
			@FormParam(""testResourceableId"") Long testResourceableId,  @Context HttpServletRequest request) {
		RepositoryManager rm = RepositoryManager.getInstance();
		RepositoryEntry testRepoEntry = rm.lookupRepositoryEntry(testResourceableId);
		if(testRepoEntry == null) {
			return Response.serverError().status(Status.NOT_FOUND).build();
		}
		CustomConfigDelegate config = CustomConfigFactory.getTestCustomConfig(testRepoEntry);
		return update(courseId, nodeId, shortTitle, longTitle, objectives, visibilityExpertRules, accessExpertRules, config, request);
	}",0
"protected void doDSGet(Context context, HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException,
            SQLException, AuthorizeException
    {
        /*
         * Possible GET parameters:
         * 
         * resume= <workspace_item_id> - Resumes submitting the given workspace
         * item
         * 
         * workflow= <workflow_id> - Starts editing the given workflow item in
         * workflow mode
         * 
         * With no parameters, doDSGet() just calls doDSPost(), which continues
         * the current submission (if one exists in the Request), or creates a
         * new submission (if no existing submission can be found).
         */

        // try to get a workspace ID or workflow ID
        String workspaceID = request.getParameter(""resume"");
        String workflowID = request.getParameter(""workflow"");
        String resumableFilename = request.getParameter(""resumableFilename"");

        // If resuming a workspace item
        if (workspaceID != null)
        {
            try
            {
                // load the workspace item
                WorkspaceItem wi = WorkspaceItem.find(context, Integer
                        .parseInt(workspaceID));

                //load submission information
                SubmissionInfo si = SubmissionInfo.load(request, wi);
                
                //TD: Special case - If a user is resuming a submission
                //where the submission process now has less steps, then
                //we will need to reset the stepReached in the database
                //(Hopefully this will never happen, but just in case!)
                if(getStepReached(si) >= si.getSubmissionConfig().getNumberOfSteps())
                {
                    //update Stage Reached to the last step in the Process
                    int lastStep = si.getSubmissionConfig().getNumberOfSteps()-1;
                    wi.setStageReached(lastStep);
                    
                    //flag that user is on last page of last step
                    wi.setPageReached(AbstractProcessingStep.LAST_PAGE_REACHED);
                    
                    //commit all changes to database immediately
                    wi.update();
                    context.commit();
                    
                    //update submission info
                    si.setSubmissionItem(wi);
                }
                    
                // start over at beginning of first step
                setBeginningOfStep(request, true);
                doStep(context, request, response, si, FIRST_STEP);
            }
            catch (NumberFormatException nfe)
            {
                log.warn(LogManager.getHeader(context, ""bad_workspace_id"",
                        ""bad_id="" + workspaceID));
                JSPManager.showInvalidIDError(request, response, workspaceID,
                        -1);
            }
        }
        else if (workflowID != null) // if resuming a workflow item
        {
            try
            {
                // load the workflow item
                WorkflowItem wi = WorkflowItem.find(context, Integer
                        .parseInt(workflowID));

                //load submission information
                SubmissionInfo si = SubmissionInfo.load(request, wi);
                
                // start over at beginning of first workflow step
                setBeginningOfStep(request, true);
                doStep(context, request, response, si, WORKFLOW_FIRST_STEP);
            }
            catch (NumberFormatException nfe)
            {
                log.warn(LogManager.getHeader(context, ""bad_workflow_id"",
                        ""bad_id="" + workflowID));
                JSPManager
                        .showInvalidIDError(request, response, workflowID, -1);
            }
        }
        else if (!StringUtils.isEmpty(resumableFilename)) // if resumable.js asks whether a part of af file was received
        {
            if (request.getMethod().equals(""GET""))
            {
                DoGetResumable(context, request, response);
            }
        }
        else
        {
            // otherwise, forward to doDSPost() to do usual processing
            doDSPost(context, request, response);
        }

    }",1
"public static boolean isActive() {
        return CACHE.get() != null;
    }",0
"@Override
	public <A extends Output<E>, E extends Exception> void append(A a, char c) throws E {
		switch (c) {
			case '""' -> {
				a.append(QUOT);
			}
			case '&' -> {
				a.append(AMP);
			}
			case '\'' -> {
				a.append(APOS);
			}
			case '<' -> {
				a.append(LT);
			}
			case '=' -> {
				a.append(EQUAL);
			}
			case '>' -> {
				a.append(GT);
			}
			case '`' -> {
				a.append(BACK_TICK);
			}
			default -> {
				a.append(c);
			}
		}
	}",1
"@Test
  public void pojo2jsonMap(TestContext context) throws Exception {
    Map<String,String> m = new HashMap<>();
    m.put(""a"", ""b"");
    context.assertEquals(""{\""a\"":\""b\""}"", PostgresClient.pojo2json(m));
  }",0
"protected void disableCertificateValidation(ClientBuilder clientBuilder) throws KeyManagementException, NoSuchAlgorithmException {
    TrustManager[] trustAllCerts = new X509TrustManager[] {
      new X509TrustManager() {
        @Override
        public X509Certificate[] getAcceptedIssuers() {
          return null;
        }
        @Override
        public void checkClientTrusted(X509Certificate[] certs, String authType) {
        }
        @Override
        public void checkServerTrusted(X509Certificate[] certs, String authType) {
        }
      }
    };
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, trustAllCerts, new SecureRandom());
    clientBuilder.sslContext(sslContext);
  }",0
"public static RequestHeaders toArmeriaRequestHeaders(ChannelHandlerContext ctx, Http2Headers headers,
                                                         boolean endOfStream, String scheme,
                                                         ServerConfig cfg) {
        final RequestHeadersBuilder builder = RequestHeaders.builder();
        toArmeria(builder, headers, endOfStream);
        // A CONNECT request might not have "":scheme"". See https://tools.ietf.org/html/rfc7540#section-8.1.2.3
        if (!builder.contains(HttpHeaderNames.SCHEME)) {
            builder.add(HttpHeaderNames.SCHEME, scheme);
        }
        if (!builder.contains(HttpHeaderNames.AUTHORITY)) {
            final String defaultHostname = cfg.defaultVirtualHost().defaultHostname();
            final int port = ((InetSocketAddress) ctx.channel().localAddress()).getPort();
            builder.add(HttpHeaderNames.AUTHORITY, defaultHostname + ':' + port);
        }
        return builder.build();
    }",0
"@Override
    public synchronized void init(Extent extent, IChunkCache<IChunkGet> get, IChunkCache<IChunkSet> set) {
        reset();
        this.minY = extent.getMinY();
        this.maxY = extent.getMaxY();
        currentThread = Thread.currentThread();
        if (get == null) {
            get = (x, z) -> {
                throw new UnsupportedOperationException();
            };
        }
        if (set == null) {
            set = (x, z) -> CharSetBlocks.newInstance();
        }
        this.cacheGet = get;
        this.cacheSet = set;
        this.setProcessor(EmptyBatchProcessor.getInstance());
        this.setPostProcessor(EmptyBatchProcessor.getInstance());
        initialized = true;

        if (extent.isWorld()) {
            world = (World) ((extent instanceof PassthroughExtent) ? ((PassthroughExtent) extent).getExtent() : extent);
        } else if (extent instanceof EditSession) {
            world = ((EditSession) extent).getWorld();
        } else {
            world = WorldWrapper.unwrap(extent);
        }
    }",0
"@Override
        public void setWidth(final int width) {
            super.setWidth(width);
            final int currH = getHeight();
            if(nativeVideo != null){
                activity.runOnUiThread(new Runnable() {

                    public void run() {
                        float nh = nativeVideo.getHeight();
                        float nw = nativeVideo.getWidth();
                        float w = width;
                        float h = currH;
                        if (nh != 0 && nw != 0) {
                            h = width * nh / nw;
                            if (h > getHeight()) {
                                h = getHeight();
                                w = h * nw / nh;
                            }
                            if (w > getWidth()) {
                                w = getWidth();
                                h = w * nh / nw;
                            }
                        }
                        RelativeLayout.LayoutParams layout = new RelativeLayout.LayoutParams((int)w, (int)h);
                        layout.addRule(RelativeLayout.CENTER_HORIZONTAL);
                        layout.addRule(RelativeLayout.CENTER_VERTICAL);
                        nativeVideo.setLayoutParams(layout);
                        nativeVideo.requestLayout();
                        nativeVideo.getHolder().setSizeFromLayout();
                    }
                });
            }
        }",0
"private <T> T execute(HttpMethod method, Env env, String path, Object request, Class<T> responseType,
                        Object... uriVariables) {

    if (path.startsWith(""/"")) {
      path = path.substring(1, path.length());
    }

    String uri = uriTemplateHandler.expand(path, uriVariables).getPath();
    Transaction ct = Tracer.newTransaction(""AdminAPI"", uri);
    ct.addData(""Env"", env);

    List<ServiceDTO> services = getAdminServices(env, ct);
    HttpHeaders extraHeaders = assembleExtraHeaders(env);

    for (ServiceDTO serviceDTO : services) {
      try {

        T result = doExecute(method, extraHeaders, serviceDTO, path, request, responseType, uriVariables);

        ct.setStatus(Transaction.SUCCESS);
        ct.complete();
        return result;
      } catch (Throwable t) {
        logger.error(""Http request failed, uri: {}, method: {}"", uri, method, t);
        Tracer.logError(t);
        if (canRetry(t, method)) {
          Tracer.logEvent(TracerEventType.API_RETRY, uri);
        } else {//biz exception rethrow
          ct.setStatus(t);
          ct.complete();
          throw t;
        }
      }
    }

    //all admin server down
    ServiceException e =
        new ServiceException(String.format(""Admin servers are unresponsive. meta server address: %s, admin servers: %s"",
                portalMetaDomainService.getDomain(env), services));
    ct.setStatus(e);
    ct.complete();
    throw e;
  }",1
"@Override
        boolean check(NetworkConfig c1, NetworkConfig c2) {
            return c1 == c2 || !(c1 == null || c2 == null)
                    && nullSafeEqual(c1.getPort(), c2.getPort())
                    && nullSafeEqual(c1.getPortCount(), c2.getPortCount())
                    && nullSafeEqual(c1.isPortAutoIncrement(), c2.isPortAutoIncrement())
                    && nullSafeEqual(c1.isReuseAddress(), c2.isReuseAddress())
                    && nullSafeEqual(c1.getPublicAddress(), c2.getPublicAddress())
                    && isCompatible(c1.getOutboundPortDefinitions(), c2.getOutboundPortDefinitions())
                    && nullSafeEqual(c1.getOutboundPorts(), c2.getOutboundPorts())
                    && isCompatible(c1.getInterfaces(), c2.getInterfaces())
                    && isCompatible(c1.getJoin(), c2.getJoin())
                    && isCompatible(c1.getSymmetricEncryptionConfig(), c2.getSymmetricEncryptionConfig())
                    && isCompatible(c1.getSocketInterceptorConfig(), c2.getSocketInterceptorConfig())
                    && isCompatible(c1.getSSLConfig(), c2.getSSLConfig());
        }",0
"public void visitNodeTree(Consumer<StateNode> visitor) {
        LinkedList<StateNode> stack = new LinkedList<>();
        stack.add(this);
        while (!stack.isEmpty()) {
            StateNode node = stack.removeFirst();
            visitor.accept(node);
            node.forEachChild(child -> stack.add(0, child));
        }
    }",0
"final void add(CharSequence name, String value) {
        final AsciiString normalizedName = HttpHeaderNames.of(name);
        requireNonNull(value, ""value"");
        final int h = normalizedName.hashCode();
        final int i = index(h);
        add0(h, i, normalizedName, value);
    }",1
"public Object nextValue() throws JSONException {
        char c = this.nextClean();
        switch (c) {
        case '{':
            this.back();
            try {
                return new JSONObject(this);
            } catch (StackOverflowError e) {
                throw new JSONException(""JSON Array or Object depth too large to process."", e);
            }
        case '[':
            this.back();
            try {
                return new JSONArray(this);
            } catch (StackOverflowError e) {
                throw new JSONException(""JSON Array or Object depth too large to process."", e);
            }
        }
        return nextSimpleValue(c);
    }",1
"@Override
    protected AbstractChainingPrintRenderer getSyntaxRenderer()
    {
        return new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,
            getListenerChain());
    }",1
"@Override
    protected void doPost( HttpServletRequest request,
                           HttpServletResponse response ) throws ServletException, IOException {

        try {
            if ( request.getParameter( ""path"" ) != null ) {

                final URI uri = new URI( request.getParameter( ""path"" ) );

                if ( !validateAccess( uri, response ) ) {
                    return;
                }

                writeFile( ioService.get( uri ), getFileItem( request ) );

                writeResponse( response, ""OK"" );
            } else if ( request.getParameter( ""folder"" ) != null ) {

                final URI uri = new URI( request.getParameter( ""folder"" ) + ""/"" + request.getParameter( ""fileName"" ) );

                if ( !validateAccess( uri, response ) ) {
                    return;
                }

                writeFile(
                        ioService.get( uri ),
                        getFileItem( request ) );

                writeResponse( response, ""OK"" );
            }

        } catch ( FileUploadException e ) {
            logError( e );
            writeResponse( response, ""FAIL"" );
        } catch ( URISyntaxException e ) {
            logError( e );
            writeResponse( response, ""FAIL"" );
        }
    }",1
"private void verifyShortcutInfoPackage(String callerPackage, ShortcutInfo si) {
        if (si == null) {
            return;
        }
        if (!Objects.equals(callerPackage, si.getPackage())) {
            android.util.EventLog.writeEvent(0x534e4554, ""109824443"", -1, """");
            throw new SecurityException(""Shortcut package name mismatch"");
        }
        final int callingUid = injectBinderCallingUid();
        if (UserHandle.getUserId(callingUid) != si.getUserId()) {
            throw new SecurityException(""User-ID in shortcut doesn't match the caller"");
        }
    }",1
"private String getPackageNameForUid(int uid) {
        String[] packageNames = mPackageManager.getPackagesForUid(uid);
        if (ArrayUtils.isEmpty(packageNames)) {
            return null;
        }
        String packageName = packageNames[0];
        if (packageNames.length == 1) {
            return packageName;
        }
        // Due to visibility changes we want to use package with oldest target SDK
        int oldestVersion = Integer.MAX_VALUE;
        for (String name : packageNames) {
            try {
                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);
                if (applicationInfo != null) {
                    int version = applicationInfo.targetSdkVersion;
                    if (version < oldestVersion) {
                        oldestVersion = version;
                        packageName = name;
                    }
                }
            } catch (NameNotFoundException e) {
                // skip
            }
        }
        return packageName;
    }",0
"private static void checkDowngrade(PackageParser.Package before, PackageInfoLite after)
            throws PackageManagerException {
        if (after.versionCode < before.mVersionCode) {
            throw new PackageManagerException(INSTALL_FAILED_VERSION_DOWNGRADE,
                    ""Update version code "" + after.versionCode + "" is older than current ""
                    + before.mVersionCode);
        } else if (after.versionCode == before.mVersionCode) {
            if (after.baseRevisionCode < before.baseRevisionCode) {
                throw new PackageManagerException(INSTALL_FAILED_VERSION_DOWNGRADE,
                        ""Update base revision code "" + after.baseRevisionCode
                        + "" is older than current "" + before.baseRevisionCode);
            }

            if (!ArrayUtils.isEmpty(after.splitNames)) {
                for (int i = 0; i < after.splitNames.length; i++) {
                    final String splitName = after.splitNames[i];
                    final int j = ArrayUtils.indexOf(before.splitNames, splitName);
                    if (j != -1) {
                        if (after.splitRevisionCodes[i] < before.splitRevisionCodes[j]) {
                            throw new PackageManagerException(INSTALL_FAILED_VERSION_DOWNGRADE,
                                    ""Update split "" + splitName + "" revision code ""
                                    + after.splitRevisionCodes[i] + "" is older than current ""
                                    + before.splitRevisionCodes[j]);
                        }
                    }
                }
            }
        }
    }",0
"@Override
    protected AbstractChainingPrintRenderer getSyntaxRenderer()
    {
        return new XHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,
            getListenerChain());
    }",1
"private void doFileUpload(HttpSession session, HttpServletRequest request,
			HttpServletResponse response) throws IOException {
		String fieldName =null;
		AjaxFileUploadListener listener = null;
		try {

			String fileName = """";

			listener = new AjaxFileUploadListener(request.getContentLength());
			FileItemFactory factory = new MonitoredDiskFileItemFactory(listener);
			fieldName = request.getParameter(""fieldName"");
			Enumeration params = request.getParameterNames();
			session.setAttribute(""FILE_UPLOAD_STATS_"" + fieldName, listener.getFileUploadStats());
			ServletFileUpload upload = new ServletFileUpload(factory);

			List items = upload.parseRequest(request);
			boolean hasError = false;
			isEmptyFile = false;

			String userId = null;
			// if we want front end access, this validation would need to be altered
			if(UtilMethods.isSet(session.getAttribute(""USER_ID""))) {
				userId = (String) session.getAttribute(""USER_ID"");
				User user = UserLocalManagerUtil.getUserById(userId);

				if(!UtilMethods.isSet(user) || !UtilMethods.isSet(user.getUserId())) {
					throw new Exception(""Could not upload File. Invalid User"");
				}

			} else {
				throw new Exception(""Could not upload File. Invalid User"");
			}


			for (Iterator i = items.iterator(); i.hasNext();) {
				FileItem fileItem = (FileItem) i.next();

				if (!fileItem.isFormField()) {


					// *************************************************
					// This is where you would process the uploaded file
					// *************************************************

					if(fileItem.getSize() == 0)
						isEmptyFile = true;

					if (fileItem.getName().contains(File.separator)) {
						fileName = fileItem.getName().substring(
								fileItem.getName().lastIndexOf(File.separator) + 1);
					} else {
						fileName = fileItem.getName();
					}
					fileName = ContentletUtil.sanitizeFileName(fileName);
					fieldName = ContentletUtil.sanitizeFileName(fieldName);
					File tempUserFolder = new File(APILocator.getFileAssetAPI().getRealAssetPathTmpBinary() + File.separator + userId +
							File.separator + fieldName);

					if(!isValidPath(tempUserFolder.getCanonicalPath())) {
						throw new IOException(""Invalid fileName or Path"");
					}

					if (!tempUserFolder.exists())
						tempUserFolder.mkdirs();
					File dest=new File(tempUserFolder.getAbsolutePath() + File.separator + fileName);
					if(dest.exists())
						dest.delete();
					fileItem.write(dest);
					fileItem.delete();
				}
			}

			if(isEmptyFile)
				fileName = """";

			if (!hasError) {
				sendCompleteResponse(response, null);
			} else {
				sendCompleteResponse(response, ""Could not process uploaded file. Please see log for details."");
			}
		} catch (Exception e) {
			listener.error(""error"");
			session.setAttribute(""FILE_UPLOAD_STATS_"" + fieldName, listener.getFileUploadStats());
			sendCompleteResponse(response, e.getMessage());
			e.printStackTrace();
		}
	}",1
"public void getById(String table, String id, Handler<AsyncResult<JsonObject>> replyHandler) {
    getById(table, id, JsonObject::new, replyHandler);
  }",0
"public ViewManager getViewManager() {
        if (viewManager == null) {
            try {
                try {
                    update();
                } catch (IDDOCNotFoundException e) {
                    reload(lastReceivedIdentifier);
                }
            } catch (PresentationException e) {
                logger.debug(StringConstants.LOG_PRESENTATION_EXCEPTION_THROWN_HERE, e.getMessage());
            } catch (RecordNotFoundException | RecordDeletedException | RecordLimitExceededException e) {
                if (e.getMessage() != null && !""null"".equals(e.getMessage()) && !""???"".equals(e.getMessage())) {
                    logger.warn(""{}: {}"", e.getClass().getName(), e.getMessage());
                }
            } catch (IndexUnreachableException | DAOException | ViewerConfigurationException e) {
                logger.error(e.getMessage(), e);
            }
        }

        return viewManager;
    }",0
"protected void sendRawPdu(SmsTracker tracker) {
        HashMap map = tracker.mData;
        byte pdu[] = (byte[]) map.get(""pdu"");

        if (mSmsSendDisabled) {
            Rlog.e(TAG, ""Device does not support sending sms."");
            tracker.onFailed(mContext, RESULT_ERROR_NO_SERVICE, 0/*errorCode*/);
            return;
        }

        if (pdu == null) {
            Rlog.e(TAG, ""Empty PDU"");
            tracker.onFailed(mContext, RESULT_ERROR_NULL_PDU, 0/*errorCode*/);
            return;
        }

        // Get calling app package name via UID from Binder call
        PackageManager pm = mContext.getPackageManager();
        String[] packageNames = pm.getPackagesForUid(Binder.getCallingUid());

        if (packageNames == null || packageNames.length == 0) {
            // Refuse to send SMS if we can't get the calling package name.
            Rlog.e(TAG, ""Can't get calling app package name: refusing to send SMS"");
            tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/);
            return;
        }

        // Get package info via packagemanager
        PackageInfo appInfo;
        try {
            // XXX this is lossy- apps can share a UID
            appInfo = pm.getPackageInfo(packageNames[0], PackageManager.GET_SIGNATURES);
        } catch (PackageManager.NameNotFoundException e) {
            Rlog.e(TAG, ""Can't get calling app package info: refusing to send SMS"");
            tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0/*errorCode*/);
            return;
        }

        // checkDestination() returns true if the destination is not a premium short code or the
        // sending app is approved to send to short codes. Otherwise, a message is sent to our
        // handler with the SmsTracker to request user confirmation before sending.
        if (checkDestination(tracker)) {
            // check for excessive outgoing SMS usage by this app
            if (!mUsageMonitor.check(appInfo.packageName, SINGLE_PART_SMS)) {
                sendMessage(obtainMessage(EVENT_SEND_LIMIT_REACHED_CONFIRMATION, tracker));
                return;
            }

            sendSms(tracker);
        }
    }",0
"public static CertRevokeRequest fromXML(String xml) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element requestElement = document.getDocumentElement();
        return fromDOM(requestElement);
    }",1
"@Override
            public SVNAuthentication createSVNAuthentication(String kind) {
                if(kind.equals(ISVNAuthenticationManager.SSL))
                    try {
                        SVNSSLAuthentication authentication = new SVNSSLAuthentication(
                                Base64.decode(certificate.getPlainText().toCharArray()),
                                Scrambler.descramble(Secret.toString(password)), false);
                        authentication.setCertificatePath(""dummy""); // TODO: remove this JENKINS-19175 workaround
                        return authentication;
                    } catch (IOException e) {
                        throw new Error(e); // can't happen
                    }
                else
                    return null; // unexpected authentication type
            }",1
"@Test
  public void saveTransSyntaxError(TestContext context) {
    postgresClient = createFoo(context);
    postgresClient.startTx(asyncAssertTx(context, trans -> {
      postgresClient.save(trans, ""'"", xPojo, context.asyncAssertFailure(save -> {
        postgresClient.rollbackTx(trans, context.asyncAssertSuccess());
      }));
    }));
  }",0
"@Override
    public void setupClientDefaults(ClientRepresentation clientRep, ClientModel newClient) {
        SamlRepresentationAttributes rep = new SamlRepresentationAttributes(clientRep.getAttributes());
        SamlClient client = new SamlClient(newClient);
        if (clientRep.isStandardFlowEnabled() == null) newClient.setStandardFlowEnabled(true);
        if (rep.getCanonicalizationMethod() == null) {
            client.setCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE);
        }
        if (rep.getSignatureAlgorithm() == null) {
            client.setSignatureAlgorithm(SignatureAlgorithm.RSA_SHA256);
        }

        if (rep.getNameIDFormat() == null) {
            client.setNameIDFormat(""username"");
        }

        if (rep.getIncludeAuthnStatement() == null) {
            client.setIncludeAuthnStatement(true);
        }

        if (rep.getForceNameIDFormat() == null) {
            client.setForceNameIDFormat(false);
        }

        if (rep.getAllowEcpFlow() == null) {
            client.setAllowECPFlow(false);
        }

        if (rep.getSamlServerSignature() == null) {
            client.setRequiresRealmSignature(true);
        }
        if (rep.getForcePostBinding() == null) {
            client.setForcePostBinding(true);
        }

        if (rep.getClientSignature() == null) {
            client.setRequiresClientSignature(true);
        }

        if (client.requiresClientSignature() && client.getClientSigningCertificate() == null) {
            CertificateRepresentation info = KeycloakModelUtils.generateKeyPairCertificate(newClient.getClientId());
            client.setClientSigningCertificate(info.getCertificate());
            client.setClientSigningPrivateKey(info.getPrivateKey());

        }

        if (clientRep.isFrontchannelLogout() == null) {
            newClient.setFrontchannelLogout(true);
        }

        client.setArtifactBindingIdentifierFrom(clientRep.getClientId());
    }",1
"private static byte[] generateDefaultPersonalizationString(SecureRandom random)
    {
        return Arrays.concatenate(Strings.toByteArray(""Default""), random.generateSeed(16),
            Pack.longToBigEndian(Thread.currentThread().getId()), Pack.longToBigEndian(System.currentTimeMillis()));
    }",1
"public EventCrfFlag findByEventCrfPath(int tagId, String path) {
        String query = ""from "" + getDomainClassName() + "" where path = :path and tagId= :tagId"";
        org.hibernate.Query q = getCurrentSession().createQuery(query);
        q.setInteger(""tagId"", tagId);
        q.setString(""path"", path);
        
        return (EventCrfFlag) q.uniqueResult();

    }",1
"public int getPendingIntentLaunchFlags() {
        // b/243794108: Ignore all flags except the new task flag, to be reconsidered in b/254490217
        return mPendingIntentLaunchFlags &
                (FLAG_ACTIVITY_NEW_TASK | FLAG_RECEIVER_FOREGROUND);
    }",1
"@Nullable
	public String getSecret() {
		return secret;
	}",0
"public PtrDnsAnswer reverseLookup(String ipAddress) throws InterruptedException, ExecutionException {

        LOG.debug(""Attempting to perform reverse lookup for IP address [{}]"", ipAddress);

        if (resolverPool.isStopped()) {
            throw new DnsClientNotRunningException();
        }

        validateIpAddress(ipAddress);

        final String inverseAddressFormat = getInverseAddressFormat(ipAddress);

        DnsResponse content = null;
        final ResolverLease resolverLease = resolverPool.takeLease();
        try {
            content = resolverLease.getResolver().query(new DefaultDnsQuestion(inverseAddressFormat, DnsRecordType.PTR)).get(requestTimeout, TimeUnit.MILLISECONDS).content();
            for (int i = 0; i < content.count(DnsSection.ANSWER); i++) {

                // Return the first PTR record, because there should be only one as per
                // http://tools.ietf.org/html/rfc1035#section-3.5
                final DnsRecord dnsRecord = content.recordAt(DnsSection.ANSWER, i);
                if (dnsRecord instanceof DefaultDnsPtrRecord) {

                    final DefaultDnsPtrRecord ptrRecord = (DefaultDnsPtrRecord) dnsRecord;
                    final PtrDnsAnswer.Builder dnsAnswerBuilder = PtrDnsAnswer.builder();

                    final String hostname = ptrRecord.hostname();
                    LOG.trace(""PTR record retrieved with hostname [{}]"", hostname);

                    try {
                        parseReverseLookupDomain(dnsAnswerBuilder, hostname);
                    } catch (IllegalArgumentException e) {
                        LOG.debug(""Reverse lookup of [{}] was partially successful. The DNS server returned [{}], "" +
                                  ""which is an invalid host name. The \""domain\"" field will be left blank."",
                                  ipAddress, hostname);
                        dnsAnswerBuilder.domain("""");
                    }

                    return dnsAnswerBuilder.dnsTTL(ptrRecord.timeToLive())
                                           .build();
                }
            }
        } catch (TimeoutException e) {
            throw new ExecutionException(""Resolver future didn't return a result in "" + requestTimeout + "" ms"", e);
        } finally {
            if (content != null) {
                // Must manually release references on content object since the DnsResponse class extends ReferenceCounted
                content.release();
            }
            resolverPool.returnLease(resolverLease);
        }

        return null;
    }",1
"public TSet readSetBegin() throws TException {
    byte type = readByte();
    int size = readI32();
    ensureContainerHasEnough(size, type);
    return new TSet(type, size);
  }",1
"public void saveWithProgrammingRights(String comment) throws XWikiException
    {
        saveWithProgrammingRights(comment, false);
    }",0
"@Override
    public StaticFileHandler createHandler(VaadinService service) {
        if (service instanceof VaadinServletService) {
            return new OSGiStaticFileHandler((VaadinServletService) service);
        }
        return null;
    }",1
"@UserHandleAware(
            enabledSinceTargetSdkVersion = UPSIDE_DOWN_CAKE,
            requiresPermissionIfNotCaller = INTERACT_ACROSS_USERS)
    public @Nullable PackagePolicy getCredentialManagerPolicy() {
        throwIfParentInstance(""getCredentialManagerPolicy"");
        if (mService != null) {
            try {
                return mService.getCredentialManagerPolicy(myUserId());
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return null;
    }",1
"final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread,
            boolean fromBinderDied) {
        // First check if this ProcessRecord is actually active for the pid.
        synchronized (mPidsSelfLocked) {
            ProcessRecord curProc = mPidsSelfLocked.get(pid);
            if (curProc != app) {
                Slog.w(TAG, ""Spurious death for "" + app + "", curProc for "" + pid + "": "" + curProc);
                return;
            }
        }

        BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
        synchronized (stats) {
            stats.noteProcessDiedLocked(app.info.uid, pid);
        }

        if (!app.killed) {
            if (!fromBinderDied) {
                Process.killProcessQuiet(pid);
            }
            killProcessGroup(app.uid, pid);
            app.killed = true;
        }

        // Clean up already done if the process has been re-started.
        if (app.pid == pid && app.thread != null &&
                app.thread.asBinder() == thread.asBinder()) {
            boolean doLowMem = app.instrumentationClass == null;
            boolean doOomAdj = doLowMem;
            if (!app.killedByAm) {
                Slog.i(TAG, ""Process "" + app.processName + "" (pid "" + pid
                        + "") has died"");
                mAllowLowerMemLevel = true;
            } else {
                // Note that we always want to do oom adj to update our state with the
                // new number of procs.
                mAllowLowerMemLevel = false;
                doLowMem = false;
            }
            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
            if (DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,
                ""Dying app: "" + app + "", pid: "" + pid + "", thread: "" + thread.asBinder());
            handleAppDiedLocked(app, false, true);

            if (doOomAdj) {
                updateOomAdjLocked();
            }
            if (doLowMem) {
                doLowMemReportIfNeededLocked(app);
            }
        } else if (app.pid != pid) {
            // A new process has already been started.
            Slog.i(TAG, ""Process "" + app.processName + "" (pid "" + pid
                    + "") has died and restarted (pid "" + app.pid + "")."");
            EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
        } else if (DEBUG_PROCESSES) {
            Slog.d(TAG_PROCESSES, ""Received spurious death notification for thread ""
                    + thread.asBinder());
        }
    }",1
"@RequiresPermissions(""user:list"")
    @GetMapping(""/list"")
    public String list(@RequestParam(defaultValue = ""1"") Integer pageNo, String username, Model model) {
        if (username != null) username = username.replace(""\"""", """").replace(""'"", """");
//        username= SecurityUtil.sanitizeInput(username);
        IPage<User> iPage = userService.selectAll(pageNo, username);
        model.addAttribute(""page"", iPage);
        model.addAttribute(""username"", username);
        return ""admin/user/list"";
    }",1
"@Override
        public void onCancelClicked() {
            mKeyguardViewControllerLazy.get().onCancelClicked();
        }",0
"public Translations toRestTranslations(URI baseUri, Document doc) throws XWikiException
    {
        Translations translations = this.objectFactory.createTranslations();
        Locale defaultLocale = getDefaultLocale(doc);
        translations.setDefault(defaultLocale.toString());

        List<Locale> locales = doc.getTranslationLocales();

        List<String> spaces = Utils.getSpacesFromSpaceId(doc.getSpace());

        // Add the default (original) page translation, if it makes sense.
        if (!locales.isEmpty() && !Locale.ROOT.equals(defaultLocale)) {
            Translation translation = this.objectFactory.createTranslation();
            translation.setLanguage(translations.getDefault());

            String pageTranslationUri = Utils
                .createURI(baseUri, PageResource.class, doc.getWiki(), spaces, doc.getDocumentReference().getName())
                .toString();
            Link pageTranslationLink = this.objectFactory.createLink();
            pageTranslationLink.setHref(pageTranslationUri);
            pageTranslationLink.setRel(Relations.PAGE);
            translation.getLinks().add(pageTranslationLink);

            String historyUri = Utils.createURI(baseUri, PageHistoryResource.class, doc.getWiki(), spaces,
                doc.getDocumentReference().getName()).toString();
            Link historyLink = this.objectFactory.createLink();
            historyLink.setHref(historyUri);
            historyLink.setRel(Relations.HISTORY);
            translation.getLinks().add(historyLink);

            translations.getTranslations().add(translation);
        }

        for (Locale locale : locales) {
            Translation translation = this.objectFactory.createTranslation();
            translation.setLanguage(locale.toString());

            String pageTranslationUri = Utils.createURI(baseUri, PageTranslationResource.class, doc.getWiki(), spaces,
                doc.getDocumentReference().getName(), locale).toString();
            Link pageTranslationLink = this.objectFactory.createLink();
            pageTranslationLink.setHref(pageTranslationUri);
            pageTranslationLink.setRel(Relations.PAGE);
            translation.getLinks().add(pageTranslationLink);

            String historyUri = Utils.createURI(baseUri, PageTranslationHistoryResource.class, doc.getWiki(), spaces,
                doc.getDocumentReference().getName(), locale).toString();
            Link historyLink = this.objectFactory.createLink();
            historyLink.setHref(historyUri);
            historyLink.setRel(Relations.HISTORY);
            translation.getLinks().add(historyLink);

            translations.getTranslations().add(translation);
        }

        return translations;
    }",0
"public static void releaseLastXrefPartial(PdfObject obj) {
        if (obj == null)
            return;
        if (!obj.isIndirect())
            return;
        if (!(obj instanceof PRIndirectReference))
            return;

        PRIndirectReference ref = (PRIndirectReference)obj;
        PdfReader reader = ref.getReader();
        if (reader.partial && reader.lastXrefPartial != -1 && reader.lastXrefPartial == ref.getNumber()) {
            reader.xrefObj.set(reader.lastXrefPartial, null);
        }
        reader.lastXrefPartial = -1;
    }",0
"private boolean guestUserRegistration(AbstractRegistrationPage registrationPage)
    {
        registrationPage.clickRegister();

        return ((RegistrationPage) registrationPage).getRegistrationSuccessMessage().isPresent();
    }",1
public void requestBugReport() throws RemoteException;,0
"private boolean createSnapshot(TaskSnapshot snapshot, int typeParams) {
        if (snapshot == null) {
            return false;
        }

        ProtoLog.v(WM_DEBUG_STARTING_WINDOW, ""Creating SnapshotStartingData"");
        mStartingData = new SnapshotStartingData(mWmService, snapshot, typeParams);
        if (task.forAllLeafTaskFragments(TaskFragment::isEmbedded)) {
            // Associate with the task so if this activity is resized by task fragment later, the
            // starting window can keep the same bounds as the task.
            associateStartingDataWithTask();
        }
        scheduleAddStartingWindow();
        return true;
    }",0
"private static RMQMessage instantiateRmqMessage(String messageClass, List<String> trustedPackages) throws RMQJMSException {
        if(isRmqObjectMessageClass(messageClass)) {
            return instantiateRmqObjectMessageWithTrustedPackages(trustedPackages);
        } else if (isRmqStreamMessageClass(messageClass)) {
            return instantiateRmqStreamMessageWithTrustedPackages(trustedPackages);
        } else {
            try {
                // instantiate the message object with the thread context classloader
                return (RMQMessage) Class.forName(messageClass, true, Thread.currentThread().getContextClassLoader()).getDeclaredConstructor().newInstance();
            } catch (InstantiationException e) {
                throw new RMQJMSException(e);
            } catch (IllegalAccessException e) {
                throw new RMQJMSException(e);
            } catch (ClassNotFoundException e) {
                throw new RMQJMSException(e);
            } catch (NoSuchMethodException e) {
                throw new RMQJMSException(e);
            } catch (InvocationTargetException e) {
                throw new RMQJMSException(e);
            }
        }
    }",1
"@Override
        public CharSequence getQueueTitle() {
            return mQueueTitle;
        }",0
"@Override
    protected void pointerReleased(final int x, final int y) {
        super.pointerReleased(x, y);
    }",0
"@Override
    public void onDisplayAdded(int displayId) {
        if (DEBUG_STACK) Slog.v(TAG, ""Display added displayId="" + displayId);
        mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_ADDED, displayId, 0));
    }",0
"@Override
	public String createQueryFragment(AtomicInteger incrementor) {
		if (condition != null) {
			return condition.createQueryFragment(incrementor);
		} else {
			return """";
		}

	}",0
"protected String evaluateTitle(String title, DocumentModelBridge document,
        DocumentDisplayerParameters parameters)
    {
        StringWriter writer = new StringWriter();
        String namespace = defaultEntityReferenceSerializer.serialize(parameters.isTransformationContextIsolated()
            ? document.getDocumentReference() : documentAccessBridge.getCurrentDocumentReference());

        // Get the velocity engine
        VelocityEngine velocityEngine;
        try {
            velocityEngine = this.velocityManager.getVelocityEngine();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        // Execute Velocity code
        Map<String, Object> backupObjects = null;
        boolean canPop = false;
        EntityReference currentWikiReference = this.modelContext.getCurrentEntityReference();
        try {
            if (parameters.isExecutionContextIsolated()) {
                backupObjects = new HashMap<>();
                // The following method call also clones the execution context.
                documentAccessBridge.pushDocumentInContext(backupObjects, document);
                // Pop the document from the context only if the push was successful!
                canPop = true;
                // Make sure to synchronize the context wiki with the context document's wiki.
                modelContext.setCurrentEntityReference(document.getDocumentReference().getWikiReference());
            }
            velocityEngine.evaluate(velocityManager.getVelocityContext(), writer, namespace, title);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            if (canPop) {
                documentAccessBridge.popDocumentFromContext(backupObjects);
                // Also restore the context wiki.
                this.modelContext.setCurrentEntityReference(currentWikiReference);
            }
        }
        return writer.toString();
    }",1
"@Test
	public void createsCountQueryForNestedReferenceCorrectly() {
		assertCountQuery(""select a.b from A a"", ""select count(a.b) from A a"");
	}",0
"public Document getDocument(DocumentReference reference, String revision) throws XWikiException
    {
        try {
            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {
                DocumentRevisionProvider revisionProvider = getDocumentRevisionProvider();
                revisionProvider.checkAccess(Right.VIEW, CurrentUserReference.INSTANCE, reference, revision);
                XWikiDocument documentRevision = revisionProvider.getRevision(reference, revision);

                if (documentRevision != null) {
                    return new Document(documentRevision, this.context);
                }
            }
        } catch (AuthorizationException e) {
            LOGGER.info(""Access denied for loading revision [{}] of document [{}]: [{}]"", revision, reference,
                ExceptionUtils.getRootCauseMessage(e));
        } catch (Exception e) {
            LOGGER.error(""Failed to access revision [{}] of document {}"", revision, reference, e);
        }

        return null;
    }",1
"public void moveTaskToTop(int taskId) {
        final long origId = Binder.clearCallingIdentity();
        try {
            synchronized(mWindowMap) {
                Task task = mTaskIdToTask.get(taskId);
                if (task == null) {
                    // Normal behavior, addAppToken will be called next and task will be created.
                    return;
                }
                final TaskStack stack = task.mStack;
                final DisplayContent displayContent = task.getDisplayContent();
                displayContent.moveStack(stack, true);
                if (displayContent.isDefaultDisplay) {
                    final TaskStack homeStack = displayContent.getHomeStack();
                    if (homeStack != stack) {
                        // When a non-home stack moves to the top, the home stack moves to the
                        // bottom.
                        displayContent.moveStack(homeStack, false);
                    }
                }
                stack.moveTaskToTop(task);
                if (mAppTransition.isTransitionSet()) {
                    task.setSendingToBottom(false);
                }
                moveStackWindowsLocked(displayContent);
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }",0
"private void handleOtherRequest(String pathInfo, HttpServletResponse response) throws IOException {
        String[] parts = pathInfo.split(""/"");
        // Image request must be in correct format.
        if (parts.length < 3) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        String contextPath = """";
        int index = pathInfo.indexOf(parts[1]);
        if (index != -1) {
            contextPath = pathInfo.substring(index + parts[1].length());
        }

        File pluginDirectory = new File(JiveGlobals.getHomeDirectory(), ""plugins"");
        File file = new File(pluginDirectory, parts[1] + File.separator + ""web"" + contextPath);

        // When using dev environment, the images dir may be under something other that web.
        Plugin plugin = pluginManager.getPlugin(parts[1]);
        PluginDevEnvironment environment = pluginManager.getDevEnvironment(plugin);

        if (environment != null) {
            file = new File(environment.getWebRoot(), contextPath);
        } else {
            if ( !ALLOW_LOCAL_FILE_READING.getValue() ) {
                // If _not_ in a DEV environment, ensure that the file that's being served is a
                // file that is part of Openfire. This guards against accessing files from the
                // operating system, or other files that shouldn't be accessible via the web (OF-1886).
                final Path absoluteHome = new File( JiveGlobals.getHomeDirectory() ).toPath().normalize().toAbsolutePath();
                final Path absoluteLookup = file.toPath().normalize().toAbsolutePath();
                if ( !absoluteLookup.startsWith( absoluteHome ) )
                {
                    response.setStatus( HttpServletResponse.SC_FORBIDDEN );
                    return;
                }
            }
        }

        if (!file.exists()) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        String contentType = getServletContext().getMimeType(pathInfo);
        if (contentType == null) {
            contentType = ""text/plain"";
        }
        response.setContentType(contentType);
        // Write out the resource to the user.
        try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {
            try (ServletOutputStream out = response.getOutputStream()) {

                // Set the size of the file.
                response.setContentLength((int) file.length());

                // Use a 1K buffer.
                byte[] buf = new byte[1024];
                int len;
                while ((len = in.read(buf)) != -1) {
                    out.write(buf, 0, len);
                }
            }
        }
    }",1
"public void initialize(CryptoWishList cwl, ServerHostKeyVerifier verifier, DHGexParameters dhgex,
			int connectTimeout, SecureRandom rnd, ProxyData proxyData) throws IOException
	{
		/* First, establish the TCP connection to the SSH-2 server */

		establishConnection(proxyData, connectTimeout);

		/* Parse the server line and say hello - important: this information is later needed for the
		 * key exchange (to stop man-in-the-middle attacks) - that is why we wrap it into an object
		 * for later use.
		 */

		ClientServerHello csh = new ClientServerHello(sock.getInputStream(), sock.getOutputStream());

		tc = new TransportConnection(sock.getInputStream(), sock.getOutputStream(), rnd);

		km = new KexManager(this, csh, cwl, hostname, port, verifier, rnd);
		km.initiateKEX(cwl, dhgex);

		receiveThread = new Thread(new Runnable()
		{
			public void run()
			{
				try
				{
					receiveLoop();
				}
				catch (IOException e)
				{
					close(e, false);

					if (log.isEnabled())
						log.log(10, ""Receive thread: error in receiveLoop: "" + e.getMessage());
				}

				if (log.isEnabled())
					log.log(50, ""Receive thread: back from receiveLoop"");

				/* Tell all handlers that it is time to say goodbye */

				if (km != null)
				{
					try
					{
						km.handleMessage(null, 0);
					}
					catch (IOException e)
					{
					}
				}

				for (int i = 0; i < messageHandlers.size(); i++)
				{
					HandlerEntry he = messageHandlers.elementAt(i);
					try
					{
						he.mh.handleMessage(null, 0);
					}
					catch (Exception ignore)
					{
					}
				}
			}
		});

		receiveThread.setDaemon(true);
		receiveThread.start();
	}",0
"private void decOpenCountLocked() {
        mOpenCount--;
        if (mOpenCount == 0) {
            mStrings.close();
            nativeDestroy(mNative);
            mNative = 0;
            if (mAssets != null) {
                mAssets.xmlBlockGone(hashCode());
            }
        }
    }",1
"public boolean validate() {
        if (mPolicyUpdate == null) {
            Log.d(TAG, ""PolicyUpdate not specified"");
            return false;
        }
        if (!mPolicyUpdate.validate()) {
            return false;
        }

        // Validate SSID exclusion list.
        if (mExcludedSsidList != null) {
            if (mExcludedSsidList.length > MAX_EXCLUSION_SSIDS) {
                Log.d(TAG, ""SSID exclusion list size exceeded the max: ""
                        + mExcludedSsidList.length);
                return false;
            }
            for (String ssid : mExcludedSsidList) {
                if (ssid.getBytes(StandardCharsets.UTF_8).length > MAX_SSID_BYTES) {
                    Log.e(TAG, ""Invalid SSID: "" + ssid);
                    return false;
                }
            }
        }
        // Validate required protocol to port map.
        if (mRequiredProtoPortMap != null) {
            for (Map.Entry<Integer, String> entry : mRequiredProtoPortMap.entrySet()) {
                int protocol = entry.getKey();
                if (protocol < 0 || protocol > 255) {
                    Log.e(TAG, ""Invalid IP protocol: "" + protocol);
                    return false;
                }
                String portNumber = entry.getValue();
                if (portNumber.getBytes(StandardCharsets.UTF_8).length > MAX_PORT_STRING_BYTES) {
                    Log.e(TAG, ""PortNumber string bytes exceeded the max: "" + portNumber);
                    return false;
                }
            }
        }
        // Validate preferred roaming partner list.
        if (mPreferredRoamingPartnerList != null) {
            if (mPreferredRoamingPartnerList.size() > MAX_NUMBER_OF_ENTRIES) {
                Log.e(TAG, ""Number of the Preferred Roaming Partner exceed the limit"");
                return false;
            }
            for (RoamingPartner partner : mPreferredRoamingPartnerList) {
                if (!partner.validate()) {
                    return false;
                }
            }
        }
        return true;
    }",1
"protected static TomlFactory newTomlFactory() {
        return TomlFactory.builder()
                .enable(TomlReadFeature.VALIDATE_NESTING_DEPTH)
                .build();
    }",1
"public @NonNull List<String> getNewPermissions() {
            return mSplitPermissionInfoParcelable.getNewPermissions();
        }",0
"@Deprecated(since = ""2.2M2"")
    public BaseObject addObjectFromRequest(String className, String prefix, int num, XWikiContext context)
        throws XWikiException
    {
        return addXObjectFromRequest(resolveClassReference(className), prefix, num, context);
    }",0
"@Test
    public void retrieveUsername(TestUtils testUtils) throws Exception
    {
        // We create three users, two of them are sharing the same email
        String user1Login = ""realuser1"";
        String user1Email = ""realuser@host.org"";

        String user2Login = ""realuser2"";
        String user2Email = ""realuser@host.org"";

        String user3Login = ""foo"";
        String user3Email = ""foo@host.org"";

        // We need to login as superadmin to set the user email.
        testUtils.loginAsSuperAdmin();
        testUtils.createUser(user1Login, ""realuserpwd"", testUtils.getURLToNonExistentPage(), ""email"", user1Email);
        testUtils.createUser(user2Login, ""realuserpwd"", testUtils.getURLToNonExistentPage(), ""email"", user2Email);
        testUtils.createUser(user3Login, ""realuserpwd"", testUtils.getURLToNonExistentPage(), ""email"", user3Email);

        testUtils.forceGuestUser();

        // check that when asking to retrieve username with a wrong email we don't get any information
        // if an user exists or not and no email is sent.
        ForgotUsernamePage forgotUsernamePage = ForgotUsernamePage.gotoPage();
        forgotUsernamePage.setEmail(""notexistant@xwiki.com"");
        ForgotUsernameCompletePage forgotUsernameCompletePage = forgotUsernamePage.clickRetrieveUsername();
        assertTrue(forgotUsernameCompletePage.isForgotUsernameQuerySent());

        // we are waiting 5 sec here just to be sure no mail is sent, maybe we could decrease the timeout value,
        // not sure.
        assertFalse(this.mail.waitForIncomingEmail(1));

        // Bypass the check that prevents to reload the current page
        testUtils.gotoPage(testUtils.getURLToNonExistentPage());

        // test getting email for a forgot username request where the email is set in one account only
        forgotUsernamePage = ForgotUsernamePage.gotoPage();
        forgotUsernamePage.setEmail(user3Email);
        forgotUsernameCompletePage = forgotUsernamePage.clickRetrieveUsername();
        assertTrue(forgotUsernameCompletePage.isForgotUsernameQuerySent());
        assertTrue(this.mail.waitForIncomingEmail(1));
        MimeMessage[] receivedEmails = this.mail.getReceivedMessages();
        assertEquals(1, receivedEmails.length);
        MimeMessage receivedEmail = receivedEmails[0];
        assertTrue(receivedEmail.getSubject().contains(""Forgot username on""));
        String receivedMailContent = getMessageContent(receivedEmail).get(""textPart"");
        assertTrue(receivedMailContent.contains(String.format(""XWiki.%s"", user3Login)));

        // remove mails for last test
        this.mail.purgeEmailFromAllMailboxes();

        // Bypass the check that prevents to reload the current page
        testUtils.gotoPage(testUtils.getURLToNonExistentPage());

        // test getting email for a forgot username request where the email is set in two accounts
        forgotUsernamePage = ForgotUsernamePage.gotoPage();
        forgotUsernamePage.setEmail(user1Email);
        forgotUsernameCompletePage = forgotUsernamePage.clickRetrieveUsername();
        assertTrue(forgotUsernameCompletePage.isForgotUsernameQuerySent());
        assertTrue(this.mail.waitForIncomingEmail(1));
        receivedEmails = this.mail.getReceivedMessages();
        assertEquals(1, receivedEmails.length);
        receivedEmail = receivedEmails[0];
        assertTrue(receivedEmail.getSubject().contains(""Forgot username on""));
        receivedMailContent = getMessageContent(receivedEmail).get(""textPart"");
        assertTrue(receivedMailContent.contains(String.format(""XWiki.%s"", user1Login)));
        assertTrue(receivedMailContent.contains(String.format(""XWiki.%s"", user2Login)));
    }",1
"void injectSendIntentSender(IntentSender intentSender, Intent extras) {
        if (intentSender == null) {
            return;
        }
        try {
            ActivityOptions options = ActivityOptions.makeBasic()
                    .setPendingIntentBackgroundActivityStartMode(
                            MODE_BACKGROUND_ACTIVITY_START_DENIED);
            intentSender.sendIntent(mContext, /* code= */ 0, extras,
                    /* onFinished=*/ null, /* handler= */ null, null, options.toBundle());
        } catch (SendIntentException e) {
            Slog.w(TAG, ""sendIntent failed()."", e);
        }
    }",1
"@Override
	protected void runTeardown() {
		Assert.assertTrue(""Socket connection is not allowed"", securityExceptionOccurred);
	}",1
"@Override
        public boolean hasStartedUserState(int userId) {
            return mUserController.hasStartedUserState(userId);
        }",0
"@Nullable
  public String getCipherAlgorithm() {
    return cipherAlgorithm;
  }",1
"public void setXObjectsToRemove(List<BaseObject> objectsToRemove)
    {
        this.xObjectsToRemove = objectsToRemove;
        setMetaDataDirty(true);
    }",0
"private String evaluate(String content, String name, VelocityContext vcontext, XWikiContext context)
    {
        StringWriter writer = new StringWriter();
        try {
            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);
            velocityManager.getVelocityEngine().evaluate(vcontext, writer, name, content);
            return writer.toString();
        } catch (Exception e) {
            LOGGER.error(""Error while parsing velocity template namespace [{}]"", name, e);
            Object[] args = { name };
            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,
                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, ""Error while parsing velocity page {0}"", e,
                args);
            return Util.getHTMLExceptionMessage(xe, context);
        }
    }",0
"@Override
        public int checkPermission(@NonNull String packageName, @NonNull String permissionName,
                int userId, @NonNull TriFunction<String, String, Integer, Integer> superImpl) {
            if (mDelegatedPackageName.equals(packageName)
                    && isDelegatedPermission(permissionName)) {
                final long identity = Binder.clearCallingIdentity();
                try {
                    return superImpl.apply(""com.android.shell"", permissionName, userId);
                } finally {
                    Binder.restoreCallingIdentity(identity);
                }
            }
            return superImpl.apply(packageName, permissionName, userId);
        }",0
"public static final File createTempDir() throws IOException
   {
      File dir = Files.createTempFile(""mpxj"", ""tmp"").toFile();
      delete(dir);
      mkdirs(dir);
      return dir;
   }",1
"@Override
    public void printXMLStartElement(String name, Attributes attributes)
    {
        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {
            handleSpaceWhenStartElement();
            super.printXMLStartElement(name, cleanAttributes(name, attributes));
        }
    }",1
"public synchronized void updateBoolean(@Positive int columnIndex, boolean x) throws SQLException {
    updateValue(columnIndex, x);
  }",0
"private void execute(String jobToken, TaskLogger jobLogger, Object executionContext) {
		jobLogger.log(""Checking cluster access..."");
		JobContext jobContext;
		if (executionContext instanceof JobContext)
			jobContext = (JobContext) executionContext;
		else
			jobContext = null;
		
		Commandline kubectl = newKubeCtl();
		kubectl.addArgs(""cluster-info"");
		kubectl.execute(new LineConsumer() {

			@Override
			public void consume(String line) {
				logger.debug(line);
			}
			
		}, new LineConsumer() {

			@Override
			public void consume(String line) {
				jobLogger.log(line);
			}
			
		}).checkReturnCode();
		
		String namespace ;
		if (jobContext != null) {
			namespace = getName() + ""-"" + jobContext.getProjectId() + ""-"" 
					+ jobContext.getBuildNumber() + ""-"" + jobContext.getRetried();
		} else {
			namespace = getName() + ""-executor-test"";
		}
		
		if (getClusterRole() != null)
			createClusterRoleBinding(namespace, jobLogger);
		
		try {
			createNamespace(namespace, jobContext, jobLogger);
			
			jobLogger.log(String.format(""Executing job (executor: %s, namespace: %s)..."", 
					getName(), namespace));
			try {
				String imagePullSecretName = createImagePullSecret(namespace, jobLogger);
				if (jobContext != null) {
					for (Service jobService: jobContext.getServices()) {
						jobLogger.log(""Starting service (name: "" + jobService.getName() + "", image: "" + jobService.getImage() + "")..."");
						startService(namespace, jobContext, jobService, imagePullSecretName, jobLogger);
					}
				}
				
				String trustCertsConfigMapName = createTrustCertsConfigMap(namespace, jobLogger);
				
				OsInfo osInfo = getBaselineOsInfo(getNodeSelector(), jobLogger);
				
				Map<String, Object> podSpec = new LinkedHashMap<>();

				List<Map<Object, Object>> containerSpecs = new ArrayList<>();
				
				String containerBuildHome;
				String containerCommandHome;
				String containerCacheHome;
				String containerAuthInfoHome;
				String trustCertsHome;
				String dockerSock;
				String containerdSock;
				String containerWorkspace;
				if (osInfo.isWindows()) {
					containerBuildHome = ""C:\\onedev-build"";
					containerWorkspace = containerBuildHome + ""\\workspace"";
					containerCacheHome = containerBuildHome + ""\\cache"";
					containerCommandHome = containerBuildHome + ""\\command"";
					containerAuthInfoHome = ""C:\\Users\\ContainerAdministrator\\auth-info"";
					trustCertsHome = containerBuildHome + ""\\trust-certs"";
					dockerSock = ""\\\\.\\pipe\\docker_engine"";
					containerdSock = ""\\\\.\\pipe\\containerd-containerd"";
				} else {
					containerBuildHome = ""/onedev-build"";
					containerWorkspace = containerBuildHome +""/workspace"";
					containerCacheHome = containerBuildHome + ""/cache"";
					containerCommandHome = containerBuildHome + ""/command"";
					containerAuthInfoHome = ""/root/auth-info"";
					trustCertsHome = containerBuildHome + ""/trust-certs"";
					dockerSock = ""/var/run/docker.sock"";
					containerdSock = ""/run/containerd/containerd.sock"";
				}

				Map<String, String> buildHomeMount = CollectionUtils.newLinkedHashMap(
						""name"", ""build-home"", 
						""mountPath"", containerBuildHome);
				Map<String, String> authInfoMount = CollectionUtils.newLinkedHashMap(
						""name"", ""auth-info-home"", 
						""mountPath"", containerAuthInfoHome);
				
				// Windows nanoserver default user is ContainerUser
				Map<String, String> authInfoMount2 = CollectionUtils.newLinkedHashMap(
						""name"", ""auth-info-home"", 
						""mountPath"", ""C:\\Users\\ContainerUser\\auth-info"");
				
				Map<String, String> cacheHomeMount = CollectionUtils.newLinkedHashMap(
						""name"", ""cache-home"", 
						""mountPath"", containerCacheHome);
				Map<String, String> trustCertsMount = CollectionUtils.newLinkedHashMap(
						""name"", ""trust-certs-home"", 
						""mountPath"", trustCertsHome);
				Map<String, String> dockerSockMount = CollectionUtils.newLinkedHashMap(
						""name"", ""docker-sock"", 
						""mountPath"", dockerSock);
				Map<String, String> containerdSockMount = CollectionUtils.newLinkedHashMap(
						""name"", ""containerd-sock"", 
						""mountPath"", containerdSock);
				
				List<Object> commonVolumeMounts = Lists.<Object>newArrayList(buildHomeMount, authInfoMount, cacheHomeMount);
				if (osInfo.isWindows())
					commonVolumeMounts.add(authInfoMount2);
				if (trustCertsConfigMapName != null)
					commonVolumeMounts.add(trustCertsMount);
				
				if (isMountContainerSock()) {
					commonVolumeMounts.add(dockerSockMount);
					commonVolumeMounts.add(containerdSockMount);
				}

				CompositeFacade entryFacade;
				if (jobContext != null) {
					entryFacade = new CompositeFacade(jobContext.getActions());
				} else {
					List<Action> actions = new ArrayList<>();
					CommandFacade facade = new CommandFacade((String) executionContext, 
							Lists.newArrayList(""this does not matter""), false);
					actions.add(new Action(""test"", facade, ExecuteCondition.ALWAYS));
					entryFacade = new CompositeFacade(actions);
				}
				
				List<String> containerNames = Lists.newArrayList(""init"");
				
				String helperImageSuffix;
				if (osInfo.isWindows()) {  
					String windowsVersion = OsInfo.WINDOWS_VERSIONS.get(osInfo.getWindowsBuild());
					if (windowsVersion != null)
						helperImageSuffix = ""windows-"" + windowsVersion.toLowerCase();
					else
						throw new ExplicitException(""Unsupported windows build number: "" + osInfo.getWindowsBuild());
				} else {
					helperImageSuffix = ""linux"";
				}
				
				String helperImage = IMAGE_REPO_PREFIX + ""-"" + helperImageSuffix + "":"" + KubernetesHelper.getVersion();
				
				List<Map<Object, Object>> commonEnvs = new ArrayList<>();
				commonEnvs.add(CollectionUtils.newLinkedHashMap(
						""name"", ENV_SERVER_URL, 
						""value"", getServerUrl()));
				commonEnvs.add(CollectionUtils.newLinkedHashMap(
						""name"", ENV_JOB_TOKEN, 
						""value"", jobToken));
				commonEnvs.add(CollectionUtils.newLinkedHashMap(
						""name"", ENV_OS_INFO,
						""value"", Hex.encodeHexString(SerializationUtils.serialize(osInfo))
						));
				commonEnvs.add(CollectionUtils.newLinkedHashMap(
						""name"", ""ONEDEV_WORKSPACE"",
						""value"", containerWorkspace
						));

				entryFacade.traverse(new LeafVisitor<Void>() {

					@Override
					public Void visit(LeafFacade facade, List<Integer> position) {
						String containerName = getContainerName(position);
						containerNames.add(containerName);
						Map<Object, Object> stepContainerSpec;
						if (facade instanceof CommandFacade) {
							CommandFacade commandFacade = (CommandFacade) facade;
							OsExecution execution = commandFacade.getExecution(osInfo);
							if (execution.getImage() == null) {
								throw new ExplicitException(""This step can only be executed by server shell ""
										+ ""executor or remote shell executor"");
							}
							
							stepContainerSpec = CollectionUtils.newHashMap(
									""name"", containerName, 
									""image"", execution.getImage());
							if (commandFacade.isUseTTY())
								stepContainerSpec.put(""tty"", true);
							stepContainerSpec.put(""volumeMounts"", commonVolumeMounts);
							stepContainerSpec.put(""env"", commonEnvs);
						} else if (facade instanceof BuildImageFacade) {
							stepContainerSpec = CollectionUtils.newHashMap(
									""name"", containerName, 
									""image"", helperImage);
							stepContainerSpec.put(""volumeMounts"", commonVolumeMounts);
							stepContainerSpec.put(""env"", commonEnvs);
						} else if (facade instanceof RunContainerFacade) {
							RunContainerFacade runContainerFacade = (RunContainerFacade) facade;
							OsContainer container = runContainerFacade.getContainer(osInfo); 
							stepContainerSpec = CollectionUtils.newHashMap(
									""name"", containerName, 
									""image"", container.getImage());
							if (runContainerFacade.isUseTTY())
								stepContainerSpec.put(""tty"", true);
							
							List<Object> volumeMounts = new ArrayList<>(commonVolumeMounts);
							for (Map.Entry<String, String> entry: container.getVolumeMounts().entrySet()) {
								String subPath = StringUtils.stripStart(entry.getKey(), ""/\\"");
								if (osInfo.isWindows())
									subPath = ""workspace\\"" + subPath;
								else
									subPath = ""workspace/"" + subPath;
								volumeMounts.add(CollectionUtils.newLinkedHashMap(
										""name"", ""build-home"", 
										""mountPath"", entry.getValue(),
										""subPath"", subPath));
							}
							stepContainerSpec.put(""volumeMounts"", volumeMounts);
							
							List<Map<Object, Object>> envs = new ArrayList<>(commonEnvs);
							for (Map.Entry<String, String> entry: container.getEnvMap().entrySet()) {
								envs.add(CollectionUtils.newLinkedHashMap(
										""name"", entry.getKey(), 
										""value"", entry.getValue()));
							}
							stepContainerSpec.put(""env"", envs);
						} else { 
							stepContainerSpec = CollectionUtils.newHashMap(
									""name"", containerName, 
									""image"", helperImage);
							stepContainerSpec.put(""volumeMounts"", commonVolumeMounts);
							stepContainerSpec.put(""env"", commonEnvs);
						}
						
						String positionStr = stringifyPosition(position);
						if (osInfo.isLinux()) {
							stepContainerSpec.put(""command"", Lists.newArrayList(""sh""));
							stepContainerSpec.put(""args"", Lists.newArrayList(containerCommandHome + ""/"" + positionStr + "".sh""));
						} else {
							stepContainerSpec.put(""command"", Lists.newArrayList(""cmd""));
							stepContainerSpec.put(""args"", Lists.newArrayList(""/c"", containerCommandHome + ""\\"" + positionStr + "".bat""));
						}

						containerSpecs.add(stepContainerSpec);
						
						return null;
					}
					
				}, new ArrayList<>());
				
				String k8sHelperClassPath;
				if (osInfo.isLinux()) {
					k8sHelperClassPath = ""/k8s-helper/*"";
				} else {
					k8sHelperClassPath = ""C:\\k8s-helper\\*"";
				}
				
				List<String> sidecarArgs = Lists.newArrayList(
						""-classpath"", k8sHelperClassPath,
						""io.onedev.k8shelper.SideCar"");
				List<String> initArgs = Lists.newArrayList(
						""-classpath"", k8sHelperClassPath, 
						""io.onedev.k8shelper.Init"");
				if (jobContext == null) {
					sidecarArgs.add(""test"");
					initArgs.add(""test"");
				}
				
				List<Map<Object, Object>> initEnvs = new ArrayList<>(commonEnvs);
				List<RegistryLoginFacade> registryLogins = new ArrayList<>();
				for (RegistryLogin login: getRegistryLogins())
					registryLogins.add(new RegistryLoginFacade(login.getRegistryUrl(), login.getUserName(), login.getPassword()));
				initEnvs.add(CollectionUtils.newLinkedHashMap(
						""name"", KubernetesHelper.ENV_REGISTRY_LOGINS,
						""value"", Hex.encodeHexString(SerializationUtils.serialize((Serializable) registryLogins))
						));
				Map<Object, Object> initContainerSpec = CollectionUtils.newHashMap(
						""name"", ""init"", 
						""image"", helperImage, 
						""command"", Lists.newArrayList(""java""), 
						""args"", initArgs,
						""env"", initEnvs,
						""volumeMounts"", commonVolumeMounts);
				
				Map<Object, Object> sidecarContainerSpec = CollectionUtils.newHashMap(
						""name"", ""sidecar"", 
						""image"", helperImage, 
						""command"", Lists.newArrayList(""java""), 
						""args"", sidecarArgs, 
						""env"", commonEnvs, 
						""volumeMounts"", commonVolumeMounts);
				
				if (jobContext != null) {
					sidecarContainerSpec.put(""resources"", CollectionUtils.newLinkedHashMap(""requests"", CollectionUtils.newLinkedHashMap(
							""cpu"", jobContext.getCpuRequirement() + ""m"", 
							""memory"", jobContext.getMemoryRequirement() + ""m"")));
				}
				
				containerSpecs.add(sidecarContainerSpec);
				containerNames.add(""sidecar"");
				
				podSpec.put(""containers"", containerSpecs);
				podSpec.put(""initContainers"", Lists.<Object>newArrayList(initContainerSpec));

				if (imagePullSecretName != null)
					podSpec.put(""imagePullSecrets"", Lists.<Object>newArrayList(CollectionUtils.newLinkedHashMap(""name"", imagePullSecretName)));
				podSpec.put(""restartPolicy"", ""Never"");		
				
				if (!getNodeSelector().isEmpty())
					podSpec.put(""nodeSelector"", toMap(getNodeSelector()));
				
				Map<Object, Object> buildHomeVolume = CollectionUtils.newLinkedHashMap(
						""name"", ""build-home"", 
						""emptyDir"", CollectionUtils.newLinkedHashMap());
				Map<Object, Object> userHomeVolume = CollectionUtils.newLinkedHashMap(
						""name"", ""auth-info-home"", 
						""emptyDir"", CollectionUtils.newLinkedHashMap());
				Map<Object, Object> cacheHomeVolume = CollectionUtils.newLinkedHashMap(
						""name"", ""cache-home"", 
						""hostPath"", CollectionUtils.newLinkedHashMap(
								""path"", osInfo.getCacheHome(), 
								""type"", ""DirectoryOrCreate""));
				List<Object> volumes = Lists.<Object>newArrayList(buildHomeVolume, userHomeVolume, cacheHomeVolume);
				if (trustCertsConfigMapName != null) {
					volumes.add(CollectionUtils.newLinkedHashMap(
							""name"", ""trust-certs-home"", 
							""configMap"", CollectionUtils.newLinkedHashMap(
									""name"", trustCertsConfigMapName)));
				}
				
				if (isMountContainerSock()) {
					volumes.add(CollectionUtils.newLinkedHashMap(
							""name"", ""docker-sock"", 
							""hostPath"", CollectionUtils.newLinkedHashMap(
									""path"", dockerSock)));
					volumes.add(CollectionUtils.newLinkedHashMap(
							""name"", ""containerd-sock"", 
							""hostPath"", CollectionUtils.newLinkedHashMap(
									""path"", containerdSock)));
				}
				podSpec.put(""volumes"", volumes);

				String podName = ""job"";
				
				Map<Object, Object> podDef = CollectionUtils.newLinkedHashMap(
						""apiVersion"", ""v1"", 
						""kind"", ""Pod"", 
						""metadata"", CollectionUtils.newLinkedHashMap(
								""name"", podName, 
								""namespace"", namespace), 
						""spec"", podSpec);
				
				createResource(podDef, Sets.newHashSet(), jobLogger);
				String podFQN = namespace + ""/"" + podName;
				
				AtomicReference<String> nodeNameRef = new AtomicReference<>(null);
				
				watchPod(namespace, podName, new AbortChecker() {

					@Override
					public Abort check(String nodeName, Collection<JsonNode> containerStatusNodes) {
						if (nodeName != null) {
							nodeNameRef.set(nodeName);
							return new Abort(null);
						} else {
							return null;
						}
					}
					
				}, jobLogger);
				
				if (jobContext != null)
					jobContext.notifyJobRunning(null);

				String nodeName = Preconditions.checkNotNull(nodeNameRef.get());
				jobLogger.log(""Running job on node "" + nodeName + ""..."");
				
				jobLogger.log(""Starting job containers..."");
				
				AtomicBoolean failed = new AtomicBoolean(false);
				
				for (String containerName: containerNames) {
					logger.debug(""Waiting for start of container (pod: {}, container: {})..."", 
							podFQN, containerName);
					
					watchPod(namespace, podName, new AbortChecker() {

						@Override
						public Abort check(String nodeName, Collection<JsonNode> containerStatusNodes) {
							ContainerError error = getContainerErrors(containerStatusNodes).get(containerName);
							if (error != null) {
								/*
								 * For non-fatal errors (command exited with non-zero code), we abort the watch 
								 * without an exception, and will continue to collect the container log which 
								 * might contain error details
								 */
								if (error.isFatal()) {
									String errorMessage;
									if (containerName.startsWith(""step-"")) {
										List<Integer> position = KubernetesHelper.parsePosition(containerName.substring(""step-"".length()));
										errorMessage = ""Step \"""" + entryFacade.getNamesAsString(position) 
												+ "": "" + error.getMessage();
									} else {
										errorMessage = containerName + "": "" + error.getMessage();
									}
									return new Abort(errorMessage);
								} else {
									return new Abort(null);
								}
							} else if (getStartedContainers(containerStatusNodes).contains(containerName)) {
								return new Abort(null);
							} else {
								return null;
							}
						}
						
					}, jobLogger);
					
					logger.debug(""Collecting log of container (pod: {}, container: {})..."", 
							podFQN, containerName);
					
					collectContainerLog(namespace, podName, containerName, LOG_END_MESSAGE, jobLogger);
					
					logger.debug(""Waiting for stop of container (pod: {})..."", 
							podFQN, containerName);
					
					watchPod(namespace, podName, new AbortChecker() {

						@Override
						public Abort check(String nodeName, Collection<JsonNode> containerStatusNodes) {
							ContainerError error = getContainerErrors(containerStatusNodes).get(containerName);
							if (error != null) {
								String errorMessage;
								if (containerName.startsWith(""step-"")) {
									List<Integer> position = KubernetesHelper.parsePosition(containerName.substring(""step-"".length()));
									errorMessage = ""Step \"""" + entryFacade.getNamesAsString(position) 
											+ "" is failed: "" + error.getMessage();
								} else {
									errorMessage = containerName + "": "" + error.getMessage();
								}
								
								/*
								 * We abort the watch with an exception for two reasons:
								 * 
								 * 1. Init container error will prevent other containers to start. 
								 * 2. Step containers may not run command in case of fatal error and sidecar 
								 *    container will wait indefinitely on the successful/failed mark file in 
								 *    this case, causing log following last indefinitely 
								 */
								if (error.isFatal() || containerName.equals(""init"")) {
									return new Abort(errorMessage);
								} else { 
									jobLogger.error(errorMessage);
									failed.set(true);
									return new Abort(null);
								} 
							} else if (getStoppedContainers(containerStatusNodes).contains(containerName)) {
								return new Abort(null);
							} else {
								return null;
							}
						}
						
					}, jobLogger);
				}
				
				if (failed.get())
					throw new FailedException();
			} finally {
				deleteNamespace(namespace, jobLogger);
			}			
		} finally {
			if (getClusterRole() != null)
				deleteClusterRoleBinding(namespace, jobLogger);
		}
	}",1
"protected SmsTracker getSmsTracker(HashMap<String, Object> data, PendingIntent sentIntent,
            PendingIntent deliveryIntent, String format, Uri messageUri, boolean isExpectMore,
            String fullMessageText, boolean isText) {
        return getSmsTracker(data, sentIntent, deliveryIntent, format, null/*unsentPartCount*/,
                null/*anyPartFailed*/, messageUri, null/*smsHeader*/, isExpectMore,
                fullMessageText, isText);
    }",0
"@Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            UserFactory.init();
        } catch (Throwable e) {
            throw new ServletException(""AddNewUserServlet: Error initialising user factory."" + e);
        }
        UserManager userFactory = UserFactory.getInstance();

        String userID = request.getParameter(""userID"");

        if (userID != null && userID.matches("".*[&<>\""`']+.*"")) {
            throw new ServletException(""User ID must not contain any HTML markup."");
        }

        String password = request.getParameter(""pass1"");

        boolean hasUser = false;
        try {
            hasUser = userFactory.hasUser(userID);
        } catch (Throwable e) {
            throw new ServletException(""can't determine if user "" + userID + "" already exists in users.xml."", e);
        }

        if (hasUser) {
            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(""/admin/userGroupView/users/newUser.jsp?action=redo"");
            dispatcher.forward(request, response);
        } else {
            final Password pass = new Password();
            pass.setEncryptedPassword(UserFactory.getInstance().encryptedPassword(password, true));
            pass.setSalt(true);

            final User newUser = new User();
            newUser.setUserId(userID);
            newUser.setPassword(pass);

            final HttpSession userSession = request.getSession(false);
            userSession.setAttribute(""user.modifyUser.jsp"", newUser);

            // forward the request for proper display
            RequestDispatcher dispatcher = this.getServletContext().getRequestDispatcher(""/admin/userGroupView/users/modifyUser.jsp"");
            dispatcher.forward(request, response);
        }
    }",1
"public Registration addSessionInitListener(SessionInitListener listener) {
        sessionInitListeners.add(listener);
        return () -> sessionInitListeners.remove(listener);
    }",0
"private boolean impliesClusterPermission(String action) {
            return clusterPerms.test(action);
        }",0
"public boolean checkPattern(List<LockPatternView.Cell> pattern, int userId)
            throws RequestThrottledException {
        throwIfCalledOnMainThread();
        try {
            VerifyCredentialResponse response =
                    getLockSettings().checkPattern(patternToString(pattern), userId);

            if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) {
                return true;
            } else if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_RETRY) {
                throw new RequestThrottledException(response.getTimeout());
            } else {
                return false;
            }
        } catch (RemoteException re) {
            return false;
        }
    }",1
"public boolean detectSafeMode() {
        if (!mInputMonitor.waitForInputDevicesReady(
                INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS)) {
            Slog.w(TAG, ""Devices still not ready after waiting ""
                   + INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS
                   + "" milliseconds before attempting to detect safe mode."");
        }

        UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
        if (um != null && um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) {
            mSafeMode = false;
            return false;
        }

        int menuState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY,
                KeyEvent.KEYCODE_MENU);
        int sState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY, KeyEvent.KEYCODE_S);
        int dpadState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_DPAD,
                KeyEvent.KEYCODE_DPAD_CENTER);
        int trackballState = mInputManager.getScanCodeState(-1, InputDevice.SOURCE_TRACKBALL,
                InputManagerService.BTN_MOUSE);
        int volumeDownState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY,
                KeyEvent.KEYCODE_VOLUME_DOWN);
        mSafeMode = menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0
                || volumeDownState > 0;
        try {
            if (SystemProperties.getInt(ShutdownThread.REBOOT_SAFEMODE_PROPERTY, 0) != 0) {
                mSafeMode = true;
                SystemProperties.set(ShutdownThread.REBOOT_SAFEMODE_PROPERTY, """");
            }
        } catch (IllegalArgumentException e) {
        }
        if (mSafeMode) {
            Log.i(TAG, ""SAFE MODE ENABLED (menu="" + menuState + "" s="" + sState
                    + "" dpad="" + dpadState + "" trackball="" + trackballState + "")"");
        } else {
            Log.i(TAG, ""SAFE MODE not enabled"");
        }
        mPolicy.setSafeMode(mSafeMode);
        return mSafeMode;
    }",1
"public static CertData fromXML(String xml) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element infoElement = document.getDocumentElement();
        return fromDOM(infoElement);
    }",1
"private void decryptBlock(int[][] KW)
    {
        int t0 = this.C0 ^ KW[ROUNDS][0];
        int t1 = this.C1 ^ KW[ROUNDS][1];
        int t2 = this.C2 ^ KW[ROUNDS][2];

        int r = ROUNDS - 1, r0, r1, r2, r3 = this.C3 ^ KW[ROUNDS][3];
        while (r > 1)
        {
            r0 = Tinv0[t0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(t2>>16)&255], 16) ^ shift(Tinv0[(t1>>24)&255], 8) ^ KW[r][0];
            r1 = Tinv0[t1&255] ^ shift(Tinv0[(t0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(t2>>24)&255], 8) ^ KW[r][1];
            r2 = Tinv0[t2&255] ^ shift(Tinv0[(t1>>8)&255], 24) ^ shift(Tinv0[(t0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];
            r3 = Tinv0[r3&255] ^ shift(Tinv0[(t2>>8)&255], 24) ^ shift(Tinv0[(t1>>16)&255], 16) ^ shift(Tinv0[(t0>>24)&255], 8) ^ KW[r--][3];
            t0 = Tinv0[r0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(r2>>16)&255], 16) ^ shift(Tinv0[(r1>>24)&255], 8) ^ KW[r][0];
            t1 = Tinv0[r1&255] ^ shift(Tinv0[(r0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(r2>>24)&255], 8) ^ KW[r][1];
            t2 = Tinv0[r2&255] ^ shift(Tinv0[(r1>>8)&255], 24) ^ shift(Tinv0[(r0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];
            r3 = Tinv0[r3&255] ^ shift(Tinv0[(r2>>8)&255], 24) ^ shift(Tinv0[(r1>>16)&255], 16) ^ shift(Tinv0[(r0>>24)&255], 8) ^ KW[r--][3];
        }

        r0 = Tinv0[t0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(t2>>16)&255], 16) ^ shift(Tinv0[(t1>>24)&255], 8) ^ KW[r][0];
        r1 = Tinv0[t1&255] ^ shift(Tinv0[(t0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(t2>>24)&255], 8) ^ KW[r][1];
        r2 = Tinv0[t2&255] ^ shift(Tinv0[(t1>>8)&255], 24) ^ shift(Tinv0[(t0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];
        r3 = Tinv0[r3&255] ^ shift(Tinv0[(t2>>8)&255], 24) ^ shift(Tinv0[(t1>>16)&255], 16) ^ shift(Tinv0[(t0>>24)&255], 8) ^ KW[r][3];
        
        // the final round's table is a simple function of Si so we don't use a whole other four tables for it

        this.C0 = (Si[r0&255]&255) ^ ((s[(r3>>8)&255]&255)<<8) ^ ((s[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];
        this.C1 = (s[r1&255]&255) ^ ((s[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (s[(r2>>24)&255]<<24) ^ KW[0][1];
        this.C2 = (s[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (s[(r3>>24)&255]<<24) ^ KW[0][2];
        this.C3 = (Si[r3&255]&255) ^ ((s[(r2>>8)&255]&255)<<8) ^ ((s[(r1>>16)&255]&255)<<16) ^ (s[(r0>>24)&255]<<24) ^ KW[0][3];
    }",1
"@Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        Log.d(LOG_TAG, ""onActivityResult: done"");
        if (resultCode != RESULT_OK) {
            Log.d(LOG_TAG, ""onActivityResult: contact picker result not OK."");
            return;
        }
        Cursor cursor = null;
        try {
            // check if the URI returned by the user belongs to the user
            final int currentUser = UserHandle.getUserId(Process.myUid());
            if (currentUser
                    != ContentProvider.getUserIdFromUri(data.getData(), currentUser)) {

                Log.w(LOG_TAG, ""onActivityResult: Contact data of different user, ""
                        + ""cannot access"");
                return;
            }
            cursor = getContentResolver().query(data.getData(),
                NUM_PROJECTION, null, null, null);
            if ((cursor == null) || (!cursor.moveToFirst())) {
                Log.d(LOG_TAG, ""onActivityResult: bad contact data, no results found."");
                return;
            }

            switch (requestCode) {
                case CommandsInterface.CF_REASON_UNCONDITIONAL:
                    mButtonCFU.onPickActivityResult(cursor.getString(0));
                    break;
                case CommandsInterface.CF_REASON_BUSY:
                    mButtonCFB.onPickActivityResult(cursor.getString(0));
                    break;
                case CommandsInterface.CF_REASON_NO_REPLY:
                    mButtonCFNRy.onPickActivityResult(cursor.getString(0));
                    break;
                case CommandsInterface.CF_REASON_NOT_REACHABLE:
                    mButtonCFNRc.onPickActivityResult(cursor.getString(0));
                    break;
                default:
                    // TODO: may need exception here.
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }",1
"public static <T> T readYamlValue(String contents, Class<T> expectedType) {
        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml(new SafeConstructor());
        return Json.mapper().convertValue(yaml.load(contents), expectedType);
    }",1
"@Override
    public void onPostDialChar(final Call call, char nextChar) {
        if (PhoneNumberUtils.is12Key(nextChar)) {
            // Play tone if it is one of the dialpad digits, canceling out the previously queued
            // up stopTone runnable since playing a new tone automatically stops the previous tone.
            if (mStopTone != null) {
                mHandler.removeCallbacks(mStopTone);
            }

            mDtmfLocalTonePlayer.playTone(call, nextChar);

            mStopTone = new Runnable() {
                @Override
                public void run() {
                    // Set a timeout to stop the tone in case there isn't another tone to follow.
                    mDtmfLocalTonePlayer.stopTone(call);
                }
            };
            mHandler.postDelayed(
                    mStopTone,
                    Timeouts.getDelayBetweenDtmfTonesMillis(mContext.getContentResolver()));
        } else if (nextChar == 0 || nextChar == TelecomManager.DTMF_CHARACTER_WAIT ||
                nextChar == TelecomManager.DTMF_CHARACTER_PAUSE) {
            // Stop the tone if a tone is playing, removing any other stopTone callbacks since
            // the previous tone is being stopped anyway.
            if (mStopTone != null) {
                mHandler.removeCallbacks(mStopTone);
            }
            mDtmfLocalTonePlayer.stopTone(call);
        } else {
            Log.w(this, ""onPostDialChar: invalid value %d"", nextChar);
        }
    }",0
"@Override
        public SyncNotedAppOp startProxyOperation(@NonNull IBinder clientId, int code,
                @NonNull AttributionSource attributionSource, boolean startIfModeDefault,
                boolean shouldCollectAsyncNotedOp, String message, boolean shouldCollectMessage,
                boolean skipProxyOperation, @AttributionFlags int proxyAttributionFlags,
                @AttributionFlags int proxiedAttributionFlags, int attributionChainId,
                @NonNull UndecFunction<IBinder, Integer, AttributionSource,
                        Boolean, Boolean, String, Boolean, Boolean, Integer, Integer, Integer,
                        SyncNotedAppOp> superImpl) {
            if (attributionSource.getUid() == mTargetUid && isTargetOp(code)) {
                final int shellUid = UserHandle.getUid(UserHandle.getUserId(
                        attributionSource.getUid()), Process.SHELL_UID);
                final long identity = Binder.clearCallingIdentity();
                try {
                    return superImpl.apply(clientId, code, new AttributionSource(shellUid,
                            ""com.android.shell"", attributionSource.getAttributionTag(),
                            attributionSource.getToken(), attributionSource.getNext()),
                            startIfModeDefault, shouldCollectAsyncNotedOp, message,
                            shouldCollectMessage, skipProxyOperation, proxyAttributionFlags,
                            proxiedAttributionFlags, attributionChainId);
                } finally {
                    Binder.restoreCallingIdentity(identity);
                }
            }
            return superImpl.apply(clientId, code, attributionSource, startIfModeDefault,
                    shouldCollectAsyncNotedOp, message, shouldCollectMessage, skipProxyOperation,
                    proxyAttributionFlags, proxiedAttributionFlags, attributionChainId);
        }",0
"private static native @Nullable String nativeGetResourceEntryName(long ptr, @AnyRes int resid);",0
"@Transactional
	public SimpleObject submit(UiSessionContext sessionContext, @RequestParam(""personId"") Patient patient,
	        @RequestParam(""htmlFormId"") HtmlForm hf,
	        @RequestParam(value = ""encounterId"", required = false) Encounter encounter,
	        @RequestParam(value = ""visitId"", required = false) Visit visit,
	        @RequestParam(value = ""createVisit"", required = false) Boolean createVisit,
	        @RequestParam(value = ""returnUrl"", required = false) String returnUrl,
	        @SpringBean(""adtService"") AdtService adtService,
	        @SpringBean(""featureToggles"") FeatureToggleProperties featureToggles, UiUtils ui, HttpServletRequest request)
	        throws Exception {
		
		// TODO formModifiedTimestamp and encounterModifiedTimestamp
		
		boolean editMode = encounter != null;
		
		FormEntrySession fes;
		if (encounter != null) {
			fes = new FormEntrySession(patient, encounter, FormEntryContext.Mode.EDIT, hf, request.getSession());
		} else {
			fes = new FormEntrySession(patient, hf, FormEntryContext.Mode.ENTER, request.getSession());
		}
		
		VisitDomainWrapper visitDomainWrapper = getVisitDomainWrapper(visit, encounter, adtService);
		setupVelocityContext(fes, visitDomainWrapper, ui, sessionContext, featureToggles);
		setupFormEntrySession(fes, visitDomainWrapper, null, ui, sessionContext, returnUrl);
		fes.getHtmlToDisplay(); // needs to happen before we validate or process a form
		
		// Validate and return with errors if any are found
		List<FormSubmissionError> validationErrors = fes.getSubmissionController().validateSubmission(fes.getContext(),
		    request);
		if (validationErrors.size() > 0) {
			return returnHelper(validationErrors, fes, null);
		}
		
		try {
			// No validation errors found so process form submission
			fes.prepareForSubmit();
			fes.getSubmissionController().handleFormSubmission(fes, request);
		}
		catch (Exception ex) {
			StringWriter sw = new StringWriter();
			ex.printStackTrace(new PrintWriter(sw));
			validationErrors.add(new FormSubmissionError(""general-form-error"",
			        ""Form submission error "" + ex.getMessage() + ""<br/>"" + sw.toString()));
			return returnHelper(validationErrors, fes, null);
		}
		
		// Check this form will actually create an encounter if its supposed to
		if (fes.getContext().getMode() == FormEntryContext.Mode.ENTER && fes.hasEncouterTag()
		        && (fes.getSubmissionActions().getEncountersToCreate() == null
		                || fes.getSubmissionActions().getEncountersToCreate().size() == 0)) {
			throw new IllegalArgumentException(""This form is not going to create an encounter"");
		}
		
		Encounter formEncounter = fes.getContext().getMode() == FormEntryContext.Mode.ENTER
		        ? fes.getSubmissionActions().getEncountersToCreate().get(0)
		        : encounter;
		
		// create a visit if necessary (note that this currently only works in real-time mode)
		if (createVisit != null && (createVisit) && visit == null) {
			visit = adtService.ensureActiveVisit(patient, sessionContext.getSessionLocation());
			fes.getContext().setVisit(visit);
		}
		
		// attach to the visit if it exists and not already attached
		if (visit != null && (encounter == null || encounter.getVisit() == null)) {
			try {
				new EncounterDomainWrapper(formEncounter).attachToVisit(visit);
			}
			catch (EncounterDateBeforeVisitStartDateException e) {
				validationErrors.add(
				    new FormSubmissionError(""general-form-error"", ui.message(""htmlformentryui.datetimeAfterVisitDate"")));
			}
			catch (EncounterDateAfterVisitStopDateException e) {
				validationErrors.add(
				    new FormSubmissionError(""general-form-error"", ui.message(""htmlformentryui.datetimeBeforeVisitDate"")));
			}
			
			if (validationErrors.size() > 0) {
				return returnHelper(validationErrors, fes, null);
			}
		}
		
		// Do actual encounter creation/updating
		fes.applyActions();
		
		request.getSession().setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_INFO_MESSAGE,
		    ui.message(
		        editMode ? ""htmlformentryui.editHtmlForm.successMessage"" : ""htmlformentryui.enterHtmlForm.successMessage"",
		        ui.format(hf.getForm()), ui.encodeJavaScript(ui.format(patient))));
		request.getSession().setAttribute(UiCommonsConstants.SESSION_ATTRIBUTE_TOAST_MESSAGE, ""true"");
		
		return returnHelper(null, fes, formEncounter);
	}",1
"@SuppressWarnings({""checkstyle:npathcomplexity""})
    private static void serializationXmlGenerator(XmlGenerator gen, Config config) {
        SerializationConfig c = config.getSerializationConfig();
        if (c == null) {
            return;
        }
        gen.open(""serialization"")
                .node(""portable-version"", c.getPortableVersion())
                .node(""use-native-byte-order"", c.isUseNativeByteOrder())
                .node(""byte-order"", c.getByteOrder())
                .node(""enable-compression"", c.isEnableCompression())
                .node(""enable-shared-object"", c.isEnableSharedObject())
                .node(""allow-unsafe"", c.isAllowUnsafe());

        Map<Integer, String> dsfClasses = c.getDataSerializableFactoryClasses();
        Map<Integer, DataSerializableFactory> dsfImpls = c.getDataSerializableFactories();
        if (!MapUtil.isNullOrEmpty(dsfClasses) || !MapUtil.isNullOrEmpty(dsfImpls)) {
            gen.open(""data-serializable-factories"");
            appendSerializationFactory(gen, ""data-serializable-factory"", dsfClasses);
            appendSerializationFactory(gen, ""data-serializable-factory"", dsfImpls);
            gen.close();
        }

        Map<Integer, String> portableClasses = c.getPortableFactoryClasses();
        Map<Integer, PortableFactory> portableImpls = c.getPortableFactories();
        if (!MapUtil.isNullOrEmpty(portableClasses) || !MapUtil.isNullOrEmpty(portableImpls)) {
            gen.open(""portable-factories"");
            appendSerializationFactory(gen, ""portable-factory"", portableClasses);
            appendSerializationFactory(gen, ""portable-factory"", portableImpls);
            gen.close();
        }

        Collection<SerializerConfig> serializers = c.getSerializerConfigs();
        GlobalSerializerConfig globalSerializerConfig = c.getGlobalSerializerConfig();
        if (CollectionUtil.isNotEmpty(serializers) || globalSerializerConfig != null) {
            gen.open(""serializers"");

            if (globalSerializerConfig != null) {
                gen.node(""global-serializer"",
                        classNameOrImplClass(
                                globalSerializerConfig.getClassName(), globalSerializerConfig.getImplementation()),
                        ""override-java-serialization"", globalSerializerConfig.isOverrideJavaSerialization());
            }

            if (CollectionUtil.isNotEmpty(serializers)) {
                for (SerializerConfig serializer : serializers) {
                    gen.node(""serializer"", null,
                            ""type-class"", classNameOrClass(serializer.getTypeClassName(), serializer.getTypeClass()),
                            ""class-name"", classNameOrImplClass(serializer.getClassName(), serializer.getImplementation()));
                }
            }
            gen.close();
        }
        gen.node(""check-class-def-errors"", c.isCheckClassDefErrors());
        JavaSerializationFilterConfig javaSerializationFilterConfig = c.getJavaSerializationFilterConfig();
        if (javaSerializationFilterConfig != null) {
            gen.open(""java-serialization-filter"");
            appendFilterList(gen, ""blacklist"", javaSerializationFilterConfig.getBlacklist());
            appendFilterList(gen, ""whitelist"", javaSerializationFilterConfig.getWhitelist());
            gen.close();
        }
        gen.close();
    }",1
"public void publishService(IBinder token, Intent intent, IBinder service) {
        // Refuse possible leaked file descriptors
        if (intent != null && intent.hasFileDescriptors() == true) {
            throw new IllegalArgumentException(""File descriptors passed in Intent"");
        }

        synchronized(this) {
            if (!(token instanceof ServiceRecord)) {
                throw new IllegalArgumentException(""Invalid service token"");
            }
            mServices.publishServiceLocked((ServiceRecord)token, intent, service);
        }
    }",0
"public ProfileInput getProfileInput(String id) {
        for (ProfileInput input: inputs) {
            if (input.getId().equals(id)) return input;
        }
        return null;
    }",0
"protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()
    {
        return this.currentmixedReferenceResolver;
    }",0
"public boolean isStandalone() {
        return manager.get() == null;
    }",0
"@CheckResult
    public boolean isPermissionRevokedByPolicy(@NonNull String packageName,
            @NonNull String permissionName) {
        try {
            return mPermissionManager.isPermissionRevokedByPolicy(packageName, permissionName,
                    mContext.getUserId());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }",0
"private String parseOptionValue(String options, String tarVal) {
        if (StringUtils.isEmpty(options) || StringUtils.isEmpty(tarVal)) {
            return StringUtils.EMPTY;
        }
        List<Map> optionList = JSON.parseArray(options, Map.class);
        for (Map option : optionList) {
            String text = option.get(""text"").toString();
            String value = option.get(""value"").toString();
            if (StringUtils.containsIgnoreCase(tarVal, value)) {
                tarVal = tarVal.replaceAll(value, text);
            }
        }
        return tarVal;
    }",0
"public String getReadingModeUrl() throws IndexUnreachableException, DAOException {
        return getFullscreenImageUrl();
    }",0
"public PtrDnsAnswer reverseLookup(String ipAddress) throws InterruptedException, ExecutionException {

        LOG.debug(""Attempting to perform reverse lookup for IP address [{}]"", ipAddress);

        if (resolverPool.isStopped()) {
            throw new DnsClientNotRunningException();
        }

        validateIpAddress(ipAddress);

        final String inverseAddressFormat = getInverseAddressFormat(ipAddress);

        DnsResponse content = null;
        final ResolverLease resolverLease = resolverPool.takeLease();
        try {
            content = resolverLease.getResolver().query(new DefaultDnsQuestion(inverseAddressFormat, DnsRecordType.PTR)).get(requestTimeout, TimeUnit.MILLISECONDS).content();
            for (int i = 0; i < content.count(DnsSection.ANSWER); i++) {

                // Return the first PTR record, because there should be only one as per
                // http://tools.ietf.org/html/rfc1035#section-3.5
                final DnsRecord dnsRecord = content.recordAt(DnsSection.ANSWER, i);
                if (dnsRecord instanceof DefaultDnsPtrRecord) {

                    final DefaultDnsPtrRecord ptrRecord = (DefaultDnsPtrRecord) dnsRecord;
                    final PtrDnsAnswer.Builder dnsAnswerBuilder = PtrDnsAnswer.builder();

                    final String hostname = ptrRecord.hostname();
                    LOG.trace(""PTR record retrieved with hostname [{}]"", hostname);

                    try {
                        parseReverseLookupDomain(dnsAnswerBuilder, hostname);
                    } catch (IllegalArgumentException e) {
                        LOG.debug(""Reverse lookup of [{}] was partially successful. The DNS server returned [{}], "" +
                                  ""which is an invalid host name. The \""domain\"" field will be left blank."",
                                  ipAddress, hostname);
                        dnsAnswerBuilder.domain("""");
                    }

                    return dnsAnswerBuilder.dnsTTL(ptrRecord.timeToLive())
                                           .build();
                }
            }
        } catch (TimeoutException e) {
            throw new ExecutionException(""Resolver future didn't return a result in "" + requestTimeout + "" ms"", e);
        } finally {
            if (content != null) {
                // Must manually release references on content object since the DnsResponse class extends ReferenceCounted
                content.release();
            }
            resolverPool.returnLease(resolverLease);
        }

        return null;
    }",1
"public final void lightenPayload() {
        tickerView = null;
        contentView = null;
        bigContentView = null;
        headsUpContentView = null;
        mLargeIcon = null;
        if (extras != null && !extras.isEmpty()) {
            final Set<String> keyset = extras.keySet();
            final int N = keyset.size();
            final String[] keys = keyset.toArray(new String[N]);
            for (int i=0; i<N; i++) {
                final String key = keys[i];
                if (TvExtender.EXTRA_TV_EXTENDER.equals(key)) {
                    continue;
                }
                final Object obj = extras.get(key);
                if (obj != null &&
                    (  obj instanceof Parcelable
                    || obj instanceof Parcelable[]
                    || obj instanceof SparseArray
                    || obj instanceof ArrayList)) {
                    extras.remove(key);
                }
            }
        }
    }",0
"public String setDoublePageModeAction(boolean doublePageMode) throws IndexUnreachableException, DAOException {
        if (viewManager == null) {
            return """";
        }
        try {
            // Adapt URL page range when switching between single and double page modes
            if (viewManager.isDoublePageMode() != doublePageMode) {
                if (doublePageMode && !viewManager.getCurrentPage().isDoubleImage()) {
                    Optional<PhysicalElement> currentLeftPage = viewManager.getCurrentLeftPage();
                    Optional<PhysicalElement> currentRightPage = viewManager.getCurrentRightPage();
                    if (currentLeftPage.isPresent() && currentRightPage.isPresent()) {
                        imageToShow = currentLeftPage.get().getOrder() + ""-"" + currentRightPage.get().getOrder();
                    } else if (currentLeftPage.isPresent()) {
                        imageToShow = currentLeftPage.get().getOrder() + ""-"" + currentLeftPage.get().getOrder();
                    } else if (currentRightPage.isPresent()) {
                        imageToShow = currentRightPage.get().getOrder() + ""-"" + currentRightPage.get().getOrder();
                    }
                } else if (doublePageMode) {
                    imageToShow = String.valueOf(viewManager.getCurrentPage().getOrder() + ""-"" + viewManager.getCurrentPage().getOrder());
                } else {
                    imageToShow = String.valueOf(viewManager.getCurrentPage().getOrder());
                }
            }
        } finally {
            viewManager.setDoublePageMode(doublePageMode);
        }

        // When not using PrettyContext, the updated URL will always be a click behind
        if (PrettyContext.getCurrentInstance() != null && PrettyContext.getCurrentInstance().getCurrentMapping() != null) {
            return ""pretty:"" + PrettyContext.getCurrentInstance().getCurrentMapping().getId();
        }

        return """";
    }",0
"private boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {
        URL resource = classLoader.getResource(resourcePath);
        if( resource !=null ) {

            String libName = name + ""-"" + getBitModel();
            if( version !=null) {
                libName += ""-"" + version;
            }
            String []libNameParts = map(libName).split(""\\."");
            String prefix = libNameParts[0]+""-"";
            String suffix = "".""+libNameParts[1];

            if( customPath!=null ) {
                // Try to extract it to the custom path...
                File target = extract(errors, resource, prefix, suffix, file(customPath));
                if( target!=null ) {
                    if( load(errors, target) ) {
                        return true;
                    }
                }
            }
            
            // Fall back to extracting to the tmp dir
            customPath = System.getProperty(""java.io.tmpdir"");
            File target = extract(errors, resource, prefix, suffix, file(customPath));
            if( target!=null ) {
                if( load(errors, target) ) {
                    return true;
                }
            }
        }
        return false;
    }",1
"@Override
    public void checkLoadedChunk(BlockVector3 pt) {
        //FAWE start - safe edit region
        testCoords(pt);
        //FAWE end
        World world = getWorld();
        //FAWE start
        int X = pt.getBlockX() >> 4;
        int Z = pt.getBlockZ() >> 4;
        if (Fawe.isMainThread()) {
            world.getChunkAt(X, Z);
        } else if (PaperLib.isPaper()) {
            PaperLib.getChunkAtAsync(world, X, Z, true);
        }
        //FAWE end
    }",1
"protected String evaluateExpression(EvaluationContext context, Expression expression) {
		return Objects.requireNonNull(expression.getValue(context, String.class));
	}",1
"@Override
    public void getBaseDisplaySize(int displayId, Point size) {
        synchronized (mWindowMap) {
            final DisplayContent displayContent = getDisplayContentLocked(displayId);
            if (displayContent != null && displayContent.hasAccess(Binder.getCallingUid())) {
                synchronized(displayContent.mDisplaySizeLock) {
                    size.x = displayContent.mBaseDisplayWidth;
                    size.y = displayContent.mBaseDisplayHeight;
                }
            }
        }
    }",0
"@Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            String ssid = intent.getStringExtra(EXTRA_PENDING_CERT_SSID);
            // This is an onGoing notification, dismiss it once an action is sent.
            dismissDialogAndNotification();
            Log.d(TAG, ""Received CertNotification: ssid="" + ssid + "", action="" + action);
            if (TextUtils.equals(action, ACTION_CERT_NOTIF_TAP)) {
                askForUserApprovalForCaCertificate();
            } else if (TextUtils.equals(action, ACTION_CERT_NOTIF_ACCEPT)) {
                handleAccept(ssid);
            } else if (TextUtils.equals(action, ACTION_CERT_NOTIF_REJECT)) {
                handleReject(ssid);
            }
        }",0
"public void switchToContactDetails(Contact contact) {
		switchToContactDetails(contact, null);
	}",0
"@GET
    @Path(""/help"")
    @Produces(""text/markdown"")
    public InputStream getFileHelp(@QueryParam(""f"") String fileName, @Context SecurityContext securityContext) {
        if (!securityContext.isUserInRole(Authentication.ROLE_FILESYSTEM_EDITOR)) {
            throw new ForbiddenException(""FILESYSTEM EDITOR role is required for retrieving help."");
        }
        ensureFileIsAllowed(fileName, securityContext);
        return this.getClass().getResourceAsStream(""/help/"" + fileName + "".md"");
    }",1
"public boolean isAutoTypeSupport() {
        return autoTypeSupport;
    }",0
"private Externalizable read(InputStream in, String className, ClassLoader classLoader) throws Exception {
            Externalizable ds = ClassLoaderUtil.newInstance(classLoader, className);
            ObjectInputStream objectInputStream = newObjectInputStream(classLoader, classFilter, in);
            ds.readExternal(objectInputStream);
            return ds;
        }",1
"@SuppressWarnings(""PMD.UseTryWithResources"") // stream may be null
    private static Properties loadProperites(String resource) {
        Properties props = new Properties();
        InputStream stream = GeoTools.class.getResourceAsStream(resource);
        if (stream != null) {
            try {
                props.load(stream);
            } catch (IOException ignore) {
            } finally {
                try {
                    stream.close();
                } catch (IOException ignore) {
                }
            }
        }

        return props;
    }",0
"public static XMLBuilder2 create(String name)
    {
        return XMLBuilder2.create(name, null, false);
    }",1
"static String renderNav2(HttpServletRequest request, String activeNav) {
        if (activeNav == null) activeNav = ""dashboard-home"";

        ID user = AppUtils.getRequestUser(request);
        JSONArray navs = License.isCommercial()
                ? NavBuilder.instance.getUserNav(user, request)
                : NavBuilder.instance.getUserNav(user);

        StringBuilder navsHtml = new StringBuilder();
        for (Object item : navs) {
            navsHtml.append(renderNavItem((JSONObject) item, activeNav)).append('\n');
        }
        return navsHtml.toString();
    }",0
"Builder setConfiguration(Configuration config) {
            mConfiguration = config;
            return this;
        }",0
"private void createSession( final AuthenticationInfo authInfo )
    {
        final LocalScope localScope = this.context.get().getLocalScope();
        final Session session = localScope.getSession();

        if ( session != null )
        {
            final var attributes = session.getAttributes();
            session.invalidate();

            final Session newSession = localScope.getSession();

            if ( newSession != null )
            {
                attributes.forEach( newSession::setAttribute );
                session.setAttribute( authInfo );

                if ( this.sessionTimeout != null )
                {
                    setSessionTimeout();
                }
            }
        }
    }",1
"protected final String constructValidationUrl(final String ticket, final String serviceUrl) {
        final Map<String, String> urlParameters = new HashMap<String, String>();

        logger.debug(""Placing URL parameters in map."");
        urlParameters.put(""ticket"", ticket);
        urlParameters.put(""service"", serviceUrl);

        if (this.renew) {
            urlParameters.put(""renew"", ""true"");
        }

        logger.debug(""Calling template URL attribute map."");
        populateUrlAttributeMap(urlParameters);

        logger.debug(""Loading custom parameters from configuration."");
        if (this.customParameters != null) {
            urlParameters.putAll(this.customParameters);
        }

        final String suffix = getUrlSuffix();
        final StringBuilder buffer = new StringBuilder(urlParameters.size() * 10 + this.casServerUrlPrefix.length()
                + suffix.length() + 1);

        int i = 0;

        buffer.append(this.casServerUrlPrefix);
        if (!this.casServerUrlPrefix.endsWith(""/"")) {
            buffer.append(""/"");
        }
        buffer.append(suffix);

        for (Map.Entry<String, String> entry : urlParameters.entrySet()) {
            final String key = entry.getKey();
            final String value = entry.getValue();

            if (value != null) {
                buffer.append(i++ == 0 ? ""?"" : ""&"");
                buffer.append(key);
                buffer.append(""="");
                final String encodedValue = encodeUrl(value);
                buffer.append(encodedValue);
            }
        }

        return buffer.toString();

    }",1
"public String getFullAvatarURL(Profile profile, AvatarFormat format) {
		return avatarRepository.getLink(profile, format);
	}",0
"@Override
    public void finishPackageInstall(int token) {
        enforceSystemOrRoot(""Only the system is allowed to finish installs"");

        if (DEBUG_INSTALL) {
            Slog.v(TAG, ""BM finishing package install for "" + token);
        }

        final Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
        mHandler.sendMessage(msg);
    }",0
"@Override
    public ServerBuilder tls(InputStream keyCertChainInputStream, InputStream keyInputStream) {
        return (ServerBuilder) TlsSetters.super.tls(keyCertChainInputStream, keyInputStream);
    }",0
"public static Document createDocument() {
    try {
      DocumentBuilderFactory dbFactory = safeDocumentBuilderFactory();
      DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();
      Document doc = docBuilder.newDocument();
      return doc;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }",1
"public void get(PageModel model, @MethodParam(""getAccount"") Account account,
	                @SpringBean(""adminAccountService"") AccountService accountService,
	                @SpringBean(""adminService"") AdministrationService administrationService,
	                @SpringBean(""providerManagementService"") ProviderManagementService providerManagementService,
					UiUtils uu,
					@SpringBean(""appFrameworkService"") AppFrameworkService appFrameworkService)
	    throws IOException {
		
		setModelAttributes(model, account, null, accountService, administrationService, providerManagementService, uu, appFrameworkService);
		if (account.getPerson().getPersonId() == null) {
			setJsonFormData(model, account, null, uu);
		}
	}",1
"@ConversationType
        public int getConversationType() {
            return mConversationType;
        }",0
"@CalledByNative
    public void showRepostFormWarningDialog(ContentViewCore contentViewCore) {
    }",0
"protected PdfDictionary readXrefSection() throws IOException {
        tokens.nextValidToken();
        if (!tokens.getStringValue().equals(""xref""))
            tokens.throwError(""xref subsection not found"");
        int start = 0;
        int end = 0;
        int pos = 0;
        int gen = 0;
        while (true) {
            tokens.nextValidToken();
            if (tokens.getStringValue().equals(""trailer""))
                break;
            if (tokens.getTokenType() != PRTokeniser.TK_NUMBER)
                tokens.throwError(""Object number of the first object in this xref subsection not found"");
            start = tokens.intValue();
            tokens.nextValidToken();
            if (tokens.getTokenType() != PRTokeniser.TK_NUMBER)
                tokens.throwError(""Number of entries in this xref subsection not found"");
            end = tokens.intValue() + start;
            if (start == 1) { // fix incorrect start number
                int back = tokens.getFilePointer();
                tokens.nextValidToken();
                pos = tokens.intValue();
                tokens.nextValidToken();
                gen = tokens.intValue();
                if (pos == 0 && gen == PdfWriter.GENERATION_MAX) {
                    --start;
                    --end;
                }
                tokens.seek(back);
            }
            ensureXrefSize(end * 2);
            for (int k = start; k < end; ++k) {
                tokens.nextValidToken();
                pos = tokens.intValue();
                tokens.nextValidToken();
                gen = tokens.intValue();
                tokens.nextValidToken();
                int p = k * 2;
                if (tokens.getStringValue().equals(""n"")) {
                    if (xref[p] == 0 && xref[p + 1] == 0) {
//                        if (pos == 0)
//                            tokens.throwError(""File position 0 cross-reference entry in this xref subsection"");
                        xref[p] = pos;
                    }
                }
                else if (tokens.getStringValue().equals(""f"")) {
                    if (xref[p] == 0 && xref[p + 1] == 0)
                        xref[p] = -1;
                }
                else
                    tokens.throwError(""Invalid cross-reference entry in this xref subsection"");
            }
        }
        PdfDictionary trailer = (PdfDictionary)readPRObject();
        PdfNumber xrefSize = (PdfNumber)trailer.get(PdfName.SIZE);
        ensureXrefSize(xrefSize.intValue() * 2);
        PdfObject xrs = trailer.get(PdfName.XREFSTM);
        if (xrs != null && xrs.isNumber()) {
            int loc = ((PdfNumber)xrs).intValue();
            try {
                readXRefStream(loc);
                newXrefType = true;
                hybridXref = true;
            }
            catch (IOException e) {
                xref = null;
                throw e;
            }
        }
        return trailer;
    }",0
"ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {
        LOGGER.info(""[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'"", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);

        if (!isValidStageCounter(stageCounter)) {
            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);
        }

        long before = System.currentTimeMillis();
        ArtifactsView view;
        //Work out the job that we are trying to retrieve
        JobIdentifier translatedId;
        try {
            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);
        } catch (Exception e) {
            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);
        }

        if (filePath.contains("".."")) {
            return FileModelAndView.forbiddenUrl(filePath);
        }

        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);

        ModelAndView createdView = view.createView(filePath, sha);
        LOGGER.info(""[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms"", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);
        return createdView;
    }",1
"@Test
  public void executeNSU() throws Exception {
    final DeferredGroupException dge = mock(DeferredGroupException.class);
    when(dge.getCause()).thenReturn(new NoSuchUniqueName(""foo"", ""metrics""));

    when(query_result.configureFromQuery((TSQuery)any(), anyInt()))
      .thenReturn(Deferred.fromError(dge));

    final HttpQuery query = NettyMocks.getQuery(tsdb,
        ""/api/query?start=1h-ago&m=sum:sys.cpu.user"");
    rpc.execute(tsdb, query);
    assertEquals(HttpResponseStatus.BAD_REQUEST, query.response().getStatus());
    final String json =
        query.response().getContent().toString(Charset.forName(""UTF-8""));
    assertTrue(json.contains(""No such name for &#39;foo&#39;: &#39;metrics&#39;""));
  }",1
"public List<Pair> parameterToPairs(String collectionFormat, String name, Object value){
    List<Pair> params = new ArrayList<Pair>();

    // preconditions
    if (name == null || name.isEmpty() || value == null) return params;

    Collection valueCollection;
    if (value instanceof Collection) {
      valueCollection = (Collection) value;
    } else {
      params.add(new Pair(name, parameterToString(value)));
      return params;
    }

    if (valueCollection.isEmpty()){
      return params;
    }

    // get the collection format (default: csv)
    String format = (collectionFormat == null || collectionFormat.isEmpty() ? ""csv"" : collectionFormat);

    // create the params based on the collection format
    if (""multi"".equals(format)) {
      for (Object item : valueCollection) {
        params.add(new Pair(name, parameterToString(item)));
      }

      return params;
    }

    String delimiter = "","";

    if (""csv"".equals(format)) {
      delimiter = "","";
    } else if (""ssv"".equals(format)) {
      delimiter = "" "";
    } else if (""tsv"".equals(format)) {
      delimiter = ""\t"";
    } else if (""pipes"".equals(format)) {
      delimiter = ""|"";
    }

    StringBuilder sb = new StringBuilder() ;
    for (Object item : valueCollection) {
      sb.append(delimiter);
      sb.append(parameterToString(item));
    }

    params.add(new Pair(name, sb.substring(1)));

    return params;
  }",0
"public void setLastseen(Long val) {
		this.lastseen = val;
	}",0
"protected void validateMaterialUrl(UrlArgument url) {
        if (url == null || isBlank(url.forDisplay())) {
            errors().add(URL, ""URL cannot be blank"");
            return;
        }

        if (System.getProperty(""gocd.verify.url.correctness"", ""y"").equalsIgnoreCase(""y"") && !url.isValidURLOrLocalPath()) {
            errors().add(URL, ""URL does not seem to be valid."");
        }
    }",1
"@SuppressWarnings(""incomplete-switch"")
    @Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property)
        throws JsonMappingException
    {
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        final AnnotatedMember accessor = (property == null || intr == null)
                ? null : property.getMember();
        final SerializationConfig config = provider.getConfig();

        // Let's start with one big transmutation: Enums that are annotated
        // to serialize as Objects may want to revert
        JsonFormat.Value format = findFormatOverrides(provider, property, handledType());
        JsonFormat.Shape shape = null;
        if ((format != null) && format.hasShape()) {
            shape = format.getShape();
            // or, alternatively, asked to revert ""back to"" other representations...
            if ((shape != JsonFormat.Shape.ANY) && (shape != _serializationShape)) {
                if (ClassUtil.isEnumType(_handledType)) {
                    switch (shape) {
                    case STRING:
                    case NUMBER:
                    case NUMBER_INT:
                        // 12-Oct-2014, tatu: May need to introspect full annotations... but
                        //   for now, just do class ones
                        BeanDescription desc = config.introspectClassAnnotations(_beanType);
                        JsonSerializer<?> ser = EnumSerializer.construct(_beanType.getRawClass(),
                                provider.getConfig(), desc, format);
                        return provider.handlePrimaryContextualization(ser, property);
                    }
                // 16-Oct-2016, tatu: Ditto for `Map`, `Map.Entry` subtypes
                } else if (shape == JsonFormat.Shape.NATURAL) {
                    if (_beanType.isMapLikeType() && Map.class.isAssignableFrom(_handledType)) {
                        ;
                    } else if (Map.Entry.class.isAssignableFrom(_handledType)) {
                        JavaType mapEntryType = _beanType.findSuperType(Map.Entry.class);

                        JavaType kt = mapEntryType.containedTypeOrUnknown(0);
                        JavaType vt = mapEntryType.containedTypeOrUnknown(1);

                        // 16-Oct-2016, tatu: could have problems with type handling, as we do not
                        //   see if ""static"" typing is needed, nor look for `TypeSerializer` yet...
                        JsonSerializer<?> ser = new MapEntrySerializer(_beanType, kt, vt,
                                false, null, property);
                        return provider.handlePrimaryContextualization(ser, property);
                    }
                }
            }
        }

        ObjectIdWriter oiw = _objectIdWriter;
        Set<String> ignoredProps = null;
        Object newFilterId = null;

        // Then we may have an override for Object Id
        if (accessor != null) {
            JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(accessor);
            if (ignorals != null) {
                ignoredProps = ignorals.findIgnoredForSerialization();
            }
            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);
            if (objectIdInfo == null) {
                // no ObjectId override, but maybe ObjectIdRef?
                if (oiw != null) {
                    objectIdInfo = intr.findObjectReferenceInfo(accessor, null);
                    if (objectIdInfo != null) {
                        oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());
                    }
                }
            } else {
                // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it
                // to be able to move to SerializerProvider (where it really belongs)
                
                // 2.1: allow modifications by ""id ref"" annotations as well:
                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);
                ObjectIdGenerator<?> gen;
                Class<?> implClass = objectIdInfo.getGeneratorType();
                JavaType type = provider.constructType(implClass);
                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];
                // Property-based generator is trickier
                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work
                    String propName = objectIdInfo.getPropertyName().getSimpleName();
                    BeanPropertyWriter idProp = null;

                    for (int i = 0, len = _props.length; ; ++i) {
                        if (i == len) {
                            provider.reportBadDefinition(_beanType, String.format(
                                    ""Invalid Object Id definition for %s: cannot find property with name '%s'"",
                                    handledType().getName(), propName));
                        }
                        BeanPropertyWriter prop = _props[i];
                        if (propName.equals(prop.getName())) {
                            idProp = prop;
                            // Let's force it to be the first property to output
                            // (although it may still get rearranged etc)
                            if (i > 0) { // note: must shuffle both regular properties and filtered
                                System.arraycopy(_props, 0, _props, 1, i);
                                _props[0] = idProp;
                                if (_filteredProps != null) {
                                    BeanPropertyWriter fp = _filteredProps[i];
                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);
                                    _filteredProps[0] = fp;
                                }
                            }
                            break;
                        }
                    }
                    idType = idProp.getType();
                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);
                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());
                } else { // other types need to be simpler
                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);
                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,
                            objectIdInfo.getAlwaysAsId());
                }
            }
            // Or change Filter Id in use?
            Object filterId = intr.findFilterId(accessor);
            if (filterId != null) {
                // but only consider case of adding a new filter id (no removal via annotation)
                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {
                    newFilterId = filterId;
                }
            }
        }
        // either way, need to resolve serializer:
        BeanSerializerBase contextual = this;
        if (oiw != null) {
            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);
            oiw = oiw.withSerializer(ser);
            if (oiw != _objectIdWriter) {
                contextual = contextual.withObjectIdWriter(oiw);
            }
        }
        // And possibly add more properties to ignore
        if ((ignoredProps != null) && !ignoredProps.isEmpty()) {
            contextual = contextual.withIgnorals(ignoredProps);
        }
        if (newFilterId != null) {
            contextual = contextual.withFilterId(newFilterId);
        }
        if (shape == null) {
            shape = _serializationShape;
        }
        // last but not least; may need to transmute into as-array serialization
        if (shape == JsonFormat.Shape.ARRAY) {
            return contextual.asArraySerializer();
        }
        return contextual;
    }",1
"public void write(SourceWriter w) {
        // class header
        String packageName = ""it.geosolutions.jaiext.jiffle.runtime"";
        w.line(""package "" + packageName + "";"");
        w.newLine();
        w.line(""import java.util.List;"");
        w.line(""import java.util.ArrayList;"");
        w.line(""import java.util.Arrays;"");
        w.newLine();

        // add the script source, if available
        String script = w.getScript();
        if (script != null) {
            String[] lines = script.split(""\n"");
            w.line(""/**"");
            w.line("" * Java runtime class generated from the following Jiffle script: "");
            w.line("" *<pre>"");
            for (String line : lines) {
                // In case the script itself includes comments, they best to be escaped
                String escaped = line.replace(""*/"", ""*&#47;"").replace(""/*"", ""&#47;*"");
                w.append("" * "").append(escaped).newLine();
            }
            w.line("" *</pre>"");
            w.line("" */"");
        }

        // class declaration
        String template = ""public class %s extends %s {"";
        String className;
        Jiffle.RuntimeModel model = w.getRuntimeModel();
        if (model == Jiffle.RuntimeModel.DIRECT) {
            className = ""JiffleDirectRuntimeImpl"";
        } else {
            className = ""JiffleIndirectRuntimeImpl"";
        }
        w.line(format(template, className, w.getBaseClassName()));

        // writing class fields
        w.inc();
        // ... if we are using a internal class, dodge map lookups while working on pixels
        if (w.isInternalBaseClass()) {
            for (String sourceImage : sourceImages) {
                w.indent().append(""SourceImage s_"").append(sourceImage).append("";"").newLine();
            }
            if (model == Jiffle.RuntimeModel.DIRECT) {
                for (String destImage : destImages) {
                    w.indent()
                            .append(""DestinationImage d_"")
                            .append(destImage)
                            .append("";"")
                            .newLine();
                }
            }
        }
        globals.writeFields(w);
        w.newLine();

        // adding the constructor
        w.indent().append(""public "").append(className).append(""() {"").newLine();
        w.inc();
        w.indent().append(""super(new String[] {"");
        globals.listNames(w);
        w.append(""});"").newLine();
        w.dec();
        w.line(""}"");
        w.newLine();

        // add the options init, if required
        if (options != null && !options.isEmpty()) {
            w.line(""protected void initOptionVars() {"");
            w.inc();
            for (Map.Entry<String, String> entry : options.entrySet()) {
                String name = entry.getKey();
                String value = entry.getValue();
                try {
                    String activeExpr = OptionLookup.getActiveRuntimExpr(name, value);
                    w.line(activeExpr);
                } catch (UndefinedOptionException e) {
                    throw new JiffleParserException(e);
                }
            }
            w.dec();
            w.line(""}"");
        }

        // and field initializer method
        w.line(""protected void initImageScopeVars() {"");
        w.inc();
        if (w.isInternalBaseClass()) {
            for (String sourceImage : sourceImages) {
                w.indent()
                        .append(""s_"")
                        .append(sourceImage)
                        .append("" = (SourceImage) _images.get(\"""")
                        .append(sourceImage)
                        .append(""\"");"")
                        .newLine();
            }
            if (model == Jiffle.RuntimeModel.DIRECT) {
                for (String destImage : destImages) {
                    w.indent()
                            .append(""d_"")
                            .append(destImage)
                            .append(""= (DestinationImage) _destImages.get(\"""")
                            .append(destImage)
                            .append(""\"");"")
                            .newLine();
                }
            }
        }
        globals.write(w);
        w.line(""_imageScopeVarsInitialized = true;"");
        w.dec();
        w.line(""}"");
        w.newLine();

        // the evaluate method
        if (model == Jiffle.RuntimeModel.DIRECT) {
            w.line(""public void evaluate(double _x, double _y) {"");
        } else {
            w.line(""public void evaluate(double _x, double _y, double[] result) {"");
        }
        w.inc();

        // basic checks at the beginning of pixel evaluation
        w.line(""if (!isWorldSet()) {"");
        w.inc();
        w.line(""setDefaultBounds();"");
        w.dec();
        w.line(""}"");
        w.line(""if (!_imageScopeVarsInitialized) {"");
        w.inc();
        w.line(""initImageScopeVars();"");
        w.dec();
        w.line(""}"");
        w.line(""_stk.clear();"");

        // centralize the source reads to avoid repeated reads
        readOptimizer.declareRepeatedReads(w);

        // the actual script
        w.newLine();
        stmts.write(w);

        w.dec();
        w.line(""}"");

        // closing class
        w.dec();
        w.line(""}"");
    }",1
"public ClientAuthenticationMethod getClientAuthenticationMethod() {
        return clientAuthenticationMethod;
    }",0
"@Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception
    {
        copyAttrsFromParentChannel(this.parent, ctx.channel());

        addHttp2StreamSpecificHandlers(ctx.pipeline());
        addHttpHandlerFn.accept(ctx.pipeline());

        ctx.pipeline().remove(this);
    }",0
"@Override
    public boolean onOptionsItemSelected(MenuItem item) {
        final int itemId = item.getItemId();
        if (itemId == android.R.id.home) {  // See ActionBar#setDisplayHomeAsUpEnabled()
            CallFeaturesSetting.goUpToTopLevelSetting(this, mSubscriptionInfoHelper);
            return true;
        }
        return super.onOptionsItemSelected(item);
    }",0
"private String gitCleanArgs() {
        if (""Y"".equalsIgnoreCase(System.getProperty(GIT_CLEAN_KEEP_IGNORED_FILES_FLAG))) {
            LOG.info(""{} = Y. Using old behaviour for clean using `-dff`"", GIT_CLEAN_KEEP_IGNORED_FILES_FLAG);
            return ""-dff"";
        } else {
            return ""-dffx"";
        }
    }",0
"boolean isKexDone() {
        return done.isSet();
    }",0
"public HgVersion version() {
        CommandLine hg = createCommandLine(""hg"").withArgs(""version"").withEncoding(""UTF-8"");
        String hgOut = execute(hg, new NamedProcessTag(""hg version check"")).outputAsString();
        return HgVersion.parse(hgOut);
    }",1
"public static void main(
		String[] args
	) {
		try {
			Properties env = System.getProperties();
			String includeDbObjects = env.getProperty(""includeDbObjects"");
			String excludeDbObjects = env.getProperty(""excludeDbObjects"");
			String valuePatterns = env.getProperty(""valuePatterns"");
			String valueReplacements = env.getProperty(""valueReplacements"");
			copyDb(
				env.getProperty(""jdbcDriverSource""), 
				env.getProperty(""usernameSource""), 
				env.getProperty(""passwordSource""), 
				env.getProperty(""jdbcUrlSource""), 
				env.getProperty(""jdbcDriverTarget""),
			    env.getProperty(""usernameTarget""), 
			    env.getProperty(""passwordTarget""), 
			    env.getProperty(""jdbcUrlTarget""), 
			    includeDbObjects == null ? Collections.<String>emptyList() : Arrays.asList(includeDbObjects.split("","")),
				excludeDbObjects == null ? Collections.<String>emptyList() : Arrays.asList(excludeDbObjects.split("","")),
				valuePatterns == null ? Collections.<String>emptyList() : Arrays.asList(valuePatterns.split("","")),
				valueReplacements == null ? Collections.<String>emptyList() : Arrays.asList(valueReplacements.split("","")),
			    System.out
			);
		} catch (Exception e) {
			new ServiceException(e).log();
		}
	}",0
"ActivityRecord findTaskLocked(ActivityRecord r) {
        if (DEBUG_TASKS) Slog.d(TAG_TASKS, ""Looking for task of "" + r);
        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {
            final ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {
                final ActivityStack stack = stacks.get(stackNdx);
                if (!r.isApplicationActivity() && !stack.isHomeStack()) {
                    if (DEBUG_TASKS) Slog.d(TAG_TASKS, ""Skipping stack: (home activity) "" + stack);
                    continue;
                }
                if (!stack.mActivityContainer.isEligibleForNewTasks()) {
                    if (DEBUG_TASKS) Slog.d(TAG_TASKS,
                            ""Skipping stack: (new task not allowed) "" + stack);
                    continue;
                }
                final ActivityRecord ar = stack.findTaskLocked(r);
                if (ar != null) {
                    return ar;
                }
            }
        }
        if (DEBUG_TASKS) Slog.d(TAG_TASKS, ""No task found"");
        return null;
    }",0
"static int parseIntAttribute(TypedXmlPullParser parser, String attribute, int def) {
        return (int) parseLongAttribute(parser, attribute, def);
    }",0
"public Registration addHeartbeatListener(HeartbeatListener listener) {
        return addListener(HeartbeatListener.class, listener);
    }",0
"public void visitUris(@NonNull Consumer<Uri> visitor) {
        visitor.accept(sound);

        if (tickerView != null) tickerView.visitUris(visitor);
        if (contentView != null) contentView.visitUris(visitor);
        if (bigContentView != null) bigContentView.visitUris(visitor);
        if (headsUpContentView != null) headsUpContentView.visitUris(visitor);

        visitIconUri(visitor, mSmallIcon);
        visitIconUri(visitor, mLargeIcon);

        if (actions != null) {
            for (Action action : actions) {
                visitIconUri(visitor, action.getIcon());
            }
        }

        if (extras != null) {
            visitIconUri(visitor, extras.getParcelable(EXTRA_LARGE_ICON_BIG, Icon.class));
            visitIconUri(visitor, extras.getParcelable(EXTRA_PICTURE_ICON, Icon.class));

            // NOTE: The documentation of EXTRA_AUDIO_CONTENTS_URI explicitly says that it is a
            // String representation of a Uri, but the previous implementation (and unit test) of
            // this method has always treated it as a Uri object. Given the inconsistency,
            // supporting both going forward is the safest choice.
            Object audioContentsUri = extras.get(EXTRA_AUDIO_CONTENTS_URI);
            if (audioContentsUri instanceof Uri) {
                visitor.accept((Uri) audioContentsUri);
            } else if (audioContentsUri instanceof String) {
                visitor.accept(Uri.parse((String) audioContentsUri));
            }

            if (extras.containsKey(EXTRA_BACKGROUND_IMAGE_URI)) {
                visitor.accept(Uri.parse(extras.getString(EXTRA_BACKGROUND_IMAGE_URI)));
            }

            ArrayList<Person> people = extras.getParcelableArrayList(EXTRA_PEOPLE_LIST);
            if (people != null && !people.isEmpty()) {
                for (Person p : people) {
                    visitor.accept(p.getIconUri());
                }
            }

            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON, Person.class);
            if (person != null) {
                visitor.accept(person.getIconUri());
            }

            final RemoteInputHistoryItem[] history = (RemoteInputHistoryItem[])
                    extras.getParcelableArray(Notification.EXTRA_REMOTE_INPUT_HISTORY_ITEMS);
            if (history != null) {
                for (int i = 0; i < history.length; i++) {
                    RemoteInputHistoryItem item = history[i];
                    if (item.getUri() != null) {
                        visitor.accept(item.getUri());
                    }
                }
            }
        }

        if (isStyle(MessagingStyle.class) && extras != null) {
            final Parcelable[] messages = extras.getParcelableArray(EXTRA_MESSAGES);
            if (!ArrayUtils.isEmpty(messages)) {
                for (MessagingStyle.Message message : MessagingStyle.Message
                        .getMessagesFromBundleArray(messages)) {
                    visitor.accept(message.getDataUri());

                    Person senderPerson = message.getSenderPerson();
                    if (senderPerson != null) {
                        visitor.accept(senderPerson.getIconUri());
                    }
                }
            }

            final Parcelable[] historic = extras.getParcelableArray(EXTRA_HISTORIC_MESSAGES);
            if (!ArrayUtils.isEmpty(historic)) {
                for (MessagingStyle.Message message : MessagingStyle.Message
                        .getMessagesFromBundleArray(historic)) {
                    visitor.accept(message.getDataUri());

                    Person senderPerson = message.getSenderPerson();
                    if (senderPerson != null) {
                        visitor.accept(senderPerson.getIconUri());
                    }
                }
            }
        }

        if (isStyle(CallStyle.class) & extras != null) {
            Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);
            if (callPerson != null) {
                visitor.accept(callPerson.getIconUri());
            }
            visitIconUri(visitor, extras.getParcelable(EXTRA_VERIFICATION_ICON));
        }

        if (mBubbleMetadata != null) {
            visitIconUri(visitor, mBubbleMetadata.getIcon());
        }
    }",1
"@Override
    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {

        // ------------------------------------------------------------------------------
        // Handle WebSocket frames
        // ------------------------------------------------------------------------------

        if (msg instanceof WebSocketFrame) {
            handleWebsocketFrame(ctx, (WebSocketFrame) msg);
            return;
        }

        // ------------------------------------------------------------------------------
        // Decode HTTP headers
        // ------------------------------------------------------------------------------

        boolean requestComplete = false;
        try {
            if (msg instanceof HttpRequest) {
                HttpRequest httpReq = (HttpRequest) msg;

                // System.out.println(""REQUEST: "" + httpReq.getUri());

                // Start a new request
                request = new Request(httpReq);

                // Handle expect-100-continue
                boolean expect100Continue = false;
                List<CharSequence> allExpectHeaders = httpReq.headers().getAll(EXPECT);
                for (int i = 0; i < allExpectHeaders.size(); i++) {
                    String h = allExpectHeaders.get(i).toString();
                    if (h.equalsIgnoreCase(""100-continue"")) {
                        expect100Continue = true;
                        break;
                    }
                }
                if (expect100Continue) {
                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE,
                            Unpooled.EMPTY_BUFFER));
                    requestComplete = true;
                    return;
                }

                closeAfterWrite = !HttpHeaderUtil.isKeepAlive(httpReq);
                addKeepAliveHeader = !closeAfterWrite && httpReq.protocolVersion().equals(HttpVersion.HTTP_1_0);

                if (httpReq.method() == HttpMethod.POST) {
                    // Start decoding HttpContent chunks
                    destroyDecoder();
                    decoder = new HttpPostRequestDecoder(factory, httpReq);

                } else {
                    // Non-POST (probably GET) -- start handling the request
                    requestComplete = true;
                }

                // TODO: will this return failure before all POST chunks have been received?
                if (!httpReq.decoderResult().isSuccess()) {
                    sendHttpErrorResponse(ctx, httpReq, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                            HttpResponseStatus.BAD_REQUEST));
                    requestComplete = true;
                    return;
                }
            }

            // ------------------------------------------------------------------------------
            // Decode HTTP POST body
            // ------------------------------------------------------------------------------

            if (msg instanceof HttpContent && decoder != null) {
                HttpContent chunk = (HttpContent) msg;
                // Offer chunk to decoder (this decreases refcount of chunk, so it doesn't have to
                // be separately released). Decoder is released after message has been handled.
                decoder.offer(chunk);

                try {
                    while (decoder.hasNext()) {
                        InterfaceHttpData data = decoder.next();
                        if (data != null) {
                            HttpDataType httpDataType = data.getHttpDataType();
                            if (httpDataType == HttpDataType.Attribute) {
                                try {
                                    Attribute attribute = (Attribute) data;
                                    request.setPostParam(attribute.getName(), attribute.getString(attribute
                                            .getCharset() == null ? Charset.forName(""UTF-8"") : attribute.getCharset()));
                                } finally {
                                    // Decrease refcount, freeing data
                                    data.release();
                                }

                            } else if (httpDataType == HttpDataType.FileUpload) {
                                FileUpload fileUpload = (FileUpload) data;
                                // TODO consider imposing size limit and returning 413 (Request Entity Too
                                // Large) once the amount of data that has been sent hits the limit
                                if (fileUpload.isCompleted()) {
                                    // Save the FileUpload object (which wraps a DiskFileUpload in /tmp).
                                    // Need to release this resource later.
                                    request.setPostFileUploadParam(fileUpload.getName(), fileUpload);
                                }
                            } else {
                                Log.warning(""Got unknown data chunk type: "" + httpDataType);
                            }
                        }
                    }
                } catch (EndOfDataDecoderException e) {
                    // Apparently decoder.hasNext() doesn't actually work
                }

                if (chunk instanceof LastHttpContent) {
                    requestComplete = true;
                }
            }

            if (!requestComplete) {
                // Wait for more chunks.
                // (Since requestComplete is false, calling return here will not call destroyDecoder()
                // in the finally block, so it will still exist when the next chunk is received.)
                return;
            }

            // ------------------------------------------------------------------------------
            // Figure out how to handle HTTP request
            // ------------------------------------------------------------------------------

            // All POST chunks have been received (or there are no chunks); ready to start handling the request

            String origReqURI = request.getURI();

            // If this is a hash URI, look up original URI whose served resource was hashed to give this hash URI.
            // We only need to serve the resource at a hash URI once per resource per client, since resources served
            // from hash URIs are indefinitely cached in the browser.
            String hashKey = CacheExtension.getHashKey(origReqURI);
            boolean isHashURI = hashKey != null;
            String reqURI = isHashURI ? CacheExtension.getOrigURI(origReqURI) : origReqURI;

            InetSocketAddress requestor = (InetSocketAddress) ctx.channel().remoteAddress();
            if (requestor != null) {
                InetAddress address = requestor.getAddress();
                if (address != null) {
                    request.setRequestor(address.getHostAddress());
                }
            }

            boolean isHEAD = request.getMethod() == HttpMethod.HEAD;

            // Run the GET method if HEAD is requested, just don't return a body.
            HttpMethod origReqMethod = request.getMethod();
            if (isHEAD) {
                request.setMethod(HttpMethod.GET);
            }

            // ------------------------------------------------------------------------------
            // Authenticate user
            // ------------------------------------------------------------------------------

            // The response object generated by a RestHandler
            Response response = null;

            // Call route handlers until one is able to handle the route,
            // or until we run out of handlers
            User user = null;
            RouteInfo authorizedRoute = null;
            ArrayList<RouteInfo> allRoutes = GribbitServer.siteResources.getAllRoutes();
            for (int i = 0, n = allRoutes.size(); i < n; i++) {
                RouteInfo route = allRoutes.get(i);
                // If the request URI matches this route path
                if (route.matches(reqURI)) {
                    Class<? extends RouteHandler> handler = route.getHandler();

                    if (!(request.getMethod() == HttpMethod.GET || request.getMethod() == HttpMethod.POST)) {

                        // We only support GET and POST at this point
                        Log.error(""Unsupported HTTP method "" + request.getMethod().name() + "" for path "" + reqURI);
                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, ""HTTP method not allowed"");

                    } else if ((request.getMethod() == HttpMethod.GET && !route.hasGetMethod())
                            || (request.getMethod() == HttpMethod.POST && !route.hasPostMethod())) {

                        // Tried to call an HTTP method that is not defined for this route
                        Log.error(""HTTP method "" + request.getMethod().name() + "" not implemented in handler ""
                                + handler.getName());
                        response = new ErrorResponse(HttpResponseStatus.METHOD_NOT_ALLOWED, ""HTTP method not allowed"");

                    } else if (RouteHandlerAuthRequired.class.isAssignableFrom(handler)) {

                        // This handler requires authentication -- check if user is logged in
                        user = User.getLoggedInUser(request);
                        if (user == null) {

                            // User is not logged in: handle request with OnUnauthorized handler instead
                            response =
                                    getResponseForErrorHandlerRoute(GribbitServer.siteResources.getUnauthorizedRoute(),
                                            request, user)
                                    // Redirect the user back to the page they were trying to get to once they
                                    // do manage to log in successfully
                                            .setCookie(
                                                    new Cookie(Cookie.REDIRECT_AFTER_LOGIN_COOKIE_NAME, ""/"", reqURI,
                                                            300));

                        } else if (RouteHandlerAuthAndValidatedEmailRequired.class.isAssignableFrom(handler)
                                && !user.emailIsValidated()) {

                            // User is logged in, but their email address has not been validated:
                            // handle request with EmailNotValidated handler instead
                            response =
                                    getResponseForErrorHandlerRoute(
                                            GribbitServer.siteResources.getEmailNotValidatedRoute(), request, user);

                        } else {

                            // Authorization required and user logged in: OK to handle request
                            // with this route
                            authorizedRoute = route;
                        }
                    } else {

                        // Authorization not required -- OK to handle request with this route
                        authorizedRoute = route;
                    }

                    // URI matches, so don't need to search further URIs
                    break;
                }
            }

            // ------------------------------------------------------------------------------
            // Complete websocket handshake if requested
            // ------------------------------------------------------------------------------

            // FIXME: Make these into class annotations
            String websocketPath = ""/websocket"";
            boolean isAuthenticatedWebsocket = true;

            if (response == null && authorizedRoute == null && msg instanceof HttpRequest
            // TODO: Read WS routes from class annotations, rather than using hardcoded ""/websocket""
                    && reqURI.endsWith(websocketPath)) {
                HttpRequest httpReq = (HttpRequest) msg;

                // Protect against CSWSH: (Cross-Site WebSocket Hijacking)
                // http://www.christian-schneider.net/CrossSiteWebSocketHijacking.html
                // http://tools.ietf.org/html/rfc6455#page-7
                CharSequence origin = request.getOrigin();
                URI originUri = null;
                if (origin != null && origin.length() > 0) {
                    try {
                        // Try parsing origin URI
                        originUri = new URI(origin.toString());
                    } catch (Exception e) {
                    }
                }
                // If port number is set but it is the default for the URI scheme, revert the port number
                // back to -1 (which means unspecified), so that it matches the server port number, 
                // which is unspecified when serving http on port 80 and https on port 443
                int originPort = originUri == null ? -1 //
                        : originUri.getPort() == 80 && ""http"".equals(originUri.getScheme()) ? -1 //
                                : originUri.getPort() == 443 && ""https"".equals(originUri.getScheme()) ? -1 //
                                        : originUri.getPort();
                // Scheme, host and port all must match to forbid cross-origin requests
                if (originUri == null //
                        || !GribbitServer.uri.getScheme().equals(originUri.getScheme()) //
                        || !GribbitServer.uri.getHost().equals(originUri.getHost()) //
                        || GribbitServer.uri.getPort() != originPort) { //
                    // Reject scripted requests to open this websocket from a different domain
                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                            HttpResponseStatus.FORBIDDEN));
                    return;
                }
                // Log.info(""Origin: "" + origin.toString());

                if (isAuthenticatedWebsocket) {
                    // For authenticated websockets, check if the user is logged in
                    User loggedInUser = User.getLoggedInUser(request);
                    if (loggedInUser == null) {
                        // Not logged in, so can't connect to this websocket
                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                                HttpResponseStatus.FORBIDDEN));
                        return;
                    }

                    // To further mitigate CSWSH attacks: check for the CSRF token in the URL parameter ""_csrf"";
                    // the passed token must match the user's CSRF token. This means the websocket URL has to
                    // be dynamically generated and inserted into the webpage that opened the websocket.
                    // TODO: generate this URL an insert into the page somehow
                    String csrfTok = loggedInUser.csrfTok;
                    if (csrfTok == null || csrfTok.isEmpty() || csrfTok.equals(CSRF.CSRF_TOKEN_UNKNOWN)
                            || csrfTok.equals(CSRF.CSRF_TOKEN_PLACEHOLDER)) {
                        // No valid CSRF token in User object
                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                                HttpResponseStatus.FORBIDDEN));
                        return;
                    }
                    String csrfParam = request.getQueryParam(""_csrf"");
                    if (csrfParam == null || csrfParam.isEmpty() || !csrfParam.equals(csrfTok)) {
                        // The CSRF URL query parameter is missing, or doesn't match the user's token 
                        sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                                HttpResponseStatus.FORBIDDEN));
                        return;                        
                    }

                    // Record which user was authenticated when the websocket upgrade request was made.
                    // TODO: Also provide a means for revoking user's session while WS is still open,
                    // e.g. poll the user table every few seconds to see if user's session token has
                    // changed in the database? (Although this would mean that logging in on a new
                    // device would log you out of all other sessions...)
                    wsAuthenticatedUser = loggedInUser;
                }

                WebSocketServerHandshakerFactory wsFactory =
                        new WebSocketServerHandshakerFactory(GribbitServer.wsUri.toString(), null, true);
                handshaker = wsFactory.newHandshaker(httpReq);
                if (handshaker == null) {
                    WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());
                } else {
                    // Attempt websocket handshake, and if it succeeds, upgrade connection to websocket
                    // TODO: filed bug report, handshaker.handshake should take HttpRequest, not FullHttpRequest
                    DefaultFullHttpRequest fullReq =
                            new DefaultFullHttpRequest(httpReq.protocolVersion(), httpReq.method(), httpReq.uri());
                    fullReq.headers().add(httpReq.headers());
                    handshaker.handshake(ctx.channel(), (FullHttpRequest) fullReq);
                }
                return;
            }

            // ------------------------------------------------------------------------------
            // Handle static file requests
            // ------------------------------------------------------------------------------

            // If no error has occurred so far, and no route handler matched the request URI, and this is a
            // GET request, then see if the URI points to a static file resource, and if so, serve the file.
            if (response == null && authorizedRoute == null) {
                // Static file requests can only use GET method
                if (request.getMethod() != HttpMethod.GET) {
                    sendHttpErrorResponse(ctx, null, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                            HttpResponseStatus.FORBIDDEN));
                    return;
                }

                File staticResourceFile = GribbitServer.siteResources.getStaticResource(reqURI);
                if (staticResourceFile == null) {

                    // Neither a route handler nor a static resource matched the request URI.
                    // Return 404 Not Found.
                    response =
                            getResponseForErrorHandlerRoute(GribbitServer.siteResources.getNotFoundRoute(), request,
                                    user);

                } else {

                    // A static resource matched the request URI, check last-modified timestamp
                    // against the If-Modified-Since header timestamp in the request.
                    long lastModifiedEpochSeconds = staticResourceFile.lastModified() / 1000;
                    if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {
                        // File has not been modified since it was last cached -- return Not Modified
                        response = new NotModifiedResponse(lastModifiedEpochSeconds);

                    } else {
                        // If file is newer than what is in the browser cache, or is not in cache, serve the file
                        serveStaticFile(reqURI, hashKey, staticResourceFile, lastModifiedEpochSeconds, ctx);

                        Log.fine(request.getRequestor() + ""\t"" + origReqMethod + ""\t"" + reqURI + ""\tfile://""
                                + staticResourceFile.getPath() + ""\t"" + HttpResponseStatus.OK + ""\t""
                                + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + "" msec"");

                        // Finished request
                        return;
                    }
                }
            }

            // ------------------------------------------------------------------------------
            // Handle GET or POST requests
            // ------------------------------------------------------------------------------

            ZonedDateTime timeNow = null;

            // If an error response hasn't yet been generated and this is a (non-static-file) GET or POST request,
            // then call the get() or post() method for the route handler bound to the request URI to obtain the
            // response object.
            boolean hashTheResponse = false;
            long hashKeyRemainingAgeSeconds = 0;
            if (response == null && authorizedRoute != null) {

                // ----------------------------------
                // See if response should be hashed
                // ----------------------------------

                // For hashed *non-file* URIs, the actual last modified timestamp of dynamically-served
                // content can't be read directly, so read the last modified timestamp stored for the
                // previously hashed version in the CacheExtension class, as long as the max age of the
                // cached version hasn't been exceeded, and see if the last modified timestamp is more
                // recent than the version cached in the browser.
                //
                // The important ramification of this is that when the resource identified by the non-file
                // URI changes, the CacheExtension class must be notified of that change (including in cases
                // where the database is modified by another database client) if the modified version should
                // start being served at a new hash URI immediately, otherwise the web client connected to
                // this web server will continue to serve old resources until the max age of the cached
                // content is exceeded.
                if (isHashURI) {
                    HashInfo hashInfo = CacheExtension.getHashInfo(reqURI);
                    if (hashInfo != null) {
                        long lastModifiedEpochSeconds = hashInfo.getLastModifiedEpochSeconds();
                        timeNow = ZonedDateTime.now();
                        long timeNowEpochSeconds = timeNow.toEpochSecond();

                        long maxAgeSeconds = authorizedRoute.getMaxAgeSeconds();
                        hashKeyRemainingAgeSeconds = lastModifiedEpochSeconds + maxAgeSeconds - timeNowEpochSeconds;

                        if (maxAgeSeconds == 0) {
                            // Content is not hash-cached
                            hashKeyRemainingAgeSeconds = 0;
                        }

                        if (maxAgeSeconds > 0 && hashKeyRemainingAgeSeconds <= 0) {
                            // Resource has expired -- call the route handler to generate a new response rather
                            // than serving a Not Modified response, and schedule the response to be hashed or
                            // re-hashed once the response has been generated.
                            hashTheResponse = true;

                            // Reset the expiry time at the requested number of seconds in the future
                            hashKeyRemainingAgeSeconds = maxAgeSeconds;

                        } else if (!request.cachedVersionIsOlderThan(lastModifiedEpochSeconds)) {
                            // Resource has not expired in cache, but client has requested it anyway.
                            // However, resource has not been modified since it was last hashed --
                            // return Not Modified.
                            response = new NotModifiedResponse(lastModifiedEpochSeconds);

                        } else {
                            // Resource has not expired in cache, but client has requested it anyway.
                            // Resource *has* been modified since it was last hashed -- serve it the
                            // normal way using the route handler, but don't hash the response, since
                            // it has not expired yet.
                        }
                    } else {
                        // There is no original URI matching this hash URI, so the hash key was stale
                        // (i.e. a URI whose hashcode has been spoofed, or a very old hashcode from
                        // the previous time the server was run), but we still got a valid request URI
                        // by stripping away the hash code, so that is served below in the normal way.
                    }
                }

                // If the response wasn't just set to ""Not Modified"" above, serve the request
                if (response == null) {

                    // -----------------------------------------------------------------
                    // Call the route handler for this request, generating the response
                    // -----------------------------------------------------------------

                    response = getResponseForRoute(authorizedRoute, request, user);

                    if (response == null) {
                        // Should not happen
                        throw new RuntimeException(""Didn't generate a response"");
                    }

                }

            }
            if (response == null) {
                // Should not happen
                throw new RuntimeException(""Didn't generate a response"");
            }

            // ------------------------------------------------------------------------------------
            // Serve an HTTP result (except in the case of static files, they were served already)
            // ------------------------------------------------------------------------------------

            // Turn the Response object into an HttpResponse object and serve it to the user over Netty.
            if (timeNow == null) {
                timeNow = ZonedDateTime.now();
            }

            // Serve the response to the client 
            serveHttpResponse(reqURI, response, isHEAD, request.acceptEncodingGzip(),//
                    timeNow, hashTheResponse, hashKeyRemainingAgeSeconds, hashKey, ctx);

            // Log the request and response
            HttpResponseStatus status = response.getStatus();
            String logMsg =
                    request.getRequestor() + ""\t"" + origReqMethod + ""\t"" + reqURI
                            + (request.getMethod() == origReqMethod ? """" : ""\t"" + request.getMethod()) + ""\t"" + status
                            + ""\t"" + (System.currentTimeMillis() - request.getReqReceivedTimeEpochMillis()) + "" msec"";
            if (status == HttpResponseStatus.OK //
                    || status == HttpResponseStatus.NOT_MODIFIED //
                    || status == HttpResponseStatus.FOUND //
                    || (status == HttpResponseStatus.NOT_FOUND //
                    && (reqURI.equals(""favicon.ico"") || reqURI.endsWith(""/favicon.ico"")))) {
                // Log at level ""fine"" for non-errors, or 404 for favicon
                Log.fine(logMsg);
            } else {
                // Log at level ""warning"" for errors, or 404 for non-favicon
                Log.warningWithoutCallerRef(logMsg);
            }

        } finally {
            if (requestComplete) {
                // Finished request -- destroy the multipart decoder and remove temporary files
                destroyDecoder();
            }
        }
    }",1
"private void setJsonFormData(PageModel model, Account account, OtherAccountData otherAccountData, UiUtils uu) throws IOException {
		
		ObjectMapper mapper = new ObjectMapper();
		SimpleObject simplePerson = new SimpleObject();
		simplePerson.put(""familyName"", uu.encodeHtml(account.getFamilyName()));
		simplePerson.put(""givenName"", uu.encodeHtml(account.getGivenName()));
		simplePerson.put(""gender"", uu.encodeHtml(account.getGender()) != null ? uu.encodeHtml(account.getGender()) : """");
		model.addAttribute(""personJson"", mapper.writeValueAsString(simplePerson));
		
		SimpleObject simpleUser = new SimpleObject();
		SimpleObject simpleProvider = new SimpleObject();
		if (otherAccountData != null) {
			if (otherAccountData.getAddUserAccount()) {
				User u = account.getUserAccounts().get(0);
				simpleUser.put(""username"", uu.encodeHtml(u.getUsername()));
				simpleUser.put(""privilegeLevel"", account.getPrivilegeLevel(u).getUuid());
				SimpleObject userProperties = new SimpleObject();
				userProperties
				        .put(OpenmrsConstants.USER_PROPERTY_CHANGE_PASSWORD, otherAccountData.getForceChangePassword());
				simpleUser.put(""userProperties"", userProperties);
				SimpleObject simpleUserCapabilities = new SimpleObject();
				for (Role cap : account.getCapabilities(u)) {
					simpleUserCapabilities.put(cap.getUuid(), true);
				}
				simpleUser.put(""capabilities"", simpleUserCapabilities);
			}
			
			if (otherAccountData.getAddProviderAccount()) {
				Provider prov = (Provider) account.getProviderAccounts().get(0);
				simpleProvider.put(""identifier"", prov.getIdentifier());
				simpleProvider.put(""providerRole"", prov.getProviderRole().getUuid());
			}
		}
		
		model.addAttribute(""userJson"", mapper.writeValueAsString(simpleUser));
		model.addAttribute(""providerJson"", mapper.writeValueAsString(simpleProvider));
	}",1
"public static boolean isCsrfTokenValid(UI ui, String requestToken) {

        if (ui.getSession().getService().getDeploymentConfiguration()
                .isXsrfProtectionEnabled()) {
            String uiToken = ui.getCsrfToken();

            if (uiToken == null || !MessageDigest.isEqual(
                    uiToken.getBytes(StandardCharsets.UTF_8),
                    requestToken.getBytes(StandardCharsets.UTF_8))) {
                return false;
            }
        }
        return true;
    }",1
"private void scrollToTLD() {
        Editable url = getText();
        if (url == null || url.length() < 1) return;
        String urlString = url.toString();
        URL javaUrl;
        try {
            javaUrl = new URL(urlString);
        } catch (MalformedURLException mue) {
            return;
        }
        String host = javaUrl.getHost();
        if (host == null || host.isEmpty()) return;
        int hostStart = urlString.indexOf(host);
        int hostEnd = hostStart + host.length();
        setSelection(hostEnd);
    }",0
"@ApiOperation(value = ""Modify Node Operation"")
	@RequestMapping(value = ""/modifyNode"", method = RequestMethod.POST)
	@ResponseBody
	public String modifyNode(@RequestParam(value = ""userid"", required = true) String userId,
			@RequestParam(value = ""solutionid"", required = false) String solutionId,
			@RequestParam(value = ""version"", required = false) String version,
			@RequestParam(value = ""cid"", required = false) String cid,
			@RequestParam(value = ""nodeid"", required = true) String nodeId,
			@RequestParam(value = ""nodename"", required = false) String nodeName,
			@RequestParam(value = ""ndata"", required = false) String ndata,
			@RequestBody(required = false) DataConnector dataConnector) {
		
		String result = null;
		FieldMap fieldMap = null;
		DataBrokerMap databrokerMap = null;
		CollatorMap collatorMap = null;
		SplitterMap  splitterMap = null;
		logger.debug(EELFLoggerDelegator.debugLogger, ""------- modifyNode() ------- : Begin"");
		try {
			if(null != dataConnector){
				if(null != dataConnector.getFieldMap()){
					fieldMap = dataConnector.getFieldMap();
				}
				if(null != dataConnector.getDatabrokerMap()){
					databrokerMap = dataConnector.getDatabrokerMap();
				}
				if(null != dataConnector.getCollatorMap()){
					collatorMap = dataConnector.getCollatorMap();
				}
				if(null != dataConnector.getSplitterMap()){
					splitterMap = dataConnector.getSplitterMap();
				}
			}
			result = solutionService.modifyNode(userId, SanitizeUtils.sanitize(solutionId), version, cid, nodeId, nodeName, ndata, fieldMap, databrokerMap, collatorMap, splitterMap);
		} catch (Exception e) {
			logger.error(EELFLoggerDelegator.errorLogger, ""-------Exception in  modifyNode() -------"", e);
		}
		logger.debug(EELFLoggerDelegator.debugLogger, ""------- modifyNode() ------- : End"");
		return result;
	}",1
"protected void updateStatusMessages() {
        updateDateSeparators();
        synchronized (this.messageList) {
            if (showLoadMoreMessages(conversation)) {
                this.messageList.add(0, Message.createLoadMoreMessage(conversation));
            }
            if (conversation.getMode() == Conversation.MODE_SINGLE) {
                ChatState state = conversation.getIncomingChatState();
                if (state == ChatState.COMPOSING) {
                    this.messageList.add(Message.createStatusMessage(conversation, getString(R.string.contact_is_typing, conversation.getName())));
                } else if (state == ChatState.PAUSED) {
                    this.messageList.add(Message.createStatusMessage(conversation, getString(R.string.contact_has_stopped_typing, conversation.getName())));
                } else {
                    for (int i = this.messageList.size() - 1; i >= 0; --i) {
                        final Message message = this.messageList.get(i);
                        if (message.getType() != Message.TYPE_STATUS) {
                            if (message.getStatus() == Message.STATUS_RECEIVED) {
                                return;
                            } else {
                                if (message.getStatus() == Message.STATUS_SEND_DISPLAYED) {
                                    this.messageList.add(i + 1,
                                            Message.createStatusMessage(conversation, getString(R.string.contact_has_read_up_to_this_point, conversation.getName())));
                                    return;
                                }
                            }
                        }
                    }
                }
            } else {
                final MucOptions mucOptions = conversation.getMucOptions();
                final List<MucOptions.User> allUsers = mucOptions.getUsers();
                final Set<ReadByMarker> addedMarkers = new HashSet<>();
                ChatState state = ChatState.COMPOSING;
                List<MucOptions.User> users = conversation.getMucOptions().getUsersWithChatState(state, 5);
                if (users.size() == 0) {
                    state = ChatState.PAUSED;
                    users = conversation.getMucOptions().getUsersWithChatState(state, 5);
                }
                if (mucOptions.isPrivateAndNonAnonymous()) {
                    for (int i = this.messageList.size() - 1; i >= 0; --i) {
                        final Set<ReadByMarker> markersForMessage = messageList.get(i).getReadByMarkers();
                        final List<MucOptions.User> shownMarkers = new ArrayList<>();
                        for (ReadByMarker marker : markersForMessage) {
                            if (!ReadByMarker.contains(marker, addedMarkers)) {
                                addedMarkers.add(marker); //may be put outside this condition. set should do dedup anyway
                                MucOptions.User user = mucOptions.findUser(marker);
                                if (user != null && !users.contains(user)) {
                                    shownMarkers.add(user);
                                }
                            }
                        }
                        final ReadByMarker markerForSender = ReadByMarker.from(messageList.get(i));
                        final Message statusMessage;
                        final int size = shownMarkers.size();
                        if (size > 1) {
                            final String body;
                            if (size <= 4) {
                                body = getString(R.string.contacts_have_read_up_to_this_point, UIHelper.concatNames(shownMarkers));
                            } else if (ReadByMarker.allUsersRepresented(allUsers, markersForMessage, markerForSender)) {
                                body = getString(R.string.everyone_has_read_up_to_this_point);
                            } else {
                                body = getString(R.string.contacts_and_n_more_have_read_up_to_this_point, UIHelper.concatNames(shownMarkers, 3), size - 3);
                            }
                            statusMessage = Message.createStatusMessage(conversation, body);
                            statusMessage.setCounterparts(shownMarkers);
                        } else if (size == 1) {
                            statusMessage = Message.createStatusMessage(conversation, getString(R.string.contact_has_read_up_to_this_point, UIHelper.getDisplayName(shownMarkers.get(0))));
                            statusMessage.setCounterpart(shownMarkers.get(0).getFullJid());
                            statusMessage.setTrueCounterpart(shownMarkers.get(0).getRealJid());
                        } else {
                            statusMessage = null;
                        }
                        if (statusMessage != null) {
                            this.messageList.add(i + 1, statusMessage);
                        }
                        addedMarkers.add(markerForSender);
                        if (ReadByMarker.allUsersRepresented(allUsers, addedMarkers)) {
                            break;
                        }
                    }
                }
                if (users.size() > 0) {
                    Message statusMessage;
                    if (users.size() == 1) {
                        MucOptions.User user = users.get(0);
                        int id = state == ChatState.COMPOSING ? R.string.contact_is_typing : R.string.contact_has_stopped_typing;
                        statusMessage = Message.createStatusMessage(conversation, getString(id, UIHelper.getDisplayName(user)));
                        statusMessage.setTrueCounterpart(user.getRealJid());
                        statusMessage.setCounterpart(user.getFullJid());
                    } else {
                        int id = state == ChatState.COMPOSING ? R.string.contacts_are_typing : R.string.contacts_have_stopped_typing;
                        statusMessage = Message.createStatusMessage(conversation, getString(id, UIHelper.concatNames(users)));
                        statusMessage.setCounterparts(users);
                    }
                    this.messageList.add(statusMessage);
                }

            }
        }
    }",0
"private String createTmpDir() {
        try {
            File tmp = Files.createTempDirectory(""fileresourcemanager"").toFile();
            String workDir = tmp.getAbsolutePath();
            return workDir;
        } catch (IOException e) {
            throw log.errorCreateWorkDir(e);
        }
    }",1
"@Override
    public void unremoveRepository(String projectName, String repositoryName,
                                   AsyncMethodCallback resultHandler) {
        handleAsVoidResult(executor.execute(Command.unremoveRepository(SYSTEM, projectName, repositoryName))
                                   .thenCompose(unused -> mds.restoreRepo(SYSTEM, projectName, repositoryName)),
                           resultHandler);
    }",0
"private void doRequest(String method, HttpServletRequest request,
			HttpServletResponse response) throws ServletException, IOException
	{
		try
		{
			int serviceId = 0;
			String proxyPath = """";
			String queryString = """";
			
			try 
			{
				if (request.getQueryString() != null)
				{
					queryString = ""?"" + request.getQueryString(); 	
				}
				
				if (request.getPathInfo() != null) // /{serviceId}/*
				{
					String[] pathParts = request.getPathInfo().split(""/"");
	
					if (pathParts.length > 1)
					{
						serviceId = Integer.parseInt(pathParts[1]);
					}
					
					if (pathParts.length > 2)
					{
						proxyPath = String.join(""/"", Arrays.copyOfRange(pathParts, 2, pathParts.length));
					}
					
					if (serviceId < 0 || serviceId > supportedServices.length)
					{
						serviceId = 0;
					}
				}
			}
			catch (Exception e) 
			{
				// Ignore and use 0
				serviceId = 0;
			}
			
			String exportUrl = System.getenv(supportedServices[serviceId]);
			
			if (exportUrl == null || exportUrl.isEmpty() || 
				(!exportUrl.startsWith(""http://"") && !exportUrl.startsWith(""https://"")))
			{
				throw new Exception(supportedServices[serviceId] + "" not set or invalid"");
			}
			else if (!exportUrl.endsWith(""/"")) // There are other non-trivial cases, admins should configure these URLs carefully
			{
				exportUrl += ""/"";
			}
			
			URL url = new URL(exportUrl + proxyPath + queryString);
			HttpURLConnection con = (HttpURLConnection) url.openConnection();
			
			con.setRequestMethod(method);
			
			//Copy request headers to export server
			Enumeration<String> headerNames = request.getHeaderNames();
			 
	        while (headerNames.hasMoreElements()) 
	        {
	            String headerName = headerNames.nextElement();
	            Enumeration<String> headers = request.getHeaders(headerName);
	            
	            while (headers.hasMoreElements()) 
	            {
	                String headerValue = headers.nextElement();
	                con.addRequestProperty(headerName, headerValue);
	            }
	        }
	        
	        if (""POST"".equals(method))
	        {
				// Send post request
				con.setDoOutput(true);
				
				OutputStream params = con.getOutputStream();
				Utils.copyRestricted(request.getInputStream(), params, MAX_FETCH_SIZE);
				params.flush();
				params.close();
	        }
	        
	        int responseCode = con.getResponseCode();
			//Copy response code
			response.setStatus(responseCode);
			
			//Copy response headers
			Map<String, List<String>> map = con.getHeaderFields();
			
			for (Map.Entry<String, List<String>> entry : map.entrySet()) 
			{
				String key = entry.getKey();
				
				if (key != null)
				{
					for (String val : entry.getValue())
					{	
						
						response.addHeader(entry.getKey(), val);
					}
				}
			}
			
			//Copy response
			OutputStream out = response.getOutputStream();
			
			//Error
			if (responseCode >= 400)
			{
				Utils.copy(con.getErrorStream(), out);
			}
			else //Success
			{
				Utils.copy(con.getInputStream(), out);
			}
			
			out.flush();
			out.close();
		}
		catch (Exception e)
		{
			response.setStatus(
					HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			e.printStackTrace();
		}
	}",1
"public static void addFileToZipAPKTool(String path, String srcFile, ZipOutputStream zip) throws Exception {
        File folder = new File(srcFile);

        String check = path.toLowerCase();
        //if(check.startsWith(""decoded unknown"") || check.startsWith(""decoded lib"") || check.startsWith(""decoded
        // assets"") || check.startsWith(""decoded original"") || check.startsWith(""decoded smali"") || check.startsWith
        // (""decoded apktool.yml""))
        if (check.startsWith(""decoded original"") || check.startsWith(""decoded smali"") || check.startsWith(""decoded ""
                + ""apktool.yml""))
            return;

        //if(path.equals(""original"") || path.equals(""classes.dex"") || path.equals(""apktool.yml""))
        //    continue;

        if (folder.isDirectory()) {
            addFolderToZipAPKTool(path, srcFile, zip);
        } else {
            byte[] buf = new byte[1024];
            int len;
            try (FileInputStream in = new FileInputStream(srcFile)) {
                ZipEntry entry;

                entry = new ZipEntry(path + ""/"" + folder.getName());
                zip.putNextEntry(entry);

                while ((len = in.read(buf)) > 0) {
                    zip.write(buf, 0, len);
                }
            }
        }
    }",0
"private String addPadding(String str, int width) {
        AttributedStringBuilder sb = new AttributedStringBuilder();
        for (int i = str.length(); i < width; i++) {
            sb.append("" "");
        }
        sb.append(str);
        return sb.toString();
    }",0
"public boolean isAttributeDefault(int index) {
            return false;
        }",0
"@Override
    public void toWriter(boolean wholeDocument, Writer writer, Properties outputProperties)
    {
        try {
            super.toWriter(wholeDocument, writer, outputProperties);
        } catch (TransformerException e) {
            throw wrapExceptionAsRuntimeException(e);
        }
    }",0
"@GuardedBy(""this"")
    private boolean removePidIfNoThreadLocked(ProcessRecord app) {
        final boolean removed;
        final int pid = app.getPid();
        synchronized (mPidsSelfLocked) {
            removed = mPidsSelfLocked.doRemoveIfNoThreadInternal(pid, app);
        }
        if (removed) {
            synchronized (sActiveProcessInfoSelfLocked) {
                sActiveProcessInfoSelfLocked.remove(pid);
            }
            mAtmInternal.onProcessUnMapped(pid);
        }
        return removed;
    }",0
"private Profile getProfileForEditing(String id, Profile authUser) {
		if (!canEditProfile(authUser, id)) {
			return null;
		}
		return isMyid(authUser, id) ? authUser : (Profile) utils.getParaClient().read(Profile.id(id));
	}",0
"private void showCcBccViews() {
        mCcBccView.show(true, true, true);
        if (mCcBccButton != null) {
            mCcBccButton.setVisibility(View.GONE);
        }
    }",0
"@Override
    protected void doStart() throws Exception {
        ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1);
        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
        scheduler.setRemoveOnCancelPolicy(true);
        _scheduler = scheduler;

        if (_transportFactories.isEmpty()) {
            _transportFactories.add(new WebSocketTransport.Factory());
            _transportFactories.add(new JettyHttpClientTransport.Factory(new HttpClient()));
        }
        for (ClientTransport.Factory factory : _transportFactories) {
            addBean(factory);
        }

        if (isAckExtensionEnabled()) {
            boolean present = false;
            for (Extension extension : _bayeux.getExtensions()) {
                if (extension instanceof AcknowledgedMessagesExtension) {
                    present = true;
                    break;
                }
            }
            if (!present) {
                _bayeux.addExtension(_ackExtension = new AcknowledgedMessagesExtension());
            }
        }

        if (isBinaryExtensionEnabled()) {
            _oortSession.addExtension(_binaryExtension = new org.cometd.client.ext.BinaryExtension());
            boolean present = false;
            for (Extension extension : _bayeux.getExtensions()) {
                if (extension instanceof BinaryExtension) {
                    present = true;
                    break;
                }
            }
            if (!present) {
                _bayeux.addExtension(_serverBinaryExtension = new BinaryExtension());
            }
        }

        _bayeux.addListener(_allChannelsFilter);

        ServerChannel oortCloudChannel = _bayeux.createChannelIfAbsent(OORT_CLOUD_CHANNEL).getReference();
        oortCloudChannel.addListener(_cloudListener);

        _oortSession.handshake();

        protectOortChannels(_bayeux);

        super.doStart();
    }",1
"@Override
	public Controller execute(FolderComponent folderComponent, UserRequest ureq, WindowControl wContr, Translator trans) {
		this.translator = trans;
		FileSelection selection = new FileSelection(ureq, folderComponent.getCurrentContainer(), folderComponent.getCurrentContainerPath());
		VFSContainer currentContainer = folderComponent.getCurrentContainer();
		if (currentContainer.canWrite() != VFSConstants.YES)
			throw new AssertException(""Cannot unzip to folder. Writing denied."");
			
	  //check if command is executed on a file containing invalid filenames or paths - checks if the resulting folder has a valid name
		if(selection.getInvalidFileNames().size()>0) {				
			status = FolderCommandStatus.STATUS_INVALID_NAME;
			return null;
		}		
		
		List<String> lockedFiles = new ArrayList<>();
		for (String sItem:selection.getFiles()) {
			VFSItem vfsItem = currentContainer.resolve(sItem);
			if (vfsItem instanceof VFSLeaf) {
				try {
					lockedFiles.addAll(checkLockedFiles((VFSLeaf)vfsItem, currentContainer, ureq.getIdentity()));
				} catch (Exception e) {
					String name = vfsItem == null ? ""NULL"" : vfsItem.getName();
					getWindowControl().setError(translator.translate(""FileUnzipFailed"", new String[]{name}));
				}
			}
		}
		
		if(!lockedFiles.isEmpty()) {
			String msg = FolderCommandHelper.renderLockedMessageAsHtml(trans, lockedFiles);
			List<String> buttonLabels = Collections.singletonList(trans.translate(""ok""));
			lockedFiledCtr = activateGenericDialog(ureq, trans.translate(""lock.title""), msg, buttonLabels, lockedFiledCtr);
			return null;
		}
		
		VFSItem currentVfsItem = null;
		try {
			boolean fileNotExist = false;
			for (String sItem:selection.getFiles()) {
				currentVfsItem = currentContainer.resolve(sItem);
				if (currentVfsItem instanceof VFSLeaf) {
					if (!doUnzip((VFSLeaf)currentVfsItem, currentContainer, ureq, wContr)) {
						status = FolderCommandStatus.STATUS_FAILED;
						break;
					}
				} else {
					fileNotExist = true;
					break;
				}
			}
			
			if (fileNotExist) {
				status = FolderCommandStatus.STATUS_FAILED;
				getWindowControl().setError(translator.translate(""FileDoesNotExist""));
			}
			
			VFSContainer inheritingCont = VFSManager.findInheritingSecurityCallbackContainer(folderComponent.getRootContainer());
			if(inheritingCont != null) {
				VFSSecurityCallback secCallback = inheritingCont.getLocalSecurityCallback();
				if(secCallback != null) {
					SubscriptionContext subsContext = secCallback.getSubscriptionContext();
					if (subsContext != null) {
						notificationsManager.markPublisherNews(subsContext, ureq.getIdentity(), true);
					}
				}
			}
		} catch (IllegalArgumentException e) {
			logError(""Corrupted ZIP"", e);
			String name = currentVfsItem == null ? ""NULL"" : currentVfsItem.getName();
			getWindowControl().setError(translator.translate(""FileUnzipFailed"", new String[]{name}));
		}
		
		return null;
	}",1
"public void overrideResourceableId(Long newId) {
		typeId = newId;
	}",0
"@Override
        public boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name,
                String[] args, int opti, boolean dumpAll, boolean dumpVisibleRootTasksOnly,
                boolean dumpFocusedRootTaskOnly, @UserIdInt int userId) {
            return ActivityTaskManagerService.this.dumpActivity(fd, pw, name, args, opti, dumpAll,
                    dumpVisibleRootTasksOnly, dumpFocusedRootTaskOnly, userId);
        }",0
"public static final String getRevision() {
        return ""b"";
    }",1
"public static <T> T withEncodedPassword(AuthenticationRequestType type, Properties info,
      PasswordAction<byte[], T> action) throws PSQLException, IOException {
    byte[] encodedPassword = withPassword(type, info, password -> {
      if (password == null) {
        throw new PSQLException(
            GT.tr(""The server requested password-based authentication, but no password was provided by plugin {0}"",
                PGProperty.AUTHENTICATION_PLUGIN_CLASS_NAME.get(info)),
            PSQLState.CONNECTION_REJECTED);
      }
      ByteBuffer buf = StandardCharsets.UTF_8.encode(CharBuffer.wrap(password));
      byte[] bytes = new byte[buf.limit()];
      buf.get(bytes);
      return bytes;
    });

    try {
      return action.apply(encodedPassword);
    } finally {
      java.util.Arrays.fill(encodedPassword, (byte) 0);
    }
  }",1
"public String getNamespaceAndName() {
        if(Strings.isNullOrEmpty(namespace)) {
            return name;
        }

        return namespace + ""-"" + name;
    }",0
"@Override
    public void overridePendingAppTransition(String packageName,
            int enterAnim, int exitAnim, IRemoteCallback startedCallback) {
        synchronized(mWindowMap) {
            mAppTransition.overridePendingAppTransition(packageName, enterAnim, exitAnim,
                    startedCallback);
        }
    }",0
"private void startAuthentication(IBinder token, long opId, int callingUserId, int groupId,
                IFingerprintServiceReceiver receiver, int flags, boolean restricted,
                String opPackageName) {
        updateActiveGroup(groupId, opPackageName);

        if (DEBUG) Slog.v(TAG, ""startAuthentication("" + opPackageName + "")"");

        AuthenticationClient client = new AuthenticationClient(getContext(), mHalDeviceId, token,
                receiver, mCurrentUserId, groupId, opId, restricted, opPackageName) {
            @Override
            public boolean handleFailedAttempt() {
                mFailedAttempts++;
                if (inLockoutMode()) {
                    // Failing multiple times will continue to push out the lockout time.
                    scheduleLockoutReset();
                    return true;
                }
                return false;
            }

            @Override
            public void resetFailedAttempts() {
                FingerprintService.this.resetFailedAttempts();
            }

            @Override
            public void notifyUserActivity() {
                FingerprintService.this.userActivity();
            }

            @Override
            public IFingerprintDaemon getFingerprintDaemon() {
                return FingerprintService.this.getFingerprintDaemon();
            }
        };

        if (inLockoutMode()) {
            Slog.v(TAG, ""In lockout mode; disallowing authentication"");
            // Don't bother starting the client. Just send the error message.
            if (!client.onError(FingerprintManager.FINGERPRINT_ERROR_LOCKOUT)) {
                Slog.w(TAG, ""Cannot send timeout message to client"");
            }
            return;
        }
        startClient(client, true /* initiatedByClient */);
    }",1
"@Override
  public User getUser() throws IllegalStateException {
    Organization org = getOrganization();
    if (org == null)
      throw new IllegalStateException(""No organization is set in security context"");

    User delegatedUser = delegatedUserHolder.get();

    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    if (auth instanceof AnonymousAuthenticationToken) {
      return SecurityUtil.createAnonymousUser(org);
    }

    if (delegatedUser != null) {
      return delegatedUser;
    }

    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);
    if (auth != null) {
      Object principal = auth.getPrincipal();
      if ((principal instanceof UserDetails)) {
        UserDetails userDetails = (UserDetails) principal;

        User user = null;

        // If user exists, fetch it from the userDirectory
        if (userDirectory != null) {
          user = userDirectory.loadUser(userDetails.getUsername());
          if (user == null) {
            logger.debug(""Authenticated user '{}' could not be found in any of the current UserProviders. ""
                + ""Continuing anyway..."", userDetails.getUsername());
          }
        } else {
          logger.debug(""No UserDirectory was found when trying to search for user '{}'"", userDetails.getUsername());
        }

        // Add the roles (authorities) in the security context
        Set<JaxbRole> roles = new HashSet<>();
        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();
        if (authorities != null) {
          for (GrantedAuthority ga : authorities) {
            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));
          }
        }

        if (user == null) {
          // No user was found. Create one to hold the auth information from the security context
          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);
        } else {
          // Combine the existing user with the roles in the security context
          user = JaxbUser.fromUser(user, roles);
        }

        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)
        delegatedUserHolder.set(user);

        return user;
      }
    }

    // Return the anonymous user by default
    return SecurityUtil.createAnonymousUser(jaxbOrganization);
  }",1
"@PostMapping(""comments"")
    @ApiOperation(""Comments a post"")
    @CacheLock(autoDelete = false, traceRequest = true)
    public BaseCommentDTO comment(@RequestBody JournalCommentParam journalCommentParam) {

        // Escape content
        journalCommentParam.setContent(HtmlUtils.htmlEscape(journalCommentParam.getContent(), StandardCharsets.UTF_8.displayName()));
        return journalCommentService.convertTo(journalCommentService.createBy(journalCommentParam));
    }",1
"public XWikiDeletedDocument[] getDeletedDocuments(String batchId, XWikiContext context) throws XWikiException
    {
        if (hasRecycleBin(context)) {
            return getRecycleBinStore().getAllDeletedDocuments(batchId, context, true);
        } else {
            return null;
        }
    }",0
"public Object invoke( Object proxy, Method method, Object[] args )
			throws Throwable
		{
			try {
				return invokeImpl( proxy, method, args );
			} catch ( TargetError te ) {
				// Unwrap target exception.  If the interface declares that
				// it throws the ex it will be delivered.  If not it will be
				// wrapped in an UndeclaredThrowable
				throw te.getTarget();
			} catch ( EvalError ee ) {
				// Ease debugging...
				// XThis.this refers to the enclosing class instance
				if ( Interpreter.DEBUG )
					Interpreter.debug( ""EvalError in scripted interface: ""
					+ XThis.this.toString() + "": ""+ ee );
				throw ee;
			}
		}",1
"@ApiOperation(value = ""set the ProbeIndicator"")
	@RequestMapping(value = ""/setProbeIndicator"", method = RequestMethod.POST)
	public @ResponseBody SuccessErrorMessage setProbeIndicator(HttpServletRequest request,
			@RequestParam(value = ""userId"", required = true) String userId,
			@RequestParam(value = ""solutionId"", required = false) String solutionId,
			@RequestParam(value = ""version"", required = true) String version,
			@RequestParam(value = ""cid"", required = false) String cid,
			@RequestParam(value = ""probeIndicator"", required = true) String probeIndicator
			)
			throws AcumosException {
        SuccessErrorMessage successErrorMessage = null;
		logger.debug(EELFLoggerDelegator.debugLogger, ""setProbeIndicator() in SolutionController Begin"");
        try {
        	successErrorMessage = compositeServiceImpl.setProbeIndicator(userId, SanitizeUtils.sanitize(solutionId), version, cid,probeIndicator);
		}catch (Exception e) {
			logger.error(EELFLoggerDelegator.errorLogger, ""Exception in setProbeIndicator() in SolutionController"", e);
		}
		logger.debug(EELFLoggerDelegator.debugLogger, ""setProbeIndicator() in SolutionController End"");
		return successErrorMessage;
	}",1
"private boolean applyAspectRatio(Rect outBounds, Rect containingAppBounds,
            Rect containingBounds, float desiredAspectRatio, boolean fixedOrientationLetterboxed) {
        final float maxAspectRatio = info.getMaxAspectRatio();
        final Task rootTask = getRootTask();
        final float minAspectRatio = getMinAspectRatio();
        // Not using ActivityRecord#isResizeable() directly because app compatibility testing
        // showed that android:supportsPictureInPicture=""true"" alone is not sufficient signal for
        // not letterboxing an app.
        // TODO(214602463): Remove multi-window check since orientation and aspect ratio
        // restrictions should always be applied in multi-window.
        if (task == null || rootTask == null
                || (inMultiWindowMode() && isResizeable(/* checkPictureInPictureSupport */ false)
                && !fixedOrientationLetterboxed)
                || (maxAspectRatio < 1 && minAspectRatio < 1 && desiredAspectRatio < 1)
                || isInVrUiMode(getConfiguration())) {
            // We don't enforce aspect ratio if the activity task is in multiwindow unless it is in
            // size-compat mode or is letterboxed from fixed orientation. We also don't set it if we
            // are in VR mode.
            return false;
        }

        final int containingAppWidth = containingAppBounds.width();
        final int containingAppHeight = containingAppBounds.height();
        final float containingRatio = computeAspectRatio(containingAppBounds);

        if (desiredAspectRatio < 1) {
            desiredAspectRatio = containingRatio;
        }

        if (maxAspectRatio >= 1 && desiredAspectRatio > maxAspectRatio) {
            desiredAspectRatio = maxAspectRatio;
        } else if (minAspectRatio >= 1 && desiredAspectRatio < minAspectRatio) {
            desiredAspectRatio = minAspectRatio;
        }

        int activityWidth = containingAppWidth;
        int activityHeight = containingAppHeight;

        if (containingRatio > desiredAspectRatio) {
            if (containingAppWidth < containingAppHeight) {
                // Width is the shorter side, so we use that to figure-out what the max. height
                // should be given the aspect ratio.
                activityHeight = (int) ((activityWidth * desiredAspectRatio) + 0.5f);
            } else {
                // Height is the shorter side, so we use that to figure-out what the max. width
                // should be given the aspect ratio.
                activityWidth = (int) ((activityHeight * desiredAspectRatio) + 0.5f);
            }
        } else if (containingRatio < desiredAspectRatio) {
            boolean adjustWidth;
            switch (getRequestedConfigurationOrientation()) {
                case ORIENTATION_LANDSCAPE:
                    // Width should be the longer side for this landscape app, so we use the width
                    // to figure-out what the max. height should be given the aspect ratio.
                    adjustWidth = false;
                    break;
                case ORIENTATION_PORTRAIT:
                    // Height should be the longer side for this portrait app, so we use the height
                    // to figure-out what the max. width should be given the aspect ratio.
                    adjustWidth = true;
                    break;
                default:
                    // This app doesn't have a preferred orientation, so we keep the length of the
                    // longer side, and use it to figure-out the length of the shorter side.
                    if (containingAppWidth < containingAppHeight) {
                        // Width is the shorter side, so we use the height to figure-out what the
                        // max. width should be given the aspect ratio.
                        adjustWidth = true;
                    } else {
                        // Height is the shorter side, so we use the width to figure-out what the
                        // max. height should be given the aspect ratio.
                        adjustWidth = false;
                    }
                    break;
            }
            if (adjustWidth) {
                activityWidth = (int) ((activityHeight / desiredAspectRatio) + 0.5f);
            } else {
                activityHeight = (int) ((activityWidth / desiredAspectRatio) + 0.5f);
            }
        }

        if (containingAppWidth <= activityWidth && containingAppHeight <= activityHeight) {
            // The display matches or is less than the activity aspect ratio, so nothing else to do.
            return false;
        }

        // Compute configuration based on max or min supported width and height.
        // Also account for the insets (e.g. display cutouts, navigation bar), which will be
        // clipped away later in {@link Task#computeConfigResourceOverrides()}, i.e., the out
        // bounds are the app bounds restricted by aspect ratio + clippable insets. Otherwise,
        // the app bounds would end up too small.
        int right = activityWidth + containingAppBounds.left;
        if (right >= containingAppBounds.right) {
            right += containingBounds.right - containingAppBounds.right;
        }
        int bottom = activityHeight + containingAppBounds.top;
        if (bottom >= containingAppBounds.bottom) {
            bottom += containingBounds.bottom - containingAppBounds.bottom;
        }
        outBounds.set(containingBounds.left, containingBounds.top, right, bottom);

        // If the bounds are restricted by fixed aspect ratio, then out bounds should be put in the
        // container app bounds. Otherwise the entire container bounds are available.
        if (!outBounds.equals(containingBounds)) {
            // The horizontal position should not cover insets (e.g. display cutout).
            outBounds.left = containingAppBounds.left;
        }

        return true;
    }",0
"@MediumTest
    @Test
    public void testAutoSpeakerphoneOutgoingTransmitOnly() throws Exception {
        // Start an incoming video call.
        IdPair ids = startAndMakeActiveOutgoingCall(""650-555-1212"",
                mPhoneAccountA0.getAccountHandle(), mConnectionServiceFixtureA,
                VideoProfile.STATE_TX_ENABLED, null);

        verifyAudioRoute(CallAudioState.ROUTE_SPEAKER);
    }",1
"public static String getDatabaseServerVersion(String jdbcUrl, String userName, String password, String deriveClass) {
        Connection connect = null;
        try {
            connect = getConnection(jdbcUrl, userName, password, deriveClass);
            if (connect != null) {
                String queryVersionSQL = ""select version()"";
                try (PreparedStatement ps = connect.prepareStatement(queryVersionSQL)) {
                    try (ResultSet resultSet = ps.executeQuery()) {
                        if (resultSet.next()) {
                            return resultSet.getString(1);
                        }
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.error(""Not can same deriveClass "" + deriveClass, e);
        } finally {
            if (connect != null) {
                try {
                    connect.close();
                } catch (SQLException e) {
                    LOGGER.error("""",e);
                }
            }
        }
        return ""Unknown"";
    }",1
"@Override
    public boolean performDexOptIfNeeded(String packageName, String instructionSet) {
        return performDexOpt(packageName, instructionSet, false);
    }",0
"@LargeTest
    @Test
    public void testOutgoingCallSelectPhoneAccountVideo() throws Exception {
        startOutgoingPhoneCallPendingCreateConnection(""650-555-1212"",
                null, mConnectionServiceFixtureA,
                Process.myUserHandle(), VideoProfile.STATE_BIDIRECTIONAL, null);
        com.android.server.telecom.Call call = mTelecomSystem.getCallsManager().getCalls()
                .iterator().next();
        assert(call.isVideoCallingSupportedByPhoneAccount());
        assertEquals(VideoProfile.STATE_BIDIRECTIONAL, call.getVideoState());

        // Change the phone account to one which supports video calling.
        call.setTargetPhoneAccount(mPhoneAccountA1.getAccountHandle());
        assert(call.isVideoCallingSupportedByPhoneAccount());
        assertEquals(VideoProfile.STATE_BIDIRECTIONAL, call.getVideoState());
    }",1
"@Override
    public XMLBuilder2 t(String value) {
        return text(value);
    }",0
"public boolean isInWYSIWYGEditMode()
    {
        return getDriver().findElements(By.xpath(""//div[@id='editcolumn' and contains(@class, 'editor-wysiwyg')]""))
            .size() > 0;
    }",0
"public void setClientKeyEntry(PrivateKey privateKey, X509Certificate clientCertificate) {
        if (clientCertificate != null) {
            if (clientCertificate.getBasicConstraints() != -1) {
                throw new IllegalArgumentException(""Cannot be a CA certificate"");
            }
            if (privateKey == null) {
                throw new IllegalArgumentException(""Client cert without a private key"");
            }
            if (privateKey.getEncoded() == null) {
                throw new IllegalArgumentException(""Private key cannot be encoded"");
            }
        }

        mClientPrivateKey = privateKey;
        mClientCertificate = clientCertificate;
    }",0
"void configureDefaults() {
        maxTotalConnections = defaultMaxTotalConnections();
        maxConnectionPerHost = defaultMaxConnectionPerHost();
        connectionTimeOutInMs = defaultConnectionTimeOutInMs();
        webSocketIdleTimeoutInMs = defaultWebSocketIdleTimeoutInMs();
        idleConnectionInPoolTimeoutInMs = defaultIdleConnectionInPoolTimeoutInMs();
        idleConnectionTimeoutInMs = defaultIdleConnectionTimeoutInMs();
        requestTimeoutInMs = defaultRequestTimeoutInMs();
        maxConnectionLifeTimeInMs = defaultMaxConnectionLifeTimeInMs();
        redirectEnabled = defaultRedirectEnabled();
        maxRedirects = defaultMaxRedirects();
        compressionEnabled = defaultCompressionEnabled();
        userAgent = defaultUserAgent();
        allowPoolingConnection = defaultAllowPoolingConnection();
        useRelativeURIsWithSSLProxies = defaultUseRelativeURIsWithSSLProxies();
        requestCompressionLevel = defaultRequestCompressionLevel();
        maxRequestRetry = defaultMaxRequestRetry();
        ioThreadMultiplier = defaultIoThreadMultiplier();
        allowSslConnectionPool = defaultAllowSslConnectionPool();
        useRawUrl = defaultUseRawUrl();
        removeQueryParamOnRedirect = defaultRemoveQueryParamOnRedirect();
        strict302Handling = defaultStrict302Handling();
        hostnameVerifier = defaultHostnameVerifier();
        spdyEnabled = defaultSpdyEnabled();
        spdyInitialWindowSize = defaultSpdyInitialWindowSize();
        spdyMaxConcurrentStreams = defaultSpdyMaxConcurrentStreams();
        acceptAnyCertificate = defaultAcceptAnyCertificate();
        if (defaultUseProxySelector()) {
            proxyServerSelector = ProxyUtils.getJdkDefaultProxyServerSelector();
        } else if (defaultUseProxyProperties()) {
            proxyServerSelector = ProxyUtils.createProxyServerSelector(System.getProperties());
        }
    }",1
"public String getIssuerDN() {
        return issuerDN;
    }",0
"@Override
        public void scheduleAppGcs() {
            synchronized (mAppProfiler.mProfilerLock) {
                mAppProfiler.scheduleAppGcsLPf();
            }
        }",0
"@Override
    public void writeUnknownObject(Object v, String name, TypedXmlSerializer out)
            throws XmlPullParserException, IOException {
        if (v instanceof PersistableBundle) {
            out.startTag(null, TAG_PERSISTABLEMAP);
            out.attribute(null, ""name"", name);
            ((PersistableBundle) v).saveToXml(out);
            out.endTag(null, TAG_PERSISTABLEMAP);
        } else {
            throw new XmlPullParserException(""Unknown Object o="" + v);
        }
    }",0
"public static void filterContent(String[] values, String customXssString) {
		String[] xssArr = XSS_STR.split(""\\|"");
		for (String value : values) {
			if (value == null || """".equals(value)) {
				return;
			}
			// 校验sql注释 不允许有sql注释
			checkSqlAnnotation(value);
			// 统一转为小写
			value = value.toLowerCase();
			//SQL注入检测存在绕过风险 https://gitee.com/jeecg/jeecg-boot/issues/I4NZGE
			//value = value.replaceAll(""/\\*.*\\*/"","""");

			for (int i = 0; i < xssArr.length; i++) {
				if (value.indexOf(xssArr[i]) > -1) {
					log.error(""请注意，存在SQL注入关键词---> {}"", xssArr[i]);
					log.error(""请注意，值可能存在SQL注入风险!---> {}"", value);
					throw new RuntimeException(""请注意，值可能存在SQL注入风险!--->"" + value);
				}
			}
			//update-begin-author:taoyan date:2022-7-13 for: 除了XSS_STR这些提前设置好的，还需要额外的校验比如 单引号
			if (customXssString != null) {
				String[] xssArr2 = customXssString.split(""\\|"");
				for (int i = 0; i < xssArr2.length; i++) {
					if (value.indexOf(xssArr2[i]) > -1) {
						log.error(""请注意，存在SQL注入关键词---> {}"", xssArr2[i]);
						log.error(""请注意，值可能存在SQL注入风险!---> {}"", value);
						throw new RuntimeException(""请注意，值可能存在SQL注入风险!--->"" + value);
					}
				}
			}
			//update-end-author:taoyan date:2022-7-13 for: 除了XSS_STR这些提前设置好的，还需要额外的校验比如 单引号
			if(Pattern.matches(SHOW_TABLES, value) || Pattern.matches(REGULAR_EXPRE_USER, value)){
				throw new RuntimeException(""请注意，值可能存在SQL注入风险!--->"" + value);
			}
		}
		return;
	}",1
"private boolean updatePersonalAppsSuspension(int profileUserId) {
        final boolean shouldSuspend;
        synchronized (getLockObject()) {
            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);
            if (profileOwner != null) {
                // Profile is considered ""off"" when it is either not running or is running locked
                // or is in quiet mode, i.e. when the admin cannot sync policies or show UI.
                boolean profileUserOff =
                        !mUserManagerInternal.isUserUnlockingOrUnlocked(profileUserId)
                        || mUserManager.isQuietModeEnabled(UserHandle.of(profileUserId));
                final int notificationState = updateProfileOffDeadlineLocked(
                        profileUserId, profileOwner, profileUserOff);
                final boolean suspendedExplicitly = profileOwner.mSuspendPersonalApps;
                final boolean suspendedByTimeout = profileOwner.mProfileOffDeadline == -1;
                Slogf.d(LOG_TAG,
                        ""Personal apps suspended explicitly: %b, by timeout: %b, notification: %d"",
                        suspendedExplicitly, suspendedByTimeout, notificationState);
                updateProfileOffDeadlineNotificationLocked(
                        profileUserId, profileOwner, notificationState);
                shouldSuspend = suspendedExplicitly || suspendedByTimeout;
            } else {
                shouldSuspend = false;
            }
        }

        final int parentUserId = getProfileParentId(profileUserId);
        suspendPersonalAppsInternal(parentUserId, profileUserId, shouldSuspend);
        return shouldSuspend;
    }",0
"public static ObjectNode parse(
            final TomlFactory tomlFactory,
            final IOContext ioContext,
            final Reader reader
    ) throws IOException {
        final TomlFactory factory = tomlFactory == null ? new TomlFactory() : tomlFactory;
        Parser parser = new Parser(factory, ioContext,
                new TomlStreamReadException.ErrorContext(ioContext.contentReference(), null),
                factory.getFormatParserFeatures(), reader);
        try {
            final ObjectNode node = parser.parse();
            if (factory.isEnabled(TomlReadFeature.VALIDATE_NESTING_DEPTH) && parser.getNestingDepth() > 0) {
                throw new IOException(""Nesting Depth is non-zero after parsing TOML"");
            }
            return node;
        } finally {
            parser.lexer.releaseBuffers();
        }
    }",1
"final ProcessRecord getProcessRecordLocked(String processName, int uid, boolean keepIfLarge) {
        if (uid == Process.SYSTEM_UID) {
            // The system gets to run in any process.  If there are multiple
            // processes with the same uid, just pick the first (this
            // should never happen).
            SparseArray<ProcessRecord> procs = mProcessNames.getMap().get(processName);
            if (procs == null) return null;
            final int procCount = procs.size();
            for (int i = 0; i < procCount; i++) {
                final int procUid = procs.keyAt(i);
                if (UserHandle.isApp(procUid) || !UserHandle.isSameUser(procUid, uid)) {
                    // Don't use an app process or different user process for system component.
                    continue;
                }
                return procs.valueAt(i);
            }
        }
        ProcessRecord proc = mProcessNames.get(processName, uid);
        if (false && proc != null && !keepIfLarge
                && proc.setProcState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY
                && proc.lastCachedPss >= 4000) {
            // Turn this condition on to cause killing to happen regularly, for testing.
            if (proc.baseProcessTracker != null) {
                proc.baseProcessTracker.reportCachedKill(proc.pkgList, proc.lastCachedPss);
            }
            proc.kill(Long.toString(proc.lastCachedPss) + ""k from cached"", true);
        } else if (proc != null && !keepIfLarge
                && mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL
                && proc.setProcState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
            if (DEBUG_PSS) Slog.d(TAG, ""May not keep "" + proc + "": pss="" + proc.lastCachedPss);
            if (proc.lastCachedPss >= mProcessList.getCachedRestoreThresholdKb()) {
                if (proc.baseProcessTracker != null) {
                    proc.baseProcessTracker.reportCachedKill(proc.pkgList, proc.lastCachedPss);
                }
                proc.kill(Long.toString(proc.lastCachedPss) + ""k from cached"", true);
            }
        }
        return proc;
    }",1
"private void triggerPolicyComplianceCheckIfNeeded(int profileUserId, boolean suspended) {
        synchronized (getLockObject()) {
            final ActiveAdmin profileOwner = getProfileOwnerAdminLocked(profileUserId);
            if (profileOwner == null) {
                Slogf.wtf(LOG_TAG, ""Profile owner not found for compliance check"");
                return;
            }
            if (suspended) {
                // If suspended, DPC will need to show an activity.
                final Intent intent = new Intent(ACTION_CHECK_POLICY_COMPLIANCE);
                intent.setPackage(profileOwner.info.getPackageName());
                mContext.startActivityAsUser(intent, UserHandle.of(profileUserId));
            } else if (profileOwner.mProfileOffDeadline > 0) {
                // If not suspended, but deadline set, DPC needs to acknowledge compliance so that
                // the deadline can be reset.
                sendAdminCommandLocked(profileOwner, ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED,
                        /* adminExtras= */ null, /* receiver= */ null, /* inForeground = */ true);
            }
        }
    }",0
"@Override
	@Transactional(rollbackFor = Exception.class)
	@CacheEvict(value={CacheConstant.SYS_USERS_CACHE}, allEntries=true)
	public void editUserWithDepart(SysUser user, String departs) {
        //更新角色的时候已经更新了一次了，可以再跟新一次
		this.updateById(user);
		String[] arr = {};
		if(oConvertUtils.isNotEmpty(departs)){
			arr = departs.split("","");
		}
		//查询已关联部门
		List<SysUserDepart> userDepartList = sysUserDepartMapper.selectList(new QueryWrapper<SysUserDepart>().lambda().eq(SysUserDepart::getUserId, user.getId()));
		if(userDepartList != null && userDepartList.size()>0){
			for(SysUserDepart depart : userDepartList ){
				//修改已关联部门删除部门用户角色关系
				if(!Arrays.asList(arr).contains(depart.getDepId())){
					List<SysDepartRole> sysDepartRoleList = sysDepartRoleMapper.selectList(
							new QueryWrapper<SysDepartRole>().lambda().eq(SysDepartRole::getDepartId,depart.getDepId()));
					List<String> roleIds = sysDepartRoleList.stream().map(SysDepartRole::getId).collect(Collectors.toList());
					if(roleIds != null && roleIds.size()>0){
						departRoleUserMapper.delete(new QueryWrapper<SysDepartRoleUser>().lambda().eq(SysDepartRoleUser::getUserId, user.getId())
								.in(SysDepartRoleUser::getDroleId,roleIds));
					}
				}
			}
		}
		//先删后加
		sysUserDepartMapper.delete(new QueryWrapper<SysUserDepart>().lambda().eq(SysUserDepart::getUserId, user.getId()));
		if(oConvertUtils.isNotEmpty(departs)) {
			for (String departId : arr) {
				SysUserDepart userDepart = new SysUserDepart(user.getId(), departId);
				sysUserDepartMapper.insert(userDepart);
			}
		}
	}",0
"public void init(FilterConfig filterConfig) throws ServletException {
    }",0
"private void registerResource(Bundle bundle) {
            Dictionary<String, String> properties = new Hashtable<String, String>();
            properties.put(
                    HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,
                    getResourceURI());
            String contextName = getContextName();
            if (contextName != null) {
                properties.put(
                        HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT,
                        ""("" + HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_NAME
                                + ""="" + contextName + "")"");
            }
            resourceRegistration = bundle.getBundleContext().registerService(
                    Servlet.class,
                    new ResourceServlet(bundle, getResourcePath()), properties);
        }",0
"protected boolean isProbablePrime(BigInteger x)
    {
        int iterations = getNumberOfIterations(x.bitLength(), param.getCertainty());

        /*
         * Primes class for FIPS 186-4 C.3 primality checking
         */
        return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);
    }",1
"private void unwantedNetwork(int reason) {
        sendMessage(CMD_UNWANTED_NETWORK, reason);
    }",0
"private void add0(int h, int i, AsciiString name, String value) {
        validateValue(value);
        // Update the hash table.
        entries[i] = new HeaderEntry(h, name, value, entries[i]);
        ++size;
    }",1
"private static String parseSoapMethodName(InputStream stream, String charEncoding) {
		try {
			// newInstance() et pas newFactory() pour java 1.5 (issue 367)
			final XMLInputFactory factory = XMLInputFactory.newInstance();
			factory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // disable DTDs entirely for that factory
			factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); // disable external entities
			final XMLStreamReader xmlReader;
			if (charEncoding != null) {
				xmlReader = factory.createXMLStreamReader(stream, charEncoding);
			} else {
				xmlReader = factory.createXMLStreamReader(stream);
			}

			//best-effort parsing

			//start document, go to first tag
			xmlReader.nextTag();

			//expect first tag to be ""Envelope""
			if (!""Envelope"".equals(xmlReader.getLocalName())) {
				LOG.debug(""Unexpected first tag of SOAP request: '"" + xmlReader.getLocalName()
						+ ""' (expected 'Envelope')"");
				return null; //failed
			}

			//scan for body tag
			if (!scanForChildTag(xmlReader, ""Body"")) {
				LOG.debug(""Unable to find SOAP 'Body' tag"");
				return null; //failed
			}

			xmlReader.nextTag();

			//tag is method name
			return ""."" + xmlReader.getLocalName();
		} catch (final XMLStreamException e) {
			LOG.debug(""Unable to parse SOAP request"", e);
			//failed
			return null;
		}
	}",1
"public int executeSql(String sql, Object[] bindArgs) throws SQLException {
        acquireReference();
        try {
            final int statementType = DatabaseUtils.getSqlStatementType(sql);
            if (statementType == DatabaseUtils.STATEMENT_ATTACH) {
                boolean disableWal = false;
                synchronized (mLock) {
                    if (!mHasAttachedDbsLocked) {
                        mHasAttachedDbsLocked = true;
                        disableWal = true;
                        mConnectionPoolLocked.disableIdleConnectionHandler();
                    }
                }
                if (disableWal) {
                    disableWriteAheadLogging();
                }
            }

            try (SQLiteStatement statement = new SQLiteStatement(this, sql, bindArgs)) {
                return statement.executeUpdateDelete();
            } finally {
                // If schema was updated, close non-primary connections, otherwise they might
                // have outdated schema information
                if (statementType == DatabaseUtils.STATEMENT_DDL) {
                    mConnectionPoolLocked.closeAvailableNonPrimaryConnectionsAndLogExceptions();
                }
            }
        } finally {
            releaseReference();
        }
    }",1
"@Override
	protected ResourceResponse newResourceResponse(Attributes attributes) {
		PageParameters params = attributes.getParameters();

		Long projectId = params.get(PARAM_PROJECT).toLong();
		Project project = OneDev.getInstance(ProjectManager.class).load(projectId);
		
		Long buildNumber = params.get(PARAM_BUILD).toOptionalLong();
		
		if (buildNumber == null)
			throw new IllegalArgumentException(""build number has to be specified"");
		
		Build build = OneDev.getInstance(BuildManager.class).find(project, buildNumber);

		if (build == null) {
			String message = String.format(""Unable to find build (project: %s, build number: %d)"", 
					project.getPath(), buildNumber);
			throw new EntityNotFoundException(message);
		}
		
		if (!SecurityUtils.canAccess(build))
			throw new UnauthorizedException();
		
		List<String> pathSegments = new ArrayList<>();

		for (int i = 0; i < params.getIndexedCount(); i++) {
			String pathSegment = params.get(i).toString();
			if (pathSegment.length() != 0)
				pathSegments.add(pathSegment);
		}
		
		if (pathSegments.isEmpty())
			throw new ExplicitException(""Artifact path has to be specified"");
		
		String artifactPath = Joiner.on(""/"").join(pathSegments);
		
		File artifactsDir = build.getArtifactsDir();
		File artifactFile = new File(artifactsDir, artifactPath);
		if (!artifactFile.exists() || artifactFile.isDirectory()) {
			String message = String.format(""Specified artifact path does not exist or is a directory (project: %s, build number: %d, path: %s)"", 
					project.getPath(), build.getNumber(), artifactPath);
			throw new ExplicitException(message);
		}
			
		ResourceResponse response = new ResourceResponse();
		response.getHeaders().addHeader(""X-Content-Type-Options"", ""nosniff"");
		response.setContentType(MimeTypes.OCTET_STREAM);
		response.disableCaching();
		
		try {
			response.setFileName(URLEncoder.encode(artifactFile.getName(), StandardCharsets.UTF_8.name()));
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		response.setContentLength(artifactFile.length());
		
		response.setWriteCallback(new WriteCallback() {

			@Override
			public void writeData(Attributes attributes) throws IOException {
				LockUtils.read(build.getArtifactsLockKey(), new Callable<Void>() {

					@Override
					public Void call() throws Exception {
						try (InputStream is = new FileInputStream(artifactFile)) {
							IOUtils.copy(is, attributes.getResponse().getOutputStream());
						}
						return null;
					}
					
				});
			}			
			
		});

		return response;
	}",1
"@Override
    public void mergeMessage(
        CodedInputStream input,
        ExtensionRegistryLite extensionRegistry,
        Descriptors.FieldDescriptor field,
        Message defaultInstance)
        throws IOException {
      if (!field.isRepeated()) {
        Message.Builder subBuilder;
        if (hasField(field)) {
          subBuilder = getFieldBuilder(field);
          if (subBuilder != null) {
            input.readMessage(subBuilder, extensionRegistry);
            return;
          } else {
            subBuilder = newMessageFieldInstance(field, defaultInstance);
            subBuilder.mergeFrom((Message) getField(field));
          }
        } else {
          subBuilder = newMessageFieldInstance(field, defaultInstance);
        }
        input.readMessage(subBuilder, extensionRegistry);
        Object unused = setField(field, subBuilder.buildPartial());
      } else {
        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);
        input.readMessage(subBuilder, extensionRegistry);
        Object unused = addRepeatedField(field, subBuilder.buildPartial());
      }
    }",1
"public static String quote(String string, boolean escapeForwardSlashAlways) {
        if (string == null || string.length() == 0) {
            return ""\""\"""";
        }

        char         c = 0;
        int          i;
        int          len = string.length();
        StringBuilder sb = new StringBuilder(len + 4);
        String       t;

        sb.append('""');
        for (i = 0; i < len; i += 1) {
            c = string.charAt(i);
            switch (c) {
            case '\\':
                // Escape a backslash, but only if it isn't already escaped
                if (i == len - 1 || string.charAt(i + 1) != '\\') {
                    sb.append('\\');
                }
                sb.append(c);
                break;
            case '""':
                sb.append('\\');
                sb.append(c);
                break;
            case '/':
            	if (escapeForwardSlashAlways || i > 0 && string.charAt(i - 1) == '<') {
                    sb.append('\\');
            	}
                sb.append(c);
                break;
            case '\b':
                sb.append(""\\b"");
                break;
            case '\t':
                sb.append(""\\t"");
                break;
            case '\n':
                sb.append(""\\n"");
                break;
            case '\f':
                sb.append(""\\f"");
                break;
            case '\r':
                sb.append(""\\r"");
                break;
            case '\u2028':
                sb.append(""\\u2028"");
                break;
            case '\u2029':
                sb.append(""\\u2029"");
                break;
            default:
                if (c < ' ') {
                    t = ""000"" + Integer.toHexString(c);
                    sb.append(""\\u"" + t.substring(t.length() - 4));
                } else {
                    sb.append(c);
                }
            }
        }
        sb.append('""');
        return sb.toString();
    }",1
"private Reader getReader(final XMLInputSource inputSource) {
        Reader reader = inputSource.getCharacterStream();
        if (reader == null) {
        	try {
				return new InputStreamReader(inputSource.getByteStream(), fJavaEncoding);
			}
        	catch (final UnsupportedEncodingException e) {
				// should not happen as this encoding is already used to parse the ""main"" source
			}
        }
        return reader;
	}",0
"public String getFullNameSQL()
    {
        return getFullNameSQL(true);
    }",0
"@Override
        public void setNeighborDiscoveryOffload(boolean enabled) {
            sendMessage(CMD_CONFIG_ND_OFFLOAD, (enabled ? 1 : 0));
        }",0
public static final native void removeAllProcessGroups();,0
"@Override
	protected @NotNull Class<?> loadClass(@NotNull String name, boolean resolve) throws ClassNotFoundException {
		Class<?> loadedClass = findLoadedClass(name);
		if (null == loadedClass) {
			try {
				loadedClass = findClass(name);
			} catch (ClassNotFoundException ex) {
				loadedClass = super.loadClass(name, resolve);
			}
		}

		if (resolve) {
			resolveClass(loadedClass);
		}

		return loadedClass;
	}",1
"private void migrate95(File dataDir, Stack<Integer> versions) {
		for (File file: dataDir.listFiles()) {
			if (file.getName().startsWith(""GpgKeys.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					Element contentElement = element.element(""content"");
					byte[] bytes = contentElement.getText().getBytes(StandardCharsets.UTF_8);
					contentElement.setText(JVM.getBase64Codec().encode(bytes));
				}
				dom.writeToFile(file, false);
			}
		}		
	}",0
"public long write(final InputStream inputStream, final RASegmentOutputStream segmentOutputStream,
                      final boolean close) {
        long bytesWritten;
        try {
            try {
                bytesWritten = StreamUtil.streamToStream(inputStream, segmentOutputStream, close);
            } finally {
                try {
                    // Ensure all streams are closed.
                    if (segmentOutputStream != null) {
                        segmentOutputStream.flush();
                        if (close) {
                            segmentOutputStream.close();
                        }
                    }

                } finally {
                    if (close && inputStream != null) {
                        inputStream.close();
                    }
                }
            }
            return bytesWritten;
        } catch (final IOException e) {
            throw new UncheckedIOException(e);
        }
    }",1
"@Test
  public void executeTransParam(TestContext context) {
    Async asyncTotal = context.async();

    Async async1 = context.async();
    JsonArray ids = new JsonArray().add(randomUuid()).add(randomUuid());
    postgresClient = insertXAndSingleQuotePojo(context, ids);
    postgresClient.startTx(trans -> {
      assertSuccess(context, trans);
      postgresClient.execute(trans, ""DELETE FROM tenant_raml_module_builder.foo WHERE id=?"", new JsonArray().add(ids.getString(1)), res -> {
        assertSuccess(context, res);
        postgresClient.rollbackTx(trans, rollback -> {
          assertSuccess(context, rollback);
          async1.complete();
        });
      });
    });
    async1.awaitSuccess(5000);

    Async async2 = context.async();
    postgresClient.startTx(trans -> {
      assertSuccess(context, trans);
      postgresClient.execute(trans, ""DELETE FROM tenant_raml_module_builder.foo WHERE id=?"", new JsonArray().add(ids.getString(0)), res -> {
        assertSuccess(context, res);
        postgresClient.endTx(trans, end -> {
          assertSuccess(context, end);
          async2.complete();
        });
      });
    });
    async2.awaitSuccess(5000);

    Async async3 = context.async();
    postgresClient.getById(FOO, ids, res -> {
      assertSuccess(context, res);
      context.assertEquals(1, res.result().size());
      async3.complete();
    });
    async3.awaitSuccess(5000);

    asyncTotal.complete();
  }",0
"@Override
  public void writeTo(T t, Class<?> type, Type genericType,
      Annotation[] annotations,
      MediaType mediaType, MultivaluedMap<String, Object> httpHeaders,
      OutputStream entityStream) throws IOException, WebApplicationException {
    try (OutputStreamWriter writer = new OutputStreamWriter(entityStream)) {
      YamlUtils.writeValue(writer, t);
    }
  }",1
"public static void setDefaultSecretKey(String secretNowKeyValue) {
        byte[] secretKeyBytes = DatatypeConverter.parseBase64Binary(secretNowKeyValue);
        secretKey = Keys.hmacShaKeyFor(secretKeyBytes);
        isUsedDefault = false;
    }",1
"public byte[] engineDoFinal(
        byte[] input,
        int inputOffset,
        int inputLen)
        throws IllegalBlockSizeException, BadPaddingException
    {
        if (inputLen != 0)
        {
            buffer.write(input, inputOffset, inputLen);
        }

        byte[] in = buffer.toByteArray();
        buffer.reset();

        // Convert parameters for use in IESEngine
        CipherParameters params = new IESWithCipherParameters(engineSpec.getDerivationV(),
            engineSpec.getEncodingV(),
            engineSpec.getMacKeySize(),
            engineSpec.getCipherKeySize());

        if (engineSpec.getNonce() != null)
        {
            params = new ParametersWithIV(params, engineSpec.getNonce());
        }

        DHParameters dhParams = ((DHKeyParameters)key).getParameters();

        byte[] V;
        if (otherKeyParameter != null)
        {
            try
            {
                if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)
                {
                    engine.init(true, otherKeyParameter, key, params);
                }
                else
                {
                    engine.init(false, key, otherKeyParameter, params);
                }
                return engine.processBlock(in, 0, in.length);
            }
            catch (Exception e)
            {
                throw new BadBlockException(""unable to process block"", e);
            }
        }

        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)
        {
            // Generate the ephemeral key pair
            DHKeyPairGenerator gen = new DHKeyPairGenerator();
            gen.init(new DHKeyGenerationParameters(random, dhParams));

            EphemeralKeyPairGenerator kGen = new EphemeralKeyPairGenerator(gen, new KeyEncoder()
            {
                public byte[] getEncoded(AsymmetricKeyParameter keyParameter)
                {
                    byte[] Vloc = new byte[(((DHKeyParameters)keyParameter).getParameters().getP().bitLength() + 7) / 8];
                    byte[] Vtmp = BigIntegers.asUnsignedByteArray(((DHPublicKeyParameters)keyParameter).getY());

                    if (Vtmp.length > Vloc.length)
                    {
                        throw new IllegalArgumentException(""Senders's public key longer than expected."");
                    }
                    else
                    {
                        System.arraycopy(Vtmp, 0, Vloc, Vloc.length - Vtmp.length, Vtmp.length);
                    }

                    return Vloc;
                }
            });

            // Encrypt the buffer
            try
            {
                engine.init(key, params, kGen);

                return engine.processBlock(in, 0, in.length);
            }
            catch (Exception e)
            {
                throw new BadBlockException(""unable to process block"", e);
            }
        }
        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)
        {
            // Decrypt the buffer
            try
            {
                engine.init(key, params, new DHIESPublicKeyParser(((DHKeyParameters)key).getParameters()));

                return engine.processBlock(in, 0, in.length);
            }
            catch (InvalidCipherTextException e)
            {
                throw new BadBlockException(""unable to process block"", e);
            }
        }
        else
        {
            throw new IllegalStateException(""IESCipher not initialised"");
        }

    }",1
"void fixUpShortcutResourceNamesAndValues(ShortcutInfo si) {
        final Resources publisherRes = injectGetResourcesForApplicationAsUser(
                si.getPackage(), si.getUserId());
        if (publisherRes != null) {
            final long start = getStatStartTime();
            try {
                si.lookupAndFillInResourceNames(publisherRes);
            } finally {
                logDurationStat(Stats.RESOURCE_NAME_LOOKUP, start);
            }
            si.resolveResourceStrings(publisherRes);
        }
    }",0
"public Object convertAnother(Object parent, Class type) {
        return convertAnother(parent, type, null);
    }",0
"public void close() {
        if (!partial)
            return;
        try {
            tokens.close();
        }
        catch (IOException e) {
            throw new ExceptionConverter(e);
        }
    }",0
"@Override
    protected BigDecimal bcdToBigDecimal() {
        if (usingBytes) {
            // Converting to a string here is faster than doing BigInteger/BigDecimal arithmetic.
            BigDecimal result = new BigDecimal(toNumberString());
            if (isNegative()) {
                result = result.negate();
            }
            return result;
        } else {
            long tempLong = 0L;
            for (int shift = (precision - 1); shift >= 0; shift--) {
                tempLong = tempLong * 10 + getDigitPos(shift);
            }
            BigDecimal result = BigDecimal.valueOf(tempLong);
            try {
                result = result.scaleByPowerOfTen(scale);
            } catch (ArithmeticException e) {
                if (e.getMessage().contains(""Underflow"")) {
                    result = BigDecimal.ZERO;
                } else {
                    throw e;
                }
            }
            if (isNegative())
                result = result.negate();
            return result;
        }
    }",1
"public int getNumExecutors() {
        return numExecutors;
    }",0
"protected void processPacks(final HttpServletRequest request, final HttpServletResponse response) 
			throws ServletException, IOException, InterruptedException, ExecutionException {
		File gitDir;
		boolean upload;
		Map<String, String> environments = new HashMap<>();
		
		sessionManager.openSession();
		try {
			String pathInfo = getPathInfo(request);
			
			String service = StringUtils.substringAfterLast(pathInfo, ""/"");

			String projectInfo = StringUtils.substringBeforeLast(pathInfo, ""/"");
			Project project = getProject(request, response, projectInfo);
			
			doNotCache(response);
			response.setHeader(""Content-Type"", ""application/x-"" + service + ""-result"");			

			String serverUrl;
	        if (serverConfig.getHttpPort() != 0)
	            serverUrl = ""http://localhost:"" + serverConfig.getHttpPort();
	        else 
	            serverUrl = ""https://localhost:"" + serverConfig.getHttpsPort();

	        environments.put(""ONEDEV_CURL"", settingManager.getSystemSetting().getCurlConfig().getExecutable());
			environments.put(""ONEDEV_URL"", serverUrl);
			environments.put(""ONEDEV_USER_ID"", SecurityUtils.getUserId().toString());
			environments.put(""ONEDEV_HOOK_TOKEN"", GitUtils.HOOK_TOKEN);
			environments.put(""ONEDEV_REPOSITORY_ID"", project.getId().toString());
			
			// to be compatible with old repository
	        environments.put(""GITPLEX_CURL"", settingManager.getSystemSetting().getCurlConfig().getExecutable());
			environments.put(""GITPLEX_URL"", serverUrl);
			environments.put(""GITPLEX_USER_ID"", SecurityUtils.getUserId().toString());
			environments.put(""GITPLEX_REPOSITORY_ID"", project.getId().toString());
			
			gitDir = storageManager.getProjectGitDir(project.getId());

			if (GitSmartHttpTools.isUploadPack(request)) {
				checkPullPermission(request, project);
				upload = true;
			} else {
				if (!SecurityUtils.canWriteCode(project))
					throw new UnauthorizedException(""You do not have permission to push to this project."");
				upload = false;
			}			
		} finally {
			sessionManager.closeSession();
		}
		
		InputStream stdin = new InputStreamWrapper(ServletUtils.getInputStream(request)) {

			@Override
			public void close() throws IOException {
			}
			
		};
		OutputStream stdout = new OutputStreamWrapper(response.getOutputStream()) {
			
			@Override
			public void close() throws IOException {
			}
			
		};
		
		String protocol = request.getHeader(""Git-Protocol"");		
		
		if (upload) {
			workExecutor.submit(new PrioritizedRunnable(PRIORITY) {
				
				@Override
				public void run() {
					AtomicBoolean toleratedErrors = new AtomicBoolean(false);
					ErrorCollector stderr = new ErrorCollector(StandardCharsets.UTF_8.name()) {

						@Override
						public void consume(String line) {
							super.consume(line);
							// This error may happen during a normal shallow fetch/clone 
							if (line.contains(""remote end hung up unexpectedly"")) {
								toleratedErrors.set(true);
								logger.debug(line);
							} else {
								logger.error(line);
							}
						}
						
					};

					ExecutionResult result;
					UploadPackCommand upload = new UploadPackCommand(gitDir, environments);
					upload.stdin(stdin).stdout(stdout).stderr(stderr).statelessRpc(true).protocol(protocol);
					result = upload.call();
					result.setStderr(stderr.getMessage());
					
					if (result.getReturnCode() != 0 && !toleratedErrors.get())
						throw result.buildException();
				}
				
			}).get();
		} else {
			workExecutor.submit(new PrioritizedRunnable(PRIORITY) {
				
				@Override
				public void run() {
					ErrorCollector stderr = new ErrorCollector(StandardCharsets.UTF_8.name()) {

						@Override
						public void consume(String line) {
							super.consume(line);
							logger.error(line);
						}
						
					};
					
					ReceivePackCommand receive = new ReceivePackCommand(gitDir, environments);
					receive.stdin(stdin).stdout(stdout).stderr(stderr).statelessRpc(true).protocol(protocol);
					ExecutionResult result = receive.call();
					result.setStderr(stderr.getMessage());
					result.checkReturnCode();
				}
				
			}).get();
		}
	}",1
"public static Element parseElement(String xml) {
    try {
      DocumentBuilderFactory dbFactory = safeDocumentBuilderFactory();
      DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();
      Document doc = docBuilder.parse(new ByteArrayInputStream(xml.getBytes()));
      return doc.getDocumentElement();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }",1
"@Override
    protected AbstractChainingPrintRenderer getSyntaxRenderer()
    {
        return new AnnotatedXHTMLChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,
            getListenerChain());
    }",1
"public JSONArray put(Object value) {
        this.myArrayList.add(value);
        return this;
    }",0
"public void throwKeyManagerException() throws PSQLException {
    if (km != null) {
      if (km instanceof LazyKeyManager) {
        ((LazyKeyManager)km).throwKeyManagerException();
      }
      if (km instanceof PKCS12KeyManager) {
        ((PKCS12KeyManager)km).throwKeyManagerException();
      }
    }
  }",0
"public void fillHelperObject(HelperObject helperObject) {
       helperObject.setUrlBase(CoreResources.getField(""sysURL"").split(""/MainMenu"")[0]);
       helperObject.setOpenClinicaMailSender(openClinicaMailSender);
       helperObject.setDataSource(dataSource);
       helperObject.setResterms(resterms);
       helperObject.setEventCrfDao(eventCrfDao);
       helperObject.setStudyEventDao(studyEventDao);
       helperObject.setStudySubjectDao(studySubjectDao);
       helperObject.setCrfVersionDao(crfVersionDao);
       helperObject.setSessionFactory(sessionFactory);
   }",0
"private static void throwSecurityExceptionIfNonWhitelistedFound(Supplier<String> message,
			List<StackFrame> nonWhitelisted) {
		if (!nonWhitelisted.isEmpty()) {
			LOG.warn(""NWSFs ==> {}"", nonWhitelisted); //$NON-NLS-1$
			var first = nonWhitelisted.get(0);
			throw new SecurityException(formatLocalized(""security.stackframe_add_info"", message.get(), //$NON-NLS-1$
					first.getLineNumber(), first.getFileName()));
		}
	}",0
"public InternetResource getResourceForKey(String key)
			throws ResourceNotFoundException {

		Matcher matcher = DATA_SEPARATOR_PATTERN.matcher(key);
		if (matcher.find()) {
			int data = matcher.start();
			key = key.substring(0, data);
		}

		return getResource(key);
	}",0
"public static String[] validateObject(ParaObject content) {
		if (content == null) {
			return new String[]{""Object cannot be null.""};
		}
		LinkedList<String> list = new LinkedList<>();
		try {
			for (ConstraintViolation<ParaObject> constraintViolation : getValidator().validate(content)) {
				String prop = ""'"".concat(constraintViolation.getPropertyPath().toString()).concat(""'"");
				list.add(prop.concat("" "").concat(constraintViolation.getMessage()));
			}
			if (content instanceof User && StringUtils.length(((User) content).getPassword()) > User.MAX_PASSWORD_LENGTH) {
				list.add(Utils.formatMessage(""{0} must not be longer than {1}."", Config._PASSWORD, User.MAX_PASSWORD_LENGTH));
			}
		} catch (Exception e) {
			logger.error(null, e);
		}
		return list.toArray(new String[]{});
	}",1
"@Override
  public void refreshRow() throws SQLException {
    checkUpdateable();
    if (onInsertRow) {
      throw new PSQLException(GT.tr(""Can''t refresh the insert row.""),
          PSQLState.INVALID_CURSOR_STATE);
    }

    if (isBeforeFirst() || isAfterLast() || castNonNull(rows, ""rows"").isEmpty()) {
      return;
    }

    StringBuilder selectSQL = new StringBuilder(""select "");

    ResultSetMetaData rsmd = getMetaData();
    PGResultSetMetaData pgmd = (PGResultSetMetaData) rsmd;
    for (int i = 1; i <= rsmd.getColumnCount(); i++) {
      if (i > 1) {
        selectSQL.append("", "");
      }
      Utils.escapeIdentifier(selectSQL, pgmd.getBaseColumnName(i));
    }
    selectSQL.append("" from "").append(onlyTable).append(tableName).append("" where "");

    List<PrimaryKey> primaryKeys = castNonNull(this.primaryKeys, ""primaryKeys"");
    int numKeys = primaryKeys.size();

    for (int i = 0; i < numKeys; i++) {

      PrimaryKey primaryKey = primaryKeys.get(i);
      Utils.escapeIdentifier(selectSQL, primaryKey.name);
      selectSQL.append("" = ?"");

      if (i < numKeys - 1) {
        selectSQL.append("" and "");
      }
    }
    String sqlText = selectSQL.toString();
    if (connection.getLogger().isLoggable(Level.FINE)) {
      connection.getLogger().log(Level.FINE, ""selecting {0}"", sqlText);
    }
    // because updateable result sets do not yet support binary transfers we must request refresh
    // with updateable result set to get field data in correct format
    PreparedStatement selectStatement = null;
    try {
      selectStatement = connection.prepareStatement(sqlText,
          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);

      for (int i = 0; i < numKeys; i++) {
        selectStatement.setObject(i + 1, primaryKeys.get(i).getValue());
      }

      PgResultSet rs = (PgResultSet) selectStatement.executeQuery();

      if (rs.next()) {
        // we know that the row is updatable as it was tested above.
        if ( rs.thisRow == null ) {
          rowBuffer = null;
        } else {
          rowBuffer = castNonNull(rs.thisRow).updateableCopy();
        }
      }

      castNonNull(rows).set(currentRow, castNonNull(rowBuffer));
      thisRow = rowBuffer;

      connection.getLogger().log(Level.FINE, ""done updates"");

      rs.close();
    } finally {
      JdbcBlackHole.close(selectStatement);
    }
  }",1
"public static void closeSubsequentFS(Path path) {
		if(path != null && FileSystems.getDefault() != path.getFileSystem()) {
			IOUtils.closeQuietly(path.getFileSystem(), null);
		}
	}",1
"public StrongAuthTracker getStrongAuthTracker() {
        return mStrongAuthTracker;
    }",0
"@SuppressLint(""SdCardPath"")
    private void startNewUpload(
        User user,
        List<String> requestedUploads,
        boolean onWifiOnly,
        boolean whileChargingOnly,
        NameCollisionPolicy nameCollisionPolicy,
        int localAction,
        boolean isCreateRemoteFolder,
        int createdBy,
        OCFile file,
        boolean disableRetries
                               ) {
        OCUpload ocUpload = new OCUpload(file, user);
        ocUpload.setFileSize(file.getFileLength());
        ocUpload.setNameCollisionPolicy(nameCollisionPolicy);
        ocUpload.setCreateRemoteFolder(isCreateRemoteFolder);
        ocUpload.setCreatedBy(createdBy);
        ocUpload.setLocalAction(localAction);
        ocUpload.setUseWifiOnly(onWifiOnly);
        ocUpload.setWhileChargingOnly(whileChargingOnly);
        ocUpload.setUploadStatus(UploadStatus.UPLOAD_IN_PROGRESS);

        UploadFileOperation newUpload = new UploadFileOperation(
            mUploadsStorageManager,
            connectivityService,
            powerManagementService,
            user,
            file,
            ocUpload,
            nameCollisionPolicy,
            localAction,
            this,
            onWifiOnly,
            whileChargingOnly,
            disableRetries,
            new FileDataStorageManager(user, getContentResolver())
        );
        newUpload.setCreatedBy(createdBy);
        if (isCreateRemoteFolder) {
            newUpload.setRemoteFolderToBeCreated();
        }
        newUpload.addDataTransferProgressListener(this);
        newUpload.addDataTransferProgressListener((FileUploaderBinder) mBinder);

        newUpload.addRenameUploadListener(this);

        Pair<String, String> putResult = mPendingUploads.putIfAbsent(
            user.getAccountName(),
            file.getRemotePath(),
            newUpload
        );

        if (putResult != null) {
            requestedUploads.add(putResult.first);

            // Save upload in database
            long id = mUploadsStorageManager.storeUpload(ocUpload);
            newUpload.setOCUploadId(id);
        }
    }",1
"void scheduleRemoveStartingWindowLocked(AppWindowToken wtoken) {
        if (mH.hasMessages(H.REMOVE_STARTING, wtoken)) {
            // Already scheduled.
            return;
        }
        if (wtoken != null && wtoken.startingWindow != null) {
            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, Debug.getCallers(1) +
                    "": Schedule remove starting "" + wtoken + (wtoken != null ?
                    "" startingWindow="" + wtoken.startingWindow : """"));
            Message m = mH.obtainMessage(H.REMOVE_STARTING, wtoken);
            mH.sendMessage(m);
        }
    }",0
"protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,
            DeserializationConfig config, BeanDescription beanDesc,
            KeyDeserializer keyDeserializer,
            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)
        throws JsonMappingException
    {
        for (Deserializers d  : _factoryConfig.deserializers()) {
            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,
                    keyDeserializer, elementTypeDeserializer, elementDeserializer);
            if (deser != null) {
                return deser;
            }
        }
        return null;
    }",0
"private <E> Registration addListener(Class<E> handler, E listener) {
        session.checkHasLock();
        List<E> list = (List<E>) listeners.computeIfAbsent(handler,
                key -> new ArrayList<>());
        list.add(listener);

        list.sort((o1, o2) -> {
            Class<?> o1Class = o1.getClass();
            Class<?> o2Class = o2.getClass();

            final ListenerPriority listenerPriority1 = o1Class
                    .getAnnotation(ListenerPriority.class);
            final ListenerPriority listenerPriority2 = o2Class
                    .getAnnotation(ListenerPriority.class);

            final int priority1 = listenerPriority1 != null
                    ? listenerPriority1.value()
                    : 0;
            final int priority2 = listenerPriority2 != null
                    ? listenerPriority2.value()
                    : 0;

            // we want to have a descending order
            return Integer.compare(priority2, priority1);
        });

        return () -> list.remove(listener);
    }",0
"public void noteAlarmStart(IIntentSender sender, int sourceUid, String tag)
            throws RemoteException;",0
"private static String subMessagePrefix(
      final String prefix, final Descriptors.FieldDescriptor field, final int index) {
    final StringBuilder result = new StringBuilder(prefix);
    if (field.isExtension()) {
      result.append('(').append(field.getFullName()).append(')');
    } else {
      result.append(field.getName());
    }
    if (index != -1) {
      result.append('[').append(index).append(']');
    }
    result.append('.');
    return result.toString();
  }",0
"private boolean maybePrunePersistedUriGrantsLocked(int uid) {
        final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.get(uid);
        if (perms == null) return false;
        if (perms.size() < MAX_PERSISTED_URI_GRANTS) return false;

        final ArrayList<UriPermission> persisted = Lists.newArrayList();
        for (UriPermission perm : perms.values()) {
            if (perm.persistedModeFlags != 0) {
                persisted.add(perm);
            }
        }

        final int trimCount = persisted.size() - MAX_PERSISTED_URI_GRANTS;
        if (trimCount <= 0) return false;

        Collections.sort(persisted, new UriPermission.PersistedTimeComparator());
        for (int i = 0; i < trimCount; i++) {
            final UriPermission perm = persisted.get(i);

            if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION,
                    ""Trimming grant created at "" + perm.persistedCreateTime);

            perm.releasePersistableModes(~0);
            removeUriPermissionIfNeededLocked(perm);
        }

        return true;
    }",0
"public static boolean postYN(String targetIn) {
        SAMLUtils.debug.message(""Inside postYN()"");
        if ((targetIn == null) || (targetIn.length() == 0)) {
            return false;
        }
        Set targets = (Set) SAMLServiceManager.
        getAttribute(SAMLConstants.POST_TO_TARGET_URLS);
        if ((targets == null) || (targets.size() == 0)) {
            return false;
        }
        URL targetUrl = null;
        try {
            targetUrl = new URL(targetIn);
        } catch (MalformedURLException me ) {
            SAMLUtils.debug.error(""SAMLUtils:postYN(): Malformed URL passed"");
            return false;
        }
        String targetInHost = targetUrl.getHost();
        int targetInPort = targetUrl.getPort();
        String targetInPath = targetUrl.getPath();
        // making target string without protocol
        String targetToCompare = new StringBuffer(targetInHost.toLowerCase())
        .append("":"").append(String.valueOf(targetInPort))
        .append(""/"").append(targetInPath).toString();
        if (targets.contains(targetToCompare)) {
            return true;
        } else {
            return false;
        }
    }",0
"@Test
  public void deleteByCriterionThatThrowsException(TestContext context) {
    Criterion criterion = new Criterion() {
      public String toString() {
        throw new RuntimeException(""missing towel"");
      }
    };
    createFoo(context).delete(FOO, criterion, context.asyncAssertFailure(fail -> {
      context.assertTrue(fail.getMessage().contains(""missing towel""));
    }));
  }",0
"@Override
    public Stream<UserSessionModel> loadUserSessionsStream(RealmModel realm, UserModel user, boolean offline, Integer firstResult, Integer maxResults) {

        String offlineStr = offlineToString(offline);

        TypedQuery<PersistentUserSessionEntity> query = paginateQuery(
                em.createNamedQuery(""findUserSessionsByUserId"", PersistentUserSessionEntity.class),
                firstResult, maxResults);

        query.setParameter(""offline"", offlineStr);
        query.setParameter(""realmId"", realm.getId());
        query.setParameter(""userId"", user.getId());

        return loadUserSessionsWithClientSessions(query, offlineStr, true);
    }",1
"ActiveAdmin getProfileOwnerLocked(@UserIdInt int userId) {
        ensureLocked();
        final ComponentName poAdminComponent = mOwners.getProfileOwnerComponent(userId);
        ActiveAdmin poAdmin = getUserData(userId).mAdminMap.get(poAdminComponent);
        return poAdmin;
    }",0
"private String targetDriverFile(String databaseType, String fileName) {
        return driverBaseDirectory
                + ""/"" + databaseType
                + ""/"" + fileName;
    }",0
"@Override
	public DOMImplementation getImplementation() {
		return doc.getImplementation();
	}",0
"public void writeLine(final String iContent) throws IOException {
    writeContent(iContent);
    out.write(OHttpUtils.EOL);
  }",0
"public int getKeyId() {
      return keyId;
    }",0
"private String clean(final String svg) {
		final String svg2 = svg.toLowerCase().replaceAll(""\\s"", """");
		if (svg2.contains(""<script>""))
			return EMPTY_SVG;
		if (svg2.contains(""</script>""))
			return EMPTY_SVG;
		if (svg2.contains(""<foreignobject""))
			return EMPTY_SVG;
		if (svg2.contains(""</foreignobject>""))
			return EMPTY_SVG;
		return svg;
	}",1
"@NonNull
        public Builder setContentTitle(CharSequence title) {
            mN.extras.putCharSequence(EXTRA_TITLE, safeCharSequence(title));
            return this;
        }",0
"@Override
    void writeIdentifierToProto(ProtoOutputStream proto, long fieldId) {
        final long token = proto.start(fieldId);
        proto.write(HASH_CODE, System.identityHashCode(this));
        proto.write(USER_ID, mUserId);
        proto.write(TITLE, intent.getComponent().flattenToShortString());
        proto.end(token);
    }",0
"private String display(Syntax targetSyntax, boolean executionContextIsolated, boolean transformationContextIsolated,
        boolean transformationContextRestricted, boolean translate) throws XWikiException
    {
        // Note: We are currently duplicating code from getRendered signature because some calling
        // code is expecting that the rendering will happen in the calling document's context and not in this
        // document's context. For example this is true for the Admin page, see
        // https://jira.xwiki.org/browse/XWIKI-4274 for more details.

        getProgress().startStep(this, ""document.progress.render"", ""Render document [{}] in syntax [{}]"",
            getDocumentReference(), targetSyntax);

        try {
            getProgress().pushLevelProgress(3, getDocumentReference());

            getProgress().startStep(getDocumentReference(), ""document.progress.render.translatedcontent"",
                ""Get translated content"");

            XWikiContext xcontext = getXWikiContext();

            XWikiDocument tdoc = translate ? getTranslatedDocument(xcontext) : this;
            String translatedContent = tdoc.getContent();

            getProgress().startStep(getDocumentReference(), ""document.progress.render.cache"",
                ""Try to get content from the cache"");

            String renderedContent = getRenderingCache().getRenderedContent(tdoc.getDocumentReferenceWithLocale(),
                translatedContent, xcontext);

            if (renderedContent == null) {
                getProgress().startStep(getDocumentReference(), ""document.progress.render.execute"", ""Execute content"");

                // Configure display
                DocumentDisplayerParameters parameters = new DocumentDisplayerParameters();
                parameters.setExecutionContextIsolated(executionContextIsolated);
                parameters.setTransformationContextIsolated(transformationContextIsolated);
                // Don't consider isRestricted() here as this could invoke a sheet.
                parameters.setTransformationContextRestricted(transformationContextRestricted);
                // Render the translated content (matching the current language) using this document's syntax.
                parameters.setContentTranslated(tdoc != this);
                parameters.setTargetSyntax(targetSyntax);

                // Execute display
                XDOM contentXDOM = getDocumentDisplayer().display(this, parameters);

                // Render the result
                renderedContent = renderXDOM(contentXDOM, targetSyntax);

                getRenderingCache().setRenderedContent(getDocumentReference(), translatedContent, renderedContent,
                    xcontext);
            }

            return renderedContent;
        } finally {
            getProgress().popLevelProgress(getDocumentReference());
            getProgress().endStep(this);
        }
    }",1
"@Override
    public void thawRotation() {
        if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,
                ""thawRotation()"")) {
            throw new SecurityException(""Requires SET_ORIENTATION permission"");
        }

        if (DEBUG_ORIENTATION) Slog.v(TAG, ""thawRotation: mRotation="" + mRotation);

        long origId = Binder.clearCallingIdentity();
        try {
            mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_FREE,
                    777); // rot not used
        } finally {
            Binder.restoreCallingIdentity(origId);
        }

        updateRotationUnchecked(false, false);
    }",0
"@Override
        public void addNewIncomingCall(PhoneAccountHandle phoneAccountHandle, Bundle extras) {
            synchronized (mLock) {
                Log.i(this, ""Adding new incoming call with phoneAccountHandle %s"",
                        phoneAccountHandle);
                if (phoneAccountHandle != null && phoneAccountHandle.getComponentName() != null) {
                    // TODO(sail): Add unit tests for adding incoming calls from a SIM call manager.
                    if (isCallerSimCallManager() && TelephonyUtil.isPstnComponentName(
                            phoneAccountHandle.getComponentName())) {
                        Log.v(this, ""Allowing call manager to add incoming call with PSTN handle"");
                    } else {
                        mAppOpsManager.checkPackage(
                                Binder.getCallingUid(),
                                phoneAccountHandle.getComponentName().getPackageName());
                        // Make sure it doesn't cross the UserHandle boundary
                        enforceUserHandleMatchesCaller(phoneAccountHandle);
                        enforcePhoneAccountIsRegisteredEnabled(phoneAccountHandle);
                    }

                    long token = Binder.clearCallingIdentity();
                    try {
                        Intent intent = new Intent(TelecomManager.ACTION_INCOMING_CALL);
                        intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE,
                            phoneAccountHandle);
                        intent.putExtra(CallIntentProcessor.KEY_IS_INCOMING_CALL, true);
                        if (extras != null) {
                            intent.putExtra(TelecomManager.EXTRA_INCOMING_CALL_EXTRAS, extras);
                        }
                        CallIntentProcessor.processIncomingCallIntent(mCallsManager, intent);
                    } finally {
                        Binder.restoreCallingIdentity(token);
                    }
                } else {
                    Log.w(this,
                            ""Null phoneAccountHandle. Ignoring request to add new incoming call"");
                }
            }
        }",1
"@Override
    public void showScreenPinningRequest(int taskId) {
        if (mKeyguardMonitor.isShowing()) {
            // Don't allow apps to trigger this from keyguard.
            return;
        }
        // Show screen pinning request, since this comes from an app, show 'no thanks', button.
        showScreenPinningRequest(taskId, true);
    }",0
"public ExecutorService getTopologyRecoveryExecutor() {
        return topologyRecoveryExecutor;
    }",0
"public static String find() {
            return BASE + TOKEN_NAME;
        }",1
"public void copyToClipboard(final Object obj) {
        if (getActivity() == null) {
            return;
        }
        getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {
                int sdk = android.os.Build.VERSION.SDK_INT;
                if (sdk < 11) {
                    android.text.ClipboardManager clipboard = (android.text.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);
                    clipboard.setText(obj.toString());
                } else {
                    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);
                    android.content.ClipData clip = ClipData.newPlainText(""Codename One"", obj.toString());
                    clipboard.setPrimaryClip(clip);
                }
            }
        });
    }",0
"@Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        if (DBG) log(""onActivityResult request:"" + requestCode + "" result:"" + resultCode);

        switch (requestCode) {
            case PIN2_REQUEST_CODE:
                Bundle extras = (intent != null) ? intent.getExtras() : null;
                if (extras != null) {
                    mPin2 = extras.getString(""pin2"");
                    processPin2(mPin2);
                } else if (resultCode != RESULT_OK) {
                    // if they cancelled, then we just cancel too.
                    if (DBG) log(""onActivityResult: cancelled."");
                    finish();
                }
                break;

            // look for the data associated with this number, and update
            // the display with it.
            case CONTACTS_PICKER_CODE:
                if (resultCode != RESULT_OK) {
                    if (DBG) log(""onActivityResult: cancelled."");
                    return;
                }
                Cursor cursor = null;
                try {
                    // check if the URI returned by the user belongs to the user
                    final int currentUser = UserHandle.getUserId(Process.myUid());
                    if (currentUser
                            != ContentProvider.getUserIdFromUri(intent.getData(), currentUser)) {
                        Log.w(LOG_TAG, ""onActivityResult: Contact data of different user, ""
                                + ""cannot access"");
                        return;
                    }
                    cursor = getContentResolver().query(intent.getData(),
                        NUM_PROJECTION, null, null, null);
                    if ((cursor == null) || (!cursor.moveToFirst())) {
                        Log.w(LOG_TAG,""onActivityResult: bad contact data, no results found."");
                        return;
                    }
                    mNameField.setText(cursor.getString(0));
                    mNumberField.setText(cursor.getString(1));
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
                break;
        }
    }",1
"public Hierarchy toRestHierarchy(EntityReference targetEntityReference, Boolean withPrettyNames)
    {
        XWikiContext xcontext = this.xcontextProvider.get();
        XWiki xwiki = xcontext.getWiki();
        Hierarchy hierarchy = new Hierarchy();
        for (EntityReference entityReference : targetEntityReference.getReversedReferenceChain()) {
            HierarchyItem hierarchyItem = new HierarchyItem();
            hierarchyItem.setName(entityReference.getName());
            hierarchyItem.setLabel(entityReference.getName());
            hierarchyItem.setType(entityReference.getType().getLowerCase());
            hierarchyItem.setUrl(xwiki.getURL(entityReference, xcontext));
            if (withPrettyNames) {
                try {
                    if (entityReference.getType() == EntityType.SPACE
                        || entityReference.getType() == EntityType.DOCUMENT) {
                        XWikiDocument document =
                            xwiki.getDocument(entityReference, xcontext).getTranslatedDocument(xcontext);
                        hierarchyItem.setLabel(document.getRenderedTitle(Syntax.PLAIN_1_0, xcontext));
                        hierarchyItem.setUrl(xwiki.getURL(document.getDocumentReferenceWithLocale(), xcontext));
                    } else if (entityReference.getType() == EntityType.WIKI) {
                        WikiDescriptor wikiDescriptor = this.wikiDescriptorManager.getById(entityReference.getName());
                        if (wikiDescriptor != null) {
                            hierarchyItem.setLabel(wikiDescriptor.getPrettyName());
                        }
                    }
                } catch (Exception e) {
                    this.logger.warn(
                        ""Failed to get the pretty name of entity [{}]. Continue using the entity name. Root cause is [{}]."",
                        entityReference, getRootCauseMessage(e));
                }
            }
            hierarchy.withItems(hierarchyItem);
        }
        return hierarchy;
    }",1
"protected Restrictor createRestrictor(Configuration config) {
        return RestrictorFactory.createRestrictor(config, logHandler);
    }",0
"public java.math.@Nullable BigDecimal getBigDecimal(@Positive int columnIndex) throws SQLException {
    return getBigDecimal(columnIndex, -1);
  }",0
"public ConnectionFactory load(String propertyFileLocation) throws IOException {
        ConnectionFactoryConfigurator.load(this, propertyFileLocation);
        return this;
    }",0
"public String getCommentTitle() {
		return commentTitle;
	}",0
"public static String getLinkTokenEmail(Context context, int bitstreamId
            , int itemID, String reqEmail, String reqName, boolean allfiles)
            throws SQLException
    {
        String base = ConfigurationManager.getProperty(""dspace.url"");

        String specialLink = (new StringBuffer()).append(base).append(
                base.endsWith(""/"") ? """" : ""/"").append(
                ""request-item"").append(""?step="" + RequestItemServlet.ENTER_TOKEN)
                .append(""&token="")
                .append(getNewToken(context, bitstreamId, itemID, reqEmail, reqName, allfiles))
                .toString();
        
        return specialLink;
    }",1
"public String getPackageForToken(IBinder token) throws RemoteException
    {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(token);
        mRemote.transact(GET_PACKAGE_FOR_TOKEN_TRANSACTION, data, reply, 0);
        reply.readException();
        String res = reply.readString();
        data.recycle();
        reply.recycle();
        return res;
    }",0
"@Override
        public void setContentLengthLong(long arg0) {
            // ignore
        }",0
"@Override
	@CacheEvict(value={CacheConstant.SYS_USERS_CACHE}, allEntries=true)
	public boolean revertLogicDeleted(List<String> userIds, SysUser updateEntity) {
		return userMapper.revertLogicDeleted(userIds, updateEntity) > 0;
	}",1
"public void write(XMLStreamWriter writer) throws XMLStreamException
    {
        writer.writeStartElement(XarModel.ELEMENT_PACKAGE);

        writer.writeStartElement(XarModel.ELEMENT_INFOS);
        writeElement(writer, XarModel.ELEMENT_INFOS_NAME, getPackageName(), true);
        writeElement(writer, XarModel.ELEMENT_INFOS_DESCRIPTION, getPackageDescription(), true);
        writeElement(writer, XarModel.ELEMENT_INFOS_LICENSE, getPackageLicense(), true);
        writeElement(writer, XarModel.ELEMENT_INFOS_AUTHOR, getPackageAuthor(), true);
        writeElement(writer, XarModel.ELEMENT_INFOS_VERSION, getPackageVersion(), true);
        writeElement(writer, XarModel.ELEMENT_INFOS_ISBACKUPPACK, String.valueOf(isPackageBackupPack()), true);
        writeElement(writer, XarModel.ELEMENT_INFOS_ISPRESERVEVERSION, String.valueOf(isPackagePreserveVersion()),
            true);
        writeElement(writer, XarModel.ELEMENT_INFOS_EXTENSIONID, getPackageExtensionId(), false);
        writer.writeEndElement();

        writer.writeStartElement(XarModel.ELEMENT_FILES);
        for (XarEntry entry : this.entries.values()) {
            writer.writeStartElement(XarModel.ELEMENT_FILES_FILE);

            writer.writeAttribute(XarModel.ATTRIBUTE_DEFAULTACTION, String.valueOf(entry.getDefaultAction()));
            writer.writeAttribute(XarModel.ATTRIBUTE_LOCALE, Objects.toString(entry.getLocale(), """"));
            if (entry.getEntryType() != null) {
                writer.writeAttribute(XarModel.ATTRIBUTE_TYPE, entry.getEntryType());
            }

            writer.writeCharacters(TOSTRING_SERIALIZER.serialize(entry));

            writer.writeEndElement();
        }
        writer.writeEndElement();
    }",0
"private String templatePath() {
        if (templatePath == null) {
            String file = HgCommand.class.getResource(""/hg.template"").getFile();
            templatePath = URLDecoder.decode(new File(file).getAbsolutePath(), StandardCharsets.UTF_8);
        }
        return templatePath;
    }",1
"public Map<String, String> handleCorsPreflightRequest(String pOrigin, String pRequestHeaders) {
        Map<String,String> ret = new HashMap<String, String>();
        if (pOrigin != null && backendManager.isOriginAllowed(pOrigin,false)) {
            // CORS is allowed, we set exactly the origin in the header, so there are no problems with authentication
            ret.put(""Access-Control-Allow-Origin"",""null"".equals(pOrigin) ? ""*"" : pOrigin);
            if (pRequestHeaders != null) {
                ret.put(""Access-Control-Allow-Headers"",pRequestHeaders);
            }
            // Fix for CORS with authentication (#104)
            ret.put(""Access-Control-Allow-Credentials"",""true"");
            // Allow for one year. Changes in access.xml are reflected directly in the  cors request itself
            ret.put(""Access-Control-Allow-Max-Age"","""" + 3600 * 24 * 365);
        }
        return ret;
    }",1
"@Override
    @SuppressWarnings(""unchecked"")
    public <T> T fromString(String content, Class<T> classOfT) {
        try (StringReader reader = new StringReader(content)) {
            JAXBContext jaxbContext = JAXBContext.newInstance(classOfT);

            XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();
            xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, true);
            XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);

            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();

            return (T) unmarshaller.unmarshal(xmlStreamReader);
        } catch (JAXBException | XMLStreamException e) {
            throw new PippoRuntimeException(e, ""Failed to deserialize content to '{}'"", classOfT.getName());
        }
    }",1
"void dumpBroadcastStatsLocked(FileDescriptor fd, PrintWriter pw, String[] args,
            int opti, boolean dumpAll, String dumpPackage) {
        if (mCurBroadcastStats == null) {
            return;
        }

        pw.println(""ACTIVITY MANAGER BROADCAST STATS STATE (dumpsys activity broadcast-stats)"");
        final long now = SystemClock.elapsedRealtime();
        if (mLastBroadcastStats != null) {
            pw.print(""  Last stats (from "");
            TimeUtils.formatDuration(mLastBroadcastStats.mStartRealtime, now, pw);
            pw.print("" to "");
            TimeUtils.formatDuration(mLastBroadcastStats.mEndRealtime, now, pw);
            pw.print("", "");
            TimeUtils.formatDuration(mLastBroadcastStats.mEndUptime
                    - mLastBroadcastStats.mStartUptime, pw);
            pw.println("" uptime):"");
            if (!mLastBroadcastStats.dumpStats(pw, ""    "", dumpPackage)) {
                pw.println(""    (nothing)"");
            }
            pw.println();
        }
        pw.print(""  Current stats (from "");
        TimeUtils.formatDuration(mCurBroadcastStats.mStartRealtime, now, pw);
        pw.print("" to now, "");
        TimeUtils.formatDuration(SystemClock.uptimeMillis()
                - mCurBroadcastStats.mStartUptime, pw);
        pw.println("" uptime):"");
        if (!mCurBroadcastStats.dumpStats(pw, ""    "", dumpPackage)) {
            pw.println(""    (nothing)"");
        }
    }",0
"@Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);

            if (DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED.equals(action) &&
                    isCurrentProfile(getSendingUserId())) {
                mUsersAllowingPrivateNotifications.clear();
                updateLockscreenNotificationSetting();
                updateNotifications();
            } else if (Intent.ACTION_DEVICE_LOCKED_CHANGED.equals(action)) {
                if (userId != mCurrentUserId && isCurrentProfile(userId)) {
                    onWorkChallengeChanged();
                }
            }
        }",0
"public void collectChanges(Consumer<NodeChange> collector) {
        boolean isAttached = isAttached();
        if (isAttached != wasAttached) {
            if (isAttached) {
                collector.accept(new NodeAttachChange(this));

                // Make all changes show up as if the node was recently attached
                clearChanges();
                forEachFeature(NodeFeature::generateChangesFromEmpty);
            } else {
                collector.accept(new NodeDetachChange(this));
            }
            wasAttached = isAttached;
        }

        if (!isAttached()) {
            return;
        }

        if (!isVisible()) {
            doCollectChanges(collector, getDisallowFeatures());
            return;
        }

        if (isInactive()) {
            if (isInitialChanges) {
                // send only required (reported) features updates
                Stream<NodeFeature> initialFeatures = Stream
                        .concat(featureSet.mappings.keySet().stream()
                                .filter(this::isReportedFeature)
                                .map(this::getFeature), getDisallowFeatures());
                doCollectChanges(collector, initialFeatures);
            } else {
                doCollectChanges(collector, getDisallowFeatures());
            }
        } else {
            doCollectChanges(collector, getInitializedFeatures());
        }
    }",1
"private String getWikiProtocol(WikiDescriptor wikiDescriptor)
    {
        // Try wiki descriptor
        Boolean secure = wikiDescriptor.isSecure();
        if (secure != null) {
            return wikiDescriptor.isSecure() == Boolean.TRUE ? ""https"" : ""http"";
        }

        // Try configuration
        String protocol = getConfiguration().getProperty(""xwiki.url.protocol"");
        if (protocol != null) {
            return protocol;
        }

        // Try main wiki
        try {
            secure = getWikiDescriptorManager().getMainWikiDescriptor().isSecure();

            if (secure != null) {
                return secure ? ""https"" : ""http"";
            }
        } catch (WikiManagerException e) {
            LOGGER.error(""Failed to get main wiki descriptor"", e);
        }

        return null;
    }",0
"public byte[] processBlock(
        byte[] in,
        int inOff,
        int inLen)
        throws InvalidCipherTextException
    {
        if (forEncryption)
        {
            if (keyPairGenerator != null)
            {
                EphemeralKeyPair ephKeyPair = keyPairGenerator.generate();

                this.privParam = ephKeyPair.getKeyPair().getPrivate();
                this.V = ephKeyPair.getEncodedPublicKey();
            }
        }
        else
        {
            if (keyParser != null)
            {
                ByteArrayInputStream bIn = new ByteArrayInputStream(in, inOff, inLen);

                try
                {
                    this.pubParam = keyParser.readKey(bIn);
                }
                catch (IOException e)
                {
                    throw new InvalidCipherTextException(""unable to recover ephemeral public key: "" + e.getMessage(), e);
                }
                catch (IllegalArgumentException e)
                {
                    throw new InvalidCipherTextException(""unable to recover ephemeral public key: "" + e.getMessage(), e);
                }

                int encLength = (inLen - bIn.available());
                this.V = Arrays.copyOfRange(in, inOff, inOff + encLength);
            }
        }

        // Compute the common value and convert to byte array. 
        agree.init(privParam);
        BigInteger z = agree.calculateAgreement(pubParam);
        byte[] Z = BigIntegers.asUnsignedByteArray(agree.getFieldSize(), z);

        // Create input to KDF.  
        if (V.length != 0)
        {
            byte[] VZ = Arrays.concatenate(V, Z);
            Arrays.fill(Z, (byte)0);
            Z = VZ;
        }

        try
        {
            // Initialise the KDF.
            KDFParameters kdfParam = new KDFParameters(Z, param.getDerivationV());
            kdf.init(kdfParam);

            return forEncryption
                ? encryptBlock(in, inOff, inLen)
                : decryptBlock(in, inOff, inLen);
        }
        finally
        {
            Arrays.fill(Z, (byte)0);
        }
    }",1
"public static AsciiString of(AsciiString name) {
        final AsciiString lowerCased = name.toLowerCase();
        final AsciiString cached = map.get(lowerCased);
        if (cached != null) {
            return cached;
        }

        return validate(lowerCased);
    }",1
"public void initialize(
        int strength,
        SecureRandom random)
    {
        if (strength < 512 || strength > 4096 || ((strength < 1024) && strength % 64 != 0) || (strength >= 1024 && strength % 1024 != 0))
        {
            throw new InvalidParameterException(""strength must be from 512 - 4096 and a multiple of 1024 above 1024"");
        }

        this.strength = strength;
        this.random = random;
        this.initialised = false;
    }",1
"private QuestionItem processResource(ResourceType resource, Path imsmanifestPath, ManifestMetadataBuilder metadataBuilder) {
		try {
			String href = resource.getHref();
			Path parentPath = imsmanifestPath.getParent();
			Path assessmentItemPath = parentPath.resolve(href);
			if(Files.notExists(assessmentItemPath)) {
				return null;
			}
			
			Path normalizedPath = assessmentItemPath.normalize();
			if(!normalizedPath.startsWith(parentPath)) {
				throw new IOException(""Invalid Item"");
			}
	
			String dir = qpoolFileStorage.generateDir();
			//storage
			File itemStorage = qpoolFileStorage.getDirectory(dir);
			File outputFile = new File(itemStorage, href);
			if(!outputFile.getParentFile().exists()) {
				outputFile.getParentFile().mkdirs();
			}
			QTI21Infos infos = getInfos(imsmanifestPath);
			convertXmlFile(assessmentItemPath, outputFile.toPath(), infos);

			QtiXmlReader qtiXmlReader = new QtiXmlReader(qtiService.jqtiExtensionManager());
			ResourceLocator fileResourceLocator = new FileResourceLocator();
			ResourceLocator inputResourceLocator = 
					ImsQTI21Resource.createResolvingResourceLocator(fileResourceLocator);
			
			URI assessmentObjectSystemId = outputFile.toURI();
			AssessmentObjectXmlLoader assessmentObjectXmlLoader = new AssessmentObjectXmlLoader(qtiXmlReader, inputResourceLocator);
			ResolvedAssessmentItem resolvedAssessmentItem = assessmentObjectXmlLoader.loadAndResolveAssessmentItem(assessmentObjectSystemId);
			AssessmentItem assessmentItem = resolvedAssessmentItem.getRootNodeLookup().extractIfSuccessful();
			
			if(!AssessmentItemChecker.checkAndCorrect(assessmentItem)) {
				qtiService.persistAssessmentObject(outputFile, assessmentItem);
			}
			
			AssessmentItemMetadata metadata = new AssessmentItemMetadata(metadataBuilder);

			String editor = null;
			String editorVersion = null;
			if(StringHelper.containsNonWhitespace(assessmentItem.getToolName())) {
				editor = assessmentItem.getToolName();
			}
			if(StringHelper.containsNonWhitespace(assessmentItem.getToolVersion())) {
				editorVersion = assessmentItem.getToolVersion();
			}

			QuestionItemImpl qitem = processItem(assessmentItem, null, href,
					editor, editorVersion, dir, metadata);

			//create manifest
			ManifestBuilder manifest = ManifestBuilder.createAssessmentItemBuilder();
			String itemId = IdentifierGenerator.newAsIdentifier(""item"").toString();
			ResourceType importedResource = manifest.appendAssessmentItem(itemId, href);
			ManifestMetadataBuilder importedMetadataBuilder = manifest.getMetadataBuilder(importedResource, true);
			importedMetadataBuilder.setMetadata(metadataBuilder.getMetadata());
			manifest.write(new File(itemStorage, ""imsmanifest.xml""));
			
			//process material
			List<String> materials = ImportExportHelper.getMaterials(assessmentItem);
			for(String material:materials) {
				if(material.indexOf(""://"") < 0) {// material can be an external URL
					Path materialFile = assessmentItemPath.getParent().resolve(material);
					Path normalizedMaterialPath = materialFile.normalize();
					if(!normalizedMaterialPath.startsWith(parentPath)) {
						throw new IOException(""Invalid Item"");
					}
					PathUtils.copyFileToDir(materialFile, outputFile.getParentFile(), material);
				}
			}
			return qitem;
		} catch (Exception e) {
			log.error("""", e);
			return null;
		}
	}",1
"public List<DocumentLink> findDocumentLinks(DOMDocument document) {
		return documentLink.findDocumentLinks(document);
	}",0
"OpenSSLSessionImpl setupSession(long sslSessionNativePointer, long sslNativePointer,
            final OpenSSLSessionImpl sessionToReuse, String hostname, int port,
            boolean handshakeCompleted) throws IOException {
        OpenSSLSessionImpl sslSession = null;
        if (sessionToReuse != null && NativeCrypto.SSL_session_reused(sslNativePointer)) {
            sslSession = sessionToReuse;
            sslSession.lastAccessedTime = System.currentTimeMillis();
            NativeCrypto.SSL_SESSION_free(sslSessionNativePointer);
        } else {
            if (!getEnableSessionCreation()) {
                // Should have been prevented by
                // NativeCrypto.SSL_set_session_creation_enabled
                throw new IllegalStateException(""SSL Session may not be created"");
            }
            X509Certificate[] localCertificates = createCertChain(NativeCrypto
                    .SSL_get_certificate(sslNativePointer));
            X509Certificate[] peerCertificates = createCertChain(NativeCrypto
                    .SSL_get_peer_cert_chain(sslNativePointer));
            sslSession = new OpenSSLSessionImpl(sslSessionNativePointer, localCertificates,
                    peerCertificates, hostname, port, getSessionContext());
            // if not, putSession later in handshakeCompleted() callback
            if (handshakeCompleted) {
                getSessionContext().putSession(sslSession);
            }
        }
        return sslSession;
    }",1
"public static boolean contains(File[] dirs, File file) {
        for (File dir : dirs) {
            if (contains(dir, file)) {
                return true;
            }
        }
        return false;
    }",0
"public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, UrlArgument repositoryUrl) {
        CommandLine hg = createCommandLine(""hg"")
                .withArgs(""clone"")
                .withArg(branchArg())
                .withArg(""--"")
                .withArg(repositoryUrl)
                .withArg(workingDir.getAbsolutePath())
                .withNonArgSecrets(secrets)
                .withEncoding(""UTF-8"");
        return execute(hg, outputStreamConsumer);
    }",1
"@Override
	public <A extends Output<E>, E extends Exception> void append(A a, CharSequence csq, int start, int end) throws E {
		csq = csq == null ? ""null"" : csq;
		for (int i = start; i < end; i++) {
			char c = csq.charAt(i);
			switch (c) {
				case '""' -> { // 34
					a.append(csq, start, i);
					start = i + 1;
					a.append(QUOT);
				}
				case '&' -> { // 38
					a.append(csq, start, i);
					start = i + 1;
					a.append(AMP);

				}
				case '\'' -> { // 39
					a.append(csq, start, i);
					start = i + 1;
					a.append(APOS);
				}
				case '<' -> { // 60
					a.append(csq, start, i);
					start = i + 1;
					a.append(LT);
				}
				case '=' -> { // 61
					a.append(csq, start, i);
					start = i + 1;
					a.append(EQUAL);
				}
				case '>' -> { // 62
					a.append(csq, start, i);
					start = i + 1;
					a.append(GT);
				}
				case '`' -> { // 96
					a.append(csq, start, i);
					start = i + 1;
					a.append(BACK_TICK);
				}
			}
		}
		a.append(csq, start, end);

	}",1
"@Override
    public void printXMLStartElement(String name, String[][] attributes)
    {
        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {
            handleSpaceWhenStartElement();
            super.printXMLStartElement(name, cleanAttributes(name, attributes));
        }
    }",1
"static void invokeMethod(Component instance, Class<?> clazz,
            String methodName, JsonArray args, int promiseId, boolean inert) {
        assert instance != null;
        Optional<Method> method = findMethod(instance, clazz, methodName);
        if (method.isPresent()) {
            invokeMethod(instance, method.get(), args, promiseId, inert);
        } else if (instance instanceof Composite) {
            Component compositeContent = ((Composite<?>) instance).getContent();
            invokeMethod(compositeContent, compositeContent.getClass(),
                    methodName, args, promiseId, inert);
        } else {
            getLogger().error(String.format(
                    ""Faulty method invocation. Neither class '%s' ""
                            + ""nor its super classes declare event handler method '%s'"",
                    instance.getClass().getName(), methodName));
            throw new IllegalStateException(""Faulty method invocation"");
        }
    }",1
"@Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        if (MenuDoubleTabUtil.shouldIgnoreTap()) {
            return false;
        } else if (conversation == null) {
            return super.onOptionsItemSelected(item);
        }
        switch (item.getItemId()) {
            case R.id.encryption_choice_axolotl:
            case R.id.encryption_choice_pgp:
            case R.id.encryption_choice_none:
                handleEncryptionSelection(item);
                break;
            case R.id.attach_choose_picture:
            case R.id.attach_take_picture:
            case R.id.attach_record_video:
            case R.id.attach_choose_file:
            case R.id.attach_record_voice:
            case R.id.attach_location:
                handleAttachmentSelection(item);
                break;
            case R.id.action_archive:
                activity.xmppConnectionService.archiveConversation(conversation);
                break;
            case R.id.action_contact_details:
                activity.switchToContactDetails(conversation.getContact());
                break;
            case R.id.action_muc_details:
                Intent intent = new Intent(getActivity(), ConferenceDetailsActivity.class);
                intent.setAction(ConferenceDetailsActivity.ACTION_VIEW_MUC);
                intent.putExtra(""uuid"", conversation.getUuid());
                startActivity(intent);
                break;
            case R.id.action_invite:
                startActivityForResult(ChooseContactActivity.create(activity, conversation), REQUEST_INVITE_TO_CONVERSATION);
                break;
            case R.id.action_clear_history:
                clearHistoryDialog(conversation);
                break;
            case R.id.action_mute:
                muteConversationDialog(conversation);
                break;
            case R.id.action_unmute:
                unmuteConversation(conversation);
                break;
            case R.id.action_block:
            case R.id.action_unblock:
                final Activity activity = getActivity();
                if (activity instanceof XmppActivity) {
                    BlockContactDialog.show((XmppActivity) activity, conversation);
                }
                break;
            default:
                break;
        }
        return super.onOptionsItemSelected(item);
    }",0
"@Override
    public int searchResultCount(Context context, String groupIdentifier) throws SQLException {
        int result = 0;
        UUID uuid = UUIDUtils.fromString(groupIdentifier);
        if (uuid == null) {
            //Search by group name
            result = groupDAO.countByNameLike(context, groupIdentifier);
        } else {
            //Search by group id
            Group group = find(context, uuid);
            if (group != null) {
                result = 1;
            }
        }

        return result;
    }",0
"BDSStateMap getBDSState()
    {
        return bdsState;
    }",0
"public static void createFeature(FF4j ff4j, HttpServletRequest req) {
        // uid
        final String featureId = req.getParameter(FEATID);
        if (featureId != null && !featureId.isEmpty()) {
            Feature fp = new Feature(featureId, false);

            // Description
            final String featureDesc = req.getParameter(DESCRIPTION);
            if (null != featureDesc && !featureDesc.isEmpty()) {
                fp.setDescription(featureDesc);
            }

            // GroupName
            final String groupName = req.getParameter(GROUPNAME);
            if (null != groupName && !groupName.isEmpty()) {
                fp.setGroup(groupName);
            }

            // Strategy
            final String strategy = req.getParameter(STRATEGY);
            if (null != strategy && !strategy.isEmpty()) {
                try {
                    Class<?> strategyClass = Class.forName(strategy);
                    if (!FlippingStrategy.class.isAssignableFrom(strategyClass)) {
                        throw new IllegalArgumentException(""Cannot create flipstrategy: <"" + strategy + ""> invalid type"");
                    }
                    FlippingStrategy fstrategy = (FlippingStrategy) strategyClass.newInstance();

                    final String strategyParams = req.getParameter(STRATEGY_INIT);
                    if (null != strategyParams && !strategyParams.isEmpty()) {
                        Map<String, String> initParams = new HashMap<String, String>();
                        String[] params = strategyParams.split("";"");
                        for (String currentP : params) {
                            String[] cur = currentP.split(""="");
                            if (cur.length < 2) {
                                throw new IllegalArgumentException(""Invalid Syntax : param1=val1,val2;param2=val3,val4"");
                            }
                            initParams.put(cur[0], cur[1]);
                        }
                        fstrategy.init(featureId, initParams);
                    }
                    fp.setFlippingStrategy(fstrategy);

                } catch (ClassNotFoundException e) {
                    throw new IllegalArgumentException(""Cannot find strategy class"", e);
                } catch (InstantiationException e) {
                    throw new IllegalArgumentException(""Cannot instantiate strategy"", e);
                } catch (IllegalAccessException e) {
                    throw new IllegalArgumentException(""Cannot instantiate : no public constructor"", e);
                }
            }

            // Permissions
            final String permission = req.getParameter(PERMISSION);
            if (null != permission && PERMISSION_RESTRICTED.equals(permission)) {
                @SuppressWarnings(""unchecked"")
                Map<String, Object> parameters = req.getParameterMap();
                Set<String> permissions = new HashSet<String>();
                for (String key : parameters.keySet()) {
                    if (key.startsWith(PREFIX_CHECKBOX)) {
                        permissions.add(key.replace(PREFIX_CHECKBOX, """"));
                    }
                }
                fp.setPermissions(permissions);
            }

            // Creation
            ff4j.getFeatureStore().create(fp);
            LOGGER.info(featureId + "" has been created"");
        }
    }",1
"@Override
    public boolean action(XWikiContext context) throws XWikiException
    {
        XWiki xwiki = context.getWiki();
        XWikiRequest request = context.getRequest();
        XWikiResponse response = context.getResponse();

        // Limit template overrides with xpage to allowed templates.
        if (!ALLOWED_TEMPLATES.contains(Utils.getPage(context.getRequest(), REGISTER))) {
            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_ACCESS_DENIED,
                String.format(""Forbidden template override with 'xpage' in [%s] action."", REGISTER));
        }

        String register = request.getParameter(REGISTER);
        if (register != null && register.equals(""1"")) {
            // CSRF prevention
            if (!csrfTokenCheck(context)) {
                return false;
            }
            // Let's verify that the user submitted the right CAPTCHA (if required).
            if (!verifyCaptcha(context, xwiki)) {
                return false;
            }

            int useemail = xwiki.getXWikiPreferenceAsInt(""use_email_verification"", 0, context);
            int result;
            if (useemail == 1) {
                result = xwiki.createUser(true, ""edit"", context);
            } else {
                result = xwiki.createUser(context);
            }
            getCurrentScriptContext().setAttribute(""reg"", Integer.valueOf(result), ScriptContext.ENGINE_SCOPE);

            // Redirect if a redirection parameter is passed.
            String redirect = Utils.getRedirect(request, null);
            if (redirect == null) {
                return true;
            } else {
                sendRedirect(response, redirect);
                return false;
            }
        }

        return true;
    }",1
"private String userReferenceToString(DocumentReference userReference)
    {
        String userString;

        if (userReference != null) {
            userString = getCompactWikiEntityReferenceSerializer().serialize(userReference, getDocumentReference());
        } else {
            userString = XWikiRightService.GUEST_USER_FULLNAME;
        }

        return userString;
    }",0
"@Override
    public SessionData decode(String data) {
        byte[] bytes = Base64.getDecoder().decode(data);
        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
             FilteringObjectInputStream objectInputStream = new FilteringObjectInputStream(inputStream)) {
            return (SessionData) objectInputStream.readObject();
        } catch (IOException | ClassNotFoundException e) {
            throw new PippoRuntimeException(e, ""Cannot deserialize session. A new one will be created."");
        }
    }",1
"@SuppressWarnings(""unchecked"")
	public ActionForward unspecified(ActionMapping rMapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
	throws Exception {
		ActionErrors errors = new ActionErrors();
		//Email parameters
		HttpSession session = request.getSession();
		Host currentHost = hostWebAPI.getCurrentHost(request);
		User currentUser = (User) session.getAttribute(WebKeys.CMS_USER);
		
		String method = request.getMethod();
		String errorURL = request.getParameter(""errorURL"");		
		errorURL = (!UtilMethods.isSet(errorURL) ? request.getHeader(""referer"") : errorURL);
		if(errorURL.indexOf(""?"") > -1)
		{
			errorURL = errorURL.substring(0,errorURL.lastIndexOf(""?""));
		}
		String x = request.getRequestURI();
		if(request.getParameterMap().size() <2){
			
			return null;
			
		}

		//Checking for captcha
		boolean useCaptcha = Config.getBooleanProperty(""FORCE_CAPTCHA"",true);
		if(!useCaptcha){
			useCaptcha = new Boolean(request.getParameter(""useCaptcha"")).booleanValue();
		}
		
		String captcha = request.getParameter(""captcha"");
		if (useCaptcha) {
		    Captcha captchaObj = (Captcha) session.getAttribute(Captcha.NAME);
            String captchaSession=captchaObj!=null ? captchaObj.getAnswer() : null;
            
			if(captcha ==null && Config.getBooleanProperty(""FORCE_CAPTCHA"",true)){
				response.getWriter().write(""Captcha is required to submit this form ( FORCE_CAPTCHA=true ).<br>To change this, edit the dotmarketing-config.properties and set FORCE_CAPTCHA=false"");
				return null;
			}
			
			
			if(!UtilMethods.isSet(captcha) || !UtilMethods.isSet(captchaSession) || !captcha.equals(captchaSession)) {
				errors.add(Globals.ERROR_KEY, new ActionMessage(""message.contentlet.required"", ""Validation Image""));
				request.setAttribute(Globals.ERROR_KEY, errors);
				session.setAttribute(Globals.ERROR_KEY, errors);
				String queryString = request.getQueryString();
				String invalidCaptchaURL = request.getParameter(""invalidCaptchaReturnUrl"");
				if(!UtilMethods.isSet(invalidCaptchaURL)) {
					invalidCaptchaURL = errorURL;
				}
				invalidCaptchaURL = invalidCaptchaURL.replaceAll(""\\s"", "" "");
				ActionForward af = new ActionForward();
					af.setRedirect(true);
					if (UtilMethods.isSet(queryString)) {
						
						af.setPath(invalidCaptchaURL + ""?"" + queryString + ""&error=Validation-Image"");
					} else {
						af.setPath(invalidCaptchaURL + ""?error=Validation-Image"");
					}
			

				
				return af;
			}
			
		}



		Map<String, Object> parameters = null;
		if (request instanceof UploadServletRequest)
		{
			UploadServletRequest uploadReq = (UploadServletRequest) request;
			parameters = new HashMap<String, Object> (uploadReq.getParameterMap());
			for (Entry<String, Object> entry : parameters.entrySet())
			{
				if(entry.getKey().toLowerCase().indexOf(""file"") > -1 && !entry.getKey().equals(""attachFiles""))
				{
					parameters.put(entry.getKey(), uploadReq.getFile(entry.getKey()));
				}
			}
		}
		else
		{
			parameters = new HashMap<String, Object> (request.getParameterMap());
		}

		Set<String> toValidate = new java.util.HashSet<String>(parameters.keySet());

		//Enhancing the ignored parameters not to be send in the email
		String ignoredParameters = (String) EmailFactory.getMapValue(""ignore"", parameters);
		if(ignoredParameters == null)
		{
			ignoredParameters = """";
		}
		ignoredParameters += "":useCaptcha:captcha:invalidCaptchaReturnUrl:return:returnUrl:errorURL:ignore:to:from:cc:bcc:dispatch:order:prettyOrder:autoReplyTo:autoReplyFrom:autoReplyText:autoReplySubject:"";
		parameters.put(""ignore"", ignoredParameters);

		// getting categories from inodes
		// getting parent category name and child categories name
		// and replacing the ""categories"" parameter
		String categories = """";
		String[] categoriesArray = request.getParameterValues(""categories"");
		if (categoriesArray != null) {
			HashMap hashCategories = new HashMap<String, String>();
			for (int i = 0; i < categoriesArray.length; i++) {
				Category node = (Category) InodeFactory.getInode(categoriesArray[i], Category.class);
				Category parent = (Category) InodeFactory.getParentOfClass(node, Category.class);
				String parentCategoryName = parent.getCategoryName();

				if (hashCategories.containsKey(parentCategoryName)) {
					String childCategoryName = (String) hashCategories.get(parentCategoryName);
					if (UtilMethods.isSet(childCategoryName)) {
						childCategoryName += "", "";
					}
					childCategoryName += node.getCategoryName();
					hashCategories.put(parentCategoryName, childCategoryName);
				}
				else {
					hashCategories.put(parentCategoryName, node.getCategoryName());
				}
			}

			Set<String> keySet = hashCategories.keySet();
			for (String stringKey: keySet) {

				if (UtilMethods.isSet(categories)) {
					categories += ""; ""; 
				}
				categories += stringKey + "" : "" + (String) hashCategories.get(stringKey);
				parameters.put(stringKey, (String) hashCategories.get(stringKey));
			}
			parameters.remove(""categories"");
		}

		WebForm webForm = new WebForm();
		try
		{
			/*validation parameter should ignore the returnUrl and erroURL field in the spam check*/
			String[] removeParams = ignoredParameters.split("":"");
			for(String param : removeParams){
				toValidate.remove(param);
			}
			
			
			
			parameters.put(""request"", request);
			parameters.put(""response"", response);
			
			//Sending the email			
			webForm = EmailFactory.sendParameterizedEmail(parameters, toValidate, currentHost, currentUser);
			
			
			
			webForm.setCategories(categories);

			if(UtilMethods.isSet(request.getParameter(""createAccount"")) && request.getParameter(""createAccount"").equals(""true""))
			{
				//if we create account set to true we create a user account and add user comments.
				createAccount(webForm, request);
				try{
    				String userInode = webForm.getUserInode();
    				String customFields = webForm.getCustomFields();
    				customFields += "" User Inode = "" + String.valueOf(userInode) + "" | "";
    				webForm.setCustomFields(customFields);
				}
				catch(Exception e){
				    
				}

			}

			
            if(UtilMethods.isSet(webForm.getFormType())){
                HibernateUtil.saveOrUpdate(webForm);
            }
			
			
			if (request.getParameter(""return"") != null)
			{
				ActionForward af = new ActionForward(SecurityUtils.stripReferer(request, request.getParameter(""return"")));
				af.setRedirect(true);
				return af;
			}
			else if (request.getParameter(""returnUrl"") != null)
			{
				ActionForward af = new ActionForward(SecurityUtils.stripReferer(request, request.getParameter(""returnUrl"")));
				af.setRedirect(true);
				return af;
			}
			else
			{
				return rMapping.findForward(""thankYouPage"");
			}

        }
        catch (DotRuntimeException e)
        {
            errors.add(Globals.ERROR_KEY, new ActionMessage(""error.processing.your.email""));
            request.getSession().setAttribute(Globals.ERROR_KEY, errors);

            String queryString = request.getQueryString();

            if (queryString == null) {
                java.util.Enumeration<String> parameterNames = request.getParameterNames();
                queryString = """";
                String parameterName;
                for (; parameterNames.hasMoreElements();) {
                    parameterName = parameterNames.nextElement();

                    if (0 < queryString.length()) {
                        queryString = queryString + ""&"" + parameterName + ""="" + UtilMethods.encodeURL(request.getParameter(parameterName));
                    } else {
                        queryString = parameterName + ""="" + UtilMethods.encodeURL(request.getParameter(parameterName));
                    }
                }
            }

            ActionForward af;
            if (UtilMethods.isSet(queryString)) {
                af = new ActionForward(SecurityUtils.stripReferer(request, errorURL + ""?"" + queryString));
            } else {
                af = new ActionForward(SecurityUtils.stripReferer(request, errorURL));
            }

            af.setRedirect(true);

            return af;
        }
		

	}",1
"@Override
    protected XDOM extractTitleFromContent(DocumentModelBridge document, DocumentDisplayerParameters parameters)
    {
        // Note: Ideally we should apply transformations on the document's returned XDOM here since macros could
        // generate headings for example or some other transformations could modify headings. However we don't do this
        // at the moment since it would be too costly to do so. In the future we will even probably remove the feature
        // of generating the title from the content.
        List<HeaderBlock> blocks =
            document.getXDOM().getBlocks(new ClassBlockMatcher(HeaderBlock.class), Block.Axes.DESCENDANT);
        if (!blocks.isEmpty()) {
            HeaderBlock heading = blocks.get(0);
            // Check the heading depth after which we should return null if no heading was found.
            if (heading.getLevel().getAsInt() <= displayConfiguration.getTitleHeadingDepth()) {
                XDOM headingXDOM = new XDOM(Collections.<Block> singletonList(heading));
                try {
                    TransformationContext txContext =
                        new TransformationContext(headingXDOM, document.getSyntax(),
                            parameters.isTransformationContextRestricted() || document.isRestricted());
                    txContext.setTargetSyntax(parameters.getTargetSyntax());
                    transformationManager.performTransformations(headingXDOM, txContext);

                    Block headingBlock = headingXDOM.getChildren().size() > 0 ? headingXDOM.getChildren().get(0) : null;
                    if (headingBlock instanceof HeaderBlock) {
                        return new XDOM(headingBlock.getChildren());
                    }
                } catch (TransformationException e) {
                    getLogger().warn(""Failed to extract title from document content."");
                }
            }
        }
        return null;
    }",1
"@Override
    public void printXMLElement(String name, String[][] attributes)
    {
        if (this.htmlElementSanitizer == null || this.htmlElementSanitizer.isElementAllowed(name)) {
            handleSpaceWhenStartElement();
            super.printXMLElement(name, cleanAttributes(name, attributes));
        }
    }",1
"public static Configuration getConfiguration(AMWTemplateExceptionHandler templateExceptionHandler) {
        Configuration cfg = new Configuration(Configuration.VERSION_2_3_22);
        // prevents Server-Side Template Injection
        cfg.setNewBuiltinClassResolver(TemplateClassResolver.ALLOWS_NOTHING_RESOLVER);
        cfg.setAPIBuiltinEnabled(false);
        cfg.setTemplateExceptionHandler(templateExceptionHandler);
        cfg.setShowErrorTips(false);
        cfg.setLogTemplateExceptions(false);
        // because otherwise freemarker renders numbers by default like 1,000,000 http://freemarker.org/docs/app_faq.html#faq_number_grouping
        cfg.setNumberFormat(""0.######"");
        return cfg;
    }",1
"public TMap readMapBegin() throws TException {
    byte keyType = readByte();
    byte valueType = readByte();
    int size = readI32();
    ensureMapHasEnough(size, keyType, valueType);
    return new TMap(keyType, valueType, size);
  }",1
"public boolean isKeyguardSecure() {
        if (mStatusBarKeyguardViewManager == null) {
            // startKeyguard() hasn't been called yet, so we don't know.
            // Make sure anything that needs to know isKeyguardSecure() checks and re-checks this
            // value onVisibilityChanged().
            Slog.w(TAG, ""isKeyguardSecure() called before startKeyguard(), returning false"",
                    new Throwable());
            return false;
        }
        return mStatusBarKeyguardViewManager.isSecure();
    }",0
"@Override
    protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {
        if (path == null || !path.startsWith(""/"")) {
            throw new MalformedURLException(path);
        }

        try {
            path = UriPath.canonical(path);

            final String addedPath = addPaths(baseResource, path);

            ExternalResource resource = new ExternalResource(addedPath);

            DirectoryTraversal.protectAgainstForExternal(resource.getPath());

            if (resource.exists() && resource.isDirectory()) {
                if (welcomeFile != null) {
                    resource = new ExternalResource(addPaths(resource.getPath(), welcomeFile));
                } else {
                    //  No welcome file configured, serve nothing since it's a directory
                    resource = null;
                }
            }

            return (resource != null && resource.exists()) ? resource : null;
        } catch (DirectoryTraversal.DirectoryTraversalDetection directoryTraversalDetection) {
            throw directoryTraversalDetection;
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(e.getClass().getSimpleName() + "" when trying to get resource. "" + e.getMessage());
            }
        }
        return null;
    }",1
"private static void verifyPeerName(PGStream stream, Properties info, SSLSocket newConnection)
      throws PSQLException {
    HostnameVerifier hvn;
    String sslhostnameverifier = PGProperty.SSL_HOSTNAME_VERIFIER.get(info);
    if (sslhostnameverifier == null) {
      hvn = PGjdbcHostnameVerifier.INSTANCE;
      sslhostnameverifier = ""PgjdbcHostnameVerifier"";
    } else {
      try {
        hvn = instantiate(HostnameVerifier.class, sslhostnameverifier, info, false, null);
      } catch (Exception e) {
        throw new PSQLException(
            GT.tr(""The HostnameVerifier class provided {0} could not be instantiated."",
                sslhostnameverifier),
            PSQLState.CONNECTION_FAILURE, e);
      }
    }

    if (hvn.verify(stream.getHostSpec().getHost(), newConnection.getSession())) {
      return;
    }

    throw new PSQLException(
        GT.tr(""The hostname {0} could not be verified by hostnameverifier {1}."",
            stream.getHostSpec().getHost(), sslhostnameverifier),
        PSQLState.CONNECTION_FAILURE);
  }",1
"@MediumTest
    @Test
    public void testSendConnectionEventNull() throws Exception {
        IdPair ids = startAndMakeActiveIncomingCall(""650-555-1212"",
                mPhoneAccountA0.getAccountHandle(), mConnectionServiceFixtureA);
        assertEquals(Call.STATE_ACTIVE, mInCallServiceFixtureX.getCall(ids.mCallId).getState());
        mConnectionServiceFixtureA.sendConnectionEvent(ids.mConnectionId, TEST_EVENT, null);
        verify(mInCallServiceFixtureX.getTestDouble(), timeout(TEST_TIMEOUT))
                .onConnectionEvent(ids.mCallId, TEST_EVENT, null);
    }",0
"void beginBackup() {
            if (DEBUG_BACKUP_TRACE) {
                clearBackupTrace();
                StringBuilder b = new StringBuilder(256);
                b.append(""beginBackup: ["");
                for (BackupRequest req : mOriginalQueue) {
                    b.append(' ');
                    b.append(req.packageName);
                }
                b.append("" ]"");
                addBackupTrace(b.toString());
            }

            mAgentBinder = null;
            mStatus = BackupTransport.TRANSPORT_OK;

            // Sanity check: if the queue is empty we have no work to do.
            if (mOriginalQueue.isEmpty()) {
                Slog.w(TAG, ""Backup begun with an empty queue - nothing to do."");
                addBackupTrace(""queue empty at begin"");
                executeNextState(BackupState.FINAL);
                return;
            }

            // We need to retain the original queue contents in case of transport
            // failure, but we want a working copy that we can manipulate along
            // the way.
            mQueue = (ArrayList<BackupRequest>) mOriginalQueue.clone();

            // The app metadata pseudopackage might also be represented in the
            // backup queue if apps have been added/removed since the last time
            // we performed a backup.  Drop it from the working queue now that
            // we're committed to evaluating it for backup regardless.
            for (int i = 0; i < mQueue.size(); i++) {
                if (PACKAGE_MANAGER_SENTINEL.equals(mQueue.get(i).packageName)) {
                    if (MORE_DEBUG) {
                        Slog.i(TAG, ""Metadata in queue; eliding"");
                    }
                    mQueue.remove(i);
                    break;
                }
            }

            if (DEBUG) Slog.v(TAG, ""Beginning backup of "" + mQueue.size() + "" targets"");

            File pmState = new File(mStateDir, PACKAGE_MANAGER_SENTINEL);
            try {
                final String transportName = mTransport.transportDirName();
                EventLog.writeEvent(EventLogTags.BACKUP_START, transportName);

                // If we haven't stored package manager metadata yet, we must init the transport.
                if (mStatus == BackupTransport.TRANSPORT_OK && pmState.length() <= 0) {
                    Slog.i(TAG, ""Initializing (wiping) backup state and transport storage"");
                    addBackupTrace(""initializing transport "" + transportName);
                    resetBackupState(mStateDir);  // Just to make sure.
                    mStatus = mTransport.initializeDevice();

                    addBackupTrace(""transport.initializeDevice() == "" + mStatus);
                    if (mStatus == BackupTransport.TRANSPORT_OK) {
                        EventLog.writeEvent(EventLogTags.BACKUP_INITIALIZE);
                    } else {
                        EventLog.writeEvent(EventLogTags.BACKUP_TRANSPORT_FAILURE, ""(initialize)"");
                        Slog.e(TAG, ""Transport error in initializeDevice()"");
                    }
                }

                // The package manager doesn't have a proper <application> etc, but since
                // it's running here in the system process we can just set up its agent
                // directly and use a synthetic BackupRequest.  We always run this pass
                // because it's cheap and this way we guarantee that we don't get out of
                // step even if we're selecting among various transports at run time.
                if (mStatus == BackupTransport.TRANSPORT_OK) {
                    PackageManagerBackupAgent pmAgent = new PackageManagerBackupAgent(
                            mPackageManager);
                    mStatus = invokeAgentForBackup(PACKAGE_MANAGER_SENTINEL,
                            IBackupAgent.Stub.asInterface(pmAgent.onBind()), mTransport);
                    addBackupTrace(""PMBA invoke: "" + mStatus);

                    // Because the PMBA is a local instance, it has already executed its
                    // backup callback and returned.  Blow away the lingering (spurious)
                    // pending timeout message for it.
                    mBackupHandler.removeMessages(MSG_TIMEOUT);
                }

                if (mStatus == BackupTransport.TRANSPORT_NOT_INITIALIZED) {
                    // The backend reports that our dataset has been wiped.  Note this in
                    // the event log; the no-success code below will reset the backup
                    // state as well.
                    EventLog.writeEvent(EventLogTags.BACKUP_RESET, mTransport.transportDirName());
                }
            } catch (Exception e) {
                Slog.e(TAG, ""Error in backup thread"", e);
                addBackupTrace(""Exception in backup thread: "" + e);
                mStatus = BackupTransport.TRANSPORT_ERROR;
            } finally {
                // If we've succeeded so far, invokeAgentForBackup() will have run the PM
                // metadata and its completion/timeout callback will continue the state
                // machine chain.  If it failed that won't happen; we handle that now.
                addBackupTrace(""exiting prelim: "" + mStatus);
                if (mStatus != BackupTransport.TRANSPORT_OK) {
                    // if things went wrong at this point, we need to
                    // restage everything and try again later.
                    resetBackupState(mStateDir);  // Just to make sure.
                    executeNextState(BackupState.FINAL);
                }
            }
        }",0
"@RequestMapping(value = STATUS_URL + ""/{referenceId:\\S+}.json"", method = RequestMethod.GET)
    public final void getStatus(
            @PathVariable final String referenceId,
            final HttpServletRequest statusRequest,
            final HttpServletResponse statusResponse) {
        MDC.put(Processor.MDC_JOB_ID_KEY, referenceId);
        setNoCache(statusResponse);
        try {
            PrintJobStatus status = this.jobManager.getStatus(referenceId);

            setContentType(statusResponse);
            try (PrintWriter writer = statusResponse.getWriter()) {
                JSONWriter json = new JSONWriter(writer);
                json.object();
                {
                    json.key(JSON_DONE).value(status.isDone());
                    json.key(JSON_STATUS).value(status.getStatus().toString().toLowerCase());
                    json.key(JSON_ELAPSED_TIME).value(status.getElapsedTime());
                    json.key(JSON_WAITING_TIME).value(status.getWaitingTime());
                    if (!StringUtils.isEmpty(status.getError())) {
                        json.key(JSON_ERROR).value(status.getError());
                    }

                    addDownloadLinkToJson(statusRequest, referenceId, json);
                }
                json.endObject();
            }
        } catch (JSONException | IOException e) {
            throw ExceptionUtils.getRuntimeException(e);
        } catch (NoSuchReferenceException e) {
            error(statusResponse, e.getMessage(), HttpStatus.NOT_FOUND);
        }
    }",1
"public static Document parse(LSInput source)
    {
        try {
            LSParser p = LS_IMPL.createLSParser(DOMImplementationLS.MODE_SYNCHRONOUS, null);
            // Disable validation, since this takes a lot of time and causes unneeded network traffic
            p.getDomConfig().setParameter(""validate"", false);
            if (p.getDomConfig().canSetParameter(DISABLE_DTD_PARAM, false)) {
                p.getDomConfig().setParameter(DISABLE_DTD_PARAM, false);
            }

            // Avoid XML eXternal Entity injection (XXE)
            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false)) {
                p.getDomConfig().setParameter(DISABLE_EXTERNAL_DOCTYPE_DECLARATION, false);
            }
            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false)) {
                p.getDomConfig().setParameter(DISABLE_EXTERNAL_PARAMETER_ENTITIES, false);
            }
            if (p.getDomConfig().canSetParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false)) {
                p.getDomConfig().setParameter(DISABLE_EXTERNAL_GENERAL_ENTITIES, false);
            }
            return p.parse(source);
        } catch (Exception ex) {
            LOGGER.warn(""Cannot parse XML document: [{}]"", ex.getMessage());
            return null;
        }
    }",1
"private final boolean checkHoldingPermissionsLocked(
            IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, final int modeFlags) {
        if (DEBUG_URI_PERMISSION) Slog.v(TAG,
                ""checkHoldingPermissionsLocked: uri="" + grantUri + "" uid="" + uid);
        if (UserHandle.getUserId(uid) != grantUri.sourceUserId) {
            if (ActivityManager.checkComponentPermission(INTERACT_ACROSS_USERS, uid, -1, true)
                    != PERMISSION_GRANTED) {
                return false;
            }
        }
        return checkHoldingPermissionsInternalLocked(pm, pi, grantUri, uid, modeFlags, true);
    }",0
"public static void endRequest() {
        final List<RequestScopedItem> result = CACHE.get();
        if (result != null) {
            CACHE.remove();
            for (final RequestScopedItem item : result) {
                item.invalidate();
            }
        }
    }",1
"public void signalPersistentProcesses(int sig) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeInt(sig);
        mRemote.transact(SIGNAL_PERSISTENT_PROCESSES_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    }",0
"private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views,
            boolean isPartialUpdate) {
        if (widget != null && widget.provider != null
                && !widget.provider.zombie && !widget.host.zombie) {

            if (isPartialUpdate && widget.views != null) {
                // For a partial update, we merge the new RemoteViews with the old.
                widget.views.mergeRemoteViews(views);
            } else {
                // For a full update we replace the RemoteViews completely.
                widget.views = views;
            }

            scheduleNotifyUpdateAppWidgetLocked(widget, views);
        }
    }",0
"public String getRealAssetPath(String inode, String fileName, String ext) {
        String _inode = inode;
        String path = """";

        String realPath = Config.getStringProperty(""ASSET_REAL_PATH"");
        if (UtilMethods.isSet(realPath) && !realPath.endsWith(java.io.File.separator))
            realPath = realPath + java.io.File.separator;

        String assetPath = Config.getStringProperty(""ASSET_PATH"", DEFAULT_RELATIVE_ASSET_PATH);
        if (UtilMethods.isSet(assetPath) && !assetPath.endsWith(java.io.File.separator))
            assetPath = assetPath + java.io.File.separator;

        path = ((!UtilMethods.isSet(realPath)) ? assetPath : realPath)
                + _inode.charAt(0) + java.io.File.separator + _inode.charAt(1)
                + java.io.File.separator + _inode+ java.io.File.separator + ""fileAsset"" + java.io.File.separator + fileName + ""."" + ext;

        if (!UtilMethods.isSet(realPath))
            return FileUtil.getRealPath(path);
        else
            return path;

    }",1
"private void checkCapabilities() {
        ncApi.getCapabilities(credentials, ApiUtils.getUrlForCapabilities(baseUrl))
            .retry(3)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new Observer<CapabilitiesOverall>() {
                @Override
                public void onSubscribe(@io.reactivex.annotations.NonNull Disposable d) {
                    // unused atm
                }

                @Override
                public void onNext(@io.reactivex.annotations.NonNull CapabilitiesOverall capabilitiesOverall) {
                    // FIXME check for compatible Call API version
                    if (hasExternalSignalingServer) {
                        setupAndInitiateWebSocketsConnection();
                    } else {
                        joinRoomAndCall();
                    }
                }

                @Override
                public void onError(@io.reactivex.annotations.NonNull Throwable e) {
                    // unused atm
                }

                @Override
                public void onComplete() {
                    // unused atm
                }
            });
    }",0
"public static URL getRequestURL(XWikiRequest request) throws XWikiException
    {
        return HttpServletUtils.getSourceURL(request);
    }",0
"@NonNull
    private Dialog createDialog(View v) {
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        builder.setView(v).setPositiveButton(R.string.common_ok, null)
                .setNeutralButton(R.string.common_cancel, null)
                .setTitle(R.string.end_to_end_encryption_title);

        Dialog dialog = builder.create();
        dialog.setCanceledOnTouchOutside(false);

        dialog.setOnShowListener(new DialogInterface.OnShowListener() {

            @Override
            public void onShow(final DialogInterface dialog) {

                Button button = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_POSITIVE);
                button.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View view) {
                        switch (keyResult) {
                            case KEY_CREATED:
                                Log_OC.d(TAG, ""New keys generated and stored."");

                                dialog.dismiss();

                                Intent intentCreated = new Intent();
                                intentCreated.putExtra(SUCCESS, true);
                                intentCreated.putExtra(ARG_POSITION, getArguments().getInt(ARG_POSITION));
                                getTargetFragment().onActivityResult(getTargetRequestCode(),
                                        SETUP_ENCRYPTION_RESULT_CODE, intentCreated);
                                break;

                            case KEY_EXISTING_USED:
                                Log_OC.d(TAG, ""Decrypt private key"");

                                textView.setText(R.string.end_to_end_encryption_decrypting);

                                try {
                                    String privateKey = task.get();
                                    String mnemonicUnchanged = passwordField.getText().toString();
                                    String mnemonic = passwordField.getText().toString().replaceAll(""\\s"", """")
                                        .toLowerCase(Locale.ROOT);
                                    String decryptedPrivateKey = EncryptionUtils.decryptPrivateKey(privateKey,
                                                                                                   mnemonic);

                                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(),
                                                                                EncryptionUtils.PRIVATE_KEY, decryptedPrivateKey);

                                    dialog.dismiss();
                                    Log_OC.d(TAG, ""Private key successfully decrypted and stored"");

                                    arbitraryDataProvider.storeOrUpdateKeyValue(user.getAccountName(),
                                                                                EncryptionUtils.MNEMONIC,
                                                                                mnemonicUnchanged);

                                    // check if private key and public key match
                                    String publicKey = arbitraryDataProvider.getValue(user.getAccountName(),
                                                                                      EncryptionUtils.PUBLIC_KEY);

                                    byte[] key1 = generateKey();
                                    String base64encodedKey = encodeBytesToBase64String(key1);

                                    String encryptedString = EncryptionUtils.encryptStringAsymmetric(base64encodedKey,
                                                                                                     publicKey);
                                    String decryptedString = decryptStringAsymmetric(encryptedString,
                                                                                     decryptedPrivateKey);

                                    byte[] key2 = decodeStringToBase64Bytes(decryptedString);

                                    if (!Arrays.equals(key1, key2)) {
                                        throw new Exception(""Keys do not match"");
                                    }

                                    Intent intentExisting = new Intent();
                                    intentExisting.putExtra(SUCCESS, true);
                                    intentExisting.putExtra(ARG_POSITION, getArguments().getInt(ARG_POSITION));
                                    getTargetFragment().onActivityResult(getTargetRequestCode(),
                                                                         SETUP_ENCRYPTION_RESULT_CODE, intentExisting);

                                } catch (Exception e) {
                                    textView.setText(R.string.end_to_end_encryption_wrong_password);
                                    Log_OC.d(TAG, ""Error while decrypting private key: "" + e.getMessage());
                                }
                                break;

                            case KEY_GENERATE:
                                passphraseTextView.setVisibility(View.GONE);
                                positiveButton.setVisibility(View.GONE);
                                neutralButton.setVisibility(View.GONE);
                                getDialog().setTitle(R.string.end_to_end_encryption_storing_keys);

                                GenerateNewKeysAsyncTask newKeysTask = new GenerateNewKeysAsyncTask();
                                newKeysTask.execute();
                                break;

                            default:
                                dialog.dismiss();
                                break;
                        }
                    }
                });
            }
        });
        return dialog;
    }",1
"private static boolean unzip(InputStream in, VFSContainer targetDir, Identity identity, boolean versioning) {
		
		VFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);

		try(ZipInputStream oZip = new ZipInputStream(in)) {
			// unzip files
			ZipEntry oEntr = oZip.getNextEntry();
			while (oEntr != null) {
				String name = oEntr.getName();
				if(!targetDir.isInPath(name)) {
					throw new IOException(""Invalip ZIP"");
				}

				if (name != null && !name.startsWith(DIR_NAME__MACOSX)) {
					if (oEntr.isDirectory()) {
						// skip MacOSX specific metadata directory
						// create directories
						getAllSubdirs(targetDir, name, identity, true);
					} else {
						// create file
						VFSContainer createIn = targetDir;
						// check if entry has directories which did not show up as
						// directories above
						int dirSepIndex = name.lastIndexOf('/');
						if (dirSepIndex == -1) {
							// try it windows style, backslash is also valid format
							dirSepIndex = name.lastIndexOf('\\');
						}
						if (dirSepIndex > 0) {
							// create subdirs
							createIn = getAllSubdirs(targetDir, name.substring(0, dirSepIndex), identity, true);
							if (createIn == null) {
								log.debug(""Error creating directory structure for zip entry: {}"", oEntr.getName());
								return false;
							}
							name = name.substring(dirSepIndex + 1);
						}
						
						if(versioning) {
							VFSLeaf newEntry = (VFSLeaf)createIn.resolve(name);
							if(newEntry == null) {
								newEntry = createIn.createChildLeaf(name);
								if (!copy(oZip, newEntry)) {
									return false;
								}
							} else if (newEntry.canVersion() == VFSConstants.YES) {
								vfsRepositoryService.addVersion(newEntry, identity, """", oZip);
							}
							if(newEntry != null && identity != null && newEntry.canMeta() == VFSConstants.YES) {
								VFSMetadata info = newEntry.getMetaInfo();
								if(info != null) {
									info.setAuthor(identity);
									vfsRepositoryService.updateMetadata(info);
								}
							}
							
						} else {
							VFSLeaf newEntry = createIn.createChildLeaf(name);
							if (newEntry != null) {
								if (!copy(oZip, newEntry)) {
									return false;
								}
					
								if(identity != null && newEntry.canMeta() == VFSConstants.YES) {
									VFSMetadata info = newEntry.getMetaInfo();
									if(info != null) {
										info.setAuthor(identity);
										vfsRepositoryService.updateMetadata(info);
									}
								}
							}
						}
					}
				}
				oZip.closeEntry();
				oEntr = oZip.getNextEntry();
			}
		} catch (IOException e) {
			return false;
		}
		return true;
	}",1
"@ApiOperation(value = ""新增"", notes = ""新增"")
    @ResponseBody
    @PostMapping(""/save"")
    @RequiresPermissions(""novel:friendLink:add"")
    public R save(@Validated FriendLinkDO friendLink) {
        if (friendLinkService.save(friendLink) > 0) {
            redisTemplate.delete(CacheKey.INDEX_LINK_KEY);
            return R.ok();
        }
        return R.error();
    }",1
"static ActivityRecord restoreFromXml(TypedXmlPullParser in,
            ActivityTaskSupervisor taskSupervisor) throws IOException, XmlPullParserException {
        Intent intent = null;
        PersistableBundle persistentState = null;
        int launchedFromUid = in.getAttributeInt(null, ATTR_LAUNCHEDFROMUID, 0);
        String launchedFromPackage = in.getAttributeValue(null, ATTR_LAUNCHEDFROMPACKAGE);
        String launchedFromFeature = in.getAttributeValue(null, ATTR_LAUNCHEDFROMFEATURE);
        String resolvedType = in.getAttributeValue(null, ATTR_RESOLVEDTYPE);
        boolean componentSpecified = in.getAttributeBoolean(null, ATTR_COMPONENTSPECIFIED, false);
        int userId = in.getAttributeInt(null, ATTR_USERID, 0);
        long createTime = in.getAttributeLong(null, ATTR_ID, -1);
        final int outerDepth = in.getDepth();

        TaskDescription taskDescription = new TaskDescription();
        taskDescription.restoreFromXml(in);

        int event;
        while (((event = in.next()) != END_DOCUMENT) &&
                (event != END_TAG || in.getDepth() >= outerDepth)) {
            if (event == START_TAG) {
                final String name = in.getName();
                if (DEBUG)
                        Slog.d(TaskPersister.TAG, ""ActivityRecord: START_TAG name="" + name);
                if (TAG_INTENT.equals(name)) {
                    intent = Intent.restoreFromXml(in);
                    if (DEBUG)
                            Slog.d(TaskPersister.TAG, ""ActivityRecord: intent="" + intent);
                } else if (TAG_PERSISTABLEBUNDLE.equals(name)) {
                    persistentState = PersistableBundle.restoreFromXml(in);
                    if (DEBUG) Slog.d(TaskPersister.TAG,
                            ""ActivityRecord: persistentState="" + persistentState);
                } else {
                    Slog.w(TAG, ""restoreActivity: unexpected name="" + name);
                    XmlUtils.skipCurrentTag(in);
                }
            }
        }

        if (intent == null) {
            throw new XmlPullParserException(""restoreActivity error intent="" + intent);
        }

        final ActivityTaskManagerService service = taskSupervisor.mService;
        final ActivityInfo aInfo = taskSupervisor.resolveActivity(intent, resolvedType, 0, null,
                userId, Binder.getCallingUid());
        if (aInfo == null) {
            throw new XmlPullParserException(""restoreActivity resolver error. Intent="" + intent +
                    "" resolvedType="" + resolvedType);
        }
        return new ActivityRecord.Builder(service)
                .setLaunchedFromUid(launchedFromUid)
                .setLaunchedFromPackage(launchedFromPackage)
                .setLaunchedFromFeature(launchedFromFeature)
                .setIntent(intent)
                .setResolvedType(resolvedType)
                .setActivityInfo(aInfo)
                .setComponentSpecified(componentSpecified)
                .setPersistentState(persistentState)
                .setTaskDescription(taskDescription)
                .setCreateTime(createTime)
                .build();
    }",0
"public int getEverythingIncludesFetchPageSize() {
		return myEverythingIncludesFetchPageSize;
	}",0
"private boolean requestStartTargetPermissionsReviewIfNeededLocked(
            BroadcastRecord receiverRecord, String receivingPackageName,
            final int receivingUserId) {
        if (!mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(
                receivingPackageName, receivingUserId)) {
            return true;
        }

        final boolean callerForeground = receiverRecord.callerApp != null
                ? receiverRecord.callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND
                : true;

        // Show a permission review UI only for explicit broadcast from a foreground app
        if (callerForeground && receiverRecord.intent.getComponent() != null) {
            IIntentSender target = mService.getIntentSenderLocked(
                    ActivityManager.INTENT_SENDER_BROADCAST, receiverRecord.callerPackage,
                    receiverRecord.callingUid, receiverRecord.userId, null, null, 0,
                    new Intent[]{receiverRecord.intent},
                    new String[]{receiverRecord.intent.resolveType(mService.mContext
                            .getContentResolver())},
                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT
                            | PendingIntent.FLAG_IMMUTABLE, null);

            final Intent intent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                    | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            intent.putExtra(Intent.EXTRA_PACKAGE_NAME, receivingPackageName);
            intent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target));

            if (DEBUG_PERMISSIONS_REVIEW) {
                Slog.i(TAG, ""u"" + receivingUserId + "" Launching permission review for package ""
                        + receivingPackageName);
            }

            mHandler.post(new Runnable() {
                @Override
                public void run() {
                    mService.mContext.startActivityAsUser(intent, new UserHandle(receivingUserId));
                }
            });
        } else {
            Slog.w(TAG, ""u"" + receivingUserId + "" Receiving a broadcast in package""
                    + receivingPackageName + "" requires a permissions review"");
        }

        return false;
    }",0
"private Provider lookupProviderLocked(ProviderId id) {
        final int N = mProviders.size();
        for (int i = 0; i < N; i++) {
            Provider provider = mProviders.get(i);
            if (provider.id.equals(id)) {
                return provider;
            }
        }
        return null;
    }",0
"public Map<String, Set<String>> getProviderMapping()
        {
            return this.providerMapping;
        }",0
"public void setStoreDir(File path) {
        setStoreDir(path.getAbsolutePath());
    }",1
"public void stopContainer(String containerId) {

        KieServerState currentState = context.getStateRepository().load(KieServerEnvironment.getServerId());
        Set<String> controllers = currentState.getControllers();

        KieServerConfig config = currentState.getConfiguration();
        if (controllers != null && !controllers.isEmpty()) {
            for (String controllerUrl : controllers) {

                if (controllerUrl != null && !controllerUrl.isEmpty()) {
                    String connectAndSyncUrl = controllerUrl + ""/management/servers/"" + KieServerEnvironment.getServerId() + ""/containers/"" + containerId + ""/status/stopped"";

                    String userName = config.getConfigItemValue(KieServerConstants.CFG_KIE_CONTROLLER_USER, ""kieserver"");
                    String password = loadControllerPassword(config);
                    String token = config.getConfigItemValue(KieServerConstants.CFG_KIE_CONTROLLER_TOKEN);

                    try {
                        makeHttpPostRequestAndCreateCustomResponse(connectAndSyncUrl, """", null, userName, password, token);
                        break;
                    } catch (Exception e) {
                        // let's check all other controllers in case of running in cluster of controllers
                        logger.warn(""Exception encountered while syncing with controller at {} error {}"", connectAndSyncUrl, e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
                        logger.debug(""Exception encountered while syncing with controller at {} error {}"", connectAndSyncUrl, e.getMessage(), e);
                    }

                }
            }
        }
    }",1
"@Override
    public List<Endpoint> searchEndpoint(String keyword, String serviceId, int limit) throws IOException {
        StringBuilder sql = new StringBuilder();
        List<Object> condition = new ArrayList<>(5);
        sql.append(""select * from "").append(EndpointTraffic.INDEX_NAME).append("" where "");
        sql.append(EndpointTraffic.SERVICE_ID).append(""=?"");
        condition.add(serviceId);
        if (!Strings.isNullOrEmpty(keyword)) {
            sql.append("" and "").append(EndpointTraffic.NAME).append("" like concat('%',?,'%') "");
            condition.add(keyword);
        }
        sql.append("" limit "").append(limit);

        List<Endpoint> endpoints = new ArrayList<>();
        try (Connection connection = h2Client.getConnection()) {
            try (ResultSet resultSet = h2Client.executeQuery(
                connection, sql.toString(), condition.toArray(new Object[0]))) {

                while (resultSet.next()) {
                    Endpoint endpoint = new Endpoint();
                    endpoint.setId(resultSet.getString(H2TableInstaller.ID_COLUMN));
                    endpoint.setName(resultSet.getString(EndpointTraffic.NAME));
                    endpoints.add(endpoint);
                }
            }
        } catch (SQLException e) {
            throw new IOException(e);
        }
        return endpoints;
    }",1
"public Mono<ActionExecutionResult> executeCommon(APIConnection apiConnection,
                                                         DatasourceConfiguration datasourceConfiguration,
                                                         ActionConfiguration actionConfiguration,
                                                         List<Map.Entry<String, String>> insertedParams) {

            // Initializing object for error condition
            ActionExecutionResult errorResult = new ActionExecutionResult();
            initUtils.initializeResponseWithError(errorResult);

            // Initializing request URL
            String url = initUtils.initializeRequestUrl(actionConfiguration, datasourceConfiguration);

            Boolean encodeParamsToggle = headerUtils.isEncodeParamsToggleEnabled(actionConfiguration);

            URI uri;
            try {
                uri = uriUtils.createUriWithQueryParams(actionConfiguration, datasourceConfiguration, url,
                        encodeParamsToggle);
            } catch (URISyntaxException e) {
                ActionExecutionRequest actionExecutionRequest =
                        RequestCaptureFilter.populateRequestFields(actionConfiguration, null, insertedParams, objectMapper);
                actionExecutionRequest.setUrl(url);
                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(e));
                errorResult.setRequest(actionExecutionRequest);
                return Mono.just(errorResult);
            }

            ActionExecutionRequest actionExecutionRequest =
                    RequestCaptureFilter.populateRequestFields(actionConfiguration, uri, insertedParams, objectMapper);

            WebClient.Builder webClientBuilder = triggerUtils.getWebClientBuilder(actionConfiguration,
                    datasourceConfiguration);

            String reqContentType = headerUtils.getRequestContentType(actionConfiguration, datasourceConfiguration);

            /* Check for content type */
            final String contentTypeError = headerUtils.verifyContentType(actionConfiguration.getHeaders());
            if (contentTypeError != null) {
                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(""Invalid value for Content-Type.""));
                errorResult.setRequest(actionExecutionRequest);
                return Mono.just(errorResult);
            }

            HttpMethod httpMethod = actionConfiguration.getHttpMethod();
            if (httpMethod == null) {
                errorResult.setBody(AppsmithPluginError.PLUGIN_EXECUTE_ARGUMENT_ERROR.getMessage(""HTTPMethod must be set.""));
                errorResult.setRequest(actionExecutionRequest);
                return Mono.just(errorResult);
            }

            if (HttpMethod.POST.equals(httpMethod)) {
                /**
                 * For content-type=application/json re-formatting is required.
                 * Ref: https://graphql.org/learn/serving-over-http/#post-request
                 *
                 * Graphql reference doc also mentions that content-type=application/graphql does not require any
                 * re-formatting.
                 * Ref: https://graphql.org/learn/serving-over-http/#post-request
                 *
                 * On searching over the web I also found that there are some custom content-type in use like
                 * `application/graphql+json` or `application/graphql-json` that expect the data in the same format
                 * as is for `application/json`. Hence, the current check assumes that any content type that differs
                 * from `application/graphql` would expect the data in the same format as for `application/json`
                 */
                if (!ApiContentType.GRAPHQL.getValue().equals(reqContentType)) {
                    /**
                     * When a GraphQL request is sent using HTTP POST method, then the request body needs to be in the
                     * following format:
                     * {
                     *     ""query"": ""... graphql query body ..."",
                     *     ""variables"": {""var1"": val1, ""var2"": val2 ...},
                     *     ""operationName"": ""name of operation"" // only required if multiple operations are defined in a
                     *     single query body
                     * }
                     * Ref: https://graphql.org/learn/serving-over-http/
                     */
                    try {
                        actionConfiguration.setBody(convertToGraphQLPOSTBodyFormat(actionConfiguration));
                    } catch (AppsmithPluginException e) {
                        return Mono.error(e);
                    }
                }
            }
            else if (HttpMethod.GET.equals(httpMethod)) {
                /**
                 * When a GraphQL request is sent using GET method, the GraphQL body and variables are sent as part of
                 * query parameters in the URL.
                 * Ref: https://graphql.org/learn/serving-over-http/
                 */
                List<Property> additionalQueryParams = getGraphQLQueryParamsForBodyAndVariables(actionConfiguration);
                uri = uriUtils.addQueryParamsToURI(uri, additionalQueryParams, encodeParamsToggle);
            }
            else {
                /**
                 * Only POST and GET HTTP methods are supported by GraphQL specifications.
                 * Ref: https://graphql.org/learn/serving-over-http/
                 */
                return Mono.error(
                        new AppsmithPluginException(
                                AppsmithPluginError.PLUGIN_ERROR,
                                ""Appsmith server has found an unexpected HTTP method configured with the GraphQL "" +
                                        ""plugin query: "" + httpMethod
                        )
                );
            }

            final RequestCaptureFilter requestCaptureFilter = new RequestCaptureFilter(objectMapper);
            Object requestBodyObj = dataUtils.getRequestBodyObject(actionConfiguration, reqContentType,
                    encodeParamsToggle,
                    httpMethod);
            WebClient client = triggerUtils.getWebClient(webClientBuilder, apiConnection, reqContentType, objectMapper,
                    EXCHANGE_STRATEGIES, requestCaptureFilter);

            /* Triggering the actual REST API call */
            Set<String> hintMessages = new HashSet<>();
            return triggerUtils.triggerApiCall(client, httpMethod, uri, requestBodyObj, actionExecutionRequest,
                    objectMapper,
                    hintMessages, errorResult, requestCaptureFilter);
        }",1
"public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection)
            throws DatabaseServiceException {
        try {

            if (connection != null && !forceNewConnection) {
                // logger.info(""connection closed::{}"", connection.isClosed());
                if (!connection.isClosed()) {
                    if (logger.isDebugEnabled()) {
                        logger.debug(""Returning existing connection::{}"", connection);
                    }

                    return connection;
                }
            }
            String dbURL = databaseConfiguration.toURI().toString();
            Class.forName(type.getClassPath());

            // logger.info(""*** type.getClassPath() ::{}, {}**** "", type.getClassPath());

            DriverManager.setLoginTimeout(10);

            connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(),
                    databaseConfiguration.getDatabasePassword());

            if (logger.isDebugEnabled()) {
                logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);
            }

            return connection;

        } catch (ClassNotFoundException e) {
            logger.error(""Jdbc Driver not found"", e);
            throw new DatabaseServiceException(e.getMessage());
        } catch (SQLException e) {
            logger.error(""SQLException::Couldn't get a Connection!"", e);
            throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
        }
    }",1
"@Unstable
    public DocumentAuthors getAuthors()
    {
        if (this.hasAccess(Right.PROGRAM)) {
            // We're using getDoc here to ensure to have a cloned doc
            return getDoc().getAuthors();
        } else {
            // in this case we don't care if the doc is cloned or not since it's readonly
            return new SafeDocumentAuthors(this.doc.getAuthors());
        }
    }",1
"private void readHeaders(long fileLength) throws IOException, RarException {
		markHead = null;
		newMhd = null;
		headers.clear();
		currentHeaderIndex = 0;
		int toRead = 0;
		//keep track of positions already processed for
		//more robustness against corrupt files
		Set<Long> processedPositions = new HashSet<Long>();
		while (true) {
			int size = 0;
			long newpos = 0;
			byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);

			long position = rof.getPosition();

			// Weird, but is trying to read beyond the end of the file
			if (position >= fileLength) {
				break;
			}

			// logger.info(""\n--------reading header--------"");
			size = rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);
			if (size == 0) {
				break;
			}
			BaseBlock block = new BaseBlock(baseBlockBuffer);

			block.setPositionInFile(position);

			switch (block.getHeaderType()) {

			case MarkHeader:
				markHead = new MarkHeader(block);
				if (!markHead.isSignature()) {
					throw new RarException(
							RarException.RarExceptionType.badRarArchive);
				}
				headers.add(markHead);
				// markHead.print();
				break;

			case MainHeader:
				toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc
						: MainHeader.mainHeaderSize;
				byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(mainbuff, toRead);
				MainHeader mainhead = new MainHeader(block, mainbuff);
				headers.add(mainhead);
				this.newMhd = mainhead;
				if (newMhd.isEncrypted()) {
					throw new RarException(
							RarExceptionType.rarEncryptedException);
				}
				// mainhead.print();
				break;

			case SignHeader:
				toRead = SignHeader.signHeaderSize;
				byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(signBuff, toRead);
				SignHeader signHead = new SignHeader(block, signBuff);
				headers.add(signHead);
				// logger.info(""HeaderType: SignHeader"");

				break;

			case AvHeader:
				toRead = AVHeader.avHeaderSize;
				byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(avBuff, toRead);
				AVHeader avHead = new AVHeader(block, avBuff);
				headers.add(avHead);
				// logger.info(""headertype: AVHeader"");
				break;

			case CommHeader:
				toRead = CommentHeader.commentHeaderSize;
				byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
				rof.readFully(commBuff, toRead);
				CommentHeader commHead = new CommentHeader(block, commBuff);
				headers.add(commHead);
				// logger.info(""method: ""+commHead.getUnpMethod()+""; 0x""+
				// Integer.toHexString(commHead.getUnpMethod()));
				newpos = commHead.getPositionInFile()
						+ commHead.getHeaderSize();
				if (processedPositions.contains(newpos)) {
					throw new RarException(RarExceptionType.badRarArchive);
				}
				processedPositions.add(newpos);
				rof.setPosition(newpos);

				break;
			case EndArcHeader:

				toRead = 0;
				if (block.hasArchiveDataCRC()) {
					toRead += EndArcHeader.endArcArchiveDataCrcSize;
				}
				if (block.hasVolumeNumber()) {
					toRead += EndArcHeader.endArcVolumeNumberSize;
				}
				EndArcHeader endArcHead;
				if (toRead > 0) {
					byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
					rof.readFully(endArchBuff, toRead);
					endArcHead = new EndArcHeader(block, endArchBuff);
					// logger.info(""HeaderType: endarch\ndatacrc:""+
					// endArcHead.getArchiveDataCRC());
				} else {
					// logger.info(""HeaderType: endarch - no Data"");
					endArcHead = new EndArcHeader(block, null);
				}
				headers.add(endArcHead);
				// logger.info(""\n--------end header--------"");
				return;

			default:
				byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);
				rof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);
				BlockHeader blockHead = new BlockHeader(block,
						blockHeaderBuffer);

				switch (blockHead.getHeaderType()) {
				case NewSubHeader:
				case FileHeader:
					toRead = blockHead.getHeaderSize()
							- BlockHeader.BaseBlockSize
							- BlockHeader.blockHeaderSize;
					byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
					rof.readFully(fileHeaderBuffer, toRead);

					FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);
					headers.add(fh);
					newpos = fh.getPositionInFile() + fh.getHeaderSize()
							+ fh.getFullPackSize();
					if (processedPositions.contains(newpos)) {
						throw new RarException(RarExceptionType.badRarArchive);
					}
					processedPositions.add(newpos);
					rof.setPosition(newpos);
					break;

				case ProtectHeader:
					toRead = blockHead.getHeaderSize()
							- BlockHeader.BaseBlockSize
							- BlockHeader.blockHeaderSize;
					byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
					rof.readFully(protectHeaderBuffer, toRead);
					ProtectHeader ph = new ProtectHeader(blockHead,
							protectHeaderBuffer);
					newpos = ph.getPositionInFile() + ph.getHeaderSize()
							+ ph.getDataSize();
					if (processedPositions.contains(newpos)) {
						throw new RarException(RarExceptionType.badRarArchive);
					}
					processedPositions.add(newpos);
					rof.setPosition(newpos);
					break;

				case SubHeader: {
					byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);
					rof.readFully(subHeadbuffer,
							SubBlockHeader.SubBlockHeaderSize);
					SubBlockHeader subHead = new SubBlockHeader(blockHead,
							subHeadbuffer);
					subHead.print();
					switch (subHead.getSubType()) {
					case MAC_HEAD: {
						byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);
						rof.readFully(macHeaderbuffer,
								MacInfoHeader.MacInfoHeaderSize);
						MacInfoHeader macHeader = new MacInfoHeader(subHead,
								macHeaderbuffer);
						macHeader.print();
						headers.add(macHeader);

						break;
					}
					// TODO implement other subheaders
					case BEEA_HEAD:
						break;
					case EA_HEAD: {
						byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);
						rof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);
						EAHeader eaHeader = new EAHeader(subHead,
								eaHeaderBuffer);
						eaHeader.print();
						headers.add(eaHeader);

						break;
					}
					case NTACL_HEAD:
						break;
					case STREAM_HEAD:
						break;
					case UO_HEAD:
						toRead = subHead.getHeaderSize();
						toRead -= BaseBlock.BaseBlockSize;
						toRead -= BlockHeader.blockHeaderSize;
						toRead -= SubBlockHeader.SubBlockHeaderSize;
						byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
						rof.readFully(uoHeaderBuffer, toRead);
						UnixOwnersHeader uoHeader = new UnixOwnersHeader(
								subHead, uoHeaderBuffer);
						uoHeader.print();
						headers.add(uoHeader);
						break;
					default:
						break;
					}

					break;
				}
				default:
					logger.warning(""Unknown Header"");
					throw new RarException(RarExceptionType.notRarArchive);

				}
			}
			// logger.info(""\n--------end header--------"");
		}
	}",1
"@Override
    public String batchUploadFile(HttpServletRequest request, List<MultipartFile> filedatas, SystemConfig systemConfig) {

        String uploadQiNiu = systemConfig.getUploadQiNiu();
        String uploadLocal = systemConfig.getUploadLocal();
        String uploadMinio = systemConfig.getUploadMinio();

        // 判断来源
        String source = request.getParameter(SysConf.SOURCE);
        //如果是用户上传，则包含用户uid
        String userUid = """";
        //如果是管理员上传，则包含管理员uid
        String adminUid = """";
        //项目名
        String projectName = """";
        //模块名
        String sortName = """";

        // 判断图片来源
        if (SysConf.PICTURE.equals(source)) {
            // 当从vue-mogu-web网站过来的，直接从参数中获取
            userUid = request.getParameter(SysConf.USER_UID);
            adminUid = request.getParameter(SysConf.ADMIN_UID);
            projectName = request.getParameter(SysConf.PROJECT_NAME);
            sortName = request.getParameter(SysConf.SORT_NAME);
        } else if (SysConf.ADMIN.equals(source)) {
            // 当图片从mogu-admin传递过来的时候
            userUid = request.getAttribute(SysConf.USER_UID).toString();
            adminUid = request.getAttribute(SysConf.ADMIN_UID).toString();
            projectName = request.getAttribute(SysConf.PROJECT_NAME).toString();
            sortName = request.getAttribute(SysConf.SORT_NAME).toString();
        } else {
            userUid = request.getAttribute(SysConf.USER_UID).toString();
            adminUid = request.getAttribute(SysConf.ADMIN_UID).toString();
            projectName = request.getAttribute(SysConf.PROJECT_NAME).toString();
            sortName = request.getAttribute(SysConf.SORT_NAME).toString();
        }

        //projectName现在默认base
        if (StringUtils.isEmpty(projectName)) {
            projectName = ""base"";
        }

        //TODO 检测用户上传，如果不是网站的用户就不能调用
        if (StringUtils.isEmpty(userUid) && StringUtils.isEmpty(adminUid)) {
            return ResultUtil.result(SysConf.ERROR, ""请先注册"");
        }

        QueryWrapper<FileSort> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq(SQLConf.SORT_NAME, sortName);
        queryWrapper.eq(SQLConf.PROJECT_NAME, projectName);
        queryWrapper.eq(SQLConf.STATUS, EStatus.ENABLE);
        List<FileSort> fileSorts = fileSortService.list(queryWrapper);

        FileSort fileSort = null;
        if (fileSorts.size() >= 1) {
            fileSort = fileSorts.get(0);
        } else {
            return ResultUtil.result(SysConf.ERROR, ""文件不被允许上传"");
        }

        String sortUrl = fileSort.getUrl();
        //判断url是否为空，如果为空，使用默认
        if (StringUtils.isEmpty(sortUrl)) {
            sortUrl = ""base/common/"";
        } else {
            sortUrl = fileSort.getUrl();
        }

        List<File> lists = new ArrayList<>();
        //文件上传
        if (filedatas != null && filedatas.size() > 0) {
            for (MultipartFile filedata : filedatas) {
                String oldName = filedata.getOriginalFilename();
                long size = filedata.getSize();
                //获取扩展名，默认是jpg
                String picExpandedName = FileUtils.getPicExpandedName(oldName);
                // 检查是否是安全的格式
                if (!FileUtils.isPic(picExpandedName)) {
                    throw new InsertException(""请上传正确格式的文件"");
                }

                //获取新文件名
                String newFileName = System.currentTimeMillis() + Constants.SYMBOL_POINT + picExpandedName;
                String localUrl = """";
                String qiNiuUrl = """";
                String minioUrl = """";
                try {
                    MultipartFile tempFileData = filedata;
                    // 上传七牛云，判断是否能够上传七牛云
                    if (EOpenStatus.OPEN.equals(uploadQiNiu)) {
                        qiNiuUrl = qiniuService.uploadFile(tempFileData);
                    }

                    // 判断是否能够上传Minio文件服务器
                    if (EOpenStatus.OPEN.equals(uploadMinio)) {
                        minioUrl = minioService.uploadFile(tempFileData);
                    }

                    // 判断是否能够上传至本地
                    if (EOpenStatus.OPEN.equals(uploadLocal)) {
                        localUrl = localFileService.uploadFile(filedata, fileSort);
                    }
                } catch (Exception e) {
                    log.info(""上传文件异常: {}"", e.getMessage());
                    e.getStackTrace();
                    return ResultUtil.result(SysConf.ERROR, ""文件上传失败，请检查系统配置"");
                }

                File file = new File();
                file.setCreateTime(new Date(System.currentTimeMillis()));
                file.setFileSortUid(fileSort.getUid());
                file.setFileOldName(oldName);
                file.setFileSize(size);
                file.setPicExpandedName(picExpandedName);
                file.setPicName(newFileName);
                file.setPicUrl(localUrl);
                file.setStatus(EStatus.ENABLE);
                file.setUserUid(userUid);
                file.setAdminUid(adminUid);
                file.setQiNiuUrl(qiNiuUrl);
                file.setMinioUrl(minioUrl);
                file.insert();
                lists.add(file);
            }
            //保存成功返回数据
            return ResultUtil.result(SysConf.SUCCESS, lists);
        }
        return ResultUtil.result(SysConf.ERROR, ""请上传图片"");
    }",1
"@Test
    public void testExtractNanosecondDecimal01()
    {
        BigDecimal value = new BigDecimal(""0"");
        checkExtractNanos(0L, 0, value);
    }",1
"public abstract BaseXMLBuilder attribute(String name, String value);",0
"@Override
    public void setAffiliationIds(ComponentName admin, List<String> ids) {
        if (!mHasFeature) {
            return;
        }
        if (ids == null) {
            throw new IllegalArgumentException(""ids must not be null"");
        }
        for (String id : ids) {
            Preconditions.checkArgument(!TextUtils.isEmpty(id), ""ids must not have empty string"");
            enforceMaxStringLength(id, ""affiliation id"");
        }

        final Set<String> affiliationIds = new ArraySet<>(ids);
        final CallerIdentity caller = getCallerIdentity(admin);
        Preconditions.checkCallAuthorization(
                isProfileOwner(caller) || isDefaultDeviceOwner(caller));
        final int callingUserId = caller.getUserId();

        synchronized (getLockObject()) {
            getUserData(callingUserId).mAffiliationIds = affiliationIds;
            saveSettingsLocked(callingUserId);
            if (callingUserId != UserHandle.USER_SYSTEM && isDeviceOwner(admin, callingUserId)) {
                // Affiliation ids specified by the device owner are additionally stored in
                // UserHandle.USER_SYSTEM's DevicePolicyData.
                getUserData(UserHandle.USER_SYSTEM).mAffiliationIds = affiliationIds;
                saveSettingsLocked(UserHandle.USER_SYSTEM);
            }

            // Affiliation status for any user, not just the calling user, might have changed.
            // The device owner user will still be affiliated after changing its affiliation ids,
            // but as a result of that other users might become affiliated or un-affiliated.
            maybePauseDeviceWideLoggingLocked();
            maybeResumeDeviceWideLoggingLocked();
            maybeClearLockTaskPolicyLocked();
            updateAdminCanGrantSensorsPermissionCache(callingUserId);
        }
    }",1
"public static FilePath getHeapDump(VirtualChannel channel) throws IOException, InterruptedException {
        return channel.call(new Callable<FilePath, IOException>() {
            public FilePath call() throws IOException {
                final File hprof = File.createTempFile(""hudson-heapdump"", ""hprof"");
                hprof.delete();
                try {
                    MBeanServer server = ManagementFactory.getPlatformMBeanServer();
                    server.invoke(new ObjectName(""com.sun.management:type=HotSpotDiagnostic""), ""dumpHeap"",
                            new Object[]{hprof.getAbsolutePath(), true}, new String[]{String.class.getName(), boolean.class.getName()});

                    return new FilePath(hprof);
                } catch (JMException e) {
                    throw new IOException2(e);
                }
            }

            private static final long serialVersionUID = 1L;
        });
    }",0
"@Override
  public AuthenticationResponse parseResponse(String encodedResponse, boolean verifySignature, KeySelector keySelector)
      throws SAMLException {

    AuthenticationResponse response = new AuthenticationResponse();
    byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);
    response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);

    Document document = newDocumentFromBytes(decodedResponse);
    if (verifySignature) {
      verifySignature(document, keySelector);
    }

    ResponseType jaxbResponse = unmarshallFromDocument(document, ResponseType.class);
    response.status.code = ResponseStatus.fromSAMLFormat(jaxbResponse.getStatus().getStatusCode().getValue());
    response.id = jaxbResponse.getID();
    response.inResponseTo = jaxbResponse.getInResponseTo();
    response.issuer = jaxbResponse.getIssuer() != null ? jaxbResponse.getIssuer().getValue() : null;
    response.issueInstant = toZonedDateTime(jaxbResponse.getIssueInstant());
    response.destination = jaxbResponse.getDestination();
    response.version = jaxbResponse.getVersion();

    List<Object> assertions = jaxbResponse.getAssertionOrEncryptedAssertion();
    for (Object assertion : assertions) {
      if (assertion instanceof EncryptedElementType) {
        logger.warn(""SAML response contained encrypted attribute. It was ignored."");
        continue;
      }

      AssertionType assertionType = (AssertionType) assertion;

      // Handle the subject
      SubjectType subject = assertionType.getSubject();
      if (subject != null) {
        response.assertion.subject = new Subject();

        List<JAXBElement<?>> elements = subject.getContent();
        for (JAXBElement<?> element : elements) {
          Class<?> type = element.getDeclaredType();
          if (type == NameIDType.class) {
            if (response.assertion.subject.nameID != null) {
              logger.warn(""SAML response contained multiple NameID elements. Only the first one was used."");
              continue;
            }

            // Extract the name
            response.assertion.subject.nameID = parseNameId((NameIDType) element.getValue());
          } else if (type == SubjectConfirmationType.class) {
            // Extract the confirmation
            response.assertion.subject.subjectConfirmation = parseConfirmation((SubjectConfirmationType) element.getValue());
          } else if (type == EncryptedElementType.class) {
            throw new SAMLException(""This library currently doesn't handle encrypted assertions"");
          }
        }
      }

      // Handle conditions to pull out audience restriction
      ConditionsType conditionsType = assertionType.getConditions();
      if (conditionsType != null) {
        response.assertion.conditions = new Conditions();
        response.assertion.conditions.notBefore = convertToZonedDateTime(conditionsType.getNotBefore());
        response.assertion.conditions.notOnOrAfter = convertToZonedDateTime(conditionsType.getNotOnOrAfter());

        List<ConditionAbstractType> conditionAbstractTypes = conditionsType.getConditionOrAudienceRestrictionOrOneTimeUse();
        // Only handling the AudienceRestriction.
        // - Optional additional conditions include OneTimeUse and ProxyRestriction.  See section 2.5.1 in the SAML v2 core spec,
        //   the way these additional conditions are described, I see no use for them.
        //   - OneTimeUse specifics are in section 2.5.1.5
        //   - ProxyRestriction specifics are in section 2.6.1.6
        //   http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf
        for (ConditionAbstractType conditionAbstractType : conditionAbstractTypes) {
          if (conditionAbstractType instanceof AudienceRestrictionType) {
            AudienceRestrictionType restrictionType = (AudienceRestrictionType) conditionAbstractType;
            response.assertion.conditions.audiences.addAll(restrictionType.getAudience());
          }
        }
      }

      // Handle the attributes
      List<StatementAbstractType> statements = assertionType.getStatementOrAuthnStatementOrAuthzDecisionStatement();
      for (StatementAbstractType statement : statements) {
        if (statement instanceof AttributeStatementType) {
          AttributeStatementType attributeStatementType = (AttributeStatementType) statement;
          List<Object> attributeObjects = attributeStatementType.getAttributeOrEncryptedAttribute();
          for (Object attributeObject : attributeObjects) {
            if (attributeObject instanceof AttributeType) {
              AttributeType attributeType = (AttributeType) attributeObject;
              String name = attributeType.getName();
              List<Object> attributeValues = attributeType.getAttributeValue();
              List<String> values = attributeValues.stream().map(SAMLTools::attributeToString).collect(Collectors.toList());
              response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);
            } else {
              throw new SAMLException(""This library currently doesn't support encrypted attributes"");
            }
          }
        }
      }
    }

    return response;
  }",1
"public boolean isLaunchTransitionFadingAway() {
        return mLaunchTransitionFadingAway;
    }",0
"@RequestMapping(value = ""/{appId}"" + STATUS_URL + ""/{referenceId:\\S+}.json"", method = RequestMethod.GET)
    public final void getStatusSpecificAppId(
            @SuppressWarnings(""unused"") @PathVariable final String appId,
            @PathVariable final String referenceId,
            final HttpServletRequest statusRequest,
            final HttpServletResponse statusResponse) {
        getStatus(referenceId, statusRequest, statusResponse);
    }",1
"public List<Cliente> buscarClienteNome(String nome) throws SQLException, ClassNotFoundException {
        Connection con = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            con = ConnectionFactory.getConnection();
            nome = ""%""+nome+""%"";
            stmt = con.prepareStatement(stmtBuscarNomeCliente);
            stmt.setString(1,nome);
            rs = stmt.executeQuery();
            return montaListaClientes(rs);

        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                rs.close();
            } catch (Exception ex) {
                System.out.println(""Erro ao fechar result set.Erro: "" + ex.getMessage());
            }
            try {
                stmt.close();
            } catch (SQLException ex) {
                System.out.println(""Erro ao fechar statement. Ex = "" + ex.getMessage());
            }
            try {
                con.close();
            } catch (SQLException ex) {
                System.out.println(""Erro ao fechar a conexao. Ex = "" + ex.getMessage());
            }
        }
    }",1
"protected void setOutputEncoding() throws Exception {
        if (strictKex) {
            if (log.isDebugEnabled()) {
                log.debug(""setOutputEncoding({}): strict KEX resets output message sequence number from {} to 0"", this, seqo);
            }
            seqo = 0;
        }

        outCipher = outSettings.getCipher(seqo);
        outMac = outSettings.getMac();
        outCompression = outSettings.getCompression();
        outSettings = null;
        outCipherSize = outCipher.getCipherBlockSize();
        outMacSize = outMac != null ? outMac.getBlockSize() : 0;
        // TODO add support for configurable compression level
        outCompression.init(Compression.Type.Deflater, -1);

        maxRekeyBlocks.set(determineRekeyBlockLimit(inCipherSize, outCipherSize));

        outBytesCount.set(0L);
        outPacketsCount.set(0L);
        outBlocksCount.set(0L);

        lastKeyTimeValue.set(Instant.now());
        firstKexPacketFollows = null;

        if (log.isDebugEnabled()) {
            log.debug(""setOutputEncoding({}): cipher {}; mac {}; compression {}; blocks limit {}"", this, outCipher, outMac,
                    outCompression, maxRekeyBlocks);
        }
    }",1
"@SuppressFBWarnings(""SQL_INJECTION_JPA"")
    // The only parameter is entityName(), which is limited to either the simple class name of the entity, or its annotation
    @Nonnull
    @Override
    public <E extends KrailEntity<ID, VER>> List<E> findAll(@Nonnull Class<E> entityClass) {
        checkNotNull(entityClass);
        EntityManager entityManager = entityManagerProvider.get();
        TypedQuery<E> query = entityManager.createQuery(""SELECT e FROM "" + entityName(entityClass) + "" e"", entityClass);
        query.setFlushMode(FlushModeType.AUTO);
        return query.getResultList();
    }",1
"protected String getInternalJsCssLib(Map<String, Object> data) {
        String jsCssLink = """";
               
        // PWA: register service worker
        if (!""true"".equals(getPropertyString(""disablePwa""))) {
            WorkflowUserManager workflowUserManager = (WorkflowUserManager)AppUtil.getApplicationContext().getBean(""workflowUserManager"");
            boolean pushEnabled = !""true"".equals(getPropertyString(""disablePush"")) && !workflowUserManager.isCurrentUserAnonymous();
            String appId = userview.getParamString(""appId"");
            if (appId != null && !appId.isEmpty()) {
                String userviewId = userview.getPropertyString(""id"");
                String key = userview.getParamString(""key"");
                if (key.isEmpty()) {
                    key = Userview.USERVIEW_KEY_EMPTY_VALUE;
                }
                
                boolean isEmbedded = false;
                if(data.get(""embed"") != null){
                    isEmbedded = (Boolean) data.get(""embed"");
                };
                
                String pwaOnlineNotificationMessage = ResourceBundleUtil.getMessage(""pwa.onlineNow"");
                String pwaOfflineNotificationMessage = ResourceBundleUtil.getMessage(""pwa.offlineNow"");
                String pwaLoginPromptMessage = ResourceBundleUtil.getMessage(""pwa.loginPrompt"");
                String pwaSyncingMessage = ResourceBundleUtil.getMessage(""pwa.syncing"");
                String pwaSyncFailedMessage = ResourceBundleUtil.getMessage(""pwa.syncFailed"");
                String pwaSyncSuccessMessage = ResourceBundleUtil.getMessage(""pwa.syncSuccess"");
                String buildNumber = ResourceBundleUtil.getMessage(""build.number"");
                
                String serviceWorkerUrl = data.get(""context_path"") + ""/web/userview/"" + appId + ""/"" + userviewId + ""/""+key+""/serviceworker"";
                jsCssLink += ""<script>$(function() {""
                        + ""var initPwaUtil = function(){""
                        + ""PwaUtil.contextPath = '"" + StringUtil.escapeString(data.get(""context_path"").toString(), StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.userviewKey = '"" + StringUtil.escapeString(key, StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.homePageLink = '"" + StringUtil.escapeString(data.get(""home_page_link"").toString(), StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.serviceWorkerPath = '"" + StringUtil.escapeString(serviceWorkerUrl, StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.subscriptionApiPath = '"" + StringUtil.escapeString(data.get(""context_path"").toString(), StringUtil.TYPE_JAVASCIPT, null) + ""/web/console/profile/subscription';""
                        + ""PwaUtil.pushEnabled = "" + pushEnabled + "";""
                        + ""PwaUtil.currentUsername = '"" + StringUtil.escapeString(workflowUserManager.getCurrentUsername(), StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.onlineNotificationMessage = '"" + StringUtil.escapeString(pwaOnlineNotificationMessage, StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.offlineNotificationMessage = '"" + StringUtil.escapeString(pwaOfflineNotificationMessage, StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.loginPromptMessage = '"" + StringUtil.escapeString(pwaLoginPromptMessage, StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.syncingMessage = '"" + StringUtil.escapeString(pwaSyncingMessage, StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.syncFailedMessage = '"" + StringUtil.escapeString(pwaSyncFailedMessage, StringUtil.TYPE_JAVA, null) + ""';""
                        + ""PwaUtil.syncSuccessMessage = '"" + StringUtil.escapeString(pwaSyncSuccessMessage, StringUtil.TYPE_JAVASCIPT, null) + ""';""
                        + ""PwaUtil.isEmbedded = "" + isEmbedded + "";""
                        + ""PwaUtil.register();""
                        + ""PwaUtil.init();""
                        + ""};""
                        + ""if (typeof PwaUtil !== \""undefined\"") {initPwaUtil();} else { $(document).on(\""PwaUtil.ready\"", function(){ initPwaUtil(); });}""
                        + ""});</script>"";
            }
        }
        return jsCssLink;
    }",1
"private XOPMultipartProxyGetFileResponse getResponse(String content) throws Exception {
        XOPMultipartProxyGetFileResponse response = new XOPMultipartProxyGetFileResponse();
        File out = Files.createTempFile(""tmp"", "".txt"").toFile();
        out.deleteOnExit();
        try (FileWriter writer = new FileWriter(out)) {
            writer.write(content);
            DataSource fds = new FileDataSource(out);
            DataHandler handler = new DataHandler(fds);
            response.setData(handler);
        }
        return response;
    }",1
"@Nullable
  public void setSecretKey(String secretKey) {
    this.secretKey = secretKey;
  }",1
"private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
        
        if (nettyProviderConfig.getSslEngineFactory() != null) {
            return nettyProviderConfig.getSslEngineFactory().newSSLEngine();
        
        } else {
            SSLContext sslContext = config.getSSLContext();
            if (sslContext == null)
                sslContext = SslUtils.getInstance().getSSLContext(config.isAcceptAnyCertificate());

            SSLEngine sslEngine = sslContext.createSSLEngine();
            sslEngine.setUseClientMode(true);
            return sslEngine;
        }
    }",1
"public boolean launchAssistIntent(Intent intent, int requestType, String hint, int userHandle,
            Bundle args) {
        return enqueueAssistContext(requestType, intent, hint, null, null, userHandle, args,
                PENDING_ASSIST_EXTRAS_TIMEOUT) != null;
    }",0
"public void setOriginalName(String originalName) {
		this.originalName = StringUtils.abbreviate(originalName, 256);
	}",1
"@Override
	public boolean getIgnoringBoundaryWhitespace() {
		return ignoringBoundaryWhite;
	}",0
"@CLIMethod(name=""restart"")
    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {
        checkPermission(ADMINISTER);
        if (req != null && req.getMethod().equals(""GET"")) {
            req.getView(this,""_restart.jelly"").forward(req,rsp);
            return;
        }

        restart();

        if (rsp != null) // null for CLI
            rsp.sendRedirect2(""."");
    }",0
"@GetMapping(""/logout"")
    public String logout(HttpSession session) {
        User user = getUser();
        if (user != null) {
            // 清除redis里的缓存
            userService.delRedisUser(user);
            // 清除session里的用户信息
            session.removeAttribute(""_user"");
            // 清除cookie里的用户token
            cookieUtil.clearCookie(systemConfigService.selectAllConfig().get(""cookie_name"").toString());
        }
        return redirect(""/"");
    }",0
"@Override
    protected List<Object> getCommandConfigurationBeans() {
        return Arrays.asList(configuration,
                httpConfiguration,
                elasticsearchConfiguration,
                elasticsearchClientConfiguration,
                emailConfiguration,
                mongoDbConfiguration,
                versionCheckConfiguration,
                kafkaJournalConfiguration,
                nettyTransportConfiguration,
                pipelineConfiguration,
                viewsConfiguration,
                processingStatusConfig,
                jobSchedulerConfiguration,
                prometheusExporterConfiguration,
                tlsConfiguration,
                geoIpProcessorConfig,
                telemetryConfiguration,
                dnsLookupAdapterConfiguration);
    }",1
"@Test
  public void setKeyParams() throws Exception {
    assertPlotParam(""key"", ""out"");
    assertPlotParam(""key"", ""left"");
    assertPlotParam(""key"", ""top"");
    assertPlotParam(""key"", ""center"");
    assertPlotParam(""key"", ""right"");
    assertPlotParam(""key"", ""horiz"");
    assertPlotParam(""key"", ""box"");
    assertPlotParam(""key"", ""bottom"");
    assertInvalidPlotParam(""key"", ""out%20right%20top%0aset%20yrange%20[33:system(%20"");
    assertInvalidPlotParam(""key"", ""%3Bsystem%20%22cat%20/home/ubuntuvm/secret.txt%20%3E/tmp/secret.txt%22%20%22"");
  }",1
"String toString(int indentFactor, int indent) throws JSONException {
        int          i;
        int          n = length();
        if (n == 0) {
            return ""{}"";
        }
        Iterator     keys = keys();
        StringBuilder sb = new StringBuilder(""{"");
        int          newindent = indent + indentFactor;
        while (keys.hasNext()) {
            Object o = keys.next();
            if (sb.length() > 1) {
                sb.append("",\n"");
            } else {
                sb.append('\n');
            }
            for (i = 0; i < newindent; i += 1) {
                sb.append(' ');
            }
            sb.append(quote(o.toString()));
            sb.append("": "");
            sb.append(valueToString(this.myHashMap.get(o), indentFactor,
                    newindent, escapeForwardSlashAlways));
        }
        if (sb.length() > 1) {
            sb.append('\n');
            for (i = 0; i < indent; i += 1) {
                sb.append(' ');
            }
        }
        sb.append('}');
        return sb.toString();
    }",0
"public static long queryNumEntries(SQLiteDatabase db, String table, String selection) {
        return queryNumEntries(db, table, selection, null);
    }",0
"public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {
        if (typeName == null) {
            return null;
        }

        if (autoTypeCheckHandlers != null) {
            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {
                Class<?> type = h.handler(typeName, expectClass, features);
                if (type != null) {
                    return type;
                }
            }
        }

        final int safeModeMask = Feature.SafeMode.mask;
        boolean safeMode = this.safeMode
                || (features & safeModeMask) != 0
                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;
        if (safeMode) {
            throw new JSONException(""safeMode not support autoType : "" + typeName);
        }

        if (typeName.length() >= 192 || typeName.length() < 3) {
            throw new JSONException(""autoType is not support. "" + typeName);
        }

        final boolean expectClassFlag;
        if (expectClass == null) {
            expectClassFlag = false;
        } else {
            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());
            if (expectHash == 0x90a25f5baa21529eL
                    || expectHash == 0x2d10a5801b9d6136L
                    || expectHash == 0xaf586a571e302c6bL
                    || expectHash == 0xed007300a7b227c6L
                    || expectHash == 0x295c4605fd1eaa95L
                    || expectHash == 0x47ef269aadc650b4L
                    || expectHash == 0x6439c4dff712ae8bL
                    || expectHash == 0xe3dd9875a2dc5283L
                    || expectHash == 0xe2a8ddba03e69e0dL
                    || expectHash == 0xd734ceb4c3e9d1daL
            ) {
                expectClassFlag = false;
            } else {
                expectClassFlag = true;
            }
        }

        String className = typeName.replace('$', '.');
        Class<?> clazz;

        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;
        if (h1 == 0xaf64164c86024f1aL) { // [
            throw new JSONException(""autoType is not support. "" + typeName);
        }

        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {
            throw new JSONException(""autoType is not support. "" + typeName);
        }

        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))
                * fnv1a_64_magic_prime)
                ^ className.charAt(1))
                * fnv1a_64_magic_prime)
                ^ className.charAt(2))
                * fnv1a_64_magic_prime;

        long fullHash = TypeUtils.fnv1a_64(className);
        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;

        if (internalDenyHashCodes != null) {
            long hash = h3;
            for (int i = 3; i < className.length(); ++i) {
                hash ^= className.charAt(i);
                hash *= fnv1a_64_magic_prime;
                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {
                    throw new JSONException(""autoType is not support. "" + typeName);
                }
            }
        }

        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {
            long hash = h3;
            for (int i = 3; i < className.length(); ++i) {
                hash ^= className.charAt(i);
                hash *= fnv1a_64_magic_prime;
                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {
                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);
                    if (clazz != null) {
                        return clazz;
                    }
                }
                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {
                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {
                        continue;
                    }

                    throw new JSONException(""autoType is not support. "" + typeName);
                }
            }
        }

        clazz = TypeUtils.getClassFromMapping(typeName);

        if (clazz == null) {
            clazz = deserializers.findClass(typeName);
        }

        if (expectClass == null && clazz != null && Throwable.class.isAssignableFrom(clazz) && !autoTypeSupport) {
            clazz = null;
        }

        if (clazz == null) {
            clazz = typeMapping.get(typeName);
        }

        if (internalWhite) {
            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);
        }

        if (clazz != null) {
            if (expectClass != null
                    && clazz != java.util.HashMap.class
                    && clazz != java.util.LinkedHashMap.class
                    && !expectClass.isAssignableFrom(clazz)) {
                throw new JSONException(""type not match. "" + typeName + "" -> "" + expectClass.getName());
            }

            return clazz;
        }

        if (!autoTypeSupport) {
            long hash = h3;
            for (int i = 3; i < className.length(); ++i) {
                char c = className.charAt(i);
                hash ^= c;
                hash *= fnv1a_64_magic_prime;

                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {
                    throw new JSONException(""autoType is not support. "" + typeName);
                }

                // white list
                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {
                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);

                    if (clazz == null) {
                        return expectClass;
                    }

                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {
                        throw new JSONException(""type not match. "" + typeName + "" -> "" + expectClass.getName());
                    }

                    return clazz;
                }
            }
        }

        boolean jsonType = false;
        InputStream is = null;
        try {
            String resource = typeName.replace('.', '/') + "".class"";
            if (defaultClassLoader != null) {
                is = defaultClassLoader.getResourceAsStream(resource);
            } else {
                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);
            }
            if (is != null) {
                ClassReader classReader = new ClassReader(is, true);
                TypeCollector visitor = new TypeCollector(""<clinit>"", new Class[0]);
                classReader.accept(visitor);
                jsonType = visitor.hasJsonType();
            }
        } catch (Exception e) {
            // skip
        } finally {
            IOUtils.close(is);
        }

        final int mask = Feature.SupportAutoType.mask;
        boolean autoTypeSupport = this.autoTypeSupport
                || (features & mask) != 0
                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;

        if (autoTypeSupport || jsonType || expectClassFlag) {
            boolean cacheClass = autoTypeSupport || jsonType;
            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);
        }

        if (clazz != null) {
            if (jsonType) {
                TypeUtils.addMapping(typeName, clazz);
                return clazz;
            }

            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger
                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver
                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //
                    ) {
                throw new JSONException(""autoType is not support. "" + typeName);
            }

            if (expectClass != null) {
                if (expectClass.isAssignableFrom(clazz)) {
                    TypeUtils.addMapping(typeName, clazz);
                    return clazz;
                } else {
                    throw new JSONException(""type not match. "" + typeName + "" -> "" + expectClass.getName());
                }
            }

            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);
            if (beanInfo.creatorConstructor != null && autoTypeSupport) {
                throw new JSONException(""autoType is not support. "" + typeName);
            }
        }

        if (!autoTypeSupport) {
            if (typeName.endsWith(""Exception"")) {
                return null;
            }

            throw new JSONException(""autoType is not support. "" + typeName);
        }

        if (clazz != null) {
            TypeUtils.addMapping(typeName, clazz);
        }

        return clazz;
    }",1
"public Object query(String query) throws ApplicationException {
        StringBuffer html = new StringBuffer();
        String[] keywords;

        int page = 1, pageSize = 20;

        this.request = (Request) this.context
                .getAttribute(HTTP_REQUEST);
        if (this.request.getParameter(""page"") == null
                || this.request.getParameter(""page"").toString().trim().length() <= 0) {
            page = 1;
        } else {
            page = Integer.parseInt(this.request.getParameter(""page"").toString());
        }

        int startIndex = (page - 1) * pageSize;
        this.setVariable(""search.title"", ""无相关结果 - "");

        if (query.trim().length() > 0) {
            query = StringUtilities.htmlSpecialChars(query);
            if (query.indexOf('|') != -1) {
                String[] q = query.split(""|"");
                query = q[0];
            }

            query = query.trim();
            keywords = query.split("" "");

            this.setVariable(""keyword"", query);
            this.setVariable(""search.title"", query + "" - "");
        } else {
            this.setVariable(""keyword"", """");
            return this;
        }

        StringBuilder condition = new StringBuilder();
        int i = 0, j, k = 0;
        String[] _keywords = new String[keywords.length];
        while (i < keywords.length) {
            _keywords[i] = ""%"" + keywords[i] + ""%"";
            if (condition.length() == 0) {
                condition.append("" bible.content like ? "");
            } else {
                condition.append("" AND bible.content like ? "");
            }
            i++;
        }

        Locale locale = this.getLocale();
        if (condition.length() == 0)
            condition.append("" book.language='"").append(locale).append(""' "");
        else
            condition.append("" AND book.language='"").append(locale).append(""' "");

        book book = new book();
        bible bible = new bible();
        if (locale.toString().equalsIgnoreCase(Locale.US.toString())) {
            bible.setTableName(""NIV"");
        } else if (locale.toString().equalsIgnoreCase(Locale.UK.toString())) {
            bible.setTableName(""ESV"");
        } else {
            bible.setTableName(locale.toString());
        }

        String SQL = ""SELECT bible.*,book.book_name FROM "" + bible.getTableName()
                + "" as bible left join "" + book.getTableName()
                + "" as book on bible.book_id=book.book_id where "" + condition
                + "" order by bible.book_id,bible.chapter_id limit "" + startIndex + "",""
                + pageSize;
        String look = ""SELECT count(bible.id) AS size FROM "" + bible.getTableName()
                + "" as bible left join "" + book.getTableName()
                + "" as book on bible.book_id=book.book_id where "" + condition;

        Table vtable = bible.find(SQL, _keywords);
        boolean noResult = vtable.size() > 0;

        if (!noResult && query.length() > 0) {
            try {
                Table list = book.findWith(""WHERE language=? and book_name=?"",
                        new Object[]{this.getLocale().toString(), query});
                if (list.size() > 0) {
                    this.response = (Response) this.context
                            .getAttribute(HTTP_RESPONSE);

                    Reforward reforward = new Reforward(request, response);
                    query = URLEncoder.encode(query, ""utf-8"");
                    reforward.setDefault(this.context.getAttribute(""HTTP_HOST"") + query);
                    reforward.forward();
                    return reforward;
                }
            } catch (ApplicationException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (UnsupportedEncodingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        Row found = bible.findOne(look, _keywords);

        long startTime = System.currentTimeMillis();
        Pager pager = new Pager();
        pager.setPageSize(pageSize);
        pager.setCurrentPage(page);
        pager.setListSize(found.getFieldInfo(""size"").intValue());

        Field field;
        int next = pager.getStartIndex();// 此位置即为当前页的第一条记录的ID

        html.append(""<ol class=\""searchresults\"" start=\"""").append(next).append(""\"">\r\n"");

        String finded, word;
        Row row;
        Enumeration<Row> table = vtable.elements();
        int n = 0;
        while (table.hasMoreElements()) {
            row = table.nextElement();
            Iterator<Field> iterator = row.iterator();

            n++;
            while (iterator.hasNext()) {
                field = iterator.next();
                finded = field.get(""content"").value().toString();

                j = 0;
                while (j < keywords.length) {
                    finded = StringUtilities.sign(finded, keywords[j++]);
                }

                html.append(""<li""
                        + (n % 2 == 0 ? "" class=\""even\"""" : "" class=\""odd\"""")
                        + ""><a href=\""""
                        + this.context.getAttribute(""HTTP_HOST"")
                        + ""bible/""
                        + field.get(""book_id"").value().toString()
                        + ""/""
                        + field.get(""chapter_id"").value().toString()
                        + ""/""
                        + field.get(""part_id"").value().toString()
                        + ""\"" target=\""_blank\"">""
                        + this.setText(""search.bible.info"", field.get(""book_name"").value()
                        .toString(), field.get(""chapter_id"").value().toString(), field
                        .get(""part_id"").value().toString()) + ""</a><p>"" + finded
                        + ""</p></li> \r\n"");
                next++;
            }
        }

        Table ktable;
        Row krow;
        while (k < keywords.length && noResult) {
            word = keywords[k++];
            keyword keyword = new keyword();
            keyword.setKeyword(word);
            ktable = keyword.setRequestFields(""id,visit"").findWith(""WHERE keyword=?"",
                    new Object[]{word});

            if (ktable.size() == 0) {
                keyword.setVisit(0);
                keyword.append();
            } else {
                krow = ktable.get(0);
                keyword.setId(krow.getFieldInfo(""id"").value());
                keyword.setVisit(krow.getFieldInfo(""visit"").intValue() + 1);
                keyword.update();
            }
        }
        html.append(""</ol>\r\n"");

        String actionURL = this.context.getAttribute(""HTTP_HOST"") + ""bible/search/""
                + query + ""&page"";
        pager.setFirstPageText(this.getProperty(""page.first.text""));
        pager.setLastPageText(this.getProperty(""page.last.text""));
        pager.setCurrentPageText(this.getProperty(""page.current.text""));
        pager.setNextPageText(this.getProperty(""page.next.text""));
        pager.setEndPageText(this.getProperty(""page.end.text""));
        pager.setControlBarText(this.getProperty(""page.controlbar.text""));

        html.append(""<div class=\""pagination\"" style=\""cursor:default\"">""
                + pager.getPageControlBar(actionURL) + ""</div>\r\n"");
        html.append(""<!-- ""
                + (System.currentTimeMillis() - startTime) + "" -->"");

        int start = page - 1 == 0 ? 1 : (page - 1) * pageSize + 1, end = page
                * pageSize;

        this.setVariable(""start"", String.valueOf(start));
        this.setVariable(""end"", String.valueOf(end));
        this.setVariable(""size"", String.valueOf(pager.getSize()));
        this.setVariable(""value"", html.toString());
        this.setVariable(""action"", this.config.get(""default.base_url"")
                + this.context.getAttribute(""REQUEST_ACTION"").toString());

        this.setText(""search.info"", start, end, query, pager.getSize());

        Session session = request.getSession();
        if (session.getAttribute(""usr"") != null) {
            this.usr = (User) session.getAttribute(""usr"");

            this.setVariable(""user.status"", """");
            this.setVariable(""user.profile"",
                    ""<a href=\""javascript:void(0)\"" onmousedown=\""profileMenu.show(event,'1')\"">""
                            + this.usr.getEmail() + ""</a>"");
        } else {
            this.setVariable(""user.status"", ""<a href=\"""" + this.getLink(""user/login"")
                    + ""\"">"" + this.getProperty(""page.login.caption"") + ""</a>"");
            this.setVariable(""user.profile"", """");
        }

        return this;
    }",1
"void setChain(BoundSqlInterceptor.Chain chain) {
        this.chain = chain;
    }",0
"@Deprecated
    public BaseObject updateObjectFromRequest(String className, String prefix, XWikiContext context)
        throws XWikiException
    {
        return updateObjectFromRequest(className, prefix, 0, context);
    }",0
"private boolean exitPublicInterface() {
		return recursionBreak.get().getAndDecrement() > 0;
	}",0
"int getLaunchedFromPid() {
        return launchedFromPid;
    }",0
"@GET
    @Path(""/"")
    @Produces(MediaType.APPLICATION_JSON)
    public List<String> getFiles(@QueryParam(""changedFilesOnly"") boolean changedFilesOnly, @Context SecurityContext securityContext) {
        if (!securityContext.isUserInRole(Authentication.ROLE_FILESYSTEM_EDITOR)) {
            throw new ForbiddenException(""FILESYSTEM EDITOR role is required for enumerating files."");
        }

        try {
            return Files.find(etcFolder, 4, (path, basicFileAttributes) -> isSupportedExtension(path), FileVisitOption.FOLLOW_LINKS)
                    .filter(p -> !p.equals(USERS_XML) || securityContext.isUserInRole(Authentication.ROLE_ADMIN))
                    .map(p -> etcFolder.relativize(p).toString())
                    .filter(p -> !changedFilesOnly || !doesFileExistAndMatchContentsWithEtcPristine(p, securityContext))
                    .sorted()
                    .collect(Collectors.toList());
        } catch (IOException e) {
            throw new RuntimeException(""Failed to enumerate files in path: "" + etcFolder, e);
        }
    }",1
"@Override
    public void onServerCertificateAvailable(
            int depth,
            byte[] subjectBytes,
            byte[] certHashBytes,
            byte[] certBytes) {
        synchronized (mLock) {
            // OpenSSL default maximum depth is 100.
            if (depth < 0 || depth > 100) {
                mNetworkHal.logCallback(""onServerCertificateAvailable: invalid depth "" + depth);
                return;
            }
            if (null == subjectBytes) {
                mNetworkHal.logCallback(""onServerCertificateAvailable: subject is null."");
                return;
            }
            if (null == certHashBytes) {
                mNetworkHal.logCallback(""onServerCertificateAvailable: cert hash is null."");
                return;
            }
            if (null == certBytes) {
                mNetworkHal.logCallback(""onServerCertificateAvailable: cert is null."");
                return;
            }

            mNetworkHal.logCallback(""onServerCertificateAvailable: ""
                    + "" depth="" + depth
                    + "" subjectBytes size="" + subjectBytes.length
                    + "" certHashBytes size="" + certHashBytes.length
                    + "" certBytes size="" + certBytes.length);

            if (0 == certHashBytes.length) return;
            if (0 == certBytes.length) return;

            String subject = byteArrayToString(subjectBytes);
            if (null == subject) {
                mNetworkHal.logCallback(
                        ""onServerCertificateAvailable: cannot convert subject bytes to string."");
                return;
            }
            String certHash = byteArrayToString(certHashBytes);
            if (null == subject) {
                mNetworkHal.logCallback(
                        ""onServerCertificateAvailable: cannot convert cert hash bytes to string."");
                return;
            }
            X509Certificate cert = null;
            try {
                CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
                InputStream in = new ByteArrayInputStream(certBytes);
                cert = (X509Certificate) certFactory.generateCertificate(in);
            } catch (CertificateException e) {
                cert = null;
                mNetworkHal.logCallback(
                        ""onServerCertificateAvailable: ""
                        + ""Failed to get instance for CertificateFactory: "" + e);
            } catch (IllegalArgumentException e) {
                cert = null;
                mNetworkHal.logCallback(
                        ""onServerCertificateAvailable: Failed to decode the data: "" + e);
            }
            if (null == cert) {
                mNetworkHal.logCallback(
                        ""onServerCertificateAvailable: Failed to read certificate."");
                return;
            }

            mNetworkHal.logCallback(""onServerCertificateAvailable:""
                    + "" depth="" + depth
                    + "" subject="" + subject
                    + "" certHash="" + certHash
                    + "" cert="" + cert);
            mWifiMonitor.broadcastCertificationEvent(
                    mIfaceName, mFrameworkNetworkId, mSsid, depth,
                    new CertificateEventInfo(cert, certHash));
        }
    }",1
"@Override
    protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {
        Http2FrameHeaderParser frameParser;
        do {
            frameParser = parseFrameNoContinuation(data);
            // if the frame requires continuation and there is remaining data in the buffer
            // it should be consumed cos spec ensures the next frame is the continuation
        } while(frameParser != null && frameParser.getContinuationParser() != null && data.hasRemaining());
        return frameParser;
    }",1
"private static void quietTrySocketClose(Socket socket) {
        if (socket != null)
            try { socket.close(); } catch (Exception _e) {/*ignore exceptions*/}
    }",0
"@Override
        public void onReceive(Context context, Intent intent) {
            if (Intent.ACTION_USER_SWITCHED.equals(intent.getAction())) {
                // tickle the settings observer: this first ensures that we're
                // observing the relevant settings for the newly-active user,
                // and then updates our own bookkeeping based on the now-
                // current user.
                mSettingsObserver.onChange(false);

                // force a re-application of focused window sysui visibility.
                // the window may never have been shown for this user
                // e.g. the keyguard when going through the new-user setup flow
                synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
                    mLastSystemUiFlags = 0;
                    updateSystemUiVisibilityLw();
                }
            }
        }",0
"protected final GF2Polynomial[] invertMatrix(GF2Polynomial[] matrix)
    {
        GF2Polynomial[] a = new GF2Polynomial[matrix.length];
        GF2Polynomial[] inv = new GF2Polynomial[matrix.length];
        GF2Polynomial dummy;
        int i, j;
        // initialize a as a copy of matrix and inv as E(inheitsmatrix)
        for (i = 0; i < mDegree; i++)
        {
            a[i] = new GF2Polynomial(matrix[i]);
            inv[i] = new GF2Polynomial(mDegree);
            inv[i].setBit(mDegree - 1 - i);
        }
        // construct triangle matrix so that for each a[i] the first i bits are
        // zero
        for (i = 0; i < mDegree - 1; i++)
        {
            // find column where bit i is set
            j = i;
            while ((j < mDegree) && !a[j].testBit(mDegree - 1 - i))
            {
                j++;
            }
            if (j >= mDegree)
            {
                throw new RuntimeException(
                    ""GF2nField.invertMatrix: Matrix cannot be inverted!"");
            }
            if (i != j)
            { // swap a[i]/a[j] and inv[i]/inv[j]
                dummy = a[i];
                a[i] = a[j];
                a[j] = dummy;
                dummy = inv[i];
                inv[i] = inv[j];
                inv[j] = dummy;
            }
            for (j = i + 1; j < mDegree; j++)
            { // add column i to all columns>i
                // having their i-th bit set
                if (a[j].testBit(mDegree - 1 - i))
                {
                    a[j].addToThis(a[i]);
                    inv[j].addToThis(inv[i]);
                }
            }
        }
        // construct Einheitsmatrix from a
        for (i = mDegree - 1; i > 0; i--)
        {
            for (j = i - 1; j >= 0; j--)
            { // eliminate the i-th bit in all
                // columns < i
                if (a[j].testBit(mDegree - 1 - i))
                {
                    a[j].addToThis(a[i]);
                    inv[j].addToThis(inv[i]);
                }
            }
        }
        return inv;
    }",1
"public void setContentType(ContentType contentType)
    {
        setContentType(contentType.toString());

        // Make sure the editor type is compatible
        EditorType compatible = getEditorType(contentType, null);
        if (compatible != null) {
            setEditor(compatible);
        }
    }",0
"@Column(name = ""ip"", nullable = false, length = 130)
    public String getIp() {
        return this.ip;
    }",1
"public static void loadConfig() {

		Properties props = loadProperties();
		if (props.isEmpty()) {
			return;
		}

		Config cfg = Config.getInstance();

		cfg.setProgramVersion(getStringProperty(props, PROGRAM_VERSION, Program.getInstance().getVersion()));
		cfg.setDefaultFontsize(getIntProperty(props, DEFAULT_FONTSIZE, cfg.getDefaultFontsize()));
		cfg.setPropertiesPanelFontsize(getIntProperty(props, PROPERTIES_PANEL_FONTSIZE, cfg.getPropertiesPanelFontsize()));
		cfg.setDefaultFontFamily(getStringProperty(props, DEFAULT_FONTFAMILY, cfg.getDefaultFontFamily()));
		SharedConfig.getInstance().setShow_stickingpolygon(getBoolProperty(props, SHOW_STICKINGPOLYGON, SharedConfig.getInstance().isShow_stickingpolygon()));
		cfg.setShow_grid(getBoolProperty(props, SHOW_GRID, cfg.isShow_grid()));
		cfg.setEnable_custom_elements(getBoolProperty(props, ENABLE_CUSTOM_ELEMENTS, cfg.isEnable_custom_elements()));
		cfg.setUiManager(getStringProperty(props, UI_MANAGER, cfg.getUiManager()));
		cfg.setPrintPadding(getIntProperty(props, PRINT_PADDING, cfg.getPrintPadding()));
		cfg.setPdfExportFont(getStringProperty(props, PDF_EXPORT_FONT, cfg.getPdfExportFont()));
		cfg.setPdfExportFontBold(getStringProperty(props, PDF_EXPORT_FONT_BOLD, cfg.getPdfExportFontBold()));
		cfg.setPdfExportFontItalic(getStringProperty(props, PDF_EXPORT_FONT_ITALIC, cfg.getPdfExportFontItalic()));
		cfg.setPdfExportFontBoldItalic(getStringProperty(props, PDF_EXPORT_FONT_BOLDITALIC, cfg.getPdfExportFontBoldItalic()));
		cfg.setCheckForUpdates(getBoolProperty(props, CHECK_FOR_UPDATES, cfg.isCheckForUpdates()));
		cfg.setSecureXmlProcessing(getBoolProperty(props, SECURE_XML_PROCESSING, cfg.isSecureXmlProcessing()));
		cfg.setOpenFileHome(getStringProperty(props, OPEN_FILE_HOME, cfg.getOpenFileHome()));
		cfg.setSaveFileHome(getStringProperty(props, SAVE_FILE_HOME, cfg.getSaveFileHome()));
		SharedConfig.getInstance().setDev_mode(getBoolProperty(props, DEV_MODE, SharedConfig.getInstance().isDev_mode()));
		cfg.setLastUsedPalette(getStringProperty(props, LAST_USED_PALETTE, cfg.getLastUsedPalette()));
		cfg.setMain_split_position(getIntProperty(props, MAIN_SPLIT_POSITION, cfg.getMain_split_position()));
		cfg.setRight_split_position(getIntProperty(props, RIGHT_SPLIT_POSITION, cfg.getRight_split_position()));
		cfg.setMail_split_position(getIntProperty(props, MAIL_SPLIT_POSITION, cfg.getMail_split_position()));
		cfg.setStart_maximized(getBoolProperty(props, START_MAXIMIZED, cfg.isStart_maximized()));

		// In case of start_maximized=true we don't store any size or location information
		if (!cfg.isStart_maximized()) {
			cfg.setProgram_size(getDimensionProperty(props, PROGRAM_SIZE, cfg.getProgram_size()));
			cfg.setProgram_location(getPointProperty(props, PROGRAM_LOCATION, cfg.getProgram_location()));
		}

		String recentFiles = props.getProperty(RECENT_FILES);
		if (recentFiles != null) {
			RecentlyUsedFilesList.getInstance().addAll(Arrays.asList(props.getProperty(RECENT_FILES).split(""\\|"")));
		}

		/* Mail */
		ConfigMail cfgMail = ConfigMail.getInstance();
		cfgMail.setMail_smtp(getStringProperty(props, MAIL_SMTP, cfgMail.getMail_smtp()));
		cfgMail.setMail_smtp_auth(getBoolProperty(props, MAIL_SMTP_AUTH, cfgMail.isMail_smtp_auth()));
		cfgMail.setMail_smtp_user(getStringProperty(props, MAIL_SMTP_USER, cfgMail.getMail_smtp_user()));
		cfgMail.setMail_smtp_pw_store(getBoolProperty(props, MAIL_SMTP_PW_STORE, cfgMail.isMail_smtp_pw_store()));
		cfgMail.setMail_smtp_pw(getStringProperty(props, MAIL_SMTP_PW, cfgMail.getMail_smtp_pw()));
		cfgMail.setMail_from(getStringProperty(props, MAIL_FROM, cfgMail.getMail_from()));
		cfgMail.setMail_to(getStringProperty(props, MAIL_TO, cfgMail.getMail_to()));
		cfgMail.setMail_cc(getStringProperty(props, MAIL_CC, cfgMail.getMail_cc()));
		cfgMail.setMail_bcc(getStringProperty(props, MAIL_BCC, cfgMail.getMail_bcc()));
		cfgMail.setMail_xml(getBoolProperty(props, MAIL_XML, cfgMail.isMail_xml()));
		cfgMail.setMail_gif(getBoolProperty(props, MAIL_GIF, cfgMail.isMail_gif()));
		cfgMail.setMail_pdf(getBoolProperty(props, MAIL_PDF, cfgMail.isMail_pdf()));

		/* Generate Class Element Options */
		ConfigClassGen genCfg = ConfigClassGen.getInstance();
		genCfg.setGenerateClassPackage(getBoolProperty(props, GENERATE_CLASS_PACKAGE, genCfg.isGenerateClassPackage()));
		genCfg.setGenerateClassFields(FieldOptions.getEnum(getStringProperty(props, GENERATE_CLASS_FIELDS, genCfg.getGenerateClassFields().toString())));
		genCfg.setGenerateClassMethods(MethodOptions.getEnum(getStringProperty(props, GENERATE_CLASS_METHODS, genCfg.getGenerateClassMethods().toString())));
		genCfg.setGenerateClassSignatures(SignatureOptions.getEnum(getStringProperty(props, GENERATE_CLASS_SIGNATURES, genCfg.getGenerateClassSignatures().toString())));
		genCfg.setGenerateClassSortings(SortOptions.getEnum(getStringProperty(props, GENERATE_CLASS_SORTINGS, genCfg.getGenerateClassSortings().toString())));

	}",1
"@Override
	public boolean loginValidate(String userName, String password, String email) {
		String sql = ""select * from voter_table where voter_name=? and email=?"";
		try {
			ps = DbUtil.getConnection().prepareStatement(sql);
			ps.setString(1, userName);
			ps.setString(2, email);
			ResultSet rs = ps.executeQuery();
			if (rs.next()) {
				String cipherText = rs.getString(""password"");
				return SHA256.validatePassword(password, cipherText);
			}
		} catch (ClassNotFoundException | SQLException e) {
			e.printStackTrace();
		}
		return false;
	}",1
"private void enforceDebuggable(ApplicationInfo info) {
        if (!Build.IS_DEBUGGABLE && (info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
            throw new SecurityException(""Process not debuggable: "" + info.packageName);
        }
    }",0
"@Override
    public boolean serveStaticResource(HttpServletRequest request,
            HttpServletResponse response) throws IOException {

        String filenameWithPath = getRequestFilename(request);
        if (HandlerHelper.isPathUnsafe(filenameWithPath)) {
            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,
                    filenameWithPath);
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            return true;
        }

        URL resourceUrl = null;
        if (isAllowedVAADINBuildUrl(filenameWithPath)) {
            resourceUrl = servletService.getClassLoader()
                    .getResource(""META-INF"" + filenameWithPath);
        }
        if (resourceUrl == null) {
            resourceUrl = servletService.getStaticResource(filenameWithPath);
        }
        if (resourceUrl == null && shouldFixIncorrectWebjarPaths()
                && isIncorrectWebjarPath(filenameWithPath)) {
            // Flow issue #4601
            resourceUrl = servletService.getStaticResource(
                    fixIncorrectWebjarPath(filenameWithPath));
        }

        if (resourceUrl == null) {
            // Not found in webcontent or in META-INF/resources in some JAR
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return true;
        }

        // There is a resource!

        // Intentionally writing cache headers also for 304 responses
        writeCacheHeaders(filenameWithPath, response);

        long timestamp = writeModificationTimestamp(resourceUrl, request,
                response);
        if (browserHasNewestVersion(request, timestamp)) {
            // Browser is up to date, nothing further to do than set the
            // response code
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            return true;
        }
        responseWriter.writeResponseContents(filenameWithPath, resourceUrl,
                request, response);
        return true;
    }",1
"public boolean isUrlOk() {
		// ::comment when __CORE__
		if (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)
			// In SANDBOX, we cannot read any URL
			return false;

		if (SecurityUtils.getSecurityProfile() == SecurityProfile.LEGACY)
			return true;

		if (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE)
			// We are UNSECURE anyway
			return true;

		if (isInUrlAllowList())
			// ::done
			return true;
		// ::comment when __CORE__

		if (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET) {
			if (forbiddenURL(cleanPath(internal.toString())))
				return false;

			final int port = internal.getPort();
			// Using INTERNET profile, port 80 and 443 are ok
			return port == 80 || port == 443 || port == -1;
		}
		return false;
		// ::done
	}",1
"@Override
    public void onPerform(CommandEvent commandEvent) {
        if (!commandEvent.getGuild().getSelfMember().hasPermission(Permission.MANAGE_WEBHOOKS)) {
            Main.getInstance().getCommandManager().sendMessage(""I need the permission `Manage Webhooks` to use this command!"", commandEvent.getChannel(), commandEvent.getInteractionHook());
        }

        if (commandEvent.isSlashCommand()) {
            Main.getInstance().getCommandManager().sendMessage(""This Command doesn't support slash commands yet."", commandEvent.getChannel(), commandEvent.getInteractionHook());
            return;
        }

        if(commandEvent.getArguments().length == 1) {
            if(commandEvent.getArguments()[0].equalsIgnoreCase(""list"")) {
                StringBuilder end = new StringBuilder(""```\n"");

                for(String users : Main.getInstance().getSqlConnector().getSqlWorker().getAllYouTubeChannels(commandEvent.getGuild().getId())) {
                    end.append(users).append(""\n"");
                }

                end.append(""```"");

                Main.getInstance().getCommandManager().sendMessage(end.toString(), 10, commandEvent.getChannel(), commandEvent.getInteractionHook());

            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""youtubenotifier list/add/remove"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else if(commandEvent.getArguments().length == 3) {

            if (commandEvent.getMessage().getMentions().getChannels(TextChannel.class).isEmpty() ||
                    !commandEvent.getMessage().getMentions().getChannels(TextChannel.class).get(0).getGuild().getId().equals(commandEvent.getGuild().getId())) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""youtubenotifier add/remove YouTubeChannel #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
                return;
            }

            String name = commandEvent.getArguments()[1];
            if (commandEvent.getArguments()[0].equalsIgnoreCase(""add"")) {
                commandEvent.getMessage().getMentions().getChannels(TextChannel.class).get(0).createWebhook(""Ree6-YouTubeNotifier-"" + name).queue(w -> Main.getInstance().getSqlConnector().getSqlWorker().addYouTubeWebhook(commandEvent.getGuild().getId(), w.getId(), w.getToken(), name));
                Main.getInstance().getCommandManager().sendMessage(""A YouTube Notifier has been created for the User "" + name + ""!"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());

                if (!Main.getInstance().getNotifier().isYouTubeRegistered(name)) {
                    Main.getInstance().getNotifier().registerYouTubeChannel(name);
                }
            } else if (commandEvent.getArguments()[0].equalsIgnoreCase(""remove"")) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""youtubenotifier remove YouTubeChannel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""youtubenotifier add YouTubeChannel #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else if(commandEvent.getArguments().length == 2) {
            String name = commandEvent.getArguments()[1];
            if(commandEvent.getArguments()[0].equalsIgnoreCase(""remove"")) {
                Main.getInstance().getSqlConnector().getSqlWorker().removeYouTubeWebhook(commandEvent.getGuild().getId(), name);
                Main.getInstance().getCommandManager().sendMessage(""A YouTube Notifier has been removed from the User "" + name + ""!"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());

                if (Main.getInstance().getNotifier().isYouTubeRegistered(name)) {
                    Main.getInstance().getNotifier().unregisterYouTubeChannel(name);
                }
            } else if (commandEvent.getArguments()[0].equalsIgnoreCase(""add"")) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""youtubenotifier add YouTubeChannel #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""youtubenotifier remove YouTubeChannel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else {
            Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""youtubenotifier list/add/remove"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
        }
        Main.getInstance().getCommandManager().deleteMessage(commandEvent.getMessage(), commandEvent.getInteractionHook());
    }",1
"@Override
    public SSLEngineResult.HandshakeStatus getHandshakeStatus() {
        debug(""JSSEngine: getHandshakeStatus()"");

        // If task is NULL, we need to update the state to check if the
        // task has been ""run"". Even if it isn't, it would be good to
        // update the status here as well. However, we DO NOT want to
        // call updateHandshakeState() in the event we have a task to
        // run: we need to run it still!
        if (checkNeedCertValidation()) {
            return handshake_state;
        }

        // Always update the handshake state; this ensures that we catch
        // looping due to missing data and flip our expected direction.
        updateHandshakeState();

        return handshake_state;
    }",0
"private void cancel() {
            synchronized (mInnerLock) {
                mIsFinished = true;
                cancelAlarmLocked();
                try {
                    mIActivityManager.unregisterUidObserver(mObserver);
                } catch (RemoteException e) {
                    Log.e(LOG_TAG, ""Unable to unregister uid observer."", e);
                }
            }
        }",1
"public String toXML() throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();

        Element pdElement = toDOM(document);
        document.appendChild(pdElement);

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
        transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""4"");

        DOMSource domSource = new DOMSource(document);

        StringWriter sw = new StringWriter();
        StreamResult streamResult = new StreamResult(sw);
        transformer.transform(domSource, streamResult);
        return sw.toString();
    }",1
"public void stopLoading() {
        if (mWebContents != null) mWebContents.stop();
    }",0
"public Resource getWorkspaceResource() {
        return new Resource(getFullDisplayName()+"" workspace"");
    }",0
"@GuardedBy({""mPm.mInstallLock"", ""mPm.mLock""})
    private AndroidPackage scanSystemPackageLI(File scanFile, int parseFlags, int scanFlags,
            UserHandle user) throws PackageManagerException {
        if (DEBUG_INSTALL) Slog.d(TAG, ""Parsing: "" + scanFile);

        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, ""parsePackage"");
        final ParsedPackage parsedPackage;
        try (PackageParser2 pp = mPm.mInjector.getScanningPackageParser()) {
            parsedPackage = pp.parsePackage(scanFile, parseFlags, false);
        } finally {
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }

        // Static shared libraries have synthetic package names
        if (parsedPackage.isStaticSharedLibrary()) {
            PackageManagerService.renameStaticSharedLibraryPackage(parsedPackage);
        }

        return addForInitLI(parsedPackage, parseFlags, scanFlags, user);
    }",0
"protected void setLocaleAndContentFields(DocumentReference documentReference, SolrInputDocument solrDocument,
        BaseProperty<ObjectPropertyReference> objectProperty) throws Exception
    {
        PropertyClass propertyClass = objectProperty.getPropertyClass(this.xcontextProvider.get());
        // Do the work for each locale.
        for (Locale documentLocale : getLocales(documentReference, null)) {
            solrDocument.addField(FieldUtils.LOCALES, documentLocale);

            setPropertyValue(solrDocument, objectProperty, propertyClass, documentLocale);
        }

        // We can`t rely on the schema's copyField here because we would trigger it for each locale. Doing the copy to
        // the text_general field manually.
        setPropertyValue(solrDocument, objectProperty, propertyClass, null);
    }",1
"@Provides
  @Singleton
  Signer signer(ClientSideSessionConfig config) {
    byte[] token = config.getSecretToken().getBytes(CharsetUtil.ISO_8859_1);
    return new DefaultSigner(new SecretKeySpec(token, config.getMacAlgorithm()));
  }",1
"public static Document toXml(final List<IBaseDataObject> list) {
        final Element root = new Element(""payload-list"");
        for (final IBaseDataObject d : list) {
            final Document doc = toXml(d);
            root.addContent(doc.detachRootElement());
            logger.debug(""Adding xml content for "" + d.shortName() + "" to document"");
        }
        return new Document(root);
    }",1
"private void updateHomepagePaddings() {
        if (!mIsEmbeddingActivityEnabled) {
            return;
        }
        if (mIsTwoPane) {
            int padding = getResources().getDimensionPixelSize(
                    R.dimen.homepage_padding_horizontal_two_pane);
            mMainFragment.setPaddingHorizontal(padding);
        } else {
            mMainFragment.setPaddingHorizontal(0);
        }
        mMainFragment.updatePreferencePadding(mIsTwoPane);
    }",0
"private void readStructure(Element design, DesignContext context) {
        if (design.children().isEmpty()) {
            return;
        }
        if (design.children().size() > 1
                || !design.child(0).tagName().equals(""table"")) {
            throw new DesignException(
                    ""Grid needs to have a table element as its only child"");
        }
        Element table = design.child(0);

        Elements colgroups = table.getElementsByTag(""colgroup"");
        if (colgroups.size() != 1) {
            throw new DesignException(
                    ""Table element in declarative Grid needs to have a""
                            + "" colgroup defining the columns used in Grid"");
        }

        List<DeclarativeValueProvider<T>> providers = new ArrayList<>();
        for (Element col : colgroups.get(0).getElementsByTag(""col"")) {
            String id = DesignAttributeHandler.readAttribute(""column-id"",
                    col.attributes(), null, String.class);

            // If there is a property with a matching name available,
            // map to that
            Optional<PropertyDefinition<T, ?>> property = propertySet
                    .getProperties().filter(p -> p.getName().equals(id))
                    .findFirst();
            Column<T, ?> column;
            if (property.isPresent()) {
                column = addColumn(id);
            } else {
                DeclarativeValueProvider<T> provider = new DeclarativeValueProvider<>();
                column = createColumn(provider, ValueProvider.identity(),
                        new HtmlRenderer());
                addColumn(getGeneratedIdentifier(), column);
                if (id != null) {
                    column.setId(id);
                }
                providers.add(provider);
            }
            column.readDesign(col, context);
        }

        for (Element child : table.children()) {
            if (child.tagName().equals(""thead"")) {
                getHeader().readDesign(child, context);
            } else if (child.tagName().equals(""tbody"")) {
                readData(child, providers);
            } else if (child.tagName().equals(""tfoot"")) {
                getFooter().readDesign(child, context);
            }
        }

        // Sync default header captions to column captions
        if (getDefaultHeaderRow() != null) {
            for (Column<T, ?> c : getColumns()) {
                HeaderCell headerCell = getDefaultHeaderRow().getCell(c);
                if (headerCell.getCellType() == GridStaticCellType.TEXT) {
                    c.setCaption(headerCell.getText());
                }
            }
        }
    }",0
"public void update(AsyncResult<SQLConnection> conn, String table, Object entity, String jsonbField, String whereClause, boolean returnUpdatedIds, Handler<AsyncResult<UpdateResult>> replyHandler) {
    if (conn.failed()) {
      replyHandler.handle(Future.failedFuture(conn.cause()));
      return;
    }
    vertx.runOnContext(v -> {
      long start = System.nanoTime();
      StringBuilder sb = new StringBuilder();
      sb.append(whereClause);
      StringBuilder returning = new StringBuilder();
      if (returnUpdatedIds) {
        returning.append(RETURNING_ID);
      }
      try {
        String q = UPDATE + schemaName + DOT + table + SET + jsonbField + "" = ?::jsonb "" + whereClause
          + SPACE + returning;
        log.debug(""update query = "" + q);
        String pojo = pojo2json(entity);
        conn.result().updateWithParams(q, new JsonArray().add(pojo), query -> {
          if (query.failed()) {
            log.error(query.cause().getMessage(), query.cause());
            replyHandler.handle(Future.failedFuture(query.cause()));
          } else {
            replyHandler.handle(Future.succeededFuture(query.result()));
          }
          statsTracker(UPDATE_STAT_METHOD, table, start);
        });
      } catch (Exception e) {
        log.error(e.getMessage(), e);
        replyHandler.handle(Future.failedFuture(e));
      }
    });
  }",0
"private void notifyCreated(int moveId, Bundle extras) {
            Slog.v(TAG, ""Move "" + moveId + "" created "" + extras.toString());

            final SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.arg2 = extras;
            obtainMessage(MSG_CREATED, args).sendToTarget();
        }",0
"@Override
    public int getPermissionFlags(String name, String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 0;
        }

        enforceGrantRevokeRuntimePermissionPermissions(""getPermissionFlags"");

        enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false,
                ""getPermissionFlags"");

        synchronized (mPackages) {
            final PackageParser.Package pkg = mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException(""Unknown package: "" + packageName);
            }

            final BasePermission bp = mSettings.mPermissions.get(name);
            if (bp == null) {
                throw new IllegalArgumentException(""Unknown permission: "" + name);
            }

            SettingBase sb = (SettingBase) pkg.mExtras;
            if (sb == null) {
                throw new IllegalArgumentException(""Unknown package: "" + packageName);
            }

            PermissionsState permissionsState = sb.getPermissionsState();
            return permissionsState.getPermissionFlags(name, userId);
        }
    }",0
"public String getRealAssetPath(String inode, String fileName, String ext) {
        String _inode = inode;
        String path = """";

        String realPath = Config.getStringProperty(""ASSET_REAL_PATH"");
        if (UtilMethods.isSet(realPath) && !realPath.endsWith(java.io.File.separator))
            realPath = realPath + java.io.File.separator;

        String assetPath = Config.getStringProperty(""ASSET_PATH"", DEFAULT_RELATIVE_ASSET_PATH);
        if (UtilMethods.isSet(assetPath) && !assetPath.endsWith(java.io.File.separator))
            assetPath = assetPath + java.io.File.separator;

        path = ((!UtilMethods.isSet(realPath)) ? assetPath : realPath)
                + _inode.charAt(0) + java.io.File.separator + _inode.charAt(1)
                + java.io.File.separator + _inode+ java.io.File.separator + ""fileAsset"" + java.io.File.separator + fileName + ""."" + ext;

        if (!UtilMethods.isSet(realPath))
            return FileUtil.getRealPath(path);
        else
            return path;

    }",1
"@Override
    protected JDBCDataStore createDataStoreInternal(JDBCDataStore dataStore, Map<String, ?> params)
            throws IOException {
        return delegate.createDataStoreInternal(dataStore, params);
    }",0
"public SecurityCheck getSecuritySettings() {
        checkTrusted();
        return SecurityCheck.INSTANCE;
    }",0
"private void handleFingerprintAuthenticated(int authUserId) {
        try {
            final int userId;
            try {
                userId = ActivityManagerNative.getDefault().getCurrentUser().id;
            } catch (RemoteException e) {
                Log.e(TAG, ""Failed to get current user id: "", e);
                return;
            }
            if (userId != authUserId) {
                Log.d(TAG, ""Fingerprint authenticated for wrong user: "" + authUserId);
                return;
            }
            if (isFingerprintDisabled(userId)) {
                Log.d(TAG, ""Fingerprint disabled by DPM for userId: "" + userId);
                return;
            }
            onFingerprintAuthenticated(userId);
        } finally {
            setFingerprintRunningState(FINGERPRINT_STATE_STOPPED);
        }
    }",1
"@Test
  public void getByIdsNull(TestContext context) {
    Async async = context.async();
    createFoo(context).getByIdAsString(FOO, (JsonArray) null, res -> {
      assertSuccess(context, res);
      context.assertTrue(res.result().isEmpty());
      async.complete();
    });
  }",0
"private void verifyContent(byte[] storedMac) throws IOException {
    byte[] calculatedMac = getDecrypter().getCalculatedAuthenticationBytes();
    byte[] first10BytesOfCalculatedMac = new byte[AES_AUTH_LENGTH];
    System.arraycopy(calculatedMac, 0, first10BytesOfCalculatedMac, 0, InternalZipConstants.AES_AUTH_LENGTH);

    if (!Arrays.equals(storedMac, first10BytesOfCalculatedMac)) {
      throw new IOException(""Reached end of data for this entry, but aes verification failed"");
    }
  }",1
"private String getOrMaskValue(String value) {
        if (value == null) {
            return null;
        }
        return maskSensitiveFields ? MASK_FOR_SENSITIVE_DATA : value;
    }",1
"private void resolveEnvVarVals(Properties prop) {
        Set<String> keys = prop.stringPropertyNames();
        for (String key : keys) {
            String val = prop.getProperty(key);
            Matcher matcher = pattern.matcher(val);
            if (matcher.find()) {
                StringBuffer sb = new StringBuffer();
                do {
                    String envVar = matcher.group(1);
                    if (System.getenv(envVar) == null) {
                        throw new IllegalArgumentException(
                                ""Invalid Environment Variable "" + envVar);
                    }
                    matcher.appendReplacement(sb, System.getenv(envVar));
                } while (matcher.find());
                matcher.appendTail(sb);
                prop.setProperty(key, sb.toString());
            }
        }
    }",0
"private void visitorPermission(Invocation ai) {
        ai.invoke();
        String templateName = ai.getReturnValue();
        if (templateName == null) {
            return;
        }
        GlobalResourceHandler.printUserTime(""Template before"");
        String templatePath = TemplateHelper.fullTemplateInfo(ai.getController(), true);
        GlobalResourceHandler.printUserTime(""Template after"");
        TemplateVO templateVO = new TemplateService().getTemplateVO(JFinal.me().getContextPath(), new File(PathKit.getWebRootPath() + templatePath));
        String ext = ZrLogUtil.getViewExt(templateVO.getViewType());
        if (ai.getController().getAttr(""log"") != null) {
            ai.getController().setAttr(""pageLevel"", 1);
        } else if (ai.getController().getAttr(""data"") != null) {
            if (""/"".equals(ai.getActionKey()) && new File(PathKit.getWebRootPath() + templatePath + ""/"" + templateName + ext).exists()) {
                ai.getController().setAttr(""pageLevel"", 2);
            } else {
                templateName = ""page"";
                ai.getController().setAttr(""pageLevel"", 1);
            }
        } else {
            ai.getController().setAttr(""pageLevel"", 2);
        }
        fullDevData(ai.getController());
        String viewPath = templatePath + ""/"" + templateName + ext;
        if (ext.equals("".ftl"")) {
            BlogFrontendFreeMarkerRender render = new BlogFrontendFreeMarkerRender(viewPath);
            render.setContext(ai.getController().getRequest(), ai.getController().getResponse());
            ai.getController().render(render);
        } else {
            ai.getController().render(viewPath);
        }

    }",1
"public void setBody(CharSequence text, boolean withSignature) {
        LogUtils.i(LOG_TAG, ""Body populated, len: %d, sig: %b"", text.length(), withSignature);
        mBodyView.setText(text);
        if (withSignature) {
            appendSignature();
        }
    }",0
"public HttpRequest timeout(final int milliseconds) {
		this.timeout = milliseconds;
		return this;
	}",0
"@Override
    public boolean checkObjectExecutePermission(Class clazz, String methodName)
    {
        Boolean result = null;
        if (methodName != null) {
            for (Map.Entry<Class, Set<String>> classSetEntry : this.whitelistedMethods.entrySet()) {
                if (classSetEntry.getKey().isAssignableFrom(clazz)) {
                    result = classSetEntry.getValue().contains(methodName.toLowerCase());
                    break;
                }
            }
        }

        if (result == null) {
            result = super.checkObjectExecutePermission(clazz, methodName);
        }
        return result;
    }",1
"public List<MetaDataDiff> getMetaDataDiff(String fromRev, XWikiContext context) throws XWikiException
    {
        XWikiDocument revdoc = context.getWiki().getDocument(this, fromRev, context);

        return getMetaDataDiff(revdoc, this, context);
    }",0
"private boolean processSanityChecksLocked(ProcessRecord process) {
        if (process == null || process.thread == null) {
            return false;
        }

        boolean isDebuggable = ""1"".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, ""0""));
        if (!isDebuggable) {
            if ((process.info.flags&ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                return false;
            }
        }

        return true;
    }",0
"public Form<T> bindFromRequest(Http.Request request, String... allowedFields) {
    return bind(
        this.messagesApi.preferred(request).lang(),
        request.attrs(),
        requestData(request),
        requestFileData(request),
        allowedFields);
  }",0
"public static CountingReader getReaderFromBinary(byte[] urlOrBinary, String compressionAlgo) {
        try {
            return getInputStreamFromBinary(urlOrBinary, compressionAlgo).asReader();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }",0
"@Override
    @Nonnull
    public final <E extends KrailEntity<ID, VER>> String entityName(@Nonnull Class<E> entityClass) {
        checkNotNull(entityClass);

        // Get the @Entity annotation to check for name change
        Entity t = entityClass.getAnnotation(Entity.class);

        //If no Table annotation use the default (simple class name)
        return t.name()
                .isEmpty() ? entityClass.getSimpleName() : t.name();


    }",1
"private boolean isDiskCacheHit(final HttpQuery query,
                                 final long end_time,
                                 final int max_age,
                                 final String basepath) throws IOException {
    final String cachepath = basepath + (query.hasQueryStringParam(""ascii"")
                                         ? "".txt"" : "".png"");
    final File cachedfile = new File(cachepath);
    if (cachedfile.exists()) {
      final long bytes = cachedfile.length();
      if (bytes < 21) {  // Minimum possible size for a PNG: 21 bytes.
                         // For .txt files, <21 bytes is almost impossible.
        logWarn(query, ""Cached "" + cachepath + "" is too small (""
                + bytes + "" bytes) to be valid.  Ignoring it."");
        return false;
      }
      if (staleCacheFile(query, end_time, max_age, cachedfile)) {
        return false;
      }
      if (query.hasQueryStringParam(""json"")) {
        HashMap<String, Object> map = loadCachedJson(query, end_time,
            max_age, basepath);
        if (map == null) {
          map = new HashMap<String, Object>();
        }
        map.put(""timing"", query.processingTimeMillis());
        map.put(""cachehit"", ""disk"");
        query.sendReply(JSON.serializeToBytes(map));
      } else if (query.hasQueryStringParam(""png"")
                 || query.hasQueryStringParam(""ascii"")) {
        query.sendFile(cachepath, max_age);
      } else {
        query.sendReply(HttpQuery.makePage(""TSDB Query"", ""Your graph is ready"",
            ""<img src=\"""" + query.request().getUri() + ""&amp;png\""/><br/>""
            + ""<small>(served from disk cache)</small>""));
      }
      graphs_diskcache_hit.incrementAndGet();
      return true;
    }
    // We didn't find an image.  Do a negative cache check.  If we've seen
    // this query before but there was no result, we at least wrote the JSON.
    final HashMap<String, Object> map = loadCachedJson(query, end_time,
        max_age, basepath);
    // If we don't have a JSON file it's a complete cache miss.  If we have
    // one, and it says 0 data points were plotted, it's a negative cache hit.
    if (map == null || !map.containsKey(""plotted"") ||
        ((Integer)map.get(""plotted"")) == 0) {
      return false;
    }
    if (query.hasQueryStringParam(""json"")) {
      map.put(""timing"", query.processingTimeMillis());
      map.put(""cachehit"", ""disk"");
      query.sendReply(JSON.serializeToBytes(map));
    } else if (query.hasQueryStringParam(""png"")) {
      query.sendReply("" "");  // Send back an empty response...
    } else {
        query.sendReply(HttpQuery.makePage(""TSDB Query"", ""No results"",
            ""Sorry, your query didn't return anything.<br/>""
            + ""<small>(served from disk cache)</small>""));
    }
    graphs_diskcache_hit.incrementAndGet();
    return true;
  }",0
"@Override
    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,
            final String authTokenType, final String[] requiredFeatures,
            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {
        Bundle.setDefusable(optionsIn, true);
        int callingUid = Binder.getCallingUid();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""addAccount: accountType "" + accountType
                    + "", response "" + response
                    + "", authTokenType "" + authTokenType
                    + "", requiredFeatures "" + Arrays.toString(requiredFeatures)
                    + "", expectActivityLaunch "" + expectActivityLaunch
                    + "", caller's uid "" + Binder.getCallingUid()
                    + "", pid "" + Binder.getCallingPid()
                    + "", for user id "" + userId);
        }
        Preconditions.checkArgument(response != null, ""response cannot be null"");
        Preconditions.checkArgument(accountType != null, ""accountType cannot be null"");
        // Only allow the system process to add accounts of other users
        if (isCrossUser(callingUid, userId)) {
            throw new SecurityException(
                    String.format(
                            ""User %s trying to add account for %s"" ,
                            UserHandle.getCallingUserId(),
                            userId));
        }

        // Is user disallowed from modifying accounts?
        if (!canUserModifyAccounts(userId, callingUid)) {
            try {
                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,
                        ""User is not allowed to add an account!"");
            } catch (RemoteException re) {
            }
            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);
            return;
        }
        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {
            try {
                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,
                        ""User cannot modify accounts of this type (policy)."");
            } catch (RemoteException re) {
            }
            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,
                    userId);
            return;
        }
        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,
                expectActivityLaunch, optionsIn, userId);
    }",0
"public String getLinkUrl() {
        return linkUrl;
    }",1
"public void parse(final InputSource is) {
        try {
            final SAXParserFactory factory = SAXParserFactory.newInstance();
            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
            final SAXParser parser = factory.newSAXParser();
            parser.parse(is, this);
        } catch (final Exception e) {
            throw new GsaConfigException(""Failed to parse XML file."", e);
        }
    }",1
"@Override
    public Consumer<OutputWriter> jsonWriter(BackupConfig backupConfig) {
        return outputWriter -> BackupConfigRepresenter.toJSON(outputWriter, backupConfig);
    }",0
"protected String getRefreshTokenCookie(String refreshToken, String tokenCookieVal, String accessToken) 
	{
		return refreshToken;
	}",0
"public static Frame readFrom(DataInputStream is, int maxPayloadSize) throws IOException {
        int type;
        int channel;

        try {
            type = is.readUnsignedByte();
        } catch (SocketTimeoutException ste) {
            // System.err.println(""Timed out waiting for a frame."");
            return null; // failed
        }

        if (type == 'A') {
            /*
             * Probably an AMQP.... header indicating a version
             * mismatch.
             */
            /*
             * Otherwise meaningless, so try to read the version,
             * and throw an exception, whether we read the version
             * okay or not.
             */
            protocolVersionMismatch(is);
        }

        channel = is.readUnsignedShort();
        int payloadSize = is.readInt();
        if (payloadSize >= maxPayloadSize) {
            throw new IllegalStateException(format(
                ""Frame body is too large (%d), maximum size is %d"",
                payloadSize, maxPayloadSize
            ));
        }
        byte[] payload = new byte[payloadSize];
        is.readFully(payload);

        int frameEndMarker = is.readUnsignedByte();
        if (frameEndMarker != AMQP.FRAME_END) {
            throw new MalformedFrameException(""Bad frame end marker: "" + frameEndMarker);
        }

        return new Frame(type, channel, payload);
    }",1
"public boolean disconnectFromSingleController(KieServerInfo serverInfo, KieServerConfig config, String controllerUrl) {
        String connectAndSyncUrl = null;
        try {
            connectAndSyncUrl = controllerUrl + ""/server/"" + KieServerEnvironment.getServerId()+""/?location=""+ URLEncoder.encode(serverInfo.getLocation(), ""UTF-8"");

            String userName = config.getConfigItemValue(KieServerConstants.CFG_KIE_CONTROLLER_USER, ""kieserver"");
            String password = loadControllerPassword(config);
            String token = config.getConfigItemValue(KieServerConstants.CFG_KIE_CONTROLLER_TOKEN);

            makeHttpDeleteRequestAndCreateCustomResponse(connectAndSyncUrl, null, userName, password, token);


            return true;
        } catch (Exception e) {
            // let's check all other controllers in case of running in cluster of controllers
            logger.debug(""Exception encountered while syncing with controller at {} error {}"", connectAndSyncUrl, e.getMessage(), e);
            
            return false;
        }
    }",1
"private void push(Context context) {
            if (++size >= limit) {
                throw new RuntimeException(JsonMessages.PARSER_INPUT_NESTED_TOO_DEEP(size));
            }
            context.next = head;
            head = context;
        }",1
"public byte[] encode(final SecretKey hmacKey)
  {
    if (hmacKey == null) {
      throw new IllegalArgumentException(""Secret key cannot be null"");
    }
    final ByteBuffer bb = ByteBuffer.allocate(length);
    bb.order(ByteOrder.BIG_ENDIAN);
    bb.putInt(VERSION);
    bb.put(ByteUtil.toBytes(keyName));
    bb.put((byte) 0);
    bb.put(ByteUtil.toUnsignedByte(nonce.length));
    bb.put(nonce);
    bb.put(hmac(bb.array(), 0, bb.limit() - HMAC_SIZE));
    return bb.array();
  }",1
"@Override
        public void dispatch(Tag tag) throws RemoteException {
            NfcPermissions.enforceAdminPermissions(mContext);
            mNfcDispatcher.dispatchTag(tag);
        }",0
"private static void addIntentParameters(Context context, Intent intent, String backupContext) {
        if (!intent.hasExtra(EXTRA_CONTEXT)) {
            // Insert some context if none exists.
            intent.putExtra(EXTRA_CONTEXT, backupContext);
        }
        intent.putExtra(EXTRA_THEME, 1 /* Light, dark action bar */);
        Theme theme = context.getTheme();
        TypedValue typedValue = new TypedValue();
        theme.resolveAttribute(android.R.attr.colorPrimary, typedValue, true);
        intent.putExtra(EXTRA_PRIMARY_COLOR, context.getColor(typedValue.resourceId));
    }",0
"private static Optional<Method> findMethod(Component instance,
            Class<?> clazz, String methodName) {
        List<Method> methods = Stream.of(clazz.getDeclaredMethods())
                .filter(method -> methodName.equals(method.getName()))
                .filter(method -> hasMethodAnnotation(method))
                .collect(Collectors.toList());
        if (methods.size() > 1) {
            String msg = String.format(""Class '%s' contains ""
                    + ""several event handler method with the same name '%s'"",
                    instance.getClass().getName(), methodName);
            getLogger().error(msg);
            throw new IllegalStateException(
                    ""Method conflict in event handler with multiple methods with same name."");
        } else if (methods.size() == 1) {
            return Optional.of(methods.get(0));
        } else if (!Component.class.equals(clazz)) {
            return findMethod(instance, clazz.getSuperclass(), methodName);
        } else {
            return Optional.empty();
        }
    }",1
"@Override
    public boolean requestIcon(String bssid, String fileName) {
        return mWifiNative.requestIcon(mInterfaceName, bssid, fileName);
    }",0
"@Override
    public int getAvailabilityStatus() {
        return mContext.getResources().getBoolean(R.bool.config_show_location_scanning)
                ? (mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_LOCATION)
                        ? DISABLED_DEPENDENT_SETTING
                        : AVAILABLE)
                : UNSUPPORTED_ON_DEVICE;
    }",1
"private boolean handleJid(Invite invite) {
		List<Contact> contacts = xmppConnectionService.findContacts(invite.getJid(), invite.account);
		if (invite.isAction(XmppUri.ACTION_JOIN)) {
			Conversation muc = xmppConnectionService.findFirstMuc(invite.getJid());
			if (muc != null) {
				switchToConversationDoNotAppend(muc, invite.getBody());
				return true;
			} else {
				showJoinConferenceDialog(invite.getJid().asBareJid().toString());
				return false;
			}
		} else if (contacts.size() == 0) {
			showCreateContactDialog(invite.getJid().toString(), invite);
			return false;
		} else if (contacts.size() == 1) {
			Contact contact = contacts.get(0);
			if (!invite.isSafeSource() && invite.hasFingerprints()) {
				displayVerificationWarningDialog(contact, invite);
			} else {
				if (invite.hasFingerprints()) {
					if (xmppConnectionService.verifyFingerprints(contact, invite.getFingerprints())) {
						Toast.makeText(this, R.string.verified_fingerprints, Toast.LENGTH_SHORT).show();
					}
				}
				if (invite.account != null) {
					xmppConnectionService.getShortcutService().report(contact);
				}
				switchToConversationDoNotAppend(contact, invite.getBody());
			}
			return true;
		} else {
			if (mMenuSearchView != null) {
				mMenuSearchView.expandActionView();
				mSearchEditText.setText("""");
				mSearchEditText.append(invite.getJid().toString());
				filter(invite.getJid().toString());
			} else {
				mInitialSearchValue.push(invite.getJid().toString());
			}
			return true;
		}
	}",1
"@Override
    protected InputSource getInputSource(final InputSource inputSource) {
        return inputSource;
    }",1
"private void warnForUnavailableBundledDependencies(
            Class<? extends Component> componentClass,
            DependencyInfo dependencies) {
        if (ui.getSession() == null
                || !ui.getSession().getConfiguration().isProductionMode()) {
            return;
        }

        List<String> jsDeps = new ArrayList<>();
        jsDeps.addAll(dependencies.getJavaScripts().stream()
                .map(dep -> dep.value()).filter(src -> !UrlUtil.isExternal(src))
                .collect(Collectors.toList()));
        jsDeps.addAll(dependencies.getJsModules().stream()
                .map(dep -> dep.value()).filter(src -> !UrlUtil.isExternal(src))
                .collect(Collectors.toList()));

        if (!jsDeps.isEmpty()) {
            maybeWarnAboutDependencies(componentClass, jsDeps);
        }
    }",0
"@Override
    public Location getCurrentLocation() throws IOException {
        Location l = getLastKnownLocation();
        if (l == null) {
            throw new IOException(""cannot retrieve location try later"");
        }
        return l;
    }",0
"public BigInteger calculateAgreement(
        DHPublicKeyParameters   pub,
        BigInteger              message)
    {
        if (!pub.getParameters().equals(dhParams))
        {
            throw new IllegalArgumentException(""Diffie-Hellman public key has wrong parameters."");
        }

        BigInteger p = dhParams.getP();

        BigInteger result = pub.getY().modPow(privateValue, p);
        if (result.compareTo(ONE) == 0)
        {
            throw new IllegalStateException(""Shared key can't be 1"");
        }

        return message.modPow(key.getX(), p).multiply(result).mod(p);
    }",1
"private XDOM displayTitle(DocumentModelBridge document, DocumentDisplayerParameters parameters)
    {
        // 1. Try to use the title provided by the user.
        String rawTitle = document.getTitle();
        if (!StringUtils.isEmpty(rawTitle)) {
            try {
                String title = rawTitle;
                // Evaluate the title only if the document is not restricted and its content's author has script
                // right, otherwise use the raw title.
                if (!document.isRestricted() && this.authorizationManager.hasAccess(Right.SCRIPT,
                    document.getContentAuthorReference(), document.getDocumentReference()))
                {
                    title = evaluateTitle(rawTitle, document, parameters);
                }
                return parseTitle(title);
            } catch (Exception e) {
                logger.warn(""Failed to interpret title of document [{}]."", document.getDocumentReference(), e);
            }
        }

        // 2. Try to extract the title from the document content.
        if (""1"".equals(this.xwikicfg.getProperty(""xwiki.title.compatibility"", ""0""))) {
            try {
                XDOM title = extractTitleFromContent(document, parameters);
                if (title != null) {
                    return title;
                }
            } catch (Exception e) {
                logger.warn(""Failed to extract title from content of document [{}]."", document.getDocumentReference(),
                    e);
            }
        }

        // 3. The title was not specified or its evaluation failed. Use the document name as a fall-back.
        return getStaticTitle(document);
    }",1
"private void sendKexInit()
            throws TransportException {
        log.debug(""Sending SSH_MSG_KEXINIT"");
        List<String> knownHostAlgs = findKnownHostAlgs(transport.getRemoteHost(), transport.getRemotePort());
        clientProposal = new Proposal(transport.getConfig(), knownHostAlgs, initialKex.get());
        transport.write(clientProposal.getPacket());
        kexInitSent.set();
    }",1
"public void setPlaybackSpeed(String packageName, int pid, int uid, float speed) {
            try {
                final String reason = TAG + "":setPlaybackSpeed"";
                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
                        pid, uid, packageName, reason);
                mCb.onSetPlaybackSpeed(packageName, pid, uid, speed);
            } catch (RemoteException e) {
                Log.e(TAG, ""Remote failure in setPlaybackSpeed."", e);
            }
        }",0
"@NonNull
    public List<String> getDelegatePackages(ComponentName who, String scope)
            throws SecurityException {
        Objects.requireNonNull(who, ""ComponentName is null"");
        Objects.requireNonNull(scope, ""Scope is null"");
        if (!Arrays.asList(DELEGATIONS).contains(scope)) {
            throw new IllegalArgumentException(""Unexpected delegation scope: "" + scope);
        }

        // Retrieve the user ID of the calling process.
        final CallerIdentity caller = getCallerIdentity(who);
        Preconditions.checkCallAuthorization(
                isDefaultDeviceOwner(caller) || isProfileOwner(caller));
        synchronized (getLockObject()) {
            return getDelegatePackagesInternalLocked(scope, caller.getUserId());
        }
    }",0
"public boolean getDismissKeyguardIfInsecure() {
        return mDismissKeyguardIfInsecure;
    }",0
"@Override
	protected void runTeardown() {
		Assert.assertTrue(""Error during initialization"", messagedInitialization);
		Assert.assertTrue(""Socket connection is not allowed"", securityExceptionOccurred);
	}",1
"public File getDownloadablePresentationFile(String meetingId, String presId, String presFilename) {
        log.info(""Find downloadable presentation for meetingId={} presId={} filename={}"", meetingId, presId,
                presFilename);
        File presDir = Util.getPresentationDir(presentationBaseDir, meetingId, presId);
        // Build file to presFilename
        // Get canonicalPath and make sure it starts with
        // /var/bigbluebutton/<meetingid-pattern>
        // If so return file, if not return null
        File presFile = new File(presDir.getAbsolutePath() + File.separatorChar + presFilename);
        try {
            String presFileCanonical = presFile.getCanonicalPath();
            log.debug(""Requested presentation name file full path {}"",presFileCanonical);
            if (presFileCanonical.startsWith(presentationBaseDir)) {
                return presFile;
            }
        } catch (IOException e) {
            log.error(""Exception getting canonical path for {}.\n{}"", presFilename, e);
            return null;
        }

        log.error(""Cannot find file for {}."", presFilename);

        return null;
    }",1
"@Test
  public void testMethodBaseWithMaliciousRequest() throws WebdavException {
    assertNotNull(methodBase.parseContent(request, response));
  }",1
"private VerifyResult verifyJar(String jarName) throws Exception {
        try (JarFile jarFile = new JarFile(jarName, true)) {
            Vector<JarEntry> entriesVec = new Vector<JarEntry>();
            byte[] buffer = new byte[8192];

            Enumeration<JarEntry> entries = jarFile.entries();
            while (entries.hasMoreElements()) {
                JarEntry je = entries.nextElement();
                entriesVec.addElement(je);

                InputStream is = jarFile.getInputStream(je);
                try {
                    while (is.read(buffer, 0, buffer.length) != -1) {
                        // we just read. this will throw a SecurityException
                        // if a signature/digest check fails.
                    }
                } finally {
                    if (is != null) {
                        is.close();
                    }
                }
            }
            return verifyJarEntryCerts(jarName, jarFile.getManifest() != null,
                    entriesVec);

        } catch (Exception e) {
            LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, e);
            throw e;
        }
    }",0
"@Override
    public void clearProfileOwner(ComponentName who) {
        if (!mHasFeature) {
            return;
        }
        Objects.requireNonNull(who, ""ComponentName is null"");

        final CallerIdentity caller = getCallerIdentity(who);
        final int userId = caller.getUserId();
        Preconditions.checkCallingUser(!isManagedProfile(userId));

        enforceUserUnlocked(userId);
        synchronized (getLockObject()) {
            // Check if this is the profile owner who is calling
            final ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller);

            mInjector.binderWithCleanCallingIdentity(() -> {
                clearProfileOwnerLocked(admin, userId);
                removeActiveAdminLocked(who, userId);
                sendOwnerChangedBroadcast(DevicePolicyManager.ACTION_PROFILE_OWNER_CHANGED,
                        userId);
            });
            Slogf.i(LOG_TAG, ""Profile owner "" + who + "" removed from user "" + userId);
        }
    }",0
"@Override
    public IntentSender createAppWidgetConfigIntentSender(String callingPackage, int appWidgetId) {
        final int userId = UserHandle.getCallingUserId();

        if (DEBUG) {
            Slog.i(TAG, ""createAppWidgetConfigIntentSender() "" + userId);
        }

        // Make sure the package runs under the caller uid.
        mSecurityPolicy.enforceCallFromPackage(callingPackage);

        synchronized (mLock) {
            ensureGroupStateLoadedLocked(userId);

            // NOTE: The lookup is enforcing security across users by making
            // sure the caller can only access widgets it hosts or provides.
            Widget widget = lookupWidgetLocked(appWidgetId,
                    Binder.getCallingUid(), callingPackage);

            if (widget == null) {
                throw new IllegalArgumentException(""Bad widget id "" + appWidgetId);
            }

            Provider provider = widget.provider;
            if (provider == null) {
                throw new IllegalArgumentException(""Widget not bound "" + appWidgetId);
            }

            Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_CONFIGURE);
            intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
            intent.setComponent(provider.info.configure);

            // All right, create the sender.
            final long identity = Binder.clearCallingIdentity();
            try {
                return PendingIntent.getActivityAsUser(
                        mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT
                                | PendingIntent.FLAG_CANCEL_CURRENT, null,
                                new UserHandle(provider.getUserId()))
                        .getIntentSender();
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }",1
"private boolean equals(final String value, final String text, final Boolean ignoreCase) {
        if (value != null && text != null) {
            String val = value.trim();
            String txt = text.trim();

            if (ignoreCase != null && ignoreCase) {
                val = val.toLowerCase();
                txt = text.toLowerCase();
            }

            return val.equals(txt);
        }

        return false;
    }",1
"@Override
    public void reportKeyguardSecured(int userHandle) {
        Preconditions.checkArgumentNonnegative(userHandle, ""Invalid userId"");

        final CallerIdentity caller = getCallerIdentity();
        Preconditions.checkCallAuthorization(hasFullCrossUsersPermission(caller, userHandle));
        Preconditions.checkCallAuthorization(hasCallingOrSelfPermission(BIND_DEVICE_ADMIN));

        if (mInjector.securityLogIsLoggingEnabled()) {
            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_SECURED);
        }
    }",0
"public int getBeginColumnNumber() { 
            return fBeginColumnNumber;
        }",0
"@Override
  protected void onInitialize()
  {
    super.onInitialize();
    final Form<FormBean> hiddenForm = new Form<FormBean>(""hiddenForm"", new CompoundPropertyModel<FormBean>(new FormBean()));
    hiddenForm.add(AttributeModifier.replace(""data-mimetype"", mimeType));
    main.add(hiddenForm);
    hiddenForm.add(new TextArea<String>(""importString""));
    hiddenForm.add(new TextArea<String>(""importFileName""));
    hiddenForm.add(new AjaxSubmitLink(""submitButton"") {
      private static final long serialVersionUID = 6140567784494429257L;

      @Override
      protected void onSubmit(final AjaxRequestTarget target, final Form< ? > form)
      {
        csrfTokenHandler.onSubmit();
        final FormBean modelObject = hiddenForm.getModel().getObject();
        onStringImport(target, modelObject.importFileName, modelObject.importString);
      }

      @Override
      protected void onError(final AjaxRequestTarget target, final Form< ? > form)
      {
        // nothing to do here
      }

    });
    csrfTokenHandler = new CsrfTokenHandler(hiddenForm);
  }",1
"private String sanitizeString(String stringToSanitize) {
        return lookupTranslator.translate(stringToSanitize);
    }",0
"protected void sendErrorRedirect(HttpServletRequest request, HttpServletResponse response, Throwable e) throws
			ServletException, IOException {
		request.setAttribute(""javax.servlet.jsp.jspException"", e);
		ServletContext sc = getServletConfig().getServletContext();
		sc.getRequestDispatcher(""/error.jsp"").forward(request, response);
	}",1
"@Nonnull
  private EEOI _readValue () throws JsonParseException
  {
    _skipSpaces ();

    final IJsonParsePosition aStartPos = _getCurrentParsePos ();

    final int cFirst = _readChar ();
    switch (cFirst)
    {
      case '\'':
      {
        _backupChar (cFirst);
        final TwoStrings aString = _readString (EStringQuoteMode.SINGLE);
        m_aCallback.onString (aString.m_sOriginal, aString.m_sUnescaped);
        break;
      }
      case '""':
      {
        _backupChar (cFirst);
        final TwoStrings aString = _readString (EStringQuoteMode.DOUBLE);
        m_aCallback.onString (aString.m_sOriginal, aString.m_sUnescaped);
        break;
      }
      case '-':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        _backupChar (cFirst);
        _readNumber ();
        break;
      case 't':
        _backupChar (cFirst);
        _expect (CJson.KEYWORD_TRUE);
        m_aCallback.onTrue ();
        break;
      case 'f':
        _backupChar (cFirst);
        _expect (CJson.KEYWORD_FALSE);
        m_aCallback.onFalse ();
        break;
      case 'n':
        _backupChar (cFirst);
        _expect (CJson.KEYWORD_NULL);
        m_aCallback.onNull ();
        break;
      case CJson.ARRAY_START:
        _incNestingLevel (aStartPos);
        _readArray ();
        _decNestingLevel ();
        break;
      case CJson.OBJECT_START:
        _incNestingLevel (aStartPos);
        _readObject ();
        _decNestingLevel ();
        break;
      case EOI:
        return EEOI.EOI;
      default:
        throw _parseEx (aStartPos, ""Syntax error in JSON. Found "" + _getPrintableChar (cFirst));
    }
    return EEOI.NOT_EOI;
  }",1
"public List<Object> json() {
        return materials;
    }",1
"@Override
    public String getHeader(Map<String, Object> data) {
        if (""true"".equals(getPropertyString(""horizontal_menu""))) {
            data.put(""header_after"", UserviewUtil.getTemplate(this, data, ""/templates/"" + getPathName() + ""Theme_horizontalMenu.ftl""));
        } else if (""horizontal_inline"".equals(getPropertyString(""horizontal_menu""))) {
            data.put(""header_name_inner_after"", UserviewUtil.getTemplate(this, data, ""/templates/"" + getPathName() + ""Theme_horizontalMenu.ftl""));
        }
        
        data.put(""header_classes"", ""navbar"");
        data.put(""header_inner_before"", ""<div class=\""navbar-inner\""><div class=\""container-fluid\""><div class=\""hi-trigger ma-trigger\"" id=\""sidebar-trigger\""><div class=\""line-wrap\""><div class=\""line top\""></div><div class=\""line center\""></div><div class=\""line bottom\""></div></div></div>"");
        data.put(""header_inner_after"", ""</div></div>"" + getPropertyString(""subheader""));
        data.put(""header_link_classes"", ""brand"");
        data.put(""header_info_classes"", ""inline-block"");
        data.put(""header_name_classes"", ""inline-block"");
        
        if (!getPropertyString(""logo"").isEmpty()) {
            data.put(""header_name_inner_before"", ""<img class=\""logo\"" alt=\""logo\"" src=\""""+getPropertyString(""logo"")+""\"" />"");
        }
        
        data.put(""header_description_classes"", ""inline-block visible-desktop"");
        data.put(""header_description_span_classes"", ""brand"");
        data.put(""header_message_after"", getNavbar(data));
        return UserviewUtil.getTemplate(this, data, ""/templates/userview/header.ftl"");
    }",0
"public static NativeArray jsFunction_getInlineContent(Context cx, Scriptable thisObj, Object[] args, Function funObj)
            throws ScriptException, APIManagementException {
        String apiName;
        String version;
        String providerName;
        String docName;
        String content = null;
        NativeArray myn = new NativeArray(0);


        if (args != null && isStringArray(args)) {
        	providerName = (String) args[0];
            apiName = (String) args[1];
            version = (String) args[2];
            docName = (String) args[3];
            try {
            	providerName = APIUtil.replaceEmailDomain(URLDecoder.decode(providerName, ""UTF-8""));
            	APIIdentifier apiId = new APIIdentifier(providerName, apiName,
                        version);

                APIConsumer apiConsumer = getAPIConsumer(thisObj);
                content = apiConsumer.getDocumentationContent(apiId, docName);
            } catch (Exception e) {
                handleException(""Error while getting Inline Document Content "", e);
            }

            if (content == null) {
                content = """";
            }

            NativeObject row = new NativeObject();
            row.put(""providerName"", row, providerName);
            row.put(""apiName"", row, apiName);
            row.put(""apiVersion"", row, version);
            row.put(""docName"", row, docName);
            row.put(""content"", row, content);
            myn.put(0, myn, row);

        }
        return myn;
    }",0
"@SuppressWarnings(""unchecked"")
    @Override
    public T deserialize(JsonParser parser, DeserializationContext context) throws IOException
    {
        //NOTE: Timestamps contain no timezone info, and are always in configured TZ. Only
        //string values have to be adjusted to the configured TZ.
        switch (parser.getCurrentTokenId())
        {
            case JsonTokenId.ID_NUMBER_FLOAT:
                return _fromDecimal(context, parser.getDecimalValue());

            case JsonTokenId.ID_NUMBER_INT:
                return _fromLong(context, parser.getLongValue());

            case JsonTokenId.ID_STRING:
            {
                String string = parser.getText().trim();
                if (string.length() == 0) {
                    return null;
                }
                // only check for other parsing modes if we are using default formatter
                if (_formatter == DateTimeFormatter.ISO_INSTANT ||
                    _formatter == DateTimeFormatter.ISO_OFFSET_DATE_TIME ||
                    _formatter == DateTimeFormatter.ISO_ZONED_DATE_TIME) {
                    // 22-Jan-2016, [datatype-jsr310#16]: Allow quoted numbers too
                    int dots = _countPeriods(string);
                    if (dots >= 0) { // negative if not simple number
                        try {
                            if (dots == 0) {
                                return _fromLong(context, Long.parseLong(string));
                            }
                            if (dots == 1) {
                                return _fromDecimal(context, new BigDecimal(string));
                            }
                        } catch (NumberFormatException e) {
                            // fall through to default handling, to get error there
                        }
                    }

                    string = replaceZeroOffsetAsZIfNecessary(string);
                }

                T value;
                try {
                    TemporalAccessor acc = _formatter.parse(string);
                    value = parsedToValue.apply(acc);
                    if (shouldAdjustToContextTimezone(context)) {
                        return adjust.apply(value, this.getZone(context));
                    }
                } catch (DateTimeException e) {
                    value = _handleDateTimeException(context, e, string);
                }
                return value;
            }

            case JsonTokenId.ID_EMBEDDED_OBJECT:
                // 20-Apr-2016, tatu: Related to [databind#1208], can try supporting embedded
                //    values quite easily
                return (T) parser.getEmbeddedObject();

            case JsonTokenId.ID_START_ARRAY:
            	return _deserializeFromArray(parser, context);
        }
        return _handleUnexpectedToken(context, parser, JsonToken.VALUE_STRING,
                JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_FLOAT);
    }",1
"private void debugAction(ActionType actionType, ActionParametersBase params) {
        log.debug(""Action type '{}', Parameters '{}'"", actionType, params); //$NON-NLS-1$
    }",0
"public void finishChannel(Channel channel) {
        setDefaultAttribute(channel, DiscardEvent.INSTANCE);

        // The channel may have already been removed if a timeout occurred, and
        // this method may be called just after.
        if (channel == null)
            return;

        LOGGER.debug(""Closing Channel {} "", channel);
        try {
            channel.close();
        } catch (Throwable t) {
            LOGGER.debug(""Error closing a connection"", t);
        }

        openChannels.remove(channel);
    }",0
"public String getAttachmentURL(String filename)
    {
        return this.doc.getAttachmentURL(filename, getXWikiContext());
    }",0
"public String getRelativeAssetsRootPath() {
        String path = """";
        path = Config.getStringProperty(""ASSET_PATH"", DEFAULT_RELATIVE_ASSET_PATH);
        return path;
    }",1
"public String toXML() throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();

        Element infoElement = toDOM(document);
        document.appendChild(infoElement);

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
        transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""4"");

        DOMSource domSource = new DOMSource(document);
        StringWriter sw = new StringWriter();
        StreamResult streamResult = new StreamResult(sw);
        transformer.transform(domSource, streamResult);

        return sw.toString();
    }",1
"private static void setAttrMapInSession(
        SessionProvider sessionProvider,
        Map attrMap, Object session)
        throws SessionException {
        if (attrMap != null && !attrMap.isEmpty()) {
            Set entrySet = attrMap.entrySet();
            for(Iterator iter = entrySet.iterator(); iter.hasNext();) {
                Map.Entry entry = (Map.Entry)iter.next();
                String attrName = (String)entry.getKey();
                String[] attrValues = null;
                if (attrName.equals(SAMLConstants.USER_NAME) ||
                    attrName.equals(SessionProvider.PRINCIPAL_NAME)) {
                    String attrValue = (String)entry.getValue();
                    attrValues = new String[1];
                    attrValues[0] = attrValue;
                } else if (attrName.equals(SessionProvider.REALM) ||
                    attrName.equals(SessionProvider.AUTH_LEVEL)) {
                    // ignore
                    continue; 
                } else {
                    attrValues = (String[])entry.getValue();
                }
                sessionProvider.setProperty(session, attrName, attrValues);
                if (debug.messageEnabled()) {
                    debug.message(""SAMLUtils.setAttrMapInSessioin: attrName =""+
                        attrName);
                }
            }
        } 
    }",0
"public static boolean isCsrfTokenValid(VaadinSession session,
            String requestToken) {

        if (session.getService().getDeploymentConfiguration()
                .isXsrfProtectionEnabled()) {
            String sessionToken = session.getCsrfToken();

            try {
                if (sessionToken == null || !MessageDigest.isEqual(
                        sessionToken.getBytes(""UTF-8""),
                        requestToken.getBytes(""UTF-8""))) {
                    return false;
                }
            } catch (UnsupportedEncodingException e) {
                getLogger().log(Level.WARNING,
                        ""Session token was not UTF-8, this should never happen."");
                return false;
            }
        }
        return true;
    }",1
"public ViewPage createPageWithAttachment(String space, String page, String content, String title,
        String attachmentName, InputStream attachmentData, UsernamePasswordCredentials credentials) throws Exception
    {
        ViewPage vp = createPage(space, page, content, title);
        attachFile(space, page, attachmentName, attachmentData, false, credentials);
        return vp;
    }",0
"private static Loader loader(final Path basedir, Loader classpath) {
    if (basedir != null && Files.exists(basedir)) {
      return name -> {
        Path path = basedir.resolve(name).normalize();
        if (Files.exists(path) && path.startsWith(basedir)) {
          try {
            return path.toUri().toURL();
          } catch (MalformedURLException x) {
            // shh
          }
        }
        return classpath.getResource(name);
      };
    }
    return classpath;
  }",1
"public static boolean validate(WifiConfiguration config, long supportedFeatureSet,
            boolean isAdd) {
        if (!validateSsid(config.SSID, isAdd)) {
            return false;
        }
        if (!validateBssid(config.BSSID)) {
            return false;
        }
        if (!validateBitSets(config)) {
            return false;
        }
        if (!validateKeyMgmt(config.allowedKeyManagement)) {
            return false;
        }
        if (config.isSecurityType(WifiConfiguration.SECURITY_TYPE_WEP)
                && config.wepKeys != null
                && !validateWepKeys(config.wepKeys, config.wepTxKeyIndex, isAdd)) {
            return false;
        }
        if (config.isSecurityType(WifiConfiguration.SECURITY_TYPE_PSK)
                && !validatePassword(config.preSharedKey, isAdd, false)) {
            return false;
        }
        if (config.isSecurityType(WifiConfiguration.SECURITY_TYPE_SAE)
                && !validatePassword(config.preSharedKey, isAdd, true)) {
            return false;
        }
        if (config.isSecurityType(WifiConfiguration.SECURITY_TYPE_WAPI_PSK)
                && !validatePassword(config.preSharedKey, isAdd, false)) {
            return false;
        }
        if (config.isSecurityType(WifiConfiguration.SECURITY_TYPE_DPP)
                && (supportedFeatureSet & WifiManager.WIFI_FEATURE_DPP_AKM) == 0) {
            Log.e(TAG, ""DPP AKM is not supported"");
            return false;
        }
        if (!validateEnterpriseConfig(config, isAdd)) {
            return false;
        }

        // b/153435438: Added to deal with badly formed WifiConfiguration from apps.
        if (config.preSharedKey != null && !config.needsPreSharedKey()) {
            Log.e(TAG, ""preSharedKey set with an invalid KeyMgmt, resetting KeyMgmt to WPA_PSK"");
            config.setSecurityParams(WifiConfiguration.SECURITY_TYPE_PSK);
        }
        if (!validateIpConfiguration(config.getIpConfiguration())) {
            return false;
        }
        // TBD: Validate some enterprise params as well in the future here.
        return true;
    }",1
"@Provides
  @Singleton
  SessionIdGenerator sessionIdGenerator() {
    return new DefaultSessionIdGenerator();
  }",1
"@Override
    public void moveTrackedEntityAttributeValues( TrackedEntityInstance original, TrackedEntityInstance duplicate,
        List<String> trackedEntityAttributes )
    {
        // Collect existing teav from original for the tea list
        Map<String, TrackedEntityAttributeValue> originalAttributeValueMap = new HashMap<>();
        original.getTrackedEntityAttributeValues().forEach( oav -> {
            if ( trackedEntityAttributes.contains( oav.getAttribute().getUid() ) )
            {
                originalAttributeValueMap.put( oav.getAttribute().getUid(), oav );
            }
        } );

        duplicate.getTrackedEntityAttributeValues()
            .stream()
            .filter( av -> trackedEntityAttributes.contains( av.getAttribute().getUid() ) )
            .forEach( av -> {

                TrackedEntityAttributeValue updatedTeav;
                org.hisp.dhis.common.AuditType auditType;
                if ( originalAttributeValueMap.containsKey( av.getAttribute().getUid() ) )
                {
                    // Teav exists in original, overwrite the value
                    updatedTeav = originalAttributeValueMap.get( av.getAttribute().getUid() );
                    updatedTeav.setValue( av.getValue() );
                    auditType = UPDATE;
                }
                else
                {
                    // teav does not exist in original, so create new and attach
                    // it to original
                    updatedTeav = new TrackedEntityAttributeValue();
                    updatedTeav.setAttribute( av.getAttribute() );
                    updatedTeav.setEntityInstance( original );
                    updatedTeav.setValue( av.getValue() );
                    auditType = CREATE;
                }
                getSession().delete( av );
                // We need to flush to make sure the previous teav is
                // deleted.
                // Or else we might end up breaking a
                // constraint, since hibernate does not respect order.
                getSession().flush();

                getSession().saveOrUpdate( updatedTeav );

                auditTeav( av, updatedTeav, auditType );

            } );
    }",0
"@GetMapping(value = ""/derby"")
    @Secured(action = ActionTypes.READ, resource = ""nacos/admin"")
    public RestResult<Object> derbyOps(@RequestParam(value = ""sql"") String sql) {
        String selectSign = ""select"";
        String limitSign = ""ROWS FETCH NEXT"";
        String limit = "" OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY"";
        try {
            if (PropertyUtil.isEmbeddedStorage()) {
                LocalDataSourceServiceImpl dataSourceService = (LocalDataSourceServiceImpl) DynamicDataSource
                        .getInstance().getDataSource();
                if (StringUtils.startsWithIgnoreCase(sql, selectSign)) {
                    if (!StringUtils.containsIgnoreCase(sql, limitSign)) {
                        sql += limit;
                    }
                    JdbcTemplate template = dataSourceService.getJdbcTemplate();
                    List<Map<String, Object>> result = template.queryForList(sql);
                    return RestResultUtils.success(result);
                }
                return RestResultUtils.failed(""Only query statements are allowed to be executed"");
            }
            return RestResultUtils.failed(""The current storage mode is not Derby"");
        } catch (Exception e) {
            return RestResultUtils.failed(e.getMessage());
        }
    }",1
"@CalledByNative
    protected long getNativePtr() {
        return mNativeTabAndroid;
    }",0
"private BigInteger[] derDecode(
        byte[]  encoding)
        throws IOException
    {
        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);
        if (s.size() != 2)
        {
            throw new IOException(""malformed signature"");
        }

        return new BigInteger[]{
            ((ASN1Integer)s.getObjectAt(0)).getValue(),
            ((ASN1Integer)s.getObjectAt(1)).getValue()
        };
    }",1
"private void migrate42(File dataDir, Stack<Integer> versions) {
		Map<String, String> commentRequests = new HashMap<>();
		Map<String, String> requestTargetHeads = new HashMap<>();
		Map<String, String> requestBaseCommits = new HashMap<>();
		
		for (File file: dataDir.listFiles()) {
			if (file.getName().startsWith(""CodeCommentRelations.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements())
					commentRequests.put(element.elementTextTrim(""comment""), element.elementTextTrim(""request""));
			} else if (file.getName().startsWith(""PullRequests.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					String id = element.elementTextTrim(""id"");
					requestBaseCommits.put(id, element.elementTextTrim(""baseCommitHash""));
					Element lastMergePreviewElement = element.element(""lastMergePreview"");
					if (lastMergePreviewElement != null) {
						Element targetHeadElement = lastMergePreviewElement.element(""targetHead"");
						requestTargetHeads.put(id, targetHeadElement.getTextTrim());
						targetHeadElement.setName(""targetHeadCommitHash"");
						lastMergePreviewElement.element(""requestHead"").setName(""headCommitHash"");
						Element mergedElement = lastMergePreviewElement.element(""merged"");
						if (mergedElement != null)
							mergedElement.setName(""mergeCommitHash"");
					} 
					element.element(""headCommitHash"").detach();
				}
				dom.writeToFile(file, false);
			} 
		}
		
		for (File file: dataDir.listFiles()) {
			if (file.getName().startsWith(""Settings.xml"")) {
				try {
					String content = FileUtils.readFileToString(file, StandardCharsets.UTF_8.name());
					content = StringUtils.replace(content, 
							""io.onedev.server.model.support.administration.authenticator.ldap."", 
							""io.onedev.server.plugin.authenticator.ldap."");
					content = StringUtils.replace(content, 
							""io.onedev.server.model.support.issue.transitiontrigger.DiscardPullRequest"", 
							""io.onedev.server.model.support.issue.transitiontrigger.DiscardPullRequestTrigger"");
					content = StringUtils.replace(content, 
							""io.onedev.server.model.support.issue.transitiontrigger.MergePullRequest"", 
							""io.onedev.server.model.support.issue.transitiontrigger.MergePullRequestTrigger"");
					content = StringUtils.replace(content, 
							""io.onedev.server.model.support.issue.transitiontrigger.OpenPullRequest"", 
							""io.onedev.server.model.support.issue.transitiontrigger.OpenPullRequestTrigger"");
					FileUtils.writeFile(file, content, StandardCharsets.UTF_8.name());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
				
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					Element keyElement = element.element(""key"");
					if (keyElement.getTextTrim().equals(""SSH"")) {
						Element valueElement = element.element(""value"");
						if (valueElement != null) 
							valueElement.element(""privateKey"").setName(""pemPrivateKey"");
					} else if (keyElement.getTextTrim().equals(""JOB_SCRIPTS"")) {
						keyElement.setText(""GROOVY_SCRIPTS"");
					}
				}
				dom.writeToFile(file, false);
			} else if (file.getName().startsWith(""Projects.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					Element buildSettingElement = element.element(""buildSetting"");
					Element actionAuthorizationsElement = buildSettingElement.element(""actionAuthorizations"");
					if (actionAuthorizationsElement.elements().isEmpty()) {
						actionAuthorizationsElement.addElement(""io.onedev.server.model.support.build.actionauthorization.CreateTagAuthorization"");
						actionAuthorizationsElement.addElement(""io.onedev.server.model.support.build.actionauthorization.CloseMilestoneAuthorization"");
					}
					element.addElement(""issueManagementEnabled"").setText(""true"");
				}
				dom.writeToFile(file, false);
			} else if (file.getName().startsWith(""CodeComments.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					Element compareContextElement = element.element(""compareContext"");
					compareContextElement.element(""compareCommit"").setName(""compareCommitHash"");
					Element markPosElement = element.element(""markPos"");
					markPosElement.setName(""mark"");
					markPosElement.element(""commit"").setName(""commitHash"");
					String requestId = commentRequests.get(element.elementTextTrim(""id""));
					if (requestId != null)
						element.addElement(""request"").setText(requestId);
				}
				dom.writeToFile(file, false);
			} else if (file.getName().startsWith(""Builds.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) 
					element.addElement(""submitReason"").setText(""Unknown"");
				dom.writeToFile(file, false);
			} else if (file.getName().startsWith(""CodeCommentRelations.xml"")) {
				FileUtils.deleteFile(file);
			} else if (file.getName().startsWith(""PullRequestBuilds.xml"")) {
				try {
					String content = FileUtils.readFileToString(file, StandardCharsets.UTF_8.name());
					content = StringUtils.replace(content, ""PullRequestBuild"", ""PullRequestVerification"");
					FileUtils.deleteFile(file);
					String newFileName = StringUtils.replace(file.getName(), ""PullRequestBuild"", ""PullRequestVerification"");
					FileUtils.writeFile(new File(dataDir, newFileName), content, StandardCharsets.UTF_8.name());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			} else if (file.getName().startsWith(""PullRequestReviews.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) { 
					Element excludeDateElement = element.element(""excludeDate"");
					if (excludeDateElement != null)
						excludeDateElement.detach();
				}
				dom.writeToFile(file, false);
			} else if (file.getName().startsWith(""Users.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					element.addElement(""accessToken"").setText(CryptoUtils.generateSecret());
					element.addElement(""ssoInfo"").addElement(""subject"").setText(UUID.randomUUID().toString());
				}
				dom.writeToFile(file, false);
			} else if (file.getName().startsWith(""PullRequestUpdates.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) { 
					element.element(""mergeBaseCommitHash"").detach();
					String requestId = element.elementTextTrim(""request"");
					String targetHead = requestTargetHeads.get(requestId);
					Element targetHeadCommitHashElement = element.addElement(""targetHeadCommitHash"");
					if (targetHead != null) 
						targetHeadCommitHashElement.setText(targetHead);
					else
						targetHeadCommitHashElement.setText(requestBaseCommits.get(requestId));
				}
				dom.writeToFile(file, false);
			}
		}
	}",1
"List<String> getRawCommandLine( String executableParameter, String... argumentsParameter )
    {
        List<String> commandLine = new ArrayList<>();
        StringBuilder sb = new StringBuilder();

        if ( executableParameter != null )
        {
            String preamble = getExecutionPreamble();
            if ( preamble != null )
            {
                sb.append( preamble );
            }

            if ( isQuotedExecutableEnabled() )
            {
                sb.append( quoteOneItem( executableParameter, true ) );
            }
            else
            {
                sb.append( executableParameter );
            }
        }
        for ( String argument : argumentsParameter )
        {
            if ( sb.length() > 0 )
            {
                sb.append( ' ' );
            }

            if ( isQuotedArgumentsEnabled() )
            {
                sb.append( quoteOneItem( argument, false ) );
            }
            else
            {
                sb.append( argument );
            }
        }

        commandLine.add( sb.toString() );

        return commandLine;
    }",1
"@Override
    public void config() {
        add(""/admin"", AdminPageController.class);
        add(""/admin/template"", AdminTemplatePageController.class);
        add(""/admin/article"", AdminArticlePageController.class);
        add(""/api/admin"", AdminController.class);
        add(""/api/admin/link"", LinkController.class);
        add(""/api/admin/comment"", CommentController.class);
        add(""/api/admin/type"", TypeController.class);
        add(""/api/admin/nav"", BlogNavController.class);
        add(""/api/admin/article"", AdminArticleController.class);
        add(""/api/admin/website"", WebSiteController.class);
        add(""/api/admin/template"", TemplateController.class);
        add(""/api/admin/upload"", UploadController.class);
        add(""/api/admin/upgrade"", UpgradeController.class);
    }",1
"public static void unzip(String zipFilePath, String targetPath, boolean overwrite) throws IOException {
        ZipFile zipFile = new ZipFile(zipFilePath);
        Enumeration<? extends ZipEntry> entryEnum = zipFile.getEntries();
        if (null != entryEnum) {
            while (entryEnum.hasMoreElements()) {
                ZipEntry zipEntry = entryEnum.nextElement();
                String filePath = zipEntry.getName();
                if (filePath.contains("".."")) {
                    filePath = filePath.replace("".."", BLANK);
                }
                if (zipEntry.isDirectory()) {
                    File dir = new File(targetPath + File.separator + filePath);
                    dir.mkdirs();
                } else {
                    File targetFile = new File(targetPath + File.separator + filePath);
                    if (!targetFile.exists() || overwrite) {
                        targetFile.getParentFile().mkdirs();
                        write(zipFile.getInputStream(zipEntry), new FileOutputStream(targetFile));
                    }
                }
            }
        }
        zipFile.close();
    }",1
"public ApiClient setReadTimeout(int readTimeout) {
    this.readTimeout = readTimeout;
    httpClient.property(ClientProperties.READ_TIMEOUT, readTimeout);
    return this;
  }",0
"private boolean extractSearchParamsDstu3CapabilityStatement(IBaseResource theConformance, String resourceName, TreeSet<String> includes, TreeSet<String> theRevIncludes, TreeSet<String> sortParams,
			boolean haveSearchParams, List<List<String>> queryIncludes) {
		CapabilityStatement conformance = (org.hl7.fhir.dstu3.model.CapabilityStatement) theConformance;
		for (CapabilityStatementRestComponent nextRest : conformance.getRest()) {
			for (CapabilityStatementRestResourceComponent nextRes : nextRest.getResource()) {
				if (nextRes.getTypeElement().getValue().equals(resourceName)) {
					for (StringType next : nextRes.getSearchInclude()) {
						if (next.isEmpty() == false) {
							includes.add(next.getValue());
						}
					}
					for (CapabilityStatementRestResourceSearchParamComponent next : nextRes.getSearchParam()) {
						if (next.getTypeElement().getValue() != org.hl7.fhir.dstu3.model.Enumerations.SearchParamType.COMPOSITE) {
							sortParams.add(next.getNameElement().getValue());
						}
					}
					if (nextRes.getSearchParam().size() > 0) {
						haveSearchParams = true;
					}
				} else {
					// It's a different resource from the one we're searching, so
					// scan for revinclude candidates
					for (CapabilityStatementRestResourceSearchParamComponent next : nextRes.getSearchParam()) {
						if (next.getTypeElement().getValue() == org.hl7.fhir.dstu3.model.Enumerations.SearchParamType.REFERENCE) {
						}
					}
				}
			}
		}
		return haveSearchParams;
	}",0
"public synchronized void updateShort(String columnName, short x) throws SQLException {
    updateShort(findColumn(columnName), x);
  }",0
"@GuardedBy(anyOf = {""this"", ""mProcLock""})
    int appServicesRestrictedInBackgroundLOSP(int uid, String packageName, int packageTargetSdk) {
        // Persistent app?
        if (mPackageManagerInt.isPackagePersistent(packageName)) {
            if (DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, ""App "" + uid + ""/"" + packageName
                        + "" is persistent; not restricted in background"");
            }
            return ActivityManager.APP_START_MODE_NORMAL;
        }

        // Non-persistent but background whitelisted?
        if (uidOnBackgroundAllowlistLOSP(uid)) {
            if (DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, ""App "" + uid + ""/"" + packageName
                        + "" on background allowlist; not restricted in background"");
            }
            return ActivityManager.APP_START_MODE_NORMAL;
        }

        // Is this app on the battery whitelist?
        if (isOnDeviceIdleAllowlistLOSP(uid, /*allowExceptIdleToo=*/ false)) {
            if (DEBUG_BACKGROUND_CHECK) {
                Slog.i(TAG, ""App "" + uid + ""/"" + packageName
                        + "" on idle allowlist; not restricted in background"");
            }
            return ActivityManager.APP_START_MODE_NORMAL;
        }

        // None of the service-policy criteria apply, so we apply the common criteria
        return appRestrictedInBackgroundLOSP(uid, packageName, packageTargetSdk);
    }",0
"@Override
  public byte[] decrypt(final byte[] input) throws CryptoException, EncodingException
  {
    return process(CipherUtil.decodeHeader(input, this::lookupKey), false, input);
  }",1
"private void notifyTrustedChangedLocked(boolean trusted) {
        int size = mKeyguardStateCallbacks.size();
        for (int i = size - 1; i >= 0; i--) {
            try {
                mKeyguardStateCallbacks.get(i).onTrustedChanged(trusted);
            } catch (RemoteException e) {
                Slog.w(TAG, ""Failed to call notifyTrustedChangedLocked"", e);
                if (e instanceof DeadObjectException) {
                    mKeyguardStateCallbacks.remove(i);
                }
            }
        }
    }",0
"private void addParameter(String name, String val, DataOutputStream postRequest) throws IOException {
		addParameterHeader(name, null, postRequest);
		postRequest.writeBytes(val);
		postRequest.writeBytes(CRLF);
	}",0
"boolean cleanupDisabledPackageReceiversLocked(
            String packageName, Set<String> filterByClasses, int userId, boolean doit) {
        boolean didSomething = false;
        for (int i = mParallelBroadcasts.size() - 1; i >= 0; i--) {
            didSomething |= mParallelBroadcasts.get(i).cleanupDisabledPackageReceiversLocked(
                    packageName, filterByClasses, userId, doit);
            if (!doit && didSomething) {
                return true;
            }
        }

        for (int i = mOrderedBroadcasts.size() - 1; i >= 0; i--) {
            didSomething |= mOrderedBroadcasts.get(i).cleanupDisabledPackageReceiversLocked(
                    packageName, filterByClasses, userId, doit);
            if (!doit && didSomething) {
                return true;
            }
        }

        return didSomething;
    }",0
"public void stop() {
        LOG.debug(""Attempting to stop DNS client"");
        if (resolverPool == null) {
            LOG.error(""DNS resolution pool is not initialized."");
            return;
        }
        resolverPool.stop();
    }",1
"private String getTableName(String str) {
        String[] arr = str.split(""\\s+(?i)where\\s+"");
        String tableName = arr[0].trim();
        //【20230814】解决使用参数tableName=sys_user t&复测，漏洞仍然存在
        if (tableName.contains(""."")) {
            tableName = tableName.substring(tableName.indexOf(""."")+1, tableName.length()).trim();
        }
        if (tableName.contains("" "")) {
            tableName = tableName.substring(0, tableName.indexOf("" "")).trim();
        }
        
        //【issues/4393】 sys_user , (sys_user), sys_user%20, %60sys_user%60
        String reg = ""\\s+|\\(|\\)|`"";
        return tableName.replaceAll(reg, """");
    }",1
"private void init(final String classPathPrefix, final String location, final Path basedir,
      final ClassLoader loader) {
    requireNonNull(loader, ""Resource loader is required."");
    this.fn = location.equals(""/"")
        ? (req, p) -> prefix.apply(p)
        : (req, p) -> MessageFormat.format(prefix.apply(location), vars(req));
    this.loader = loader(basedir, classpathLoader(classPathPrefix, classLoader));
  }",1
"@Before
    public void setUp() throws Exception {
        super.setUp();
        sqlTestList.add(setUp(new SQLDataSetDefTest()));
        sqlTestList.add(setUp(new SQLDataSetTrimTest()));
        sqlTestList.add(setUp(new SQLTableDataSetLookupTest()));
        sqlTestList.add(setUp(new SQLQueryDataSetLookupTest()));
        sqlTestList.add(setUp(new SQLInjectionAttacksTest()));
    }",1
"@CalledByNative
    private void onNativeFlingStopped() {
        // Note that mTouchScrollInProgress should normally be false at this
        // point, but we reset it anyway as another failsafe.
        mTouchScrollInProgress = false;
        if (mPotentiallyActiveFlingCount <= 0) return;
        mPotentiallyActiveFlingCount--;
        updateGestureStateListener(GestureEventType.FLING_END);
    }",0
"public ApiClient addDefaultCookie(String key, String value) {
    defaultCookieMap.put(key, value);
    return this;
  }",0
"@Override
    public void onFailedIncomingCall(Call call) {
        setCallState(call, CallState.DISCONNECTED);
        call.removeListener(this);
    }",0
"protected XWikiDocument prepareEditedDocument(XWikiContext context) throws XWikiException
    {
        // Determine the edited document (translation).
        XWikiDocument editedDocument = getEditedDocument(context);
        EditForm editForm = (EditForm) context.getForm();

        // Update the edited document based on the template specified on the request.
        readFromTemplate(editedDocument, editForm.getTemplate(), context);

        // The default values from the template can be overwritten by additional request parameters.
        updateDocumentTitleAndContentFromRequest(editedDocument, context);
        editedDocument.readObjectsFromForm(editForm, context);

        // Set the current user as creator, author and contentAuthor when the edited document is newly created to avoid
        // using XWikiGuest instead (because those fields were not previously initialized).
        if (editedDocument.isNew()) {
            editedDocument.setCreatorReference(context.getUserReference());
            editedDocument.setAuthorReference(context.getUserReference());
            editedDocument.setContentAuthorReference(context.getUserReference());
        }

        // Expose the edited document on the XWiki context and the Velocity context.
        putDocumentOnContext(editedDocument, context);

        return editedDocument;
    }",1
"protected void handleSerialization(Node node) {
            BeanDefinitionBuilder serializationConfigBuilder = createBeanBuilder(SerializationConfig.class);
            AbstractBeanDefinition beanDefinition = serializationConfigBuilder.getBeanDefinition();
            fillAttributeValues(node, serializationConfigBuilder);
            for (Node child : childElements(node)) {
                String nodeName = cleanNodeName(child);
                if (""data-serializable-factories"".equals(nodeName)) {
                    handleDataSerializableFactories(child, serializationConfigBuilder);
                } else if (""portable-factories"".equals(nodeName)) {
                    handlePortableFactories(child, serializationConfigBuilder);
                } else if (""serializers"".equals(nodeName)) {
                    handleSerializers(child, serializationConfigBuilder);
                } else if (""java-serialization-filter"".equals(nodeName)) {
                    handleJavaSerializationFilter(child, serializationConfigBuilder);
                }
            }
            configBuilder.addPropertyValue(""serializationConfig"", beanDefinition);
        }",1
"public NMapRun getResult() {
        OnePassParser parser = new OnePassParser();
        NMapRun nmapRun = parser.parse(results.getOutput(), OnePassParser.STRING_INPUT);
        return nmapRun;
    }",1
"public static WorkBundle buildWorkBundle(String xml) {
        Document jdoc;
        try {
            jdoc = JDOMUtil.createDocument(xml, false);
            return buildWorkBundle(jdoc);
        } catch (Exception ex) {
            logger.error(""Cannot make WorkBundle from "" + xml, ex);
            return null;
        }
    }",0
"@Exported(visibility=3)
        public String getUpstreamUrl() {
            return upstreamUrl;
        }",0
"public static String concatenateWhere(String a, String b) {
        if (TextUtils.isEmpty(a)) {
            return b;
        }
        if (TextUtils.isEmpty(b)) {
            return a;
        }

        return ""("" + a + "") AND ("" + b + "")"";
    }",0
"@Override
    public CategoryMixin getCategoryMixin() {
        return mCategoryMixin;
    }",0
"public File prepareDownloadFile(Response response) throws IOException {
    String filename = null;
    String contentDisposition = (String) response.getHeaders().getFirst(""Content-Disposition"");
    if (contentDisposition != null && !"""".equals(contentDisposition)) {
      // Get filename from the Content-Disposition header.
      Pattern pattern = Pattern.compile(""filename=['\""]?([^'\""\\s]+)['\""]?"");
      Matcher matcher = pattern.matcher(contentDisposition);
      if (matcher.find())
        filename = matcher.group(1);
    }

    String prefix;
    String suffix = null;
    if (filename == null) {
      prefix = ""download-"";
      suffix = """";
    } else {
      int pos = filename.lastIndexOf('.');
      if (pos == -1) {
        prefix = filename + ""-"";
      } else {
        prefix = filename.substring(0, pos) + ""-"";
        suffix = filename.substring(pos);
      }
      // Files.createTempFile requires the prefix to be at least three characters long
      if (prefix.length() < 3)
        prefix = ""download-"";
    }

    if (tempFolderPath == null)
      return Files.createTempFile(prefix, suffix).toFile();
    else
      return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
  }",1
"@Nullable
  public static String color2html(@Nullable final Color color, final boolean hasAlpha) {
    String result = null;
    if (color != null) {
      final StringBuilder buffer = new StringBuilder();

      buffer.append('#');

      final int[] components;

      if (hasAlpha) {
        components = new int[]{color.getAlpha(), color.getRed(), color.getGreen(), color.getBlue()};
      } else {
        components = new int[]{color.getRed(), color.getGreen(), color.getBlue()};
      }

      for (final int c : components) {
        final String str = Integer.toHexString(c & 0xFF).toUpperCase(Locale.ENGLISH);
        if (str.length() < 2) {
          buffer.append('0');
        }
        buffer.append(str);
      }

      result = buffer.toString();
    }
    return result;
  }",1
"private native void nativeSetMultiTouchZoomSupportEnabled(
            long nativeContentViewCoreImpl, boolean enabled);",0
"ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {
        if (info == null) return null;
        ApplicationInfo newInfo = new ApplicationInfo(info);
        newInfo.uid = applyUserId(info.uid, userId);
        newInfo.dataDir = USER_DATA_DIR + userId + ""/""
                + info.packageName;
        return newInfo;
    }",0
"public static Path getDataFolder(String pi, String dataFolderName, String dataRepositoryFolder) {
        Path repository;
        // TODO Find a way to use absolute repo paths in unit tests
        if (StringUtils.isBlank(dataRepositoryFolder)) {
            repository = Paths.get(DataManager.getInstance().getConfiguration().getViewerHome());
        } else if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryFolder)).isAbsolute()) {
            repository = Paths.get(dataRepositoryFolder);
        } else {
            repository = Paths.get(DataManager.getInstance().getConfiguration().getDataRepositoriesHome(), dataRepositoryFolder);
        }

        Path folder = repository.resolve(dataFolderName).resolve(pi);

        return folder;
    }",0
"@Override
    public String getStringParameterSQL(String param) {
        // DASHBUILDE-113: SQL Injection on data set lookup filters
        String escapedParam = param.replaceAll(""'"", ""''"");
        return ""'"" + escapedParam + ""'"";
    }",1
"@Override
  public void writeTo(T t, Class<?> type, Type genericType,
      Annotation[] annotations,
      MediaType mediaType, MultivaluedMap<String, Object> httpHeaders,
      OutputStream entityStream) throws IOException, WebApplicationException {
    Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));
    try (OutputStreamWriter writer = new OutputStreamWriter(entityStream)) {
      yaml.dump(t, writer);
    }
  }",1
"public void shutdown() {

        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                logger.warn(""Non-Managed connection could not be closed. Whoops!"", e);
            }
        }
    }",1
"@Override
    public synchronized boolean isInboundDone() {
        return isInboundDone || engineClosed;
    }",0
"private void validateCertificateAuthority(final TrustAnchor trustAnchor,
                                              final Map<URI, RpkiRepository> registeredRepositories,
                                              final CertificateRepositoryObjectValidationContext context,
                                              final ValidationResult validationResult,
                                              final List<Key> validatedObjects) {

        ValidationLocation certificateLocation = validationResult.getCurrentLocation();
        ValidationResult temporary = ValidationResult.withLocation(certificateLocation);
        try {
            RpkiRepository rpkiRepository = Bench.mark(trustAnchor.getName(),""registerRepository"", () ->
                storage.writeTx(tx -> registerRepository(tx, trustAnchor, registeredRepositories, context)));

            temporary.warnIfTrue(rpkiRepository.isPending(), VALIDATOR_RPKI_REPOSITORY_PENDING, rpkiRepository.getLocationUri());
            if (rpkiRepository.isPending()) {
                return;
            }

            X509ResourceCertificate certificate = context.getCertificate();
            URI manifestUri = certificate.getManifestUri();
            temporary.setLocation(new ValidationLocation(manifestUri));

            Optional<RpkiObject> manifestObject = Bench.mark(trustAnchor.getName(), ""findLatestMftByAKI"", () ->
                storage.readTx(tx -> rpkiObjects.findLatestMftByAKI(tx, certificate.getSubjectKeyIdentifier())));

            if (!manifestObject.isPresent()) {
                if (rpkiRepository.getStatus() == RpkiRepository.Status.FAILED) {
                    temporary.error(ValidationString.VALIDATOR_NO_MANIFEST_REPOSITORY_FAILED, rpkiRepository.getLocationUri());
                } else {
                    temporary.error(ValidationString.VALIDATOR_NO_LOCAL_MANIFEST_NO_MANIFEST_IN_REPOSITORY, manifestUri.toString(), rpkiRepository.getLocationUri());
                }
            }

            final Optional<ManifestCms> maybeManifest = manifestObject.flatMap(x -> x.get(ManifestCms.class, temporary));

            temporary.rejectIfTrue(manifestObject.isPresent() &&
                            rpkiRepository.getStatus() == RpkiRepository.Status.FAILED &&
                            maybeManifest.isPresent() &&
                            maybeManifest.get().isPastValidityTime(),
                    ValidationString.VALIDATOR_OLD_LOCAL_MANIFEST_REPOSITORY_FAILED, rpkiRepository.getLocationUri());

            if (temporary.hasFailureForCurrentLocation()) {
                return;
            }

            final ManifestCms manifest = maybeManifest.get();
            List<Map.Entry<String, byte[]>> crlEntries = manifest.getFiles().entrySet().stream()
                    .filter(entry -> RepositoryObjectType.parse(entry.getKey()) == RepositoryObjectType.Crl)
                    .collect(toList());
            temporary.rejectIfFalse(crlEntries.size() == 1, VALIDATOR_MANIFEST_CONTAINS_ONE_CRL_ENTRY, String.valueOf(crlEntries.size()));
            if (temporary.hasFailureForCurrentLocation()) {
                return;
            }

            Map.Entry<String, byte[]> crlEntry = crlEntries.get(0);
            URI crlUri = manifestUri.resolve(crlEntry.getKey());

            Optional<RpkiObject> crlObject = storage.readTx(tx -> rpkiObjects.findBySha256(tx, crlEntry.getValue()));
            temporary.rejectIfFalse(crlObject.isPresent(), VALIDATOR_CRL_FOUND, crlUri.toASCIIString());
            if (temporary.hasFailureForCurrentLocation()) {
                return;
            }

            temporary.setLocation(new ValidationLocation(crlUri));
            final Optional<X509Crl> crl = crlObject.flatMap(x -> x.get(X509Crl.class, temporary));

            if (temporary.hasFailureForCurrentLocation()) {
                return;
            }

            final X509Crl x509Crl = crl.get();
            x509Crl.validate(crlUri.toASCIIString(), context, null, validationConfig.validationOptions(), temporary);
            if (temporary.hasFailureForCurrentLocation()) {
                return;
            }

            temporary.setLocation(new ValidationLocation(manifestUri));
            manifest.validate(manifestUri.toASCIIString(), context, x509Crl, manifest.getCrlUri(), validationConfig.validationOptions(), temporary);
            if (temporary.hasFailureForCurrentLocation()) {
                return;
            }
            validatedObjects.add(manifestObject.get().key());

            manifest.getFiles().entrySet()
                .parallelStream()
                .flatMap(entry -> getManifestEntry(manifestUri, entry))
                .flatMap(tuple -> getCertificateRepositoryObjectValidationContext(trustAnchor, context, validatedObjects, crlUri, x509Crl, tuple))
                .map(tuple -> {
                    final ValidationResult vr = tuple.v2();
                    validateCertificateAuthority(trustAnchor, registeredRepositories, tuple.v1(), vr, validatedObjects);
                    return vr;
                })
                .forEachOrdered(temporary::addAll);
        } catch (ManifestEntryException e){
            temporary.addAll(e.getVr());
        }
        catch (Exception e) {
            validationResult.error(ErrorCodes.UNHANDLED_EXCEPTION, e.toString(), ExceptionUtils.getStackTrace(e));
        }

        finally {
            validationResult.addAll(temporary);
        }
    }",1
"@Override
	public List<KBTemplate> findAll(int start, int end) {
		return findAll(start, end, null);
	}",0
"public void removeStack(int stackId) {
        synchronized (mWindowMap) {
            mStackIdToStack.remove(stackId);
        }
    }",0
"@Override
    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,
            MapType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        JavaType keyType = type.getKeyType();
        JavaType contentType = type.getContentType();
        
        // First: is there annotation-specified deserializer for values?
        @SuppressWarnings(""unchecked"")
        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();

        // Ok: need a key deserializer (null indicates 'default' here)
        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();
        // Then optional type info; either attached to type, or resolved separately:
        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();
        // but if not, may still be possible to find:
        if (contentTypeDeser == null) {
            contentTypeDeser = findTypeDeserializer(config, contentType);
        }

        // 23-Nov-2010, tatu: Custom deserializer?
        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,
                keyDes, contentTypeDeser, contentDeser);

        if (deser == null) {
            // Value handling is identical for all, but EnumMap requires special handling for keys
            Class<?> mapClass = type.getRawClass();
            if (EnumMap.class.isAssignableFrom(mapClass)) {
                ValueInstantiator inst;

                // 06-Mar-2017, tatu: Should only need to check ValueInstantiator for
                //    custom sub-classes, see [databind#1544]
                if (mapClass == EnumMap.class) {
                    inst = null;
                } else {
                    inst = findValueInstantiator(ctxt, beanDesc);
                }
                Class<?> kt = keyType.getRawClass();
                if (kt == null || !ClassUtil.isEnumType(kt)) {
                    throw new IllegalArgumentException(""Cannot construct EnumMap; generic (key) type not available"");
                }
                deser = new EnumMapDeserializer(type, inst, null,
                        contentDeser, contentTypeDeser, null);
            }

            // Otherwise, generic handler works ok.
    
            /* But there is one more twist: if we are being asked to instantiate
             * an interface or abstract Map, we need to either find something
             * that implements the thing, or give up.
             *
             * Note that we do NOT try to guess based on secondary interfaces
             * here; that would probably not work correctly since casts would
             * fail later on (as the primary type is not the interface we'd
             * be implementing)
             */
            if (deser == null) {
                if (type.isInterface() || type.isAbstract()) {
                    MapType fallback = _mapAbstractMapType(type, config);
                    if (fallback != null) {
                        type = (MapType) fallback;
                        mapClass = type.getRawClass();
                        // But if so, also need to re-check creators...
                        beanDesc = config.introspectForCreation(type);
                    } else {
                        // [databind#292]: Actually, may be fine, but only if polymorphic deser enabled
                        if (type.getTypeHandler() == null) {
                            throw new IllegalArgumentException(""Cannot find a deserializer for non-concrete Map type ""+type);
                        }
                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);
                    }
                } else {
                    // 10-Jan-2017, tatu: `java.util.Collections` types need help:
                    deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);
                    if (deser != null) {
                        return deser;
                    }
                }
                if (deser == null) {
                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);
                    // 01-May-2016, tatu: Which base type to use here gets tricky, since
                    //   most often it ought to be `Map` or `EnumMap`, but due to abstract
                    //   mapping it will more likely be concrete type like `HashMap`.
                    //   So, for time being, just pass `Map.class`
                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);
                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,
                            beanDesc.getClassInfo());
                    Set<String> ignored = (ignorals == null) ? null
                            : ignorals.findIgnoredForDeserialization();
                    md.setIgnorableProperties(ignored);
                    deser = md;
                }
            }
        }
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);
            }
        }
        return deser;
    }",1
"@Deprecated
    public void addEntry(LocalDocumentReference reference)
    {
        addEntry(reference, null);
    }",0
"@Override
    public boolean onAuthenticated(int fingerId, int groupId) {
        boolean result = false;
        boolean authenticated = fingerId != 0;

        IFingerprintServiceReceiver receiver = getReceiver();
        if (receiver != null) {
            try {
                MetricsLogger.action(getContext(), MetricsEvent.ACTION_FINGERPRINT_AUTH,
                        authenticated);
                if (!authenticated) {
                    receiver.onAuthenticationFailed(getHalDeviceId());
                } else {
                    if (DEBUG) {
                        Slog.v(TAG, ""onAuthenticated(owner="" + getOwnerString()
                                + "", id="" + fingerId + "", gp="" + groupId + "")"");
                    }
                    Fingerprint fp = !getIsRestricted()
                            ? new Fingerprint("""" /* TODO */, groupId, fingerId, getHalDeviceId())
                            : null;
                    receiver.onAuthenticationSucceeded(getHalDeviceId(), fp, getTargetUserId());
                }
            } catch (RemoteException e) {
                Slog.w(TAG, ""Failed to notify Authenticated:"", e);
                result = true; // client failed
            }
        } else {
            result = true; // client not listening
        }
        if (!authenticated) {
            if (receiver != null) {
                FingerprintUtils.vibrateFingerprintError(getContext());
            }
            // allow system-defined limit of number of attempts before giving up
            boolean inLockoutMode =  handleFailedAttempt();
            // send lockout event in case driver doesn't enforce it.
            if (inLockoutMode) {
                try {
                    Slog.w(TAG, ""Forcing lockout (fp driver code should do this!)"");
                    receiver.onError(getHalDeviceId(),
                            FingerprintManager.FINGERPRINT_ERROR_LOCKOUT);
                } catch (RemoteException e) {
                    Slog.w(TAG, ""Failed to notify lockout:"", e);
                }
            }
            result |= inLockoutMode;
        } else {
            if (receiver != null) {
                FingerprintUtils.vibrateFingerprintSuccess(getContext());
            }
            result |= true; // we have a valid fingerprint, done
            resetFailedAttempts();
        }
        return result;
    }",1
"private String escapeString(final String string)
  {
    if (string == null || string.length() == 0) {
      return ""\""\"""";
    }
    char c = 0;
    int i;
    final int len = string.length();
    final StringBuilder sb = new StringBuilder(len + 4);
    String t;
    sb.append('""');
    for (i = 0; i < len; i += 1) {
      c = string.charAt(i);
      switch (c) {
        case '\\':
        case '""':
          sb.append('\\');
          sb.append(c);
          break;
        case '/':
          // if (b == '<') {
          sb.append('\\');
          // }
          sb.append(c);
          break;
        case '\b':
          sb.append(""\\b"");
          break;
        case '\t':
          sb.append(""\\t"");
          break;
        case '\n':
          sb.append(""\\n"");
          break;
        case '\f':
          sb.append(""\\f"");
          break;
        case '\r':
          sb.append(""\\r"");
          break;
        default:
          if (c < ' ') {
            t = ""000"" + Integer.toHexString(c);
            sb.append(""\\u"" + t.substring(t.length() - 4));
          } else {
            if (escapeHtml == true) {
              switch (c) {
                case '<':
                  sb.append(""&lt;"");
                  break;
                case '>':
                  sb.append(""&gt;"");
                  break;
                case '&':
                  sb.append(""&amp;"");
                  break;
                case '""':
                  sb.append(""&quot;"");
                  break;
                case '\'':
                  sb.append(""&#x27;"");
                  break;
                case '/':
                  sb.append(""&#x2F;"");
                  break;
                default:
                  sb.append(c);
              }
            } else {
              sb.append(c);
            }
          }
      }
    }
    sb.append('""');
    return sb.toString();
  }",1
"boolean clearPackagePreferredActivitiesLPw(String packageName, int userId) {
        ArrayList<PreferredActivity> removed = null;
        boolean changed = false;
        for (int i=0; i<mSettings.mPreferredActivities.size(); i++) {
            final int thisUserId = mSettings.mPreferredActivities.keyAt(i);
            PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);
            if (userId != UserHandle.USER_ALL && userId != thisUserId) {
                continue;
            }
            Iterator<PreferredActivity> it = pir.filterIterator();
            while (it.hasNext()) {
                PreferredActivity pa = it.next();
                // Mark entry for removal only if it matches the package name
                // and the entry is of type ""always"".
                if (packageName == null ||
                        (pa.mPref.mComponent.getPackageName().equals(packageName)
                                && pa.mPref.mAlways)) {
                    if (removed == null) {
                        removed = new ArrayList<PreferredActivity>();
                    }
                    removed.add(pa);
                }
            }
            if (removed != null) {
                for (int j=0; j<removed.size(); j++) {
                    PreferredActivity pa = removed.get(j);
                    pir.removeFilter(pa);
                }
                changed = true;
            }
        }
        return changed;
    }",0
"public static Iterable<Node> childElements(Node node) {
        return new IterableNodeList(node, Node.ELEMENT_NODE);
    }",0
"public String addScenarioToPlan(SaveApiPlanRequest request) {
        if (CollectionUtils.isEmpty(request.getPlanIds())) {
            MSException.throwException(Translator.get(""plan id is null ""));
        }
        Map<String, List<String>> mapping = request.getMapping();
        Map<String, String> envMap = request.getEnvMap();
        Set<String> set = mapping.keySet();
        List<TestPlanDTO> list = extTestPlanMapper.selectByIds(request.getPlanIds());
        SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
        ExtTestPlanScenarioCaseMapper scenarioBatchMapper = sqlSession.getMapper(ExtTestPlanScenarioCaseMapper.class);
        ExtTestPlanApiCaseMapper apiCaseBatchMapper = sqlSession.getMapper(ExtTestPlanApiCaseMapper.class);

        String environmentType = request.getEnvironmentType();
        String envGroupId = request.getEnvGroupId();
        for (TestPlanDTO testPlan : list) {
            if (!set.isEmpty()) {
                set.forEach(id -> {
                    TestPlanApiScenario testPlanApiScenario = new TestPlanApiScenario();
                    testPlanApiScenario.setId(UUID.randomUUID().toString());
                    testPlanApiScenario.setApiScenarioId(id);
                    testPlanApiScenario.setTestPlanId(testPlan.getId());
                    testPlanApiScenario.setCreateTime(System.currentTimeMillis());
                    testPlanApiScenario.setUpdateTime(System.currentTimeMillis());
                    if (StringUtils.equals(environmentType, EnvironmentType.GROUP.name()) && StringUtils.isNotBlank(envGroupId)) {
                        testPlanApiScenario.setEnvironmentType(EnvironmentType.GROUP.name());
                        testPlanApiScenario.setEnvironmentGroupId(envGroupId);
                    } else if (StringUtils.equals(environmentType, EnvironmentType.JSON.name())) {
                        Map<String, String> newEnvMap = new HashMap<>(16);
                        if (envMap != null && !envMap.isEmpty()) {
                            List<String> lt = mapping.get(id);
                            lt.forEach(l -> {
                                newEnvMap.put(l, envMap.get(l));
                            });
                        }
                        testPlanApiScenario.setEnvironmentType(EnvironmentType.JSON.name());
                        testPlanApiScenario.setEnvironment(JSON.toJSONString(newEnvMap));
                    }
                    if (StringUtils.isNotBlank(testPlanApiScenario.getEnvironmentType())) {
                        Long nextScenarioOrder = ServiceUtils.getNextOrder(testPlan.getId(), extTestPlanScenarioCaseMapper::getLastOrder);
                        testPlanApiScenario.setOrder(nextScenarioOrder);
                        scenarioBatchMapper.insertIfNotExists(testPlanApiScenario);
                    }
                });
            }
            if (request.getApiIds() != null) {
                for (String caseId : request.getApiIds()) {
                    TestPlanApiCase testPlanApiCase = new TestPlanApiCase();
                    testPlanApiCase.setId(UUID.randomUUID().toString());
                    testPlanApiCase.setApiCaseId(caseId);
                    testPlanApiCase.setTestPlanId(testPlan.getId());
                    testPlanApiCase.setCreateTime(System.currentTimeMillis());
                    testPlanApiCase.setUpdateTime(System.currentTimeMillis());
                    apiCaseBatchMapper.insertIfNotExists(testPlanApiCase);
                }
            }
        }
        sqlSession.flushStatements();
        if (sqlSession != null && sqlSessionFactory != null) {
            SqlSessionUtils.closeSqlSession(sqlSession, sqlSessionFactory);
        }
        return ""success"";
    }",0
"public File prepareDownloadFile(Response response) throws IOException {
    String filename = null;
    String contentDisposition = (String) response.getHeaders().getFirst(""Content-Disposition"");
    if (contentDisposition != null && !"""".equals(contentDisposition)) {
      // Get filename from the Content-Disposition header.
      Pattern pattern = Pattern.compile(""filename=['\""]?([^'\""\\s]+)['\""]?"");
      Matcher matcher = pattern.matcher(contentDisposition);
      if (matcher.find())
        filename = matcher.group(1);
    }

    String prefix;
    String suffix = null;
    if (filename == null) {
      prefix = ""download-"";
      suffix = """";
    } else {
      int pos = filename.lastIndexOf('.');
      if (pos == -1) {
        prefix = filename + ""-"";
      } else {
        prefix = filename.substring(0, pos) + ""-"";
        suffix = filename.substring(pos);
      }
      // Files.createTempFile requires the prefix to be at least three characters long
      if (prefix.length() < 3)
        prefix = ""download-"";
    }

    if (tempFolderPath == null)
      return Files.createTempFile(prefix, suffix).toFile();
    else
      return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
  }",1
"private VerifyCredentialResponse doVerifyPassword(String password, CredentialHash storedHash,
            boolean hasChallenge, long challenge, int userId) throws RemoteException {
       return verifyCredential(userId, storedHash, password, hasChallenge, challenge,
               new CredentialUtil() {
                   @Override
                   public void setCredential(String password, String oldPassword, int userId)
                           throws RemoteException {
                        setLockPasswordInternal(password, oldPassword, userId);
                   }

                   @Override
                   public byte[] toHash(String password, int userId) {
                       return mLockPatternUtils.passwordToHash(password, userId);
                   }

                   @Override
                   public String adjustForKeystore(String password) {
                       return password;
                   }
               }
       );
    }",0
"@Nullable
	protected String getDescription(InstanceEvent event, Instance instance) {
		Map<String, Object> root = new HashMap<>();
		root.put(""event"", event);
		root.put(""instance"", instance);
		root.put(""lastStatus"", getLastStatus(event.getInstance()));
		SimpleEvaluationContext context = SimpleEvaluationContext
				.forPropertyAccessors(DataBindingPropertyAccessor.forReadOnlyAccess(), new MapAccessor())
				.withRootObject(root).build();
		return description.getValue(context, String.class);
	}",1
"protected void sendReport(
    	RequestContext requestContext,
        Hashtable<String, Integer> errorList
     ) throws IOException {
    	HttpServletResponse resp = requestContext.getHttpServletResponse();
    	HttpServletRequest req = requestContext.getHttpServletRequest();
        resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
        String absoluteUri = req.getRequestURI();
        // String relativePath = getRelativePath(req);
        HashMap<String, String> namespaces = new HashMap<String, String>();
        namespaces.put(""DAV:"", ""D"");
        XMLWriter writer = new XMLWriter(resp.getWriter(), namespaces);
        writer.writeXMLHeader();
        writer.writeElement(""DAV::multistatus"", XMLWriter.OPENING);
        Enumeration<String> pathList = errorList.keys();
        while (pathList.hasMoreElements()) {
            String errorPath = pathList.nextElement();
            int errorCode = errorList.get(errorPath);
            writer.writeElement(""DAV::response"", XMLWriter.OPENING);
            writer.writeElement(""DAV::href"", XMLWriter.OPENING);
            String toAppend = null;
            if (absoluteUri.endsWith(errorPath)) {
                toAppend = absoluteUri;
            } else if (absoluteUri.contains(errorPath)) {
                int endIndex = absoluteUri.indexOf(errorPath) + errorPath.length();
                toAppend = absoluteUri.substring(0, endIndex);
            }
            if (!toAppend.startsWith(""/"") && !toAppend.startsWith(""http:"")) {
                toAppend = ""/"" + toAppend;
            }
            writer.writeText(errorPath);
            writer.writeElement(""DAV::href"", XMLWriter.CLOSING);
            writer.writeElement(""DAV::status"", XMLWriter.OPENING);
            writer.writeText(""HTTP/1.1 "" + errorCode);
            writer.writeElement(""DAV::status"", XMLWriter.CLOSING);
            writer.writeElement(""DAV::response"", XMLWriter.CLOSING);
        }
        writer.writeElement(""DAV::multistatus"", XMLWriter.CLOSING);
        writer.sendData();
    }",0
"@Override
        protected void onServiceReady(ICarrierMessagingService carrierMessagingService) {
            try {
                carrierMessagingService.sendMultipartTextSms(
                        mParts, getSubId(), mTrackers[0].mDestAddress,
                        getSendSmsFlag(mTrackers[0].mDeliveryIntent), mSenderCallback);
            } catch (RemoteException e) {
                Rlog.e(TAG, ""Exception sending the SMS: "" + e);
                mSenderCallback.onSendMultipartSmsComplete(
                        CarrierMessagingService.SEND_STATUS_RETRY_ON_CARRIER_NETWORK,
                        null /* smsResponse */);
            }
        }",0
"private void createBuffers() {
        debug(""JSSEngine: createBuffers()"");

        // If the buffers exist, destroy them and then recreate them.

        if (read_buf != null) {
            Buffer.Free(read_buf);
        }
        read_buf = Buffer.Create(BUFFER_SIZE);

        if (write_buf != null) {
            Buffer.Free(write_buf);
        }
        write_buf = Buffer.Create(BUFFER_SIZE);
    }",0
"private boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {
        boolean allowed = checkPermission(android.Manifest.permission.REAL_GET_TASKS,
                callingPid, callingUid) == PackageManager.PERMISSION_GRANTED;
        if (!allowed) {
            if (checkPermission(android.Manifest.permission.GET_TASKS,
                    callingPid, callingUid) == PackageManager.PERMISSION_GRANTED) {
                // Temporary compatibility: some existing apps on the system image may
                // still be requesting the old permission and not switched to the new
                // one; if so, we'll still allow them full access.  This means we need
                // to see if they are holding the old permission and are a system app.
                try {
                    if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) {
                        allowed = true;
                        Slog.w(TAG, caller + "": caller "" + callingUid
                                + "" is using old GET_TASKS but privileged; allowing"");
                    }
                } catch (RemoteException e) {
                }
            }
        }
        if (!allowed) {
            Slog.w(TAG, caller + "": caller "" + callingUid
                    + "" does not hold REAL_GET_TASKS; limiting output"");
        }
        return allowed;
    }",1
"@SuppressFBWarnings(""DMI"")
    private void notifyUploadResult(UploadFileOperation upload, RemoteOperationResult uploadResult) {
        Log_OC.d(TAG, ""NotifyUploadResult with resultCode: "" + uploadResult.getCode());
        // cancelled operation or success -> silent removal of progress notification
        if (mNotificationManager == null) {
            mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        }

        // Only notify if the upload fails
        if (!uploadResult.isCancelled() &&
            !uploadResult.isSuccess() &&
            !ResultCode.LOCAL_FILE_NOT_FOUND.equals(uploadResult.getCode()) &&
            !uploadResult.getCode().equals(ResultCode.DELAYED_FOR_WIFI) &&
            !uploadResult.getCode().equals(ResultCode.DELAYED_FOR_CHARGING) &&
            !uploadResult.getCode().equals(ResultCode.DELAYED_IN_POWER_SAVE_MODE) &&
            !uploadResult.getCode().equals(ResultCode.LOCK_FAILED)) {

            int tickerId = R.string.uploader_upload_failed_ticker;

            String content;

            // check credentials error
            boolean needsToUpdateCredentials = uploadResult.getCode() == ResultCode.UNAUTHORIZED;
            if (needsToUpdateCredentials) {
                tickerId = R.string.uploader_upload_failed_credentials_error;
            } else if (uploadResult.getCode() == ResultCode.SYNC_CONFLICT) { // check file conflict
                tickerId = R.string.uploader_upload_failed_sync_conflict_error;
            }

            mNotificationBuilder
                .setTicker(getString(tickerId))
                .setContentTitle(getString(tickerId))
                .setAutoCancel(true)
                .setOngoing(false)
                .setProgress(0, 0, false);

            content = ErrorMessageAdapter.getErrorCauseMessage(uploadResult, upload, getResources());

            if (needsToUpdateCredentials) {
                // let the user update credentials with one click
                Intent updateAccountCredentials = new Intent(this, AuthenticatorActivity.class);
                updateAccountCredentials.putExtra(
                    AuthenticatorActivity.EXTRA_ACCOUNT, upload.getAccount()
                );
                updateAccountCredentials.putExtra(
                    AuthenticatorActivity.EXTRA_ACTION,
                    AuthenticatorActivity.ACTION_UPDATE_EXPIRED_TOKEN
                );

                updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
                updateAccountCredentials.addFlags(Intent.FLAG_FROM_BACKGROUND);
                mNotificationBuilder.setContentIntent(PendingIntent.getActivity(
                    this,
                    (int) System.currentTimeMillis(),
                    updateAccountCredentials,
                    PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE
                ));
            } else {
                Intent intent;
                if (uploadResult.getCode().equals(ResultCode.SYNC_CONFLICT)) {
                    intent = ConflictsResolveActivity.createIntent(upload.getFile(),
                                                                   upload.getUser(),
                                                                   upload.getOCUploadId(),
                                                                   Intent.FLAG_ACTIVITY_CLEAR_TOP,
                                                                   this);
                } else {
                    intent = UploadListActivity.createIntent(upload.getFile(),
                                                             upload.getUser(),
                                                             Intent.FLAG_ACTIVITY_CLEAR_TOP,
                                                             this);
                }

                mNotificationBuilder.setContentIntent(PendingIntent.getActivity(this,
                                                                                (int) System.currentTimeMillis(),
                                                                                intent,
                                                                                PendingIntent.FLAG_IMMUTABLE)
                                                     );
            }

            mNotificationBuilder.setContentText(content);
            if (!uploadResult.isSuccess()) {
                mNotificationManager.notify((new SecureRandom()).nextInt(), mNotificationBuilder.build());
            }
        }
    }",1
"private void configureProxy() {
        saveProxyConfiguration = saveProxyConfiguration();
        final String host = (String) getInputParameter(PROXY_HOST);
        if (host == null || host.isEmpty()) {
            return;
        }
        logger.info(PROXY_HOST + "" "" + host);
        final String protocol = (String) getInputParameter(PROXY_PROTOCOL);
        logger.info(PROXY_PROTOCOL + "" "" + protocol);
        final String port = (String) getInputParameter(PROXY_PORT);
        logger.info(PROXY_PORT + "" "" + port);

        if (SOCKS.equals(protocol)) {
            System.setProperty(""socksProxyHost"", host);
            logger.info(""Setting environment variable: socksProxyHost="" + host);
            System.setProperty(""socksProxyPort"", port);
            logger.info(""Setting environment variable: socksProxyPort="" + port);
        } else {
            final String hostKey = String.format(""%s.proxyHost"", protocol.toLowerCase());
            System.setProperty(hostKey, host);
            logger.info(""Setting environment variable: "" + hostKey + ""="" + host);
            final String portKey = String.format(""%s.proxyPort"", protocol.toLowerCase());
            System.setProperty(portKey, port);
            logger.info(""Setting environment variable: "" + portKey + ""="" + port);
        }

        final String user = (String) getInputParameter(PROXY_USER);
        logger.info(PROXY_USER + "" "" + user);
        final String password = (String) getInputParameter(PROXY_PASSWORD);
        logger.info(PROXY_PASSWORD + "" ********"");
        if (user != null && !user.isEmpty()) {
            Authenticator.setDefault(new Authenticator() {

                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(user,
                            password != null ? password.toCharArray() : """".toCharArray());
                }

            });
        }

    }",1
"private ServletFileUpload getServletFileUpload() {
        FileItemFactory factory = new DiskFileItemFactory();
        ServletFileUpload upload = new ServletFileUpload( factory );
        upload.setHeaderEncoding( ""UTF-8"" );
        return upload;
    }",1
"private void populateMap(Object bean, Set<Object> objectsRecord) {
        Class<?> klass = bean.getClass();

        // If klass is a System class then set includeSuperClass to false.

        boolean includeSuperClass = klass.getClassLoader() != null;

        Method[] methods = includeSuperClass ? klass.getMethods() : klass.getDeclaredMethods();
        for (final Method method : methods) {
            final int modifiers = method.getModifiers();
            if (Modifier.isPublic(modifiers)
                    && !Modifier.isStatic(modifiers)
                    && method.getParameterTypes().length == 0
                    && !method.isBridge()
                    && method.getReturnType() != Void.TYPE
                    && isValidMethodName(method.getName())) {
                final String key = getKeyNameFromMethod(method);
                if (key != null && !key.isEmpty()) {
                    try {
                        final Object result = method.invoke(bean);
                        if (result != null) {
                            // check cyclic dependency and throw error if needed
                            // the wrap and populateMap combination method is
                            // itself DFS recursive
                            if (objectsRecord.contains(result)) {
                                throw recursivelyDefinedObjectException(key);
                            }

                            objectsRecord.add(result);

                            this.map.put(key, wrap(result, objectsRecord));

                            objectsRecord.remove(result);

                            // we don't use the result anywhere outside of wrap
                            // if it's a resource we should be sure to close it
                            // after calling toString
                            if (result instanceof Closeable) {
                                try {
                                    ((Closeable) result).close();
                                } catch (IOException ignore) {
                                }
                            }
                        }
                    } catch (IllegalAccessException ignore) {
                    } catch (IllegalArgumentException ignore) {
                    } catch (InvocationTargetException ignore) {
                    }
                }
            }
        }
    }",1
"protected RuntimeResourceDefinition getResourceType(HomeRequest theRequest, HttpServletRequest theReq) throws ServletException {
		String resourceName = sanitizeUrlPart(defaultString(theReq.getParameter(PARAM_RESOURCE)));
		RuntimeResourceDefinition def = getContext(theRequest).getResourceDefinition(resourceName);
		if (def == null) {
			throw new ServletException(""Invalid resourceName: "" + resourceName);
		}
		return def;
	}",1
"public static Document toXml(final IBaseDataObject d) {
        final Element root = new Element(""payload"");
        root.addContent(JDOMUtil.protectedElement(""name"", d.getFilename()));
        final Element cf = new Element(""current-forms"");
        for (final String c : d.getAllCurrentForms()) {
            cf.addContent(JDOMUtil.simpleElement(""current-form"", c));
        }
        root.addContent(cf);
        root.addContent(JDOMUtil.simpleElement(""encoding"", d.getFontEncoding()));
        root.addContent(JDOMUtil.simpleElement(""filetype"", d.getFileType()));
        root.addContent(JDOMUtil.simpleElement(""classification"", d.getClassification()));
        final Element th = new Element(""transform-history"");
        for (final String s : d.transformHistory()) {
            th.addContent(JDOMUtil.simpleElement(""itinerary-step"", s));
        }
        root.addContent(th);
        if (d.getProcessingError() != null) {
            root.addContent(JDOMUtil.simpleElement(""processing-error"", d.getProcessingError()));
        }
        final Element meta = new Element(""metadata"");
        for (final String key : d.getParameters().keySet()) {
            final Element m = JDOMUtil.protectedElement(""param"", d.getStringParameter(key));
            m.setAttribute(""name"", key);
            meta.addContent(m);
        }
        root.addContent(meta);

        if (d.header() != null) {
            root.addContent(JDOMUtil.protectedElement(""header"", d.header()));
        }
        if (d.dataLength() > 0) {
            root.addContent(JDOMUtil.protectedElement(""data"", d.data()));
        }
        if (d.footer() != null) {
            root.addContent(JDOMUtil.protectedElement(""footer"", d.footer()));
        }

        // Alt views
        if (d.getNumAlternateViews() > 0) {
            final Element views = new Element(""views"");
            for (final String av : d.getAlternateViewNames()) {
                final Element v = JDOMUtil.protectedElement(""view"", d.getAlternateView(av));
                v.setAttribute(""name"", av);
                views.addContent(v);
            }
            root.addContent(views);
        }

        logger.debug(""Produced xml document for "" + d.shortName());
        return new Document(root);
    }",1
"boolean inSizeCompatMode() {
        if (mInSizeCompatModeForBounds) {
            return true;
        }
        if (mCompatDisplayInsets == null || !shouldCreateCompatDisplayInsets()
                // The orientation is different from parent when transforming.
                || isFixedRotationTransforming()) {
            return false;
        }
        final Rect appBounds = getConfiguration().windowConfiguration.getAppBounds();
        if (appBounds == null) {
            // The app bounds hasn't been computed yet.
            return false;
        }
        final WindowContainer parent = getParent();
        if (parent == null) {
            // The parent of detached Activity can be null.
            return false;
        }
        final Configuration parentConfig = parent.getConfiguration();
        // Although colorMode, screenLayout, smallestScreenWidthDp are also fixed, generally these
        // fields should be changed with density and bounds, so here only compares the most
        // significant field.
        return parentConfig.densityDpi != getConfiguration().densityDpi;
    }",0
"static PhoneAccount createPhoneAccount(Context context, SipProfile profile) {
        // Build a URI to represent the SIP account.  Does not use SipProfile#getUriString() since
        // that prototype can include transport information which we do not want to see in the
        // phone account.
        String sipAddress = profile.getUserName() + ""@"" + profile.getSipDomain();
        Uri sipUri = Uri.parse(profile.getUriString());

        PhoneAccountHandle accountHandle =
                SipUtil.createAccountHandle(context, profile.getProfileName());

        final ArrayList<String> supportedUriSchemes = new ArrayList<String>();
        supportedUriSchemes.add(PhoneAccount.SCHEME_SIP);
        if (useSipForPstnCalls(context)) {
            supportedUriSchemes.add(PhoneAccount.SCHEME_TEL);
        }

        PhoneAccount.Builder builder = PhoneAccount.builder(accountHandle, profile.getDisplayName())
                .setCapabilities(PhoneAccount.CAPABILITY_CALL_PROVIDER
                        | PhoneAccount.CAPABILITY_MULTI_USER)
                .setAddress(sipUri)
                .setShortDescription(sipAddress)
                .setIcon(Icon.createWithResource(
                        context.getResources(), R.drawable.ic_dialer_sip_black_24dp))
                .setSupportedUriSchemes(supportedUriSchemes);

        return builder.build();
    }",0
"@Override
    public int getMaxY() {
        return maxY;
    }",0
"private List<Map<String, Object>> findEntry(String sql, Object[] paras) {
        List<Log> logList = find(sql, paras);
        List<Map<String, Object>> convertList = new ArrayList<>();
        for (Log log : logList) {
            convertList.add(log.getAttrs());
        }
        return convertList;
    }",1
"private void addSecurityPages() {
		add(new DynamicPathPageMapper(""login"", LoginPage.class));
		add(new DynamicPathPageMapper(""logout"", LogoutPage.class));
		add(new DynamicPathPageMapper(""signup"", SignUpPage.class));
		add(new DynamicPathPageMapper(""reset-password"", PasswordResetPage.class));
		add(new DynamicPathPageMapper(SsoProcessPage.MOUNT_PATH + ""/${stage}/${connector}"", SsoProcessPage.class));
	}",0
"@Override
    public TraceBrief queryBasicTraces(long startSecondTB,
                                       long endSecondTB,
                                       long minDuration,
                                       long maxDuration,
                                       String endpointName,
                                       String serviceId,
                                       String serviceInstanceId,
                                       String endpointId,
                                       String traceId,
                                       int limit,
                                       int from,
                                       TraceState traceState,
                                       QueryOrder queryOrder) throws IOException {
        StringBuilder sql = new StringBuilder();
        List<Object> parameters = new ArrayList<>(10);

        sql.append(""from "").append(SegmentRecord.INDEX_NAME).append("" where "");
        sql.append("" 1=1 "");
        if (startSecondTB != 0 && endSecondTB != 0) {
            sql.append("" and "").append(SegmentRecord.TIME_BUCKET).append("" >= ?"");
            parameters.add(startSecondTB);
            sql.append("" and "").append(SegmentRecord.TIME_BUCKET).append("" <= ?"");
            parameters.add(endSecondTB);
        }
        if (minDuration != 0 || maxDuration != 0) {
            if (minDuration != 0) {
                sql.append("" and "").append(SegmentRecord.LATENCY).append("" >= ?"");
                parameters.add(minDuration);
            }
            if (maxDuration != 0) {
                sql.append("" and "").append(SegmentRecord.LATENCY).append("" <= ?"");
                parameters.add(maxDuration);
            }
        }
        if (!Strings.isNullOrEmpty(endpointName)) {
            sql.append("" and "").append(SegmentRecord.ENDPOINT_NAME).append("" like concat('%',?,'%')"");
            parameters.add(endpointName);
        }
        if (StringUtil.isNotEmpty(serviceId)) {
            sql.append("" and "").append(SegmentRecord.SERVICE_ID).append("" = ?"");
            parameters.add(serviceId);
        }
        if (StringUtil.isNotEmpty(serviceInstanceId)) {
            sql.append("" and "").append(SegmentRecord.SERVICE_INSTANCE_ID).append("" = ?"");
            parameters.add(serviceInstanceId);
        }
        if (!Strings.isNullOrEmpty(endpointId)) {
            sql.append("" and "").append(SegmentRecord.ENDPOINT_ID).append("" = ?"");
            parameters.add(endpointId);
        }
        if (!Strings.isNullOrEmpty(traceId)) {
            sql.append("" and "").append(SegmentRecord.TRACE_ID).append("" = ?"");
            parameters.add(traceId);
        }
        switch (traceState) {
            case ERROR:
                sql.append("" and "").append(SegmentRecord.IS_ERROR).append("" = "").append(BooleanUtils.TRUE);
                break;
            case SUCCESS:
                sql.append("" and "").append(SegmentRecord.IS_ERROR).append("" = "").append(BooleanUtils.FALSE);
                break;
        }
        switch (queryOrder) {
            case BY_START_TIME:
                sql.append("" order by "").append(SegmentRecord.START_TIME).append("" "").append(SortOrder.DESC);
                break;
            case BY_DURATION:
                sql.append("" order by "").append(SegmentRecord.LATENCY).append("" "").append(SortOrder.DESC);
                break;
        }

        TraceBrief traceBrief = new TraceBrief();
        try (Connection connection = h2Client.getConnection()) {

            try (ResultSet resultSet = h2Client.executeQuery(connection, buildCountStatement(sql.toString()), parameters
                .toArray(new Object[0]))) {
                while (resultSet.next()) {
                    traceBrief.setTotal(resultSet.getInt(""total""));
                }
            }

            buildLimit(sql, from, limit);

            try (ResultSet resultSet = h2Client.executeQuery(
                connection, ""select * "" + sql.toString(), parameters.toArray(new Object[0]))) {
                while (resultSet.next()) {
                    BasicTrace basicTrace = new BasicTrace();

                    basicTrace.setSegmentId(resultSet.getString(SegmentRecord.SEGMENT_ID));
                    basicTrace.setStart(resultSet.getString(SegmentRecord.START_TIME));
                    basicTrace.getEndpointNames().add(resultSet.getString(SegmentRecord.ENDPOINT_NAME));
                    basicTrace.setDuration(resultSet.getInt(SegmentRecord.LATENCY));
                    basicTrace.setError(BooleanUtils.valueToBoolean(resultSet.getInt(SegmentRecord.IS_ERROR)));
                    String traceIds = resultSet.getString(SegmentRecord.TRACE_ID);
                    basicTrace.getTraceIds().add(traceIds);
                    traceBrief.getTraces().add(basicTrace);
                }
            }
        } catch (SQLException e) {
            throw new IOException(e);
        }

        return traceBrief;
    }",1
"@Override
    public int describeContents() {
        return 0;
    }",0
"public void moveTaskToFront(int task, int flags, Bundle options) throws RemoteException;",0
"protected void internalHandleResult(AsyncResponse asyncResponse,
                                        Object res,
                                        Throwable ex,
                                        String errorMsg) {
        if (ex instanceof RestException) {
            log.error(errorMsg, ex);
            asyncResponse.resume(ex);
        } else if (ex != null) {
            log.error(errorMsg, ex);
            asyncResponse.resume(new RestException(ex));
        } else {
            if (res == null) {
                asyncResponse.resume(Response.noContent().build());
            } else {
                asyncResponse.resume(res);
            }
        }
    }",0
"@Override
	protected void onInitialize() {
		super.onInitialize();

		container = new WebMarkupContainer(""container"");
		container.setOutputMarkupId(true);
		
		add(container);
		
		WebMarkupContainer editLink = new WebMarkupContainer(""editLink"");
		WebMarkupContainer splitLink = new WebMarkupContainer(""splitLink"");
		WebMarkupContainer preview = new WebMarkupContainer(""preview"");
		WebMarkupContainer edit = new WebMarkupContainer(""edit"");
		container.add(editLink);
		container.add(splitLink);
		container.add(preview);
		container.add(edit);
		
		container.add(AttributeAppender.append(""class"", compactMode?""compact-mode"":""normal-mode""));
		
		container.add(new DropdownLink(""doReference"") {


			@Override
			protected Component newContent(String id, FloatingPanel dropdown) {
				return new Fragment(id, ""referenceMenuFrag"", MarkdownEditor.this) {

					@Override
					public void renderHead(IHeaderResponse response) {
						super.renderHead(response);
						String script = String.format(""onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));"", 
								container.getMarkupId(), getMarkupId());
						response.render(OnDomReadyHeaderItem.forScript(script));
					}
					
				}.setOutputMarkupId(true);
			}
			
		}.setVisible(getReferenceSupport() != null));
		
		container.add(new DropdownLink(""actionMenuTrigger"") {


			@Override
			protected Component newContent(String id, FloatingPanel dropdown) {
				return new Fragment(id, ""actionMenuFrag"", MarkdownEditor.this) {

					@Override
					protected void onInitialize() {
						super.onInitialize();
						add(new WebMarkupContainer(""doMention"").setVisible(getUserMentionSupport() != null));
						
						if (getReferenceSupport() != null) 
							add(new Fragment(""doReference"", ""referenceMenuFrag"", MarkdownEditor.this));
						else 
							add(new WebMarkupContainer(""doReference"").setVisible(false));
					}

					@Override
					public void renderHead(IHeaderResponse response) {
						super.renderHead(response);
						String script = String.format(""onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));"", 
								container.getMarkupId(), getMarkupId());
						response.render(OnDomReadyHeaderItem.forScript(script));
					}
					
				}.setOutputMarkupId(true);
			}
			
		});
		
		container.add(new WebMarkupContainer(""doMention"").setVisible(getUserMentionSupport() != null));
			
		edit.add(input = new TextArea<String>(""input"", Model.of(getModelObject())));
		for (AttributeModifier modifier: getInputModifiers()) 
			input.add(modifier);

		if (initialSplit) {
			container.add(AttributeAppender.append(""class"", ""split-mode""));
			preview.add(new Label(""rendered"", new LoadableDetachableModel<String>() {

				@Override
				protected String load() {
					return renderInput(input.getConvertedInput());
				}
				
			}) {

				@Override
				public void renderHead(IHeaderResponse response) {
					super.renderHead(response);
					String script = String.format(
							""onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));"", 
							container.getMarkupId());
					response.render(OnDomReadyHeaderItem.forScript(script));
				}
				
			}.setEscapeModelStrings(false));
			splitLink.add(AttributeAppender.append(""class"", ""active""));
		} else {
			container.add(AttributeAppender.append(""class"", ""edit-mode""));
			preview.add(new WebMarkupContainer(""rendered""));
			editLink.add(AttributeAppender.append(""class"", ""active""));
		}
		
		container.add(new WebMarkupContainer(""canAttachFile"").setVisible(getAttachmentSupport()!=null));
		
		container.add(actionBehavior = new AbstractPostAjaxBehavior() {

			@Override
			protected void updateAjaxAttributes(AjaxRequestAttributes attributes) {
				super.updateAjaxAttributes(attributes);
				attributes.setChannel(new AjaxChannel(""markdown-preview"", AjaxChannel.Type.DROP));
			}

			@Override
			protected void respond(AjaxRequestTarget target) {
				IRequestParameters params = RequestCycle.get().getRequest().getPostParameters();
				String action = params.getParameterValue(""action"").toString("""");
				switch (action) {
				case ""render"":
					String markdown = params.getParameterValue(""param1"").toString();
					String rendered = renderInput(markdown);
					String script = String.format(""onedev.server.markdown.onRendered('%s', '%s');"", 
							container.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));
					target.appendJavaScript(script);
					break;
				case ""emojiQuery"":
					List<String> emojiNames = new ArrayList<>();
					String emojiQuery = params.getParameterValue(""param1"").toOptionalString();
					if (StringUtils.isNotBlank(emojiQuery)) {
						emojiQuery = emojiQuery.toLowerCase();
						for (String emojiName: EmojiOnes.getInstance().all().keySet()) {
							if (emojiName.toLowerCase().contains(emojiQuery))
								emojiNames.add(emojiName);
						}
						emojiNames.sort((name1, name2) -> name1.length() - name2.length());
					} else {
						emojiNames.add(""smile"");
						emojiNames.add(""worried"");
						emojiNames.add(""blush"");
						emojiNames.add(""+1"");
						emojiNames.add(""-1"");
					}

					List<Map<String, String>> emojis = new ArrayList<>();
					for (String emojiName: emojiNames) {
						if (emojis.size() < ATWHO_LIMIT) {
							String emojiCode = EmojiOnes.getInstance().all().get(emojiName);
							CharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(
									EmojiOnes.class, ""icon/"" + emojiCode + "".png""), new PageParameters());
							Map<String, String> emoji = new HashMap<>();
							emoji.put(""name"", emojiName);
							emoji.put(""url"", url.toString());
							emojis.add(emoji);
						}
					}
					String json;
					try {
						json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);
					} catch (JsonProcessingException e) {
						throw new RuntimeException(e);
					}
					script = String.format(""$('#%s').data('atWhoEmojiRenderCallback')(%s);"", container.getMarkupId(), json);
					target.appendJavaScript(script);
					break;
				case ""loadEmojis"":
					emojis = new ArrayList<>();
					String urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,
					        ""icon/FILENAME.png""), new PageParameters()).toString();
					
					for (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {
						Map<String, String> emoji = new HashMap<>();
						emoji.put(""name"", entry.getKey());
						emoji.put(""url"", urlPattern.replace(""FILENAME"", entry.getValue()));
						emojis.add(emoji);
					}

					try {
						json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);
					} catch (JsonProcessingException e) {
						throw new RuntimeException(e);
					}

					script = String.format(""onedev.server.markdown.onEmojisLoaded('%s', %s);"", container.getMarkupId(), json);
					target.appendJavaScript(script);
					break;
				case ""userQuery"":
					String userQuery = params.getParameterValue(""param1"").toOptionalString();

					AvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);
					List<Map<String, String>> userList = new ArrayList<>();
					for (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {
						Map<String, String> userMap = new HashMap<>();
						userMap.put(""name"", user.getName());
						if (user.getFullName() != null)
							userMap.put(""fullName"", user.getFullName());
						String noSpaceName = StringUtils.deleteWhitespace(user.getName());
						if (user.getFullName() != null) {
							String noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());
							userMap.put(""searchKey"", noSpaceName + "" "" + noSpaceFullName);
						} else {
							userMap.put(""searchKey"", noSpaceName);
						}
						String avatarUrl = avatarManager.getAvatarUrl(user);
						userMap.put(""avatarUrl"", avatarUrl);
						userList.add(userMap);
					}
					
					try {
						json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);
					} catch (JsonProcessingException e) {
						throw new RuntimeException(e);
					}
					script = String.format(""$('#%s').data('atWhoUserRenderCallback')(%s);"", container.getMarkupId(), json);
					target.appendJavaScript(script);	
					break;
				case ""referenceQuery"":
					String referenceQuery = params.getParameterValue(""param1"").toOptionalString();
					String referenceQueryType = params.getParameterValue(""param2"").toOptionalString();
					String referenceProjectName = params.getParameterValue(""param3"").toOptionalString();
					List<Map<String, String>> referenceList = new ArrayList<>();
					Project referenceProject;
					if (StringUtils.isNotBlank(referenceProjectName)) 
						referenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);
					else
						referenceProject = null;
					if (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {
						if (""issue"".equals(referenceQueryType)) {
							for (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {
								Map<String, String> referenceMap = new HashMap<>();
								referenceMap.put(""referenceType"", ""issue"");
								referenceMap.put(""referenceNumber"", String.valueOf(issue.getNumber()));
								referenceMap.put(""referenceTitle"", issue.getTitle());
								referenceMap.put(""searchKey"", issue.getNumber() + "" "" + StringUtils.deleteWhitespace(issue.getTitle()));
								referenceList.add(referenceMap);
							}
						} else if (""pullrequest"".equals(referenceQueryType)) {
							for (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {
								Map<String, String> referenceMap = new HashMap<>();
								referenceMap.put(""referenceType"", ""pull request"");
								referenceMap.put(""referenceNumber"", String.valueOf(request.getNumber()));
								referenceMap.put(""referenceTitle"", request.getTitle());
								referenceMap.put(""searchKey"", request.getNumber() + "" "" + StringUtils.deleteWhitespace(request.getTitle()));
								referenceList.add(referenceMap);
							}
						} else if (""build"".equals(referenceQueryType)) {
							for (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {
								Map<String, String> referenceMap = new HashMap<>();
								referenceMap.put(""referenceType"", ""build"");
								referenceMap.put(""referenceNumber"", String.valueOf(build.getNumber()));
								
								String title;
								if (build.getVersion() != null) 
									title = ""("" + build.getVersion() + "") "" + build.getJobName();
								else
									title = build.getJobName();
								referenceMap.put(""referenceTitle"", title);
								referenceMap.put(""searchKey"", build.getNumber() + "" "" + StringUtils.deleteWhitespace(title));
								referenceList.add(referenceMap);
							}
						}
					}
					
					try {
						json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);
					} catch (JsonProcessingException e) {
						throw new RuntimeException(e);
					}
					script = String.format(""$('#%s').data('atWhoReferenceRenderCallback')(%s);"", container.getMarkupId(), json);
					target.appendJavaScript(script);
					break;
				case ""selectImage"":
				case ""selectLink"":
					new ModalPanel(target) {
						
						@Override
						protected Component newContent(String id) {
							return new InsertUrlPanel(id, MarkdownEditor.this, action.equals(""selectImage"")) {

								@Override
								protected void onClose(AjaxRequestTarget target) {
									close();
								}
								
							};
						}

						@Override
						protected void onClosed() {
							super.onClosed();
							AjaxRequestTarget target = 
									Preconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));
							target.appendJavaScript(String.format(""$('#%s textarea').focus();"", container.getMarkupId()));
						}
						
					};
					break;
				case ""insertUrl"":
					String name;
					try {
						name = URLDecoder.decode(params.getParameterValue(""param1"").toString(), StandardCharsets.UTF_8.name());
					} catch (UnsupportedEncodingException e) {
						throw new RuntimeException(e);
					}
					String replaceMessage = params.getParameterValue(""param2"").toString();
					String url = getAttachmentSupport().getAttachmentUrl(name);
					insertUrl(target, isWebSafeImage(name), url, name, replaceMessage);
					
					break;
				default:
					throw new IllegalStateException(""Unknown action: "" + action);
				}		
			}
			
		});
		
		container.add(attachmentUploadBehavior = new AbstractPostAjaxBehavior() {
			
			@Override
			protected void respond(AjaxRequestTarget target) {
				Preconditions.checkNotNull(getAttachmentSupport(), ""Unexpected attachment upload request"");
				HttpServletRequest request = (HttpServletRequest) RequestCycle.get().getRequest().getContainerRequest();
				HttpServletResponse response = (HttpServletResponse) RequestCycle.get().getResponse().getContainerResponse();
				try {
					String fileName = FilenameUtils.sanitizeFilename(
							URLDecoder.decode(request.getHeader(""File-Name""), StandardCharsets.UTF_8.name()));
					String attachmentName = getAttachmentSupport().saveAttachment(fileName, request.getInputStream());
					response.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));
					response.setStatus(HttpServletResponse.SC_OK);
				} catch (Exception e) {
					logger.error(""Error uploading attachment."", e);
					try {
						if (e.getMessage() != null)
							response.getWriter().print(e.getMessage());
						else
							response.getWriter().print(""Internal server error"");
					} catch (IOException e2) {
						throw new RuntimeException(e2);
					}
					response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
				}
			}
			
		});
	}",1
"public static void setAttribute(@Nonnull final String name, @Nullable final String value, @Nonnull @MustNotContainNull final Topic[] topics) {
    for (final Topic t : topics) {
      t.setAttribute(name, value);
    }
  }",0
"@Override
	protected void removeFolderReferences(Folder folder) throws DotDataException, DotStateException, ElasticsearchException, DotSecurityException {
	    //Folder parentFolder = null;
	    Identifier folderId = null;
        try{
            //parentFolder = APILocator.getFolderAPI().findParentFolder(folder, APILocator.getUserAPI().getSystemUser(), false);
            folderId = APILocator.getIdentifierAPI().find(folder.getIdentifier());
        }catch(Exception e){
            Logger.debug(this, ""Unable to get parent folder for folder = "" + folder.getInode(), e);
        }
        //String parentFolderId = parentFolder!=null?parentFolder.getInode():FolderAPI.SYSTEM_FOLDER;
        DotConnect dc = new DotConnect();
        dc.setSQL(""select identifier,inode from identifier,contentlet where identifier.id = contentlet.identifier and parent_path = ? and host_inode=?"");
        dc.addParam(folderId.getPath());
        dc.addParam(folder.getHostId());
        List<HashMap<String, String>> contentInodes = dc.loadResults();
        dc.setSQL(""update identifier set parent_path = ? where asset_type='contentlet' and parent_path = ? and host_inode=?"");
        dc.addParam(""/"");
        dc.addParam(folderId.getPath());
        dc.addParam(folder.getHostId());
        dc.loadResult();
        for(HashMap<String, String> ident:contentInodes){
             String inode = ident.get(""inode"");
             cc.remove(inode);
             Contentlet content = find(inode);
             new ESContentletIndexAPI().addContentToIndex(content);
        }
	}",0
"public ModelAndView commitUserRegisterUser() {
		String username = """";
		String password = """";
		String confirmPassword = """";
		String email = """";
		String confirmEmail = """";
		String avatarPath = """";
		try{
			username = this.getValue(request.getPart(""username""));
			password = this.getValue(request.getPart(""password""));
			confirmPassword = this.getValue(request.getPart(""confirmPassword""));
			email = this.getValue(request.getPart(""email""));
			confirmEmail = this.getValue(request.getPart(""confirmEmail""));
			avatarPath = FileUploadController.getFileName(request.getPart(""image""));
		} catch (ServletException e1) {
			e1.printStackTrace();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		
		RegisterUserModel model = new RegisterUserModel();
		ModelAndView mv = null;
		
		if(!password.equals(confirmPassword)) {
			request.setAttribute(""attemptedAccount"", new Account(username, email, avatarPath, Roles.User, password));
			mv = new ModelAndView(""Passwords did not match"", ""/WEB-INF/register.jsp"");
		}
		if(!email.equals(confirmEmail)){
			request.setAttribute(""attemptedAccount"", new Account(username, email, avatarPath, Roles.User, password));
			mv = new ModelAndView(""Emails did not match. "", ""/WEB-INF/register.jsp"");
		}
		try {
			Account user = new Account(username, email, avatarPath, Roles.User, password);
			dataService.registerUser(user);
			FileUploadController.processRequest(request, response, filePath);
			model.setUser(user);
			mv = new ModelAndView(model, ""/WEB-INF/account/profile.jsp"");
		} catch(UsernameAlreadyExistsException e) {
			request.setAttribute(""attemptedAccount"", new Account(username, email, avatarPath, Roles.User, password));
			mv = new ModelAndView(""Username has already been used."", ""/WEB-INF/register.jsp"");
		} catch (ServletException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return mv;
	}",1
"@Override
    public Contact getContactById(String id, boolean includesFullName, boolean includesPicture,
                                  boolean includesNumbers, boolean includesEmail, boolean includeAddress){
        if(!checkForPermission(Manifest.permission.READ_CONTACTS, ""This is required to get the contacts"")){
            return null;
        }
        return AndroidContactsManager.getInstance().getContact(getContext(), id, includesFullName, includesPicture,
                includesNumbers, includesEmail, includeAddress);
    }",0
"private
    void setTimeFromNITZString (String nitz, long nitzReceiveTime)
    {
        // ""yy/mm/dd,hh:mm:ss(+/-)tz""
        // tz is in number of quarter-hours

        long start = SystemClock.elapsedRealtime();
        if (DBG) {
            log(""NITZ: "" + nitz + "","" + nitzReceiveTime +
                        "" start="" + start + "" delay="" + (start - nitzReceiveTime));
        }

        try {
            /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
            Calendar c = Calendar.getInstance(TimeZone.getTimeZone(""GMT""));

            c.clear();
            c.set(Calendar.DST_OFFSET, 0);

            String[] nitzSubs = nitz.split(""[/:,+-]"");

            int year = 2000 + Integer.parseInt(nitzSubs[0]);
            if (year > MAX_NITZ_YEAR) {
              if (DBG) loge(""NITZ year: "" + year + "" exceeds limit, skip NITZ time update"");
              return;
            }
            c.set(Calendar.YEAR, year);

            // month is 0 based!
            int month = Integer.parseInt(nitzSubs[1]) - 1;
            c.set(Calendar.MONTH, month);

            int date = Integer.parseInt(nitzSubs[2]);
            c.set(Calendar.DATE, date);

            int hour = Integer.parseInt(nitzSubs[3]);
            c.set(Calendar.HOUR, hour);

            int minute = Integer.parseInt(nitzSubs[4]);
            c.set(Calendar.MINUTE, minute);

            int second = Integer.parseInt(nitzSubs[5]);
            c.set(Calendar.SECOND, second);

            boolean sign = (nitz.indexOf('-') == -1);

            int tzOffset = Integer.parseInt(nitzSubs[6]);

            int dst = (nitzSubs.length >= 8 ) ? Integer.parseInt(nitzSubs[7])
                                              : 0;

            // The zone offset received from NITZ is for current local time,
            // so DST correction is already applied.  Don't add it again.
            //
            // tzOffset += dst * 4;
            //
            // We could unapply it if we wanted the raw offset.

            tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;

            TimeZone    zone = null;

            // As a special extension, the Android emulator appends the name of
            // the host computer's timezone to the nitz string. this is zoneinfo
            // timezone name of the form Area!Location or Area!Location!SubLocation
            // so we need to convert the ! into /
            if (nitzSubs.length >= 9) {
                String  tzname = nitzSubs[8].replace('!','/');
                zone = TimeZone.getTimeZone( tzname );
            }

            String iso = ((TelephonyManager) mPhone.getContext().
                    getSystemService(Context.TELEPHONY_SERVICE)).
                    getNetworkCountryIsoForPhone(mPhone.getPhoneId());

            if (zone == null) {
                if (mGotCountryCode) {
                    if (iso != null && iso.length() > 0) {
                        zone = TimeUtils.getTimeZone(tzOffset, dst != 0,
                                c.getTimeInMillis(),
                                iso);
                    } else {
                        // We don't have a valid iso country code.  This is
                        // most likely because we're on a test network that's
                        // using a bogus MCC (eg, ""001""), so get a TimeZone
                        // based only on the NITZ parameters.
                        zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                    }
                }
            }

            if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))){
                // We got the time before the country or the zone has changed
                // so we don't know how to identify the DST rules yet.  Save
                // the information and hope to fix it up later.

                mNeedFixZone = true;
                mZoneOffset  = tzOffset;
                mZoneDst     = dst != 0;
                mZoneTime    = c.getTimeInMillis();
            }
            if (DBG) {
                log(""NITZ: tzOffset="" + tzOffset + "" dst="" + dst + "" zone="" +
                        (zone!=null ? zone.getID() : ""NULL"") +
                        "" iso="" + iso + "" mGotCountryCode="" + mGotCountryCode +
                        "" mNeedFixZone="" + mNeedFixZone);
            }

            if (zone != null) {
                if (getAutoTimeZone()) {
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                }
                saveNitzTimeZone(zone.getID());
            }

            String ignore = SystemProperties.get(""gsm.ignore-nitz"");
            if (ignore != null && ignore.equals(""yes"")) {
                if (DBG) log(""NITZ: Not setting clock because gsm.ignore-nitz is set"");
                return;
            }

            try {
                mWakeLock.acquire();

                /**
                 * Correct the NITZ time by how long its taken to get here.
                 */
                long millisSinceNitzReceived
                        = SystemClock.elapsedRealtime() - nitzReceiveTime;

                if (millisSinceNitzReceived < 0) {
                    // Sanity check: something is wrong
                    if (DBG) {
                        log(""NITZ: not setting time, clock has rolled ""
                                        + ""backwards since NITZ time was received, ""
                                        + nitz);
                    }
                    return;
                }

                if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                    // If the time is this far off, something is wrong > 24 days!
                    if (DBG) {
                        log(""NITZ: not setting time, processing has taken ""
                                    + (millisSinceNitzReceived / (1000 * 60 * 60 * 24))
                                    + "" days"");
                    }
                    return;
                }

                // Note: with range checks above, cast to int is safe
                c.add(Calendar.MILLISECOND, (int)millisSinceNitzReceived);

                if (getAutoTime()) {
                    /**
                     * Update system time automatically
                     */
                    long gained = c.getTimeInMillis() - System.currentTimeMillis();
                    long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
                    int nitzUpdateSpacing = Settings.Global.getInt(mCr,
                            Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
                    int nitzUpdateDiff = Settings.Global.getInt(mCr,
                            Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);

                    if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing)
                            || (Math.abs(gained) > nitzUpdateDiff)) {
                        if (DBG) {
                            log(""NITZ: Auto updating time of day to "" + c.getTime()
                                + "" NITZ receive delay="" + millisSinceNitzReceived
                                + ""ms gained="" + gained + ""ms from "" + nitz);
                        }

                        setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    } else {
                        if (DBG) {
                            log(""NITZ: ignore, a previous update was ""
                                + timeSinceLastUpdate + ""ms ago and gained="" + gained + ""ms"");
                        }
                        return;
                    }
                }

                /**
                 * Update properties and save the time we did the update
                 */
                if (DBG) log(""NITZ: update nitz time property"");
                SystemProperties.set(""gsm.nitz.time"", String.valueOf(c.getTimeInMillis()));
                mSavedTime = c.getTimeInMillis();
                mSavedAtTime = SystemClock.elapsedRealtime();
            } finally {
                long end = SystemClock.elapsedRealtime();
                if (DBG) log(""NITZ: end="" + end + "" dur="" + (end - start));
                mWakeLock.release();
            }
        } catch (RuntimeException ex) {
            loge(""NITZ: Parsing NITZ time "" + nitz + "" ex="" + ex);
        }
    }",1
"private static void verify(
                DataSource apk,
                long cdStartOffset,
                List<CentralDirectoryRecord> cdRecords,
                Set<String> cdEntryNames,
                Map<Integer, String> supportedApkSigSchemeNames,
                Set<Integer> foundApkSigSchemeIds,
                int minSdkVersion,
                int maxSdkVersion,
                Result result) throws ApkFormatException, IOException, NoSuchAlgorithmException {

            // Find JAR manifest and signature block files.
            CentralDirectoryRecord manifestEntry = null;
            Map<String, CentralDirectoryRecord> sigFileEntries = new HashMap<>(1);
            List<CentralDirectoryRecord> sigBlockEntries = new ArrayList<>(1);
            for (CentralDirectoryRecord cdRecord : cdRecords) {
                String entryName = cdRecord.getName();
                if (!entryName.startsWith(""META-INF/"")) {
                    continue;
                }
                if ((manifestEntry == null) && (V1SchemeConstants.MANIFEST_ENTRY_NAME.equals(
                        entryName))) {
                    manifestEntry = cdRecord;
                    continue;
                }
                if (entryName.endsWith("".SF"")) {
                    sigFileEntries.put(entryName, cdRecord);
                    continue;
                }
                if ((entryName.endsWith("".RSA""))
                        || (entryName.endsWith("".DSA""))
                        || (entryName.endsWith("".EC""))) {
                    sigBlockEntries.add(cdRecord);
                    continue;
                }
            }
            if (manifestEntry == null) {
                result.addError(Issue.JAR_SIG_NO_MANIFEST);
                return;
            }

            // Parse the JAR manifest and check that all JAR entries it references exist in the APK.
            byte[] manifestBytes;
            try {
                manifestBytes =
                        LocalFileRecord.getUncompressedData(apk, manifestEntry, cdStartOffset);
            } catch (ZipFormatException e) {
                throw new ApkFormatException(""Malformed ZIP entry: "" + manifestEntry.getName(), e);
            }

            Pair<ManifestParser.Section, Map<String, ManifestParser.Section>> manifestSections =
                    parseManifest(manifestBytes, cdEntryNames, result);

            if (result.containsErrors()) {
                return;
            }

            ManifestParser.Section manifestMainSection = manifestSections.getFirst();
            Map<String, ManifestParser.Section> entryNameToManifestSection =
                    manifestSections.getSecond();

            // STATE OF AFFAIRS:
            // * All JAR entries listed in JAR manifest are present in the APK.

            // Identify signers
            List<Signer> signers = new ArrayList<>(sigBlockEntries.size());
            for (CentralDirectoryRecord sigBlockEntry : sigBlockEntries) {
                String sigBlockEntryName = sigBlockEntry.getName();
                int extensionDelimiterIndex = sigBlockEntryName.lastIndexOf('.');
                if (extensionDelimiterIndex == -1) {
                    throw new RuntimeException(
                            ""Signature block file name does not contain extension: ""
                                    + sigBlockEntryName);
                }
                String sigFileEntryName =
                        sigBlockEntryName.substring(0, extensionDelimiterIndex) + "".SF"";
                CentralDirectoryRecord sigFileEntry = sigFileEntries.get(sigFileEntryName);
                if (sigFileEntry == null) {
                    result.addWarning(
                            Issue.JAR_SIG_MISSING_FILE, sigBlockEntryName, sigFileEntryName);
                    continue;
                }
                String signerName = sigBlockEntryName.substring(""META-INF/"".length());
                Result.SignerInfo signerInfo =
                        new Result.SignerInfo(
                                signerName, sigBlockEntryName, sigFileEntry.getName());
                Signer signer = new Signer(signerName, sigBlockEntry, sigFileEntry, signerInfo);
                signers.add(signer);
            }
            if (signers.isEmpty()) {
                result.addError(Issue.JAR_SIG_NO_SIGNATURES);
                return;
            }
            if (signers.size() > MAX_APK_SIGNERS) {
                result.addError(Issue.JAR_SIG_MAX_SIGNATURES_EXCEEDED, MAX_APK_SIGNERS,
                        signers.size());
                return;
            }

            // Verify each signer's signature block file .(RSA|DSA|EC) against the corresponding
            // signature file .SF. Any error encountered for any signer terminates verification, to
            // mimic Android's behavior.
            for (Signer signer : signers) {
                signer.verifySigBlockAgainstSigFile(
                        apk, cdStartOffset, minSdkVersion, maxSdkVersion);
                if (signer.getResult().containsErrors()) {
                    result.signers.add(signer.getResult());
                }
            }
            if (result.containsErrors()) {
                return;
            }
            // STATE OF AFFAIRS:
            // * All JAR entries listed in JAR manifest are present in the APK.
            // * All signature files (.SF) verify against corresponding block files (.RSA|.DSA|.EC).

            // Verify each signer's signature file (.SF) against the JAR manifest.
            List<Signer> remainingSigners = new ArrayList<>(signers.size());
            for (Signer signer : signers) {
                signer.verifySigFileAgainstManifest(
                        manifestBytes,
                        manifestMainSection,
                        entryNameToManifestSection,
                        supportedApkSigSchemeNames,
                        foundApkSigSchemeIds,
                        minSdkVersion,
                        maxSdkVersion);
                if (signer.isIgnored()) {
                    result.ignoredSigners.add(signer.getResult());
                } else {
                    if (signer.getResult().containsErrors()) {
                        result.signers.add(signer.getResult());
                    } else {
                        remainingSigners.add(signer);
                    }
                }
            }
            if (result.containsErrors()) {
                return;
            }
            signers = remainingSigners;
            if (signers.isEmpty()) {
                result.addError(Issue.JAR_SIG_NO_SIGNATURES);
                return;
            }
            // STATE OF AFFAIRS:
            // * All signature files (.SF) verify against corresponding block files (.RSA|.DSA|.EC).
            // * Contents of all JAR manifest sections listed in .SF files verify against .SF files.
            // * All JAR entries listed in JAR manifest are present in the APK.

            // Verify data of JAR entries against JAR manifest and .SF files. On Android, an APK's
            // JAR entry is considered signed by signers associated with an .SF file iff the entry
            // is mentioned in the .SF file and the entry's digest(s) mentioned in the JAR manifest
            // match theentry's uncompressed data. Android requires that all such JAR entries are
            // signed by the same set of signers. This set may be smaller than the set of signers
            // we've identified so far.
            Set<Signer> apkSigners =
                    verifyJarEntriesAgainstManifestAndSigners(
                            apk,
                            cdStartOffset,
                            cdRecords,
                            entryNameToManifestSection,
                            signers,
                            minSdkVersion,
                            maxSdkVersion,
                            result);
            if (result.containsErrors()) {
                return;
            }
            // STATE OF AFFAIRS:
            // * All signature files (.SF) verify against corresponding block files (.RSA|.DSA|.EC).
            // * Contents of all JAR manifest sections listed in .SF files verify against .SF files.
            // * All JAR entries listed in JAR manifest are present in the APK.
            // * All JAR entries present in the APK and supposed to be covered by JAR signature
            //   (i.e., reside outside of META-INF/) are covered by signatures from the same set
            //   of signers.

            // Report any JAR entries which aren't covered by signature.
            Set<String> signatureEntryNames = new HashSet<>(1 + result.signers.size() * 2);
            signatureEntryNames.add(manifestEntry.getName());
            for (Signer signer : apkSigners) {
                signatureEntryNames.add(signer.getSignatureBlockEntryName());
                signatureEntryNames.add(signer.getSignatureFileEntryName());
            }
            for (CentralDirectoryRecord cdRecord : cdRecords) {
                String entryName = cdRecord.getName();
                if ((entryName.startsWith(""META-INF/""))
                        && (!entryName.endsWith(""/""))
                        && (!signatureEntryNames.contains(entryName))) {
                    result.addWarning(Issue.JAR_SIG_UNPROTECTED_ZIP_ENTRY, entryName);
                }
            }

            // Reflect the sets of used signers and ignored signers in the result.
            for (Signer signer : signers) {
                if (apkSigners.contains(signer)) {
                    result.signers.add(signer.getResult());
                } else {
                    result.ignoredSigners.add(signer.getResult());
                }
            }

            result.verified = true;
        }",1
"private static Pair<byte[], Integer> generateApkSignatureSchemeV2Block(
            List<SignerConfig> signerConfigs,
            Map<ContentDigestAlgorithm, byte[]> contentDigests,
            boolean v3SigningEnabled,
            List<byte[]> preservedV2SignerBlocks)
            throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
        // FORMAT:
        // * length-prefixed sequence of length-prefixed signer blocks.

        if (signerConfigs.size() > MAX_APK_SIGNERS) {
            throw new IllegalArgumentException(
                    ""APK Signature Scheme v2 only supports a maximum of "" + MAX_APK_SIGNERS + "", ""
                            + signerConfigs.size() + "" provided"");
        }

        List<byte[]> signerBlocks = new ArrayList<>(signerConfigs.size());
        if (preservedV2SignerBlocks != null && preservedV2SignerBlocks.size() > 0) {
            signerBlocks.addAll(preservedV2SignerBlocks);
        }
        int signerNumber = 0;
        for (SignerConfig signerConfig : signerConfigs) {
            signerNumber++;
            byte[] signerBlock;
            try {
                signerBlock = generateSignerBlock(signerConfig, contentDigests, v3SigningEnabled);
            } catch (InvalidKeyException e) {
                throw new InvalidKeyException(""Signer #"" + signerNumber + "" failed"", e);
            } catch (SignatureException e) {
                throw new SignatureException(""Signer #"" + signerNumber + "" failed"", e);
            }
            signerBlocks.add(signerBlock);
        }

        return Pair.of(
                encodeAsSequenceOfLengthPrefixedElements(
                        new byte[][] {
                            encodeAsSequenceOfLengthPrefixedElements(signerBlocks),
                        }),
                V2SchemeConstants.APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
    }",1
"private boolean mutateSecureSetting(String name, String value, int requestingUserId,
            int operation, boolean forceNotify) {
        // Make sure the caller can change the settings.
        enforceWritePermission(Manifest.permission.WRITE_SECURE_SETTINGS);

        // Resolve the userId on whose behalf the call is made.
        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(requestingUserId);

        // If this is a setting that is currently restricted for this user, do not allow
        // unrestricting changes.
        if (isGlobalOrSecureSettingRestrictedForUser(name, callingUserId, value,
                Binder.getCallingUid())) {
            return false;
        }

        // Determine the owning user as some profile settings are cloned from the parent.
        final int owningUserId = resolveOwningUserIdForSecureSettingLocked(callingUserId, name);

        // Only the owning user can change the setting.
        if (owningUserId != callingUserId) {
            return false;
        }

        // Special cases for location providers (sigh).
        if (Settings.Secure.LOCATION_PROVIDERS_ALLOWED.equals(name)) {
            return updateLocationProvidersAllowedLocked(value, owningUserId, forceNotify);
        }

        // Mutate the value.
        synchronized (mLock) {
            switch (operation) {
                case MUTATION_OPERATION_INSERT: {
                    return mSettingsRegistry.insertSettingLocked(SETTINGS_TYPE_SECURE,
                            owningUserId, name, value, getCallingPackage(), forceNotify);
                }

                case MUTATION_OPERATION_DELETE: {
                    return mSettingsRegistry.deleteSettingLocked(SETTINGS_TYPE_SECURE,
                            owningUserId, name, forceNotify);
                }

                case MUTATION_OPERATION_UPDATE: {
                    return mSettingsRegistry.updateSettingLocked(SETTINGS_TYPE_SECURE,
                            owningUserId, name, value, getCallingPackage(), forceNotify);
                }
            }
        }

        return false;
    }",1
"public boolean checkUrlParameter(String url)
	{
		if (url != null)
		{
			try
			{
				URL parsedUrl = new URL(url);
				String protocol = parsedUrl.getProtocol();
				String host = parsedUrl.getHost();
				InetAddress address = InetAddress.getByName(host);
				String hostAddress = address.getHostAddress();
				host = host.toLowerCase();

				return (protocol.equals(""http"") || protocol.equals(""https""))
						&& !address.isAnyLocalAddress()
						&& !address.isLoopbackAddress()
						&& !address.isLinkLocalAddress()
						&& !host.endsWith("".internal"") // Redundant
						&& !host.endsWith("".local"") // Redundant
						&& !host.contains(""localhost"") // Redundant
						&& !hostAddress.startsWith(""0."") // 0.0.0.0/8 
						&& !hostAddress.startsWith(""10."") // 10.0.0.0/8
						&& !hostAddress.startsWith(""127."") // 127.0.0.0/8
						&& !hostAddress.startsWith(""169.254."") // 169.254.0.0/16
						&& !hostAddress.startsWith(""172.16."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.17."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.18."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.19."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.20."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.21."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.22."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.23."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.24."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.25."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.26."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.27."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.28."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.29."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.30."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.31."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""192.0.0."") // 192.0.0.0/24
						&& !hostAddress.startsWith(""192.168."") // 192.168.0.0/16
						&& !hostAddress.startsWith(""198.18."") // 198.18.0.0/15
						&& !hostAddress.startsWith(""198.19."") // 198.18.0.0/15
						&& !host.endsWith("".arpa""); // reverse domain (needed?)
			}
			catch (MalformedURLException e)
			{
				return false;
			}
			catch (UnknownHostException e)
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}",1
"public void handle(final HttpServletRequest request, final HttpServletResponse response)
      throws Exception
  {
     new ContextualHttpServletRequest(request)
     {
        @Override
        public void process() throws Exception
        {
           ServletContexts.instance().setRequest(request);
           
           if (request.getQueryString() == null)
           {
              throw new ServletException(""Invalid request - no component specified"");
           }
                     
           Set<Component> components = new HashSet<Component>();
           Set<Type> types = new HashSet<Type>();
           
           response.setContentType(""text/javascript"");

           Enumeration e = request.getParameterNames();
           while (e.hasMoreElements())
           {
              String componentName = ((String) e.nextElement()).trim();
              
              Component component = Component.forName(componentName);
              if (component == null)
              {                 
                 log.error(String.format(""Component not found: [%s]"", componentName));
                 throw new ServletException(""Invalid request - component not found."");
              }
              else
              {
                 components.add(component);
              }
           }
           
           generateComponentInterface(components, response.getOutputStream(), types);            
       }
     }.run();
  }",1
JpaPatternEntity find(PatternCacheKey cacheKey);,1
"protected void configureParser(final XMLReader parser, final SAXHandler contentHandler)
			throws JDOMException {

		// Setup SAX handlers.

		parser.setContentHandler(contentHandler);

		if (saxEntityResolver != null) {
			parser.setEntityResolver(saxEntityResolver);
		}

		if (saxDTDHandler != null) {
			parser.setDTDHandler(saxDTDHandler);
		} else {
			parser.setDTDHandler(contentHandler);
		}

		if (saxErrorHandler != null) {
			parser.setErrorHandler(saxErrorHandler);
		} else {
			parser.setErrorHandler(new BuilderErrorHandler());
		}

		boolean success = false;

		try {
			parser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER,
					contentHandler);
			success = true;
		} catch (final SAXNotSupportedException e) {
			// No lexical reporting available
		} catch (final SAXNotRecognizedException e) {
			// No lexical reporting available
		}

		// Some parsers use alternate property for lexical handling (grr...)
		if (!success) {
			try {
				parser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER_ALT,
						contentHandler);
				success = true;
			} catch (final SAXNotSupportedException e) {
				// No lexical reporting available
			} catch (final SAXNotRecognizedException e) {
				// No lexical reporting available
			}
		}

		// Set any user-specified properties on the parser.
		for (final Map.Entry<String, Object> me : properties.entrySet()) {
			internalSetProperty(parser, me.getKey(), me.getValue(), me.getKey());
		}

		// Set entity expansion
		// Note SAXHandler can work regardless of how this is set, but when
		// entity expansion it's worth it to try to tell the parser not to
		// even bother with external general entities.
		// Apparently no parsers yet support this feature.
		// XXX It might make sense to setEntityResolver() with a resolver
		// that simply ignores external general entities
		try {
			if (parser.getFeature(SAX_FEATURE_EXTERNAL_ENT) != expand) {
				parser.setFeature(SAX_FEATURE_EXTERNAL_ENT, expand);
			}
		} catch (final SAXException e) { /* Ignore... */
		}

		// Try setting the DeclHandler if entity expansion is off
		if (!expand) {
			try {
				parser.setProperty(SAX_PROPERTY_DECLARATION_HANDLER,
						contentHandler);
				success = true;
			} catch (final SAXNotSupportedException e) {
				// No lexical reporting available
			} catch (final SAXNotRecognizedException e) {
				// No lexical reporting available
			}
		}
		// Set any user-specified features on the parser.
		for (final Map.Entry<String, Boolean> me : features.entrySet()) {
			internalSetFeature(parser, me.getKey(), me.getValue().booleanValue(), me.getKey());
		}
	}",1
"public static boolean isBreakpointAvailable(final int id, final FileDownloadModel model) {
        return isBreakpointAvailable(id, model, null);
    }",0
"@Override
    public Thermodynamic getThermodynamic(String tableName, DownSampling downsampling, List<String> ids,
                                          String valueCName) throws IOException {
        StringBuilder sql = new StringBuilder(
            ""select "" + ThermodynamicMetrics.STEP + "" step, "" + ThermodynamicMetrics.NUM_OF_STEPS + "" num_of_steps, "" + ThermodynamicMetrics.DETAIL_GROUP + "" detail_group, "" + ""id "" + "" from "" + tableName + "" where id in ("");
        List<Object> parameters = new ArrayList();
        for (int i = 0; i < ids.size(); i++) {
            if (i == 0) {
                sql.append(""?"");
            } else {
                sql.append("",?"");
            }
            parameters.add(ids.get(i));
        }
        sql.append("")"");

        List<List<Long>> thermodynamicValueCollection = new ArrayList<>();
        Map<String, List<Long>> thermodynamicValueMatrix = new HashMap<>();

        try (Connection connection = h2Client.getConnection()) {
            Thermodynamic thermodynamic = new Thermodynamic();
            int numOfSteps = 0;
            int axisYStep = 0;
            try (ResultSet resultSet = h2Client.executeQuery(
                connection, sql.toString(), parameters.toArray(new Object[0]))) {

                while (resultSet.next()) {
                    axisYStep = resultSet.getInt(""step"");
                    String id = resultSet.getString(""id"");
                    numOfSteps = resultSet.getInt(""num_of_steps"") + 1;
                    String value = resultSet.getString(""detail_group"");
                    IntKeyLongValueHashMap intKeyLongValues = new IntKeyLongValueHashMap(5);
                    intKeyLongValues.toObject(value);

                    List<Long> axisYValues = new ArrayList<>();
                    for (int i = 0; i < numOfSteps; i++) {
                        axisYValues.add(0L);
                    }

                    for (IntKeyLongValue intKeyLongValue : intKeyLongValues.values()) {
                        axisYValues.set(intKeyLongValue.getKey(), intKeyLongValue.getValue());
                    }

                    thermodynamicValueMatrix.put(id, axisYValues);
                }

                // try to add default values when there is no data in that time bucket.
                ids.forEach(id -> {
                    if (thermodynamicValueMatrix.containsKey(id)) {
                        thermodynamicValueCollection.add(thermodynamicValueMatrix.get(id));
                    } else {
                        thermodynamicValueCollection.add(new ArrayList<>());
                    }
                });
            }

            thermodynamic.fromMatrixData(thermodynamicValueCollection, numOfSteps);
            thermodynamic.setAxisYStep(axisYStep);

            return thermodynamic;
        } catch (SQLException e) {
            throw new IOException(e);
        }
    }",1
"@Deprecated // v2.15
    public static ObjectNode parse(
            final IOContext ioContext,
            final int options,
            final Reader reader
    ) throws IOException {
        Parser parser = new Parser(new TomlFactory(), ioContext,
                new TomlStreamReadException.ErrorContext(ioContext.contentReference(), null), options, reader);
        try {
            final ObjectNode node = parser.parse();
            if (TomlReadFeature.VALIDATE_NESTING_DEPTH.enabledIn(options) && parser.getNestingDepth() > 0) {
                throw new IOException(""Nesting Depth is non-zero after parsing TOML"");
            }
            return node;
        } finally {
            parser.lexer.releaseBuffers();
        }
    }",1
"protected void deleteDocument() throws XWikiException
    {
        getXWikiContext().getWiki().deleteDocument(this.doc, getXWikiContext());
        this.initialDoc = this.doc;
    }",0
"public CopyBuildTask compress() {
		zipMethod = COMPRESS;
		return this;
	}",0
"public void service() throws ONetworkProtocolException, IOException {
    ++connection.data.totalRequests;
    connection.data.commandInfo = null;
    connection.data.commandDetail = null;

    final String callbackF;
    if (OGlobalConfiguration.NETWORK_HTTP_JSONP_ENABLED.getValueAsBoolean() && request.parameters != null && request.parameters.containsKey(OHttpUtils.CALLBACK_PARAMETER_NAME))
      callbackF = request.parameters.get(OHttpUtils.CALLBACK_PARAMETER_NAME);
    else
      callbackF = null;

    response = new OHttpResponse(channel.outStream, request.httpVersion, additionalResponseHeaders, responseCharSet,
        connection.data.serverInfo, request.sessionId, callbackF, request.keepAlive, connection);
    response.setJsonErrorResponse(jsonResponseError);
    if (request.contentEncoding != null && request.contentEncoding.equals(OHttpUtils.CONTENT_ACCEPT_GZIP_ENCODED)) {
      response.setContentEncoding(OHttpUtils.CONTENT_ACCEPT_GZIP_ENCODED);
    }

    waitNodeIsOnline();

    final long begin = System.currentTimeMillis();

    boolean isChain;
    do {
      isChain = false;
      final String command;
      if (request.url.length() < 2) {
        command = """";
      } else {
        command = request.url.substring(1);
      }

      final String commandString = getCommandString(command);

      final OServerCommand cmd = (OServerCommand) cmdManager.getCommand(commandString);
      Map<String, String> requestParams = cmdManager.extractUrlTokens(commandString);
      if (requestParams != null) {
        if (request.parameters == null) {
          request.parameters = new HashMap<String, String>();
        }
        for (Map.Entry<String, String> entry : requestParams.entrySet()) {
          request.parameters.put(entry.getKey(), URLDecoder.decode(entry.getValue(), ""UTF-8""));
        }
      }

      if (cmd != null)
        try {
          if (cmd.beforeExecute(request, response))
            try {
              // EXECUTE THE COMMAND
              isChain = cmd.execute(request, response);
            } finally {
              cmd.afterExecute(request, response);
            }

        } catch (Exception e) {
          handleError(e);
        }
      else {
        try {
          OLogManager.instance().warn(
              this,
              ""->"" + channel.socket.getInetAddress().getHostAddress() + "": Command not found: "" + request.httpMethod + "".""
                  + URLDecoder.decode(command, ""UTF-8""));

          sendError(OHttpUtils.STATUS_INVALIDMETHOD_CODE, OHttpUtils.STATUS_INVALIDMETHOD_DESCRIPTION, null,
              OHttpUtils.CONTENT_TEXT_PLAIN, ""Command not found: "" + command, request.keepAlive);
        } catch (IOException e1) {
          sendShutdown();
        }
      }
    } while (isChain);

    connection.data.lastCommandInfo = connection.data.commandInfo;
    connection.data.lastCommandDetail = connection.data.commandDetail;

    connection.data.lastCommandExecutionTime = System.currentTimeMillis() - begin;
    connection.data.totalCommandExecutionTime += connection.data.lastCommandExecutionTime;
  }",1
"public String getUnresolvedIndexPattern(User user) {
            return replaceProperties(indexPattern, user);
        }",0
"private IResource loadAndAddConfDstu2(HttpServletRequest theServletRequest, final HomeRequest theRequest, final ModelMap theModel) {
		CaptureInterceptor interceptor = new CaptureInterceptor();
		GenericClient client = theRequest.newClient(theServletRequest, getContext(theRequest), myConfig, interceptor);

		ca.uhn.fhir.model.dstu2.resource.Conformance conformance;
		try {
			conformance = client.fetchConformance().ofType(Conformance.class).execute();
		} catch (Exception e) {
			ourLog.warn(""Failed to load conformance statement, error was: {}"", e.toString());
			theModel.put(""errorMsg"", toDisplayError(""Failed to load conformance statement, error was: "" + e.toString(), e));
			conformance = new ca.uhn.fhir.model.dstu2.resource.Conformance();
		}

		theModel.put(""jsonEncodedConf"", getContext(theRequest).newJsonParser().encodeResourceToString(conformance));

		Map<String, Number> resourceCounts = new HashMap<>();
		long total = 0;
		for (ca.uhn.fhir.model.dstu2.resource.Conformance.Rest nextRest : conformance.getRest()) {
			for (ca.uhn.fhir.model.dstu2.resource.Conformance.RestResource nextResource : nextRest.getResource()) {
				List<ExtensionDt> exts = nextResource.getUndeclaredExtensionsByUrl(RESOURCE_COUNT_EXT_URL);
				if (exts != null && exts.size() > 0) {
					Number nextCount = ((DecimalDt) (exts.get(0).getValue())).getValueAsNumber();
					resourceCounts.put(nextResource.getTypeElement().getValue(), nextCount);
					total += nextCount.longValue();
				}
			}
		}
		theModel.put(""resourceCounts"", resourceCounts);

		if (total > 0) {
			for (ca.uhn.fhir.model.dstu2.resource.Conformance.Rest nextRest : conformance.getRest()) {
				Collections.sort(nextRest.getResource(), new Comparator<ca.uhn.fhir.model.dstu2.resource.Conformance.RestResource>() {
					@Override
					public int compare(ca.uhn.fhir.model.dstu2.resource.Conformance.RestResource theO1, ca.uhn.fhir.model.dstu2.resource.Conformance.RestResource theO2) {
						DecimalDt count1 = new DecimalDt();
						List<ExtensionDt> count1exts = theO1.getUndeclaredExtensionsByUrl(RESOURCE_COUNT_EXT_URL);
						if (count1exts != null && count1exts.size() > 0) {
							count1 = (DecimalDt) count1exts.get(0).getValue();
						}
						DecimalDt count2 = new DecimalDt();
						List<ExtensionDt> count2exts = theO2.getUndeclaredExtensionsByUrl(RESOURCE_COUNT_EXT_URL);
						if (count2exts != null && count2exts.size() > 0) {
							count2 = (DecimalDt) count2exts.get(0).getValue();
						}
						int retVal = count2.compareTo(count1);
						if (retVal == 0) {
							retVal = theO1.getTypeElement().getValue().compareTo(theO2.getTypeElement().getValue());
						}
						return retVal;
					}
				});
			}
		}

		theModel.put(""conf"", conformance);
		theModel.put(""requiredParamExtension"", ExtensionConstants.PARAM_IS_REQUIRED);

		return conformance;
	}",1
"public Object map2bean(final Map map, Class targetType) {
		Object target = null;

		// create targets type
		String className = (String) map.get(classMetadataName);

		if (className == null) {
			if (targetType == null) {
				// nothing to do, no information about target type found
				target = map;
			}
		}
		else {
			checkClassName(jsonParser.classnameWhitelist, className);

			try {
				targetType = ClassLoaderUtil.loadClass(className);
			} catch (ClassNotFoundException cnfex) {
				throw new JsonException(cnfex);
			}
		}

		if (target == null) {
			target = jsonParser.newObjectInstance(targetType);
		}

		ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());

		boolean targetIsMap = target instanceof Map;

		for (Object key : map.keySet()) {
			String keyName = key.toString();

			if (classMetadataName != null) {
				if (keyName.equals(classMetadataName)) {
					continue;
				}
			}

			PropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);

			if (!targetIsMap && pd == null) {
				// target property does not exist, continue
				continue;
			}

			// value is one of JSON basic types, like Number, Map, List...
			Object value = map.get(key);

			Class propertyType = pd == null ? null : pd.getType();
			Class componentType = pd == null ? null : pd.resolveComponentType(true);

			if (value != null) {
				if (value instanceof List) {
					if (componentType != null && componentType != String.class) {
						value = generifyList((List) value, componentType);
					}
				}
				else if (value instanceof Map) {
					// if the value we want to inject is a Map...
					if (!ClassUtil.isTypeOf(propertyType, Map.class)) {
						// ... and if target is NOT a map
						value = map2bean((Map) value, propertyType);
					}
					else {
						// target is also a Map, but we might need to generify it
						Class keyType = pd == null ? null : pd.resolveKeyType(true);

						if (keyType != String.class || componentType != String.class) {
							// generify
							value = generifyMap((Map) value, keyType, componentType);
						}
					}
				}
			}

			if (targetIsMap) {
				((Map)target).put(keyName, value);
			}
			else {
				try {
					setValue(target, pd, value);
				} catch (Exception ignore) {
					ignore.printStackTrace();
				}
			}
		}

		return target;
	}",1
"private void buildSQL() throws SQLException {
            StringBuilder sb = new StringBuilder(128);
            sb.append(""INSERT INTO "");
            sb.append(mTableName);
            sb.append("" ("");

            StringBuilder sbv = new StringBuilder(128);
            sbv.append(""VALUES ("");

            int i = 1;
            Cursor cur = null;
            try {
                cur = mDb.rawQuery(""PRAGMA table_info("" + mTableName + "")"", null);
                mColumns = new HashMap<String, Integer>(cur.getCount());
                while (cur.moveToNext()) {
                    String columnName = cur.getString(TABLE_INFO_PRAGMA_COLUMNNAME_INDEX);
                    String defaultValue = cur.getString(TABLE_INFO_PRAGMA_DEFAULT_INDEX);

                    mColumns.put(columnName, i);
                    sb.append(""'"");
                    sb.append(columnName);
                    sb.append(""'"");

                    if (defaultValue == null) {
                        sbv.append(""?"");
                    } else {
                        sbv.append(""COALESCE(?, "");
                        sbv.append(defaultValue);
                        sbv.append("")"");
                    }

                    sb.append(i == cur.getCount() ? "") "" : "", "");
                    sbv.append(i == cur.getCount() ? "");"" : "", "");
                    ++i;
                }
            } finally {
                if (cur != null) cur.close();
            }

            sb.append(sbv);

            mInsertSQL = sb.toString();
            if (DEBUG) Log.v(TAG, ""insert statement is "" + mInsertSQL);
        }",0
"public void deleteMonitoredItems(ServiceRequest service) throws UaException {
        DeleteMonitoredItemsRequest request = (DeleteMonitoredItemsRequest) service.getRequest();

        UInteger subscriptionId = request.getSubscriptionId();
        Subscription subscription = subscriptions.get(subscriptionId);
        List<UInteger> itemsToDelete = l(request.getMonitoredItemIds());

        if (subscription == null) {
            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);
        }
        if (itemsToDelete.isEmpty()) {
            throw new UaException(StatusCodes.Bad_NothingToDo);
        }

        StatusCode[] deleteResults = new StatusCode[itemsToDelete.size()];
        List<BaseMonitoredItem<?>> deletedItems = newArrayListWithCapacity(itemsToDelete.size());

        synchronized (subscription) {
            for (int i = 0; i < itemsToDelete.size(); i++) {
                UInteger itemId = itemsToDelete.get(i);
                BaseMonitoredItem<?> item = subscription.getMonitoredItems().get(itemId);

                if (item == null) {
                    deleteResults[i] = new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);
                } else {
                    deletedItems.add(item);

                    deleteResults[i] = StatusCode.GOOD;

                    monitoredItemCount.decrementAndGet();
                    server.getMonitoredItemCount().decrementAndGet();
                }
            }

            subscription.removeMonitoredItems(deletedItems);
        }

        /*
         * Notify AddressSpaces of the items that have been deleted.
         */

        byMonitoredItemType(
            deletedItems,
            dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),
            eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)
        );

        /*
         * Build and return results.
         */
        ResponseHeader header = service.createResponseHeader();

        DeleteMonitoredItemsResponse response = new DeleteMonitoredItemsResponse(
            header,
            deleteResults,
            new DiagnosticInfo[0]
        );

        service.setResponse(response);
    }",1
"@Override
    public void setTransformCamera(Object nativeGraphics, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ) {
        CN1Matrix4f m = (CN1Matrix4f)nativeGraphics;
        m.setCamera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
    }",0
"@Override
    public final void finishHeavyWeightApp() {
        if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES)
                != PackageManager.PERMISSION_GRANTED) {
            String msg = ""Permission Denial: finishHeavyWeightApp() from pid=""
                    + Binder.getCallingPid()
                    + "", uid="" + Binder.getCallingUid()
                    + "" requires "" + android.Manifest.permission.FORCE_STOP_PACKAGES;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }

        synchronized(this) {
            final ProcessRecord proc = mHeavyWeightProcess;
            if (proc == null) {
                return;
            }

            ArrayList<ActivityRecord> activities = new ArrayList<>(proc.activities);
            for (int i = 0; i < activities.size(); i++) {
                ActivityRecord r = activities.get(i);
                if (!r.finishing && r.isInStackLocked()) {
                    r.getStack().finishActivityLocked(r, Activity.RESULT_CANCELED,
                            null, ""finish-heavy"", true);
                }
            }

            mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,
                    proc.userId, 0));
            mHeavyWeightProcess = null;
        }
    }",0
"private LogHandler createLogHandler(String pLogHandlerClass, String pDebug) {
        if (pLogHandlerClass != null) {
            return ClassUtil.newInstance(pLogHandlerClass);
        } else {
            final boolean debug = Boolean.valueOf(pDebug);
            return new LogHandler.StdoutLogHandler(debug);
        }
    }",0
"private ResourceInfo findResourceCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {
        
        ResourceInfo info = null;
        
        lock.lock();
        try {
            info = getFromCache(resourceName, libraryName, localePrefix, contracts);
            if (info == null) {
                info = doLookup(libraryName, resourceName, localePrefix, true, isViewResource, contracts, ctx);
                if (info != null) {
                    addToCache(info, contracts);
                }
            }
        } finally {
            lock.unlock();
        }
        
        return info;
    }",0
"@Override
	public void contextRefreshed() {
		contextLastRefreshedTime = System.currentTimeMillis();

		// START HACK
		// since we're not using a Listener anymore, these are not set at startup
		try {
			Class<?> webConstants1x = Context.loadClass(""org.openmrs.web.WebConstants"");
			String webappName = (String) webConstants1x.getField(""WEBAPP_NAME"").get(null);
			WebConstants.CONTEXT_PATH = webappName;
			WebConstants.WEBAPP_NAME = webappName;
		} catch (Exception ex) {
			log.error(""Failed to get CONTEXT_PATH from WebConstants during UI Framework startup"");
		}
		// END HACK
		
		PageFactory pageFactory = getComponent(PageFactory.class);
		FragmentFactory fragmentFactory = getComponent(FragmentFactory.class);
		ResourceFactory resourceFactory = getComponent(ResourceFactory.class);

		// Register a standard resource provider that can load file-based resources
		resourceFactory.addResourceProvider(ConfigurationResourceProvider.RESOURCE_KEY, new ConfigurationResourceProvider());

		List<UiContextRefreshedCallback> callbacks = Context.getRegisteredComponents(UiContextRefreshedCallback.class);
		for (UiContextRefreshedCallback callback : callbacks) {
			try {
				callback.afterContextRefreshed(pageFactory, fragmentFactory, resourceFactory);
			}
			catch (Exception ex) {
				log.error(""Error in UiContextRefreshedCallback: "" + callback, ex);
			}
		}
	}",1
"@Override
	public void onConversationUpdate() {
		refreshUi();
	}",0
"public static boolean prepareHelpMenuItem(final Activity activity, MenuItem helpMenuItem,
            String helpUriString, String backupContext) {
        if (Global.getInt(activity.getContentResolver(), Global.DEVICE_PROVISIONED, 0) == 0) {
            return false;
        }
        if (TextUtils.isEmpty(helpUriString)) {
            // The help url string is empty or null, so set the help menu item to be invisible.
            helpMenuItem.setVisible(false);

            // return that the help menu item is not visible (i.e. false)
            return false;
        } else {
            final Intent intent = getHelpIntent(activity, helpUriString, backupContext);

            // Set the intent to the help menu item, show the help menu item in the overflow
            // menu, and make it visible.
            if (intent != null) {
                helpMenuItem.setOnMenuItemClickListener(new OnMenuItemClickListener() {
                    @Override
                    public boolean onMenuItemClick(MenuItem item) {
                        try {
                            activity.startActivityForResult(intent, 0);
                        } catch (ActivityNotFoundException exc) {
                            Log.e(TAG, ""No activity found for intent: "" + intent);
                        }
                        return true;
                    }
                });
                helpMenuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
                helpMenuItem.setVisible(true);
            } else {
                helpMenuItem.setVisible(false);
                return false;
            }

            // return that the help menu item is visible (i.e., true)
            return true;
        }
    }",1
"@Override
    public void sendRedirect(String redirect) throws IOException
    {
        if (StringUtils.isBlank(redirect)) {
            // Nowhere to go to
            return;
        }
        if (StringUtils.containsAny(redirect, '\r', '\n')) {
            LOGGER.warn(""Possible HTTP Response Splitting attack, attempting to redirect to [{}]"", redirect);
            return;
        }

        if (StringUtils.startsWith(redirect, ""//"")) {
            LOGGER.warn(""Possible phishing attack, attempting to redirect to [{}]. If this request is legitimate, ""
                + ""use an actual absolute URL and pay attention to configure properly url.trustedDomains in ""
                + ""xwiki.properties"", redirect);
            return;
        }

        // check for trusted domains, only if the given location is an absolute URL.
        if (ABSOLUTE_URL_PATTERN.matcher(redirect).matches()) {
            if (!getURLSecurityManager().isDomainTrusted(new URL(redirect))) {
                LOGGER.warn(
                    ""Possible phishing attack, attempting to redirect to [{}], this request has been blocked. ""
                        + ""If the request was legitimate, add the domain related to this request in the list ""
                        + ""of trusted domains in the configuration: it can be configured in xwiki.properties in ""
                        + ""url.trustedDomains."", redirect);
                return;
            }
        }
        this.response.sendRedirect(redirect);
    }",1
"void silence(Call call) {
        final String callId = mCallIdMapper.getCallId(call);
        if (callId != null && isServiceValid(""silence"")) {
            try {
                logOutgoing(""silence %s"", callId);
                mServiceInterface.silence(callId, Log.getExternalSession(TELECOM_ABBREVIATION));
            } catch (RemoteException e) {
            }
        }
    }",0
"private void handleProtocolVersionMismatch() throws IOException {
        // Probably an AMQP.... header indicating a version mismatch
        // Otherwise meaningless, so try to read the version,
        // and throw an exception, whether we read the version
        // okay or not.
        // Try to read everything from the network, this header
        // is small and should never require several network reads.
        byte[] expectedBytes = new byte[] { 'M', 'Q', 'P' };
        int expectedBytesCount = 0;
        while (somethingToRead() && expectedBytesCount < 3) {
            // We expect the letters M, Q, P in that order: generate an informative error if they're not found
            int nextByte = readFromBuffer();
            if (nextByte != expectedBytes[expectedBytesCount]) {
                throw new MalformedFrameException(""Invalid AMQP protocol header from server: expected character "" +
                    expectedBytes[expectedBytesCount] + "", got "" + nextByte);
            }
            expectedBytesCount++;
        }

        if (expectedBytesCount != 3) {
            throw new MalformedFrameException(""Invalid AMQP protocol header from server: read only ""
                + (expectedBytesCount + 1) + "" byte(s) instead of 4"");
        }

        int[] signature = new int[4];

        for (int i = 0; i < 4; i++) {
            if (somethingToRead()) {
                signature[i] = readFromBuffer();
            } else {
                throw new MalformedFrameException(""Invalid AMQP protocol header from server"");
            }
        }

        MalformedFrameException x;

        if (signature[0] == 1 &&
            signature[1] == 1 &&
            signature[2] == 8 &&
            signature[3] == 0) {
            x = new MalformedFrameException(""AMQP protocol version mismatch; we are version "" +
                AMQP.PROTOCOL.MAJOR + ""-"" + AMQP.PROTOCOL.MINOR + ""-"" + AMQP.PROTOCOL.REVISION +
                "", server is 0-8"");
        } else {
            String sig = """";
            for (int i = 0; i < 4; i++) {
                if (i != 0)
                    sig += "","";
                sig += signature[i];
            }

            x = new MalformedFrameException(""AMQP protocol version mismatch; we are version "" +
                AMQP.PROTOCOL.MAJOR + ""-"" + AMQP.PROTOCOL.MINOR + ""-"" + AMQP.PROTOCOL.REVISION +
                "", server sent signature "" + sig);
        }
        throw x;
    }",0
"@Override  // UnlockMethodCache.OnUnlockMethodChangedListener
    public void onUnlockMethodStateChanged() {
        logStateToEventlog();
    }",0
"void configureExecutors() {
        applicationThreadPool = Executors.newCachedThreadPool(new ThreadFactory() {
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r, ""AsyncHttpClient-Callback"");
                t.setDaemon(true);
                return t;
            }
        });
    }",0
"public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {
        if (typeName == null) {
            return null;
        }

        if (autoTypeCheckHandlers != null) {
            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {
                Class<?> type = h.handler(typeName, expectClass, features);
                if (type != null) {
                    return type;
                }
            }
        }

        final int safeModeMask = Feature.SafeMode.mask;
        boolean safeMode = this.safeMode
                || (features & safeModeMask) != 0
                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;
        if (safeMode) {
            throw new JSONException(""safeMode not support autoType : "" + typeName);
        }

        final int mask = Feature.SupportAutoType.mask;
        boolean autoTypeSupport = this.autoTypeSupport
                || (features & mask) != 0
                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;

        if (typeName.length() >= 192 || typeName.length() < 3) {
            throw new JSONException(""autoType is not support. "" + typeName);
        }

        final boolean expectClassFlag;
        if (expectClass == null) {
            expectClassFlag = false;
        } else {
            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());
            if (expectHash == 0x90a25f5baa21529eL
                    || expectHash == 0x2d10a5801b9d6136L
                    || expectHash == 0xaf586a571e302c6bL
                    || expectHash == 0xed007300a7b227c6L
                    || expectHash == 0x295c4605fd1eaa95L
                    || expectHash == 0x47ef269aadc650b4L
                    || expectHash == 0x6439c4dff712ae8bL
                    || expectHash == 0xe3dd9875a2dc5283L
                    || expectHash == 0xe2a8ddba03e69e0dL
                    || expectHash == 0xd734ceb4c3e9d1daL
            ) {
                expectClassFlag = false;
            } else {
                expectClassFlag = true;
            }
        }

        String className = typeName.replace('$', '.');
        Class<?> clazz;

        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;
        if (h1 == 0xaf64164c86024f1aL) { // [
            throw new JSONException(""autoType is not support. "" + typeName);
        }

        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {
            throw new JSONException(""autoType is not support. "" + typeName);
        }

        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))
                * fnv1a_64_magic_prime)
                ^ className.charAt(1))
                * fnv1a_64_magic_prime)
                ^ className.charAt(2))
                * fnv1a_64_magic_prime;

        long fullHash = TypeUtils.fnv1a_64(className);
        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;

        if (internalDenyHashCodes != null) {
            long hash = h3;
            for (int i = 3; i < className.length(); ++i) {
                hash ^= className.charAt(i);
                hash *= fnv1a_64_magic_prime;
                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {
                    throw new JSONException(""autoType is not support. "" + typeName);
                }
            }
        }

        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {
            long hash = h3;
            for (int i = 3; i < className.length(); ++i) {
                hash ^= className.charAt(i);
                hash *= fnv1a_64_magic_prime;
                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {
                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);
                    if (clazz != null) {
                        return clazz;
                    }
                }
                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {
                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {
                        continue;
                    }

                    throw new JSONException(""autoType is not support. "" + typeName);
                }
            }
        }

        clazz = TypeUtils.getClassFromMapping(typeName);

        if (clazz == null) {
            clazz = deserializers.findClass(typeName);
        }

        if (expectClass == null && clazz != null && Throwable.class.isAssignableFrom(clazz) && !autoTypeSupport) {
            clazz = null;
        }

        if (clazz == null) {
            clazz = typeMapping.get(typeName);
        }

        if (internalWhite) {
            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);
        }

        if (clazz != null) {
            if (expectClass != null
                    && clazz != java.util.HashMap.class
                    && clazz != java.util.LinkedHashMap.class
                    && !expectClass.isAssignableFrom(clazz)) {
                throw new JSONException(""type not match. "" + typeName + "" -> "" + expectClass.getName());
            }

            return clazz;
        }

        if (!autoTypeSupport) {
            long hash = h3;
            for (int i = 3; i < className.length(); ++i) {
                char c = className.charAt(i);
                hash ^= c;
                hash *= fnv1a_64_magic_prime;

                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {
                    if (typeName.endsWith(""Exception"") || typeName.endsWith(""Error"")) {
                        return null;
                    }

                    throw new JSONException(""autoType is not support. "" + typeName);
                }

                // white list
                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {
                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);

                    if (clazz == null) {
                        return expectClass;
                    }

                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {
                        throw new JSONException(""type not match. "" + typeName + "" -> "" + expectClass.getName());
                    }

                    return clazz;
                }
            }
        }

        boolean jsonType = false;
        InputStream is = null;
        try {
            String resource = typeName.replace('.', '/') + "".class"";
            if (defaultClassLoader != null) {
                is = defaultClassLoader.getResourceAsStream(resource);
            } else {
                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);
            }
            if (is != null) {
                ClassReader classReader = new ClassReader(is, true);
                TypeCollector visitor = new TypeCollector(""<clinit>"", new Class[0]);
                classReader.accept(visitor);
                jsonType = visitor.hasJsonType();
            }
        } catch (Exception e) {
            // skip
        } finally {
            IOUtils.close(is);
        }

        if (autoTypeSupport || jsonType || expectClassFlag) {
            boolean cacheClass = autoTypeSupport || jsonType;
            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);
        }

        if (clazz != null) {
            if (jsonType) {
                if (autoTypeSupport) {
                    TypeUtils.addMapping(typeName, clazz);
                }
                return clazz;
            }

            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger
                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver
                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //
                    ) {
                throw new JSONException(""autoType is not support. "" + typeName);
            }

            if (expectClass != null) {
                if (expectClass.isAssignableFrom(clazz)) {
                    if (autoTypeSupport) {
                        TypeUtils.addMapping(typeName, clazz);
                    }
                    return clazz;
                } else {
                    throw new JSONException(""type not match. "" + typeName + "" -> "" + expectClass.getName());
                }
            }

            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);
            if (beanInfo.creatorConstructor != null && autoTypeSupport) {
                throw new JSONException(""autoType is not support. "" + typeName);
            }
        }

        if (!autoTypeSupport) {
            if (typeName.endsWith(""Exception"") || typeName.endsWith(""Error"")) {
                return null;
            }

            throw new JSONException(""autoType is not support. "" + typeName);
        }

        if (clazz != null) {
            if (autoTypeSupport) {
                TypeUtils.addMapping(typeName, clazz);
            }
        }

        return clazz;
    }",1
"@Test
  public void startTxGetConnectionFails(TestContext context) {
    postgresClientGetConnectionFails().startTx(context.asyncAssertFailure());
  }",0
"@Override
    protected DataSource createDataSource(Map<String, ?> params, SQLDialect dialect)
            throws IOException {
        String jndiName = (String) JNDI_REFNAME.lookUp(params);
        if (jndiName == null) throw new IOException(""Missing "" + JNDI_REFNAME.description);

        DataSource ds = null;

        try {
            ds = (DataSource) GeoTools.jndiLookup(jndiName);
        } catch (NamingException e1) {
            // check if the user did not specify ""java:comp/env""
            // and this code is running in a J2EE environment
            try {
                if (jndiName.startsWith(J2EERootContext) == false) {
                    ds = (DataSource) GeoTools.jndiLookup(J2EERootContext + jndiName);
                    // success --> issue a waring
                    Logger.getLogger(this.getClass().getName())
                            .log(
                                    Level.WARNING,
                                    ""Using ""
                                            + J2EERootContext
                                            + jndiName
                                            + "" instead of ""
                                            + jndiName
                                            + "" would avoid an unnecessary JNDI lookup"");
                }
            } catch (NamingException e2) {
                // do nothing, was only a try
            }
        }

        if (ds == null) throw new IOException(""Cannot find JNDI data source: "" + jndiName);
        else return ds;
    }",1
"private static File createSmallFile() {
        java.nio.file.Path smallfile = null;
        try {
            smallfile = Files.createTempFile(""smalltmp"", ""tmp"");
            try (BufferedWriter writer = Files.newBufferedWriter(smallfile)) {
                writer.write(""123456789"");
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return smallfile.toFile();
    }",1
"public boolean processXml() throws WebdavException {
    if (!isAppXml()) {
      return false;
    }

    try {
      reqRdr = req.getReader();
    } catch (final Throwable t) {
      throw new WebdavException(t);
    }

    xmlDoc = parseXmlSafely(req.getContentLength(), reqRdr);
    getTheReader = false;
    return true;
  }",1
"private void logError( Throwable e ) {
        logger.error( ""Failed to upload a file."", e );
    }",1
"public Userview createUserview(AppDefinition appDef, String json, String menuId, boolean preview, String contextPath, Map requestParameters, String key, Boolean embed) {
        String permissionKey = Permission.DEFAULT;
                
        if (key != null && key.trim().length() == 0) {
            key = null;
        }
        if (key != null) {
            key = StringEscapeUtils.escapeHtml(key);
        }

        //process json with hash variable
        json = AppUtil.processHashVariable(json, null, StringUtil.TYPE_JSON, null, appDef);
        json = AppUtil.replaceAppMessages(json, StringUtil.TYPE_JSON);

        User currentUser = workflowUserManager.getCurrentUser();

        if (requestParameters == null) {
            requestParameters = new HashMap<String, Object>();
        }
        requestParameters = convertRequestParamMap(requestParameters);
        requestParameters.put(""contextPath"", contextPath);
        requestParameters.put(""isPreview"", Boolean.toString(preview));
        requestParameters.put(""embed"", Boolean.toString(embed));
        requestParameters.put(""appId"", appDef.getAppId());
        requestParameters.put(""appVersion"", appDef.getVersion().toString());
        requestParameters.put(""key"", (key != null)?key:"""");

        String appId = appDef.getId();
        String appVersion = appDef.getVersion().toString();
        Userview userview = new Userview();
        userview.setParams(requestParameters);
        
        boolean userviewPermission = false;
        
        //if screenshot, set user to null (anonymous)
        User currentThreadUser = currentUser;
        boolean isScreenCapture = workflowUserManager.isCurrentUserInRole(WorkflowUserManager.ROLE_ADMIN) && ""true"".equalsIgnoreCase((String) requestParameters.get(""_isScreenCapture""));
        if (isScreenCapture) {
            currentUser = null;
            workflowUserManager.setCurrentThreadUser(WorkflowUserManager.ROLE_ANONYMOUS);
        }

        try {
            //set userview properties
            JSONObject userviewObj = new JSONObject(json);
            userview.setProperties(PropertyUtil.getProperties(userviewObj.getJSONObject(""properties"")));

            //set Setting
            JSONObject settingObj = userviewObj.getJSONObject(""setting"");
            UserviewSetting setting = new UserviewSetting();
            setting.setProperties(PropertyUtil.getProperties(settingObj.getJSONObject(""properties"")));

            //set theme & permission
            try {
                JSONObject themeObj = settingObj.getJSONObject(""properties"").getJSONObject(""theme"");
                JSONObject themeProperties = themeObj.getJSONObject(""properties"");
                UserviewTheme theme = (UserviewTheme) pluginManager.getPlugin(themeObj.getString(""className""));
                if (theme == null) {
                    String defaultTheme = ResourceBundleUtil.getMessage(""generator.userview.theme"");
                    theme = (UserviewTheme) pluginManager.getPlugin(defaultTheme);
                    String defaultThemePropertiesKey = ""generator.userview.theme."" + defaultTheme + "".properties"";
                    String defaultThemeProperties = ""{"" + ResourceBundleUtil.getMessage(defaultThemePropertiesKey) + ""}"";
                    themeProperties = new JSONObject(defaultThemeProperties);
                }
                theme.setProperties(PropertyUtil.getProperties(themeProperties));
                theme.setRequestParameters(requestParameters);
                theme.setUserview(userview);
                setting.setTheme(theme);
            } catch (Exception e) {
                LogUtil.debug(getClass().getName(), ""set theme error."");
            }
            try {
                if (!""true"".equals(setting.getPropertyString(""tempDisablePermissionChecking""))) {
                    if (settingObj.getJSONObject(""properties"").has(""permission_rules"")) {
                        JSONArray permissionRules = settingObj.getJSONObject(""properties"").getJSONArray(""permission_rules"");
                        if (permissionRules != null && permissionRules.length() > 0) {
                            for (int i = 0; i < permissionRules.length(); i++) {
                                JSONObject rule = permissionRules.getJSONObject(i);
                                if (rule.has(""permission"")) {
                                    JSONObject permissionObj = rule.optJSONObject(""permission"");
                                    userviewPermission = UserviewUtil.getPermisionResult(permissionObj, requestParameters, currentUser);
                                    if (userviewPermission) {
                                        permissionKey = rule.getString(""permission_key"");
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (!userviewPermission) {
                        if (settingObj.getJSONObject(""properties"").has(""permission"")) {
                            JSONObject permissionObj = settingObj.getJSONObject(""properties"").getJSONObject(""permission"");
                            userviewPermission = UserviewUtil.getPermisionResult(permissionObj, requestParameters, currentUser);
                        } else {
                            userviewPermission = true;
                        }
                    }
                } else {
                    userviewPermission = true;
                }
            } catch (Exception e) {
                LogUtil.debug(getClass().getName(), ""set permission error."");
            }
            userview.setSetting(setting);

            //set categories
            Collection<UserviewCategory> categories = new ArrayList<UserviewCategory>();
            
            if (userviewPermission) {
                JSONArray categoriesArray = userviewObj.getJSONArray(""categories"");
                for (int i = 0; i < categoriesArray.length(); i++) {
                    JSONObject categoryObj = (JSONObject) categoriesArray.get(i);

                    UserviewCategory category = new UserviewCategory();
                    category.setProperties(PropertyUtil.getProperties(categoryObj.getJSONObject(""properties"")));
                    
                    //check for permission
                    JSONObject ruleObj = null;
                    if (Permission.DEFAULT.equals(permissionKey)) {
                        ruleObj = categoryObj.getJSONObject(""properties"");
                    } else if (categoryObj.getJSONObject(""properties"").has(""permission_rules"")) {
                        JSONObject permissionRules = categoryObj.getJSONObject(""properties"").getJSONObject(""permission_rules"");
                        if (permissionRules != null && permissionRules.has(permissionKey)) {
                            ruleObj = permissionRules.getJSONObject(permissionKey);
                        }
                    }
                        
                    boolean hasPermis = false;
                    if (preview || ""true"".equals(setting.getPropertyString(""tempDisablePermissionChecking""))) {
                        hasPermis = true;
                    } else {
                        if (ruleObj != null) {
                            if (ruleObj.has(""permissionDeny"") && ""true"".equals(ruleObj.getString(""permissionDeny""))) {
                                hasPermis = false;
                            } else if (ruleObj.has(""permission"")){
                                try {
                                    JSONObject permissionObj = ruleObj.getJSONObject(""permission"");
                                    hasPermis = UserviewUtil.getPermisionResult(permissionObj, requestParameters, currentUser);
                                } catch (Exception e) {
                                    LogUtil.debug(getClass().getName(), ""set category permission error."");
                                }
                            } else {
                                hasPermis = true;
                            }
                            
                            //handle for permission rule to override the default setting
                            if (ruleObj.has(""hide"") && ""yes"".equals(ruleObj.getString(""hide""))) {
                                category.setProperty(""hide"", ""yes"");
                            } else { 
                                category.setProperty(""hide"", """");
                            }
                        } else { //when no properties found for the category object
                            hasPermis = true;
                            category.setProperty(""hide"", """");
                        }
                    }

                    if (hasPermis) {
                        //set menus
                        JSONArray menusArray = categoryObj.getJSONArray(""menus"");
                        Collection<UserviewMenu> menus = new ArrayList<UserviewMenu>();
                        for (int j = 0; j < menusArray.length(); j++) {
                            try {
                                //set menu
                                JSONObject menuObj = (JSONObject) menusArray.get(j);
                                UserviewMenu menu = (UserviewMenu) pluginManager.getPlugin(menuObj.getString(""className""));

                                // check for mobile support
                                boolean isMobileView = MobileUtil.isMobileView();
                                if (isMobileView && (menu instanceof MobileElement) && !((MobileElement)menu).isMobileSupported()) {
                                    // mobile not supported, skip this menu
                                    continue;
                                }
                                
                                //check for deny
                                JSONObject menuRuleObj = null;
                                if (Permission.DEFAULT.equals(permissionKey)) {
                                    menuRuleObj = menuObj.getJSONObject(""properties"");
                                } else if (menuObj.getJSONObject(""properties"").has(""permission_rules"")) {
                                    JSONObject permissionRules = menuObj.getJSONObject(""properties"").getJSONObject(""permission_rules"");
                                    if (permissionRules != null && permissionRules.has(permissionKey)) {
                                        menuRuleObj = permissionRules.getJSONObject(permissionKey);
                                    }
                                }
                                if (menuRuleObj != null && menuRuleObj.has(""permissionDeny"") && ""true"".equals(menuRuleObj.getString(""permissionDeny""))) {
                                    continue;
                                }

                                menu.setProperties(PropertyUtil.getProperties(menuObj.getJSONObject(""properties"")));
                                menu.setRequestParameters(requestParameters);
                                menu.setUserview(userview);
                                String mId = getMenuId(menu);
                                menu.setProperty(""menuId"", mId);

                                if (preview) {
                                    menu.setUrl(contextPath + ""/web/console/app/"" + appId + ""/"" + appVersion + ""/userview/builderPreview/"" + userview.getPropertyString(""id"") + ""/"" + mId);
                                } else {
                                    menu.setKey(key);
                                    String prefix = ""/web/userview/"";

                                    if (embed) {
                                        prefix = ""/web/embed/userview/"";
                                    }

                                    menu.setUrl(contextPath + prefix + appId + ""/"" + userview.getPropertyString(""id"") + ""/"" + ((key != null) ? StringEscapeUtils.escapeHtml(key) : Userview.USERVIEW_KEY_EMPTY_VALUE) + ""/"" + mId);
                                }

                                //set Current, if current menu id is empty, search the 1st valid menu
                                if ((("""".equals(menuId) || ""index"".equals(menuId) || menuId == null) && userview.getCurrent() == null && menu.isHomePageSupported())
                                        || (menuId != null && menuId.equals(mId))) {
                                    userview.setCurrent(menu);
                                    userview.setCurrentCategory(category);
                                }

                                //set home menu Id
                                if (userview.getPropertyString(""homeMenuId"") == null || userview.getPropertyString(""homeMenuId"").isEmpty() && menu.isHomePageSupported()) {
                                    userview.setProperty(""homeMenuId"", mId);
                                }
                                
                                if (menuRuleObj == null || !menuRuleObj.has(""permissionHidden"") || !""true"".equals(menuRuleObj.getString(""permissionHidden""))) {
                                    menu = new CachedUserviewMenu(menu);
                                    menus.add(menu);
                                }
                            } catch (Exception e) {
                                LogUtil.debug(getClass().getName(), ""Userview Menu class file not found"");
                            }
                        }

                        category.setMenus(menus);
                        if (!""yes"".equals(category.getPropertyString(""hide"")) && menus.size() > 0) {
                            categories.add(category);
                        }
                    }
                }
            }
            userview.setCategories(categories);
        } catch (Exception ex) {
            LogUtil.error(getClass().getName(), ex, ""Create Userview Error!!"");
        } finally {
            if (isScreenCapture) {
                workflowUserManager.setCurrentThreadUser(currentThreadUser);
            }
        }
        return userview;
    }",1
"@Override
	public String getUserName(int userId){
		String userName = null;
		Driver driver = new SQLServerDriver();
		try {
			Connection con = driver.connect(connectionUrl, new Properties());
			PreparedStatement statement = con.prepareStatement(""Select userName from UserTable where userId = ?"");
			statement.setInt(1, userId);
			ResultSet rs = statement.executeQuery();
			rs.next();
			userName = rs.getString(""userName"");
			
		} catch (SQLException e) {
			e.printStackTrace();
		}	
		
		return userName;
	}",1
"@Override
    protected Response newBrowserAuthentication(AuthenticationSessionModel authSession, boolean isPassive, boolean redirectToAuthentication, SamlProtocol samlProtocol) {
        // Saml ECP flow creates only TRANSIENT user sessions
        authSession.setClientNote(AuthenticationManager.USER_SESSION_PERSISTENT_STATE, UserSessionModel.SessionPersistenceState.TRANSIENT.toString());
        return super.newBrowserAuthentication(authSession, isPassive, redirectToAuthentication, createEcpSamlProtocol());
    }",1
"public static Account fromXML(String xml) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element accountElement = document.getDocumentElement();
        return fromDOM(accountElement);
    }",1
"@Override
    protected boolean isInContentBounds(float x, float y) {
        float stackScrollerX = mNotificationStackScroller.getX();
        return !mNotificationStackScroller.isBelowLastNotification(x - stackScrollerX, y)
                && stackScrollerX < x && x < stackScrollerX + mNotificationStackScroller.getWidth();
    }",0
"@Nullable
    public PersistableBundle getTransferOwnershipBundle() {
        throwIfParentInstance(""getTransferOwnershipBundle"");
        try {
            return mService.getTransferOwnershipBundle();
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }",0
"public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, DataHolder dataHolder)
            throws IOException {
        if (collectionUpdateLimit >= 0) {
            if (dataHolder == null) {
                dataHolder = new MapBackedDataHolder();
            }
            dataHolder.put(COLLECTION_UPDATE_LIMIT, new Integer(collectionUpdateLimit));
            dataHolder.put(COLLECTION_UPDATE_SECONDS, new Integer(0));
        }
        final DataHolder dh = dataHolder;
        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {
            public Object readFromStream() throws EOFException {
                if (!reader.hasMoreChildren()) {
                    throw new EOFException();
                }
                reader.moveDown();
                final Object result = unmarshal(reader, null, dh);
                reader.moveUp();
                return result;
            }

            public Map readFieldsFromStream() throws IOException {
                throw new NotActiveException(""not in call to readObject"");
            }

            public void defaultReadObject() throws NotActiveException {
                throw new NotActiveException(""not in call to readObject"");
            }

            public void registerValidation(ObjectInputValidation validation, int priority) throws NotActiveException {
                throw new NotActiveException(""stream inactive"");
            }

            public void close() {
                reader.close();
            }
        }, classLoaderReference);
    }",1
"@Override
    public void onTouchSlopExceeded() {
        mStackScroller.removeLongPressCallback();
        mStackScroller.checkSnoozeLeavebehind();
    }",0
"private void setTimeFromNITZString (String nitz, long nitzReceiveTime) {
        // ""yy/mm/dd,hh:mm:ss(+/-)tz""
        // tz is in number of quarter-hours

        long start = SystemClock.elapsedRealtime();
        if (DBG) {log(""NITZ: "" + nitz + "","" + nitzReceiveTime +
                        "" start="" + start + "" delay="" + (start - nitzReceiveTime));
        }

        try {
            /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
            Calendar c = Calendar.getInstance(TimeZone.getTimeZone(""GMT""));

            c.clear();
            c.set(Calendar.DST_OFFSET, 0);

            String[] nitzSubs = nitz.split(""[/:,+-]"");

            int year = 2000 + Integer.parseInt(nitzSubs[0]);
            if (year > MAX_NITZ_YEAR) {
              if (DBG) loge(""NITZ year: "" + year + "" exceeds limit, skip NITZ time update"");
              return;
            }
            c.set(Calendar.YEAR, year);

            // month is 0 based!
            int month = Integer.parseInt(nitzSubs[1]) - 1;
            c.set(Calendar.MONTH, month);

            int date = Integer.parseInt(nitzSubs[2]);
            c.set(Calendar.DATE, date);

            int hour = Integer.parseInt(nitzSubs[3]);
            c.set(Calendar.HOUR, hour);

            int minute = Integer.parseInt(nitzSubs[4]);
            c.set(Calendar.MINUTE, minute);

            int second = Integer.parseInt(nitzSubs[5]);
            c.set(Calendar.SECOND, second);

            boolean sign = (nitz.indexOf('-') == -1);

            int tzOffset = Integer.parseInt(nitzSubs[6]);

            int dst = (nitzSubs.length >= 8 ) ? Integer.parseInt(nitzSubs[7])
                                              : 0;

            // The zone offset received from NITZ is for current local time,
            // so DST correction is already applied.  Don't add it again.
            //
            // tzOffset += dst * 4;
            //
            // We could unapply it if we wanted the raw offset.

            tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;

            TimeZone    zone = null;

            // As a special extension, the Android emulator appends the name of
            // the host computer's timezone to the nitz string. this is zoneinfo
            // timezone name of the form Area!Location or Area!Location!SubLocation
            // so we need to convert the ! into /
            if (nitzSubs.length >= 9) {
                String  tzname = nitzSubs[8].replace('!','/');
                zone = TimeZone.getTimeZone( tzname );
            }

            String iso = ((TelephonyManager) mPhone.getContext().
                    getSystemService(Context.TELEPHONY_SERVICE)).
                    getNetworkCountryIsoForPhone(mPhone.getPhoneId());

            if (zone == null) {

                if (mGotCountryCode) {
                    if (iso != null && iso.length() > 0) {
                        zone = TimeUtils.getTimeZone(tzOffset, dst != 0,
                                c.getTimeInMillis(),
                                iso);
                    } else {
                        // We don't have a valid iso country code.  This is
                        // most likely because we're on a test network that's
                        // using a bogus MCC (eg, ""001""), so get a TimeZone
                        // based only on the NITZ parameters.
                        zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                    }
                }
            }

            if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))){
                // We got the time before the country or the zone has changed
                // so we don't know how to identify the DST rules yet.  Save
                // the information and hope to fix it up later.

                mNeedFixZoneAfterNitz = true;
                mZoneOffset  = tzOffset;
                mZoneDst     = dst != 0;
                mZoneTime    = c.getTimeInMillis();
            }

            if (zone != null) {
                if (getAutoTimeZone()) {
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                }
                saveNitzTimeZone(zone.getID());
            }

            String ignore = SystemProperties.get(""gsm.ignore-nitz"");
            if (ignore != null && ignore.equals(""yes"")) {
                log(""NITZ: Not setting clock because gsm.ignore-nitz is set"");
                return;
            }

            try {
                mWakeLock.acquire();

                if (getAutoTime()) {
                    long millisSinceNitzReceived
                            = SystemClock.elapsedRealtime() - nitzReceiveTime;

                    if (millisSinceNitzReceived < 0) {
                        // Sanity check: something is wrong
                        if (DBG) {
                            log(""NITZ: not setting time, clock has rolled ""
                                            + ""backwards since NITZ time was received, ""
                                            + nitz);
                        }
                        return;
                    }

                    if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                        // If the time is this far off, something is wrong > 24 days!
                        if (DBG) {
                            log(""NITZ: not setting time, processing has taken ""
                                        + (millisSinceNitzReceived / (1000 * 60 * 60 * 24))
                                        + "" days"");
                        }
                        return;
                    }

                    // Note: with range checks above, cast to int is safe
                    c.add(Calendar.MILLISECOND, (int)millisSinceNitzReceived);

                    if (DBG) {
                        log(""NITZ: Setting time of day to "" + c.getTime()
                            + "" NITZ receive delay(ms): "" + millisSinceNitzReceived
                            + "" gained(ms): ""
                            + (c.getTimeInMillis() - System.currentTimeMillis())
                            + "" from "" + nitz);
                    }

                    setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    Rlog.i(LOG_TAG, ""NITZ: after Setting time of day"");
                }
                SystemProperties.set(""gsm.nitz.time"", String.valueOf(c.getTimeInMillis()));
                saveNitzTime(c.getTimeInMillis());
                if (VDBG) {
                    long end = SystemClock.elapsedRealtime();
                    log(""NITZ: end="" + end + "" dur="" + (end - start));
                }
                mNitzUpdatedTime = true;
            } finally {
                mWakeLock.release();
            }
        } catch (RuntimeException ex) {
            loge(""NITZ: Parsing NITZ time "" + nitz + "" ex="" + ex);
        }
    }",1
"@Override
    public void simulateBlockMine(BlockVector3 pt) {
        //FAWE start - safe edit region
        testCoords(pt);
        //FAWE end
        getWorld().getBlockAt(pt.getBlockX(), pt.getBlockY(), pt.getBlockZ()).breakNaturally();
    }",1
"public String getDestinationString(String transportName) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.BACKUP,
                ""getDestinationString"");

        synchronized (mTransports) {
            final IBackupTransport transport = mTransports.get(transportName);
            if (transport != null) {
                try {
                    final String text = transport.currentDestinationString();
                    if (MORE_DEBUG) Slog.d(TAG, ""getDestinationString() returning "" + text);
                    return text;
                } catch (RemoteException e) {
                    /* fall through to return null */
                }
            }
        }

        return null;
    }",0
"@Override
	public VFSContainer createChildContainer(String name) {
		File fNewFile = new File(getBasefile(), name);
		if(!isInPath(name)) {
			log.warn(""Could not create a new container::{} in container::{} - file out of parent directory"", name, getBasefile().getAbsolutePath());
			return null;
		}
		if (!fNewFile.mkdir()) {
			return null;
		}
		LocalFolderImpl locFI =  new LocalFolderImpl(fNewFile, this);
		locFI.setDefaultItemFilter(defaultFilter);
		return locFI;
	}",1
"public String getPlmn() {
        return getFieldValue(PLMN_KEY, """");
    }",0
"String[] getShellArgs()
    {
        if ( shellArgs.isEmpty() )
        {
            return null;
        }
        else
        {
            return shellArgs.toArray( new String[0] );
        }
    }",1
"public SAXParser newSAXParser() {
        final SAXParser ret;
        try {
            ret = new XercesJAXPSAXParser(this, features, validating, handleXInclude);
        } catch (final SAXException se) {
            // Translate to ParserConfigurationException
            throw new OXFException(se); // so we see a decent stack trace!
        }
        return ret;
    }",1
"private Properties getPageProperties(WikiPage page) {
		Properties p = new Properties();
		p.setProperty(PAGENAME, page.getPageName());
		p.setProperty(VERSION, String.valueOf(page.getVersion()));
		p.setProperty(FORUM_KEY, String.valueOf(page.getForumKey()));
		p.setProperty(INITIAL_AUTHOR, String.valueOf(page.getInitalAuthor()));
		p.setProperty(MODIFY_AUTHOR, String.valueOf(page.getModifyAuthor()));
		p.setProperty(C_TIME, String.valueOf(page.getCreationTime()));
		p.setProperty(VIEW_COUNT, String.valueOf(page.getViewCount()));
		p.setProperty(M_TIME, String.valueOf(page.getModificationTime()));
		p.setProperty(UPDATE_COMMENT, page.getUpdateComment());
		return p;
	}",0
"public boolean deleteSettingLocked(int type, int userId, String name, boolean forceNotify,
                Set<String> criticalSettings) {
            final int key = makeKey(type, userId);

            boolean success = false;
            SettingsState settingsState = peekSettingsStateLocked(key);
            if (settingsState != null) {
                success = settingsState.deleteSettingLocked(name);
            }

            if (success && criticalSettings != null && criticalSettings.contains(name)) {
                settingsState.persistSyncLocked();
            }

            if (forceNotify || success) {
                notifyForSettingsChange(key, name);
            }
            return success;
        }",0
"@Override
        public void putStringForUser(ContentResolver resolver, String name, String value,
            int userHandle) {
            Settings.Secure.putStringForUser(resolver, name, value, userHandle);
        }",0
"@Override
    public void startLockTaskMode(int taskId) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeInt(taskId);
        mRemote.transact(START_LOCK_TASK_BY_TASK_ID_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    }",0
"public static PolicyConstraintValue fromXML(String xml) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element pcvElement = document.getDocumentElement();
        return fromDOM(pcvElement);
    }",1
"protected static Document createDocumentImpl(
        String name, String namespaceURI, boolean enableExternalEntities)
        throws ParserConfigurationException, FactoryConfigurationError
    {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(isNamespaceAware);
        enableOrDisableExternalEntityParsing(factory, enableExternalEntities);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();
        Element rootElement = null;
        if (namespaceURI != null && namespaceURI.length() > 0) {
            rootElement = document.createElementNS(namespaceURI, name);
        } else {
            rootElement = document.createElement(name);
        }
        document.appendChild(rootElement);
        return document;
    }",1
"private boolean isFwdChangeSuccess() {
        if (mForwardingChangeResults == null) {
            return true;
        }

        for (AsyncResult result : mForwardingChangeResults.values()) {
            Throwable exception = result.exception;
            if (exception != null) {
                String msg = exception.getMessage();
                msg = (msg != null) ? msg : """";
                Log.w(LOG_TAG, ""Failed to change forwarding setting. Reason: "" + msg);
                return false;
            }
        }
        return true;
    }",0
"public static SFile fromFile(File internal) {
		if (internal == null)
			return null;

		return new SFile(internal);
	}",1
"public String getView() {
        return view == null ? null : view.getValue();
    }",0
"void addPathParam(String name, String value, boolean encoded) {
    if (relativeUrl == null) {
      // The relative URL is cleared when the first query parameter is set.
      throw new AssertionError();
    }
    String replacement = canonicalizeForPath(value, encoded);
    String newRelativeUrl = relativeUrl.replace(""{"" + name + ""}"", replacement);
    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
      throw new IllegalArgumentException(
          ""@Path parameters shouldn't perform path traversal ('.' or '..'): "" + value);
    }
    relativeUrl = newRelativeUrl;
  }",1
"default List<String> getPermissions() {
    List<String> permissions = new ArrayList<>();
    permissions.add(""*:*"");
    permissions.add(this.getName().substring(0, this.getName().indexOf('_')) + "":*"");
    permissions.add(this.getName().replace('_', ':'));
    return permissions;
  }",1
"@Override
        public boolean enablePhoneAccount(PhoneAccountHandle accountHandle, boolean isEnabled) {
            enforceModifyPermission();
            synchronized (mLock) {
                long token  = Binder.clearCallingIdentity();
                try {
                    // enable/disable phone account
                    return mPhoneAccountRegistrar.enablePhoneAccount(accountHandle, isEnabled);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            }
        }",0
"@Override
    public BigInteger bigIntegerValueExact() {
        BigDecimal bd = bigDecimalValue();
        if (Math.abs(bd.scale()) <= bigIntegerScaleLimit) {
            return bd.toBigIntegerExact();
        }
        throw new UnsupportedOperationException(
                JsonMessages.NUMBER_SCALE_LIMIT_EXCEPTION(bd.scale(), bigIntegerScaleLimit));
    }",1
"public static String getPropertyDef(InputSpec inputSpec, Map<String, Integer> indexes, 
			String pattern, DefaultValueProvider defaultValueProvider) {
		pattern = InputSpec.escape(pattern);
		int index = indexes.get(inputSpec.getName());
		StringBuffer buffer = new StringBuffer();
		inputSpec.appendField(buffer, index, ""String"");
		inputSpec.appendCommonAnnotations(buffer, index);
		if (!inputSpec.isAllowEmpty())
			buffer.append(""    @NotEmpty\n"");
		if (pattern != null)
			buffer.append(""    @Pattern(regexp=\"""" + pattern + ""\"", message=\""Should match regular expression: "" + pattern + ""\"")\n"");
		inputSpec.appendMethods(buffer, index, ""String"", null, defaultValueProvider);

		return buffer.toString();
	}",1
"@Override
	public File getUploaded(Long projectId) {
		return new File(Bootstrap.getSiteDir(), ""assets/avatars/uploaded/projects/"" + projectId + "".jpg"");
	}",1
"@PostMapping
    public Result create(@RequestBody Map<String, String> body) {
        User user = getApiUser();
        ApiAssert.isTrue(user.getActive(), ""你的帐号还没有激活，请去个人设置页面激活帐号"");
        String title = body.get(""title"");
        String content = body.get(""content"");
        String tag = body.get(""tag"");
        //    String tags = body.get(""tags"");
        title = Jsoup.clean(title, Whitelist.basic());
        ApiAssert.notEmpty(title, ""请输入标题"");
        ApiAssert.isNull(topicService.selectByTitle(title), ""话题标题重复"");
        //    String[] strings = StringUtils.commaDelimitedListToStringArray(tags);
        //    Set<String> set = StringUtil.removeEmpty(strings);
        //    ApiAssert.notTrue(set.isEmpty() || set.size() > 5, ""请输入标签且标签最多5个"");
        // 保存话题
        // 再次将tag转成逗号隔开的字符串
        //    tags = StringUtils.collectionToCommaDelimitedString(set);
        Topic topic = topicService.insert(title, content, tag, user);
        topic.setContent(SensitiveWordUtil.replaceSensitiveWord(topic.getContent(), ""*"", SensitiveWordUtil.MinMatchType));
        return success(topic);
    }",1
"public static XMLTypeValidator createXMLTypeValidator(String xmlSchema) {
      try {
        // create a SchemaFactory capable of understanding WXS schemas
        SchemaFactory factory = createSchemaFactoryInstance();
        // load a WXS schema, represented by a Schema instance
        Source xmlSchemaSource = new StreamSource(new StringReader(xmlSchema));
        return new XMLTypeValidator(factory.newSchema(xmlSchemaSource).newValidator());
      } catch (SAXException e) {
        throw new RuntimeException(e);
      }
    }",1
"public static Info fromXML(String xml) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element element = document.getDocumentElement();
        return fromDOM(element);
    }",1
"@Override
    public BaseObject remove(int index)
    {
        rangeCheck(index);

        BaseObject previous = this.map.remove(index);

        // Shifts right values to the left
        if (index < this.size - 1) {
            for (int i = index; i < this.size - 1; ++i) {
                put(i, get(i + 1));
            }
        }

        // The list is one element shorter
        --this.size;

        return previous;
    }",1
"public static PSystemVersion createShowVersion2(UmlSource source) {
		final List<String> strings = new ArrayList<>();
		strings.add(""<b>PlantUML version "" + Version.versionString() + ""</b> ("" + Version.compileTimeString() + "")"");
		strings.add(""("" + License.getCurrent() + "" source distribution)"");
		// :: uncomment when __CORE__
//		strings.add("" "");
//		strings.add(""Compiled with CheerpJ 2.3"");
//		strings.add(""Powered by CheerpJ, a Leaning Technologies Java tool"");
		// :: done
		// :: comment when __CORE__
		GraphvizCrash.checkOldVersionWarning(strings);
		if (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE) {
			strings.add(""Loaded from "" + Version.getJarPath());

			if (OptionFlags.getInstance().isWord()) {
				strings.add(""Word Mode"");
				strings.add(""Command Line: "" + Run.getCommandLine());
				strings.add(""Current Dir: "" + new SFile(""."").getAbsolutePath());
				strings.add(""plantuml.include.path: "" + PreprocessorUtils.getenv(SecurityUtils.PATHS_INCLUDES));
			}
		}
		strings.add("" "");

		GraphvizUtils.addDotStatus(strings, true);
		strings.add("" "");
		for (String name : OptionPrint.interestingProperties())
			strings.add(name);

		for (String v : OptionPrint.interestingValues())
			strings.add(v);

		// ::done

		return new PSystemVersion(source, true, strings);
	}",1
"protected void unlockSession(WrappedSession wrappedSession) {
        assert getSessionLock(wrappedSession) != null;
        assert ((ReentrantLock) getSessionLock(wrappedSession))
                .isHeldByCurrentThread() : ""Trying to unlock the session but it has not been locked by this thread"";
        getSessionLock(wrappedSession).unlock();
    }",0
"@Override
	public VFSLeaf createChildLeaf(String name) {
		File fNewFile = new File(getBasefile(), name);
		try {
			if(!isInPath(name)) {
				log.warn(""Could not create a new leaf::{} in container::{} - file out of parent directory"", name, getBasefile().getAbsolutePath());
				return null;
			}
			if(!fNewFile.getParentFile().exists()) {
				fNewFile.getParentFile().mkdirs();
			}
			if (!fNewFile.createNewFile()) {
				log.warn(""Could not create a new leaf::{} in container::{} - file alreay exists"", name, getBasefile().getAbsolutePath());
				return null;
			} 
		} catch (Exception e) {
			log.error(""Error while creating child leaf::{} in container::{}"", name, getBasefile().getAbsolutePath(), e);
			return null;
		}
		return new LocalFileImpl(fNewFile, this);
	}",1
"private @Nullable WifiConfiguration getInternalConfiguredNetwork(
            @NonNull WifiConfiguration config) {
        WifiConfiguration internalConfig = mConfiguredNetworks.getForCurrentUser(config.networkId);
        if (internalConfig != null) {
            return internalConfig;
        }
        internalConfig = mConfiguredNetworks.getByConfigKeyForCurrentUser(
                config.getProfileKey());
        if (internalConfig != null) {
            return internalConfig;
        }
        internalConfig = getInternalConfiguredNetworkByUpgradableType(config);
        if (internalConfig == null) {
            Log.e(TAG, ""Cannot find network with networkId "" + config.networkId
                    + "" or configKey "" + config.getProfileKey()
                    + "" or upgradable security type check"");
        }
        return internalConfig;
    }",0
"@Override
    public int subWindowTypeToLayerLw(int type) {
        switch (type) {
        case TYPE_APPLICATION_PANEL:
        case TYPE_APPLICATION_ATTACHED_DIALOG:
            return APPLICATION_PANEL_SUBLAYER;
        case TYPE_APPLICATION_MEDIA:
            return APPLICATION_MEDIA_SUBLAYER;
        case TYPE_APPLICATION_MEDIA_OVERLAY:
            return APPLICATION_MEDIA_OVERLAY_SUBLAYER;
        case TYPE_APPLICATION_SUB_PANEL:
            return APPLICATION_SUB_PANEL_SUBLAYER;
        }
        Log.e(TAG, ""Unknown sub-window type: "" + type);
        return 0;
    }",0
"private static void handleErrorResponse(HttpsURLConnection conn, String url, String moduleFullName) {
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {
            StringBuilder result = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                result.append(line);
            }

            MapValue payload = (MapValue) JSONParser.parse(result.toString());
            createError(""error: "" + payload.getStringValue(""message""));
        } catch (IOException e) {
            createError(""failed to pull the module '"" + moduleFullName + ""' from the remote repository '"" + url + ""'"");
        }
    }",1
"@Override
    public void killAllBackgroundProcesses() {
        if (checkCallingPermission(android.Manifest.permission.KILL_BACKGROUND_PROCESSES)
                != PackageManager.PERMISSION_GRANTED) {
            final String msg = ""Permission Denial: killAllBackgroundProcesses() from pid=""
                    + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid()
                    + "" requires "" + android.Manifest.permission.KILL_BACKGROUND_PROCESSES;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }

        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();

        ProcessRecord proc;
        synchronized (mPidsSelfLocked) {
            proc = mPidsSelfLocked.get(callingPid);
        }
        if (callingUid >= FIRST_APPLICATION_UID
                && (proc == null || !proc.info.isSystemApp())) {
            final String msg = ""Permission Denial: killAllBackgroundProcesses() from pid=""
                    + callingPid + "", uid="" + callingUid + "" is not allowed"";
            Slog.w(TAG, msg);
            // Silently return to avoid existing apps from crashing.
            return;
        }

        final long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                // Allow memory level to go down (the flag needs to be set before updating oom adj)
                // because this method is also used to simulate low memory.
                mAppProfiler.setAllowLowerMemLevelLocked(true);
                synchronized (mProcLock) {
                    mProcessList.killPackageProcessesLSP(null /* packageName */, -1 /* appId */,
                            UserHandle.USER_ALL, ProcessList.CACHED_APP_MIN_ADJ,
                            ApplicationExitInfo.REASON_USER_REQUESTED,
                            ApplicationExitInfo.SUBREASON_KILL_BACKGROUND,
                            ""kill all background"");
                }

                mAppProfiler.doLowMemReportIfNeededLocked(null);
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }",1
"public String toXML() throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();

        Element accountElement = toDOM(document);
        document.appendChild(accountElement);

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
        transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""4"");

        DOMSource domSource = new DOMSource(document);
        StringWriter sw = new StringWriter();
        StreamResult streamResult = new StreamResult(sw);
        transformer.transform(domSource, streamResult);
        return sw.toString();
    }",1
"boolean installCaCertsToKeyChain(IKeyChainService keyChainService) {
        for (X509Certificate caCert : mCaCerts) {
            byte[] bytes = null;
            try {
                bytes = caCert.getEncoded();
            } catch (CertificateEncodingException e) {
                throw new AssertionError(e);
            }
            if (bytes != null) {
                try {
                    keyChainService.installCaCertificate(bytes);
                } catch (RemoteException e) {
                    Log.w(TAG, ""installCaCertsToKeyChain(): "" + e);
                    return false;
                }
            }
        }
        return true;
    }",0
"public void setSessionId(String sessionId) {
    this.sessionId = sessionId;
  }",0
"void reparent(TaskFragment newTaskFrag, int position, String reason) {
        if (getParent() == null) {
            Slog.w(TAG, ""reparent: Attempted to reparent non-existing app token: "" + token);
            return;
        }
        final TaskFragment prevTaskFrag = getTaskFragment();
        if (prevTaskFrag == newTaskFrag) {
            throw new IllegalArgumentException(reason + "": task fragment ="" + newTaskFrag
                    + "" is already the parent of r="" + this);
        }

        ProtoLog.i(WM_DEBUG_ADD_REMOVE, ""reparent: moving activity=%s""
                + "" to new task fragment in task=%d at %d"", this, task.mTaskId, position);
        reparent(newTaskFrag, position);
    }",0
"public String getRealAssetPath(String inode, String fileName, String ext) {
        String _inode = inode;
        String path = """";

        String realPath = Config.getStringProperty(""ASSET_REAL_PATH"");
        if (UtilMethods.isSet(realPath) && !realPath.endsWith(java.io.File.separator))
            realPath = realPath + java.io.File.separator;

        String assetPath = Config.getStringProperty(""ASSET_PATH"", ""/assets"");
        if (UtilMethods.isSet(assetPath) && !assetPath.endsWith(java.io.File.separator))
            assetPath = assetPath + java.io.File.separator;

        path = ((!UtilMethods.isSet(realPath)) ? assetPath : realPath)
                + _inode.charAt(0) + java.io.File.separator + _inode.charAt(1)
                + java.io.File.separator + _inode+ java.io.File.separator + ""fileAsset"" + java.io.File.separator + fileName + ""."" + ext;

        if (!UtilMethods.isSet(realPath))
            return FileUtil.getRealPath(path);
        else
            return path;

    }",1
"@Override
    public Response processRemoveProducer(ProducerId id) throws Exception {
        SessionId sessionId = id.getParentId();
        ConnectionId connectionId = sessionId.getParentId();
        TransportConnectionState cs = lookupConnectionState(connectionId);
        SessionState ss = cs.getSessionState(sessionId);
        if (ss == null) {
            throw new IllegalStateException(""Cannot remove a producer from a session that had not been registered: ""
                    + sessionId);
        }
        ProducerState ps = ss.removeProducer(id);
        if (ps == null) {
            throw new IllegalStateException(""Cannot remove a producer that had not been registered: "" + id);
        }
        removeProducerBrokerExchange(id);
        broker.removeProducer(cs.getContext(), ps.getInfo());
        return null;
    }",0
"private static String replaceSecurityRoles(final String orig, final User user) {
        String retVal = orig;
        if (orig.contains(""${user.securityRoles}"") || orig.contains(""${user_securityRoles}"")) {
            final String commaSeparatedRoles = toQuotedCommaSeparatedString(user.getSecurityRoles());
            retVal = orig.replace(""${user.securityRoles}"", commaSeparatedRoles).replace(""${user_securityRoles}"", commaSeparatedRoles);
        }
        return retVal;
    }",0
"@Test(timeout = 100)
    public void testDeserializationAsFloatEdgeCase10() throws Exception
    {
        String input = ""1e-10000000"";
        Duration value = READER.without(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                                 .readValue(input);
        assertEquals(0, value.getSeconds());
    }",1
"public void takeEmergencyCallAction() {
        MetricsLogger.action(mContext, MetricsLogger.ACTION_EMERGENCY_CALL);
        // TODO: implement a shorter timeout once new PowerManager API is ready.
        // should be the equivalent to the old userActivity(EMERGENCY_CALL_TIMEOUT)
        mPowerManager.userActivity(SystemClock.uptimeMillis(), true);
        try {
            ActivityManagerNative.getDefault().stopLockTaskMode();
        } catch (RemoteException e) {
            Slog.w(LOG_TAG, ""Failed to stop app pinning"");
        }
        if (isInCall()) {
            resumeCall();
            if (mEmergencyButtonCallback != null) {
                mEmergencyButtonCallback.onEmergencyButtonClickedWhenInCall();
            }
        } else {
            KeyguardUpdateMonitor.getInstance(mContext).reportEmergencyCallAction(
                    true /* bypassHandler */);
            getContext().startActivityAsUser(INTENT_EMERGENCY_DIAL,
                    ActivityOptions.makeCustomAnimation(getContext(), 0, 0).toBundle(),
                    new UserHandle(KeyguardUpdateMonitor.getCurrentUser()));
        }
    }",1
"@Override
    public void onPerform(CommandEvent commandEvent) {
        if (!commandEvent.getGuild().getSelfMember().hasPermission(Permission.MANAGE_WEBHOOKS)) {
            Main.getInstance().getCommandManager().sendMessage(""I need the permission `Manage Webhooks` to use this command!"", commandEvent.getChannel(), commandEvent.getInteractionHook());
        }

        if (commandEvent.isSlashCommand()) {
            Main.getInstance().getCommandManager().sendMessage(""This Command doesn't support slash commands yet."", commandEvent.getChannel(), commandEvent.getInteractionHook());
            return;
        }

        if (commandEvent.getArguments().length == 1) {
            if (commandEvent.getArguments()[0].equalsIgnoreCase(""list"")) {
                StringBuilder end = new StringBuilder(""```\n"");

                for (String users : Main.getInstance().getSqlConnector().getSqlWorker().getAllTwitchNames(commandEvent.getGuild().getId())) {
                    end.append(users).append(""\n"");
                }

                end.append(""```"");

                Main.getInstance().getCommandManager().sendMessage(end.toString(), 10, commandEvent.getChannel(), commandEvent.getInteractionHook());

            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""twitch list/add/remove"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else if (commandEvent.getArguments().length == 3) {

            if (commandEvent.getMessage().getMentions().getChannels(TextChannel.class).isEmpty() ||
                    !commandEvent.getMessage().getMentions().getChannels(TextChannel.class).get(0).getGuild().getId().equals(commandEvent.getGuild().getId())) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""twitch add/remove TwitchName #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
                return;
            }

            String name = commandEvent.getArguments()[1];
            if (commandEvent.getArguments()[0].equalsIgnoreCase(""add"")) {
                commandEvent.getMessage().getMentions().getChannels(TextChannel.class).get(0).createWebhook(""Ree6-TwitchNotifier-"" + name).queue(w -> Main.getInstance().getSqlConnector().getSqlWorker().addTwitchWebhook(commandEvent.getGuild().getId(), w.getId(), w.getToken(), name.toLowerCase()));
                Main.getInstance().getCommandManager().sendMessage(""A TwitchStream Notifier has been created for the User "" + name + ""!"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());

                if (!Main.getInstance().getNotifier().isTwitchRegistered(name)) {
                    Main.getInstance().getNotifier().registerTwitchChannel(name);
                }
            } else if (commandEvent.getArguments()[0].equalsIgnoreCase(""remove"")) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""twitch remove TwitchName"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""twitch add TwitchName #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else if (commandEvent.getArguments().length == 2) {
            String name = commandEvent.getArguments()[1];
            if (commandEvent.getArguments()[0].equalsIgnoreCase(""remove"")) {
                Main.getInstance().getSqlConnector().getSqlWorker().removeTwitchWebhook(commandEvent.getGuild().getId(), name);
                Main.getInstance().getCommandManager().sendMessage(""A TwitchStream Notifier has been removed from the User "" + name + ""!"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());

                if (Main.getInstance().getNotifier().isTwitchRegistered(name)) {
                    Main.getInstance().getNotifier().unregisterTwitchChannel(name);
                }
            } else if (commandEvent.getArguments()[0].equalsIgnoreCase(""add"")) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""twitch add TwitchName #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""twitch remove TwitchName"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else {
            Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""twitch list/add/remove"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
        }
        Main.getInstance().getCommandManager().deleteMessage(commandEvent.getMessage(), commandEvent.getInteractionHook());
    }",1
"public Connection getConnection(DatabaseConfiguration databaseConfiguration) throws DatabaseServiceException {
        try {
            if (connection != null) {
                connection.close();
            }

            Class.forName(type.getClassPath());
            String dbURL = getDatabaseUrl(databaseConfiguration);
            connection = DriverManager.getConnection(dbURL);

            logger.debug(""*** Acquired New  connection for ::{} **** "", dbURL);

            return connection;
        } catch (ClassNotFoundException e) {
            logger.error(""Jdbc Driver not found"", e);
            throw new DatabaseServiceException(e.getMessage());
        } catch (SQLException e) {
            logger.error(""SQLException::Couldn't get a Connection!"", e);
            throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());
        }
    }",0
"private void consumeHeaderFrame(Frame f) throws IOException {
        if (f.type == AMQP.FRAME_HEADER) {
            this.contentHeader = AMQImpl.readContentHeaderFrom(f.getInputStream());
            long bodySize = this.contentHeader.getBodySize();
            if (bodySize >= this.maxBodyLength) {
                throw new IllegalStateException(format(
                    ""Message body is too large (%d), maximum size is %d"",
                    bodySize, this.maxBodyLength
                ));
            }
            this.remainingBodyBytes = bodySize;
            updateContentBodyState();
        } else {
            throw new UnexpectedFrameError(f, AMQP.FRAME_HEADER);
        }
    }",1
"public void setXObjects(Map<DocumentReference, List<BaseObject>> objects)
    {
        if (objects == null) {
            // Make sure we don`t set a null objects map since we assume everywhere that it is not null when using it.
            objects = new HashMap<>();
        }

        boolean isDirty = false;

        for (List<BaseObject> objList : objects.values()) {
            for (BaseObject obj : objList) {
                obj.setOwnerDocument(this);
                isDirty = true;
            }
        }

        // This operation resulted in marking the current document dirty.
        if (isDirty) {
            setMetaDataDirty(true);
        }

        // Replace the current objects with the provided ones.
        Map<DocumentReference, BaseObjects> objectsCopy = new ConcurrentSkipListMap<>();
        objects.forEach((k, v) -> objectsCopy.put(k, new BaseObjects(v)));
        this.xObjects = objectsCopy;
    }",1
"@Override
    protected void process(EntityReference source)
    {
        this.progressManager.pushLevelProgress(2, this);
        AttachmentReference destination = this.request.getProperty(MoveAttachmentRequest.DESTINATION);
        boolean autoRedirect = this.request.getProperty(MoveAttachmentRequest.AUTO_REDIRECT);

        XWiki wiki = this.xcontextProvider.get().getWiki();

        // Update the author for the attribution of the attachment uploader.
        this.modelBridge.setContextUserReference(this.request.getUserReference());
        try {
            if (checkMoveRights(source, destination)) {
                this.progressManager.startStep(this);
                moveAttachment(source, destination, autoRedirect, wiki);
                this.progressManager.endStep(this);

                this.progressManager.startStep(this);
                this.observationManager.notify(new AttachmentMovedEvent((AttachmentReference) source, destination),
                    this,
                    this.request);
                this.progressManager.endStep(this);
            }
        } finally {
            this.progressManager.popLevelProgress(this);
        }
    }",1
"public void setContinueNavigationAction(
            ContinueNavigationAction continueNavigationAction) {
        this.continueNavigationAction = continueNavigationAction;
    }",0
"@SuppressWarnings({ ""PMD.AvoidCatchingThrowable"", ""PMD.AvoidInstanceofChecksInCatchClause"" })
    private void handle(ServletRequestHandler pReqHandler,HttpServletRequest pReq, HttpServletResponse pResp) throws IOException {
        JSONAware json = null;
        try {
            // Check access policy
            requestHandler.checkAccess(pReq.getRemoteHost(), pReq.getRemoteAddr(),
                                       getOriginOrReferer(pReq));

            // Remember the agent URL upon the first request. Needed for discovery
            updateAgentUrlIfNeeded(pReq);

            // Dispatch for the proper HTTP request method
            json = pReqHandler.handleRequest(pReq,pResp);
        } catch (Throwable exp) {
            json = requestHandler.handleThrowable(
                    exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);
        } finally {
            setCorsHeader(pReq, pResp);

            String callback = pReq.getParameter(ConfigKey.CALLBACK.getKeyValue());
            String answer = json != null ?
                    json.toJSONString() :
                    requestHandler.handleThrowable(new Exception(""Internal error while handling an exception"")).toJSONString();
            if (callback != null) {
                // Send a JSONP response
                sendResponse(pResp, ""text/javascript"", callback + ""("" + answer + "");"");
            } else {
                sendResponse(pResp, getMimeType(pReq),answer);
            }
        }
    }",1
"private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        DelegatingSerializationFilter filter = new DelegatingSerializationFilter();
        filter.setFilter(in, ""org.keycloak.KeycloakSecurityContext;org.keycloak.KeycloakPrincipal;java.util.*;!*"");
        in.defaultReadObject();
    }",1
"@Beta
  public static void createParentDirs(File file) throws IOException {
    checkNotNull(file);
    File parent = file.getCanonicalFile().getParentFile();
    if (parent == null) {
      /*
       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't
       * mean that the root itself exists -- consider x:\ on a Windows machine without such a drive
       * -- or even that the caller can create it, but this method makes no such guarantees even for
       * non-root files.
       */
      return;
    }
    parent.mkdirs();
    if (!parent.isDirectory()) {
      throw new IOException(""Unable to create parent directories of "" + file);
    }
  }",0
"@Override
    public Repository getRepository(Project project) {
    	Repository repository = repositoryCache.get(project.getId());
    	if (repository == null) {
    		synchronized (repositoryCache) {
    			repository = repositoryCache.get(project.getId());
    			if (repository == null) {
    				try {
						repository = new FileRepository(project.getGitDir());
					} catch (IOException e) {
						throw new RuntimeException(e);
					}
    				repositoryCache.put(project.getId(), repository);
    			}
    		}
    	}
    	return repository;
    }",0
"public void prepare(Template template, HttpServletRequest request) {

		// Request

		template.put(""request"", request);

		// Portlet config

		PortletConfig portletConfig = (PortletConfig)request.getAttribute(
			JavaConstants.JAVAX_PORTLET_CONFIG);

		if (portletConfig != null) {
			template.put(""portletConfig"", portletConfig);
		}

		// Render request

		final PortletRequest portletRequest =
			(PortletRequest)request.getAttribute(
				JavaConstants.JAVAX_PORTLET_REQUEST);

		if (portletRequest != null) {
			if (portletRequest instanceof RenderRequest) {
				template.put(""renderRequest"", portletRequest);
			}
		}

		// Render response

		final PortletResponse portletResponse =
			(PortletResponse)request.getAttribute(
				JavaConstants.JAVAX_PORTLET_RESPONSE);

		if (portletResponse != null) {
			if (portletResponse instanceof RenderResponse) {
				template.put(""renderResponse"", portletResponse);
			}
		}

		// XML request

		if ((portletRequest != null) && (portletResponse != null)) {
			template.put(
				""portletRequestModelFactory"",
				new PortletRequestModelFactory(
					portletRequest, portletResponse));

			// Deprecated

			template.put(
				""xmlRequest"",
				new Object() {

					@Override
					public String toString() {
						PortletRequestModel portletRequestModel =
							new PortletRequestModel(
								portletRequest, portletResponse);

						return portletRequestModel.toXML();
					}

				}
			);
		}

		// Theme display

		ThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(
			WebKeys.THEME_DISPLAY);

		if (themeDisplay != null) {
			Layout layout = themeDisplay.getLayout();
			List<Layout> layouts = themeDisplay.getLayouts();

			template.put(""themeDisplay"", themeDisplay);
			template.put(""company"", themeDisplay.getCompany());
			template.put(""user"", themeDisplay.getUser());
			template.put(""realUser"", themeDisplay.getRealUser());
			template.put(""layout"", layout);
			template.put(""layouts"", layouts);
			template.put(""plid"", String.valueOf(themeDisplay.getPlid()));
			template.put(
				""layoutTypePortlet"", themeDisplay.getLayoutTypePortlet());
			template.put(
				""scopeGroupId"", new Long(themeDisplay.getScopeGroupId()));
			template.put(
				""permissionChecker"", themeDisplay.getPermissionChecker());
			template.put(""locale"", themeDisplay.getLocale());
			template.put(""timeZone"", themeDisplay.getTimeZone());
			template.put(""colorScheme"", themeDisplay.getColorScheme());
			template.put(""portletDisplay"", themeDisplay.getPortletDisplay());

			// Navigation items

			if (layout != null) {
				List<NavItem> navItems = NavItem.fromLayouts(
					request, layouts, template);

				template.put(""navItems"", navItems);
			}

			// Deprecated

			template.put(
				""portletGroupId"", new Long(themeDisplay.getScopeGroupId()));
		}

		// Theme

		Theme theme = (Theme)request.getAttribute(WebKeys.THEME);

		if ((theme == null) && (themeDisplay != null)) {
			theme = themeDisplay.getTheme();
		}

		if (theme != null) {
			template.put(""theme"", theme);
		}

		// Tiles attributes

		prepareTiles(template, request);

		// Page title and subtitle

		ListMergeable<String> pageTitleListMergeable =
			(ListMergeable<String>)request.getAttribute(WebKeys.PAGE_TITLE);

		if (pageTitleListMergeable != null) {
			String pageTitle = pageTitleListMergeable.mergeToString(
				StringPool.SPACE);

			template.put(""pageTitle"", HtmlUtil.stripHtml(pageTitle));
		}

		ListMergeable<String> pageSubtitleListMergeable =
			(ListMergeable<String>)request.getAttribute(WebKeys.PAGE_SUBTITLE);

		if (pageSubtitleListMergeable != null) {
			String pageSubtitle = pageSubtitleListMergeable.mergeToString(
				StringPool.SPACE);

			template.put(""pageSubtitle"", HtmlUtil.stripHtml(pageSubtitle));
		}
	}",1
"void maybeValidateXml(File file) {
        if (!file.getName().endsWith("".xml"")) {
            return;
        }

        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(false);
        factory.setNamespaceAware(true);

        try {
            factory.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
            factory.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
            factory.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
        } catch (ParserConfigurationException e) {
            throw new BadRequestException(Response.status(Response.Status.BAD_REQUEST)
                    .entity(""Error configuring parser factory: "" + e.getMessage()).build());
        }

        final CapturingErrorHandler errorHandler = new CapturingErrorHandler();
        try {
            final DocumentBuilder builder = factory.newDocumentBuilder();
            builder.setErrorHandler(errorHandler);
            builder.parse(file);
        } catch (ParserConfigurationException | SAXException | IOException e) {
            throw new BadRequestException(Response.status(Response.Status.BAD_REQUEST)
                    .entity(""Validation failed: "" + e.getMessage()).build());
        }
    }",1
"public List<List<ObjectDiff>> getClassDiff(XWikiDocument fromDoc, XWikiDocument toDoc, XWikiContext context)
    {
        List<List<ObjectDiff>> difflist = new ArrayList<List<ObjectDiff>>();
        BaseClass oldClass = fromDoc.getXClass();
        BaseClass newClass = toDoc.getXClass();

        if ((newClass == null) && (oldClass == null)) {
            return difflist;
        }

        List<ObjectDiff> dlist = newClass.getDiff(oldClass, context);
        if (!dlist.isEmpty()) {
            difflist.add(dlist);
        }

        return difflist;
    }",0
"public void close(final AjaxRequestTarget target)
  {
    csrfTokenHandler.onSubmit();
    target.appendJavaScript(""$('#"" + getMainContainerMarkupId() + ""').modal('hide');"");
  }",1
"private String normalizeJarBasePath(String rawPath) {
        if (rawPath == null || rawPath.isEmpty()) {
            return """";
        }
        return rawPath.endsWith(JAR_PATH_SEPARATOR) ? rawPath
                : rawPath + JAR_PATH_SEPARATOR;
    }",0
"@Override
    public void setAccountManagementDisabled(ComponentName who, String accountType,
            boolean disabled, boolean parent) {
        if (!mHasFeature) {
            return;
        }
        Objects.requireNonNull(who, ""ComponentName is null"");
        enforceMaxStringLength(accountType, ""account type"");

        final CallerIdentity caller = getCallerIdentity(who);
        synchronized (getLockObject()) {
            /*
             * When called on the parent DPM instance (parent == true), affects active admin
             * selection in two ways:
             * * The ActiveAdmin must be of an org-owned profile owner.
             * * The parent ActiveAdmin instance should be used for managing the restriction.
             */
            final ActiveAdmin ap;
            if (parent) {
                ap = getParentOfAdminIfRequired(getOrganizationOwnedProfileOwnerLocked(caller),
                        parent);
            } else {
                ap = getParentOfAdminIfRequired(getProfileOwnerOrDeviceOwnerLocked(caller), parent);
            }

            if (disabled) {
                ap.accountTypesWithManagementDisabled.add(accountType);
            } else {
                ap.accountTypesWithManagementDisabled.remove(accountType);
            }
            saveSettingsLocked(UserHandle.getCallingUserId());
        }
    }",1
"public String upload(MultipartFile file, String fileName) {

        //构造一个带指定Zone对象的配置类，注意这里需要根据自己的选择的存储区域来选择对应的Zone对象
        Configuration cfg = new Configuration(Zone.zone0());
        //...其他参数参考类注释
        UploadManager uploadManager = new UploadManager(cfg);
        //默认不指定key的情况下，以文件内容的hash值作为文件名
        String key = null;
        Auth auth = Auth.create(ACCESS_KEY, SECRET_KEY);
        String upToken = auth.uploadToken(BUCKET);
        try {
            Response response = null;

            response = uploadManager.put(file.getInputStream(), fileName, upToken, null, null);

            //解析上传成功的结果
            DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);
            return putRet.key;
        } catch (QiniuException ex) {
            Response r = ex.response;
            LOGGER.error(r.toString());
            throw BusinessException.withErrorCode(ErrorConstant.Att.UPLOAD_FILE_FAIL).withErrorMessageArguments(ex.getMessage());
        } catch (IOException e) {
            LOGGER.error(""file upload failed"", e);
            throw BusinessException.withErrorCode(ErrorConstant.Att.UPLOAD_FILE_FAIL).withErrorMessageArguments(e.getMessage());
        }
        
    }",1
"public Iterable<DependencyFilter> getDependencyFilters() {
        return dependencyFilters;
    }",0
"public static String sanitizeString(String raw, boolean allowHTML)
    {
        if (raw==null || raw.length()==0) {
            return raw;
        }

        Matcher scriptMatcher = scriptPattern.matcher(raw);
        String next = scriptMatcher.replaceAll(""&#x73;cript"");

        Matcher imgOnErrorMatcher = imgOnErrorPattern.matcher(next);
        next = imgOnErrorMatcher.replaceAll(""$1&#x6f;$2"");

        if (!allowHTML) {
            next = next.replaceAll(""<"", ""&lt;"").replaceAll("">"", ""&gt;"").replaceAll(""\"""", ""&quot;"");
        }
        return next;
    }",1
"@Override
    public void onStart() {
        super.onStart();
        if (this.reInitRequiredOnStart && this.conversation != null) {
            final Bundle extras = pendingExtras.pop();
            reInit(this.conversation, extras != null);
            if (extras != null) {
                processExtras(extras);
            }
        } else if (conversation == null && activity != null && activity.xmppConnectionService != null) {
            final String uuid = pendingConversationsUuid.pop();
            Log.d(Config.LOGTAG, ""ConversationFragment.onStart() - activity was bound but no conversation loaded. uuid="" + uuid);
            if (uuid != null) {
                findAndReInitByUuidOrArchive(uuid);
            }
        }
    }",0
"public AwTestContainerView createAwTestContainerView(AwTestRunnerActivity activity,
                boolean allowHardwareAcceleration) {
            return new AwTestContainerView(activity, allowHardwareAcceleration);
        }",0
"public void broadcastWpsFailEvent(String iface, int cfgError, int vendorErrorCode) {
        int reason = 0;
        switch(vendorErrorCode) {
            case REASON_TKIP_ONLY_PROHIBITED:
                sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_TKIP_ONLY_PROHIBITED);
                return;
            case REASON_WEP_PROHIBITED:
                sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_WEP_PROHIBITED);
                return;
            default:
                reason = vendorErrorCode;
                break;
        }
        switch(cfgError) {
            case CONFIG_AUTH_FAILURE:
                sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_AUTH_FAILURE);
                return;
            case CONFIG_MULTIPLE_PBC_DETECTED:
                sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_OVERLAP_ERROR);
                return;
            default:
                if (reason == 0) {
                    reason = cfgError;
                }
                break;
        }
        //For all other errors, return a generic internal error
        sendMessage(iface, WPS_FAIL_EVENT, WifiManager.ActionListener.FAILURE_INTERNAL_ERROR,
                reason);
    }",0
"@Override
    public void setIntegerLength(int minInt, int maxInt) {
        // Validation should happen outside of DecimalQuantity, e.g., in the Rounder class.
        assert minInt >= 0;
        assert maxInt >= minInt;

        // Special behavior: do not set minInt to be less than what is already set.
        // This is so significant digits rounding can set the integer length.
        if (minInt < lReqPos) {
            minInt = lReqPos;
        }

        // Save values into internal state
        // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE
        lOptPos = maxInt;
        lReqPos = minInt;
    }",0
"private String getMimeType(ParsedUri pParsedUri) {
        return MimeTypeUtil.getResponseMimeType(
            pParsedUri.getParameter(ConfigKey.MIME_TYPE.getKeyValue()),
            configuration.get(ConfigKey.MIME_TYPE),
            pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue()));
    }",1
"private void load(@NotNull Dependency dependency) throws LoadFailureException {
		try {
			classLoader.addURL(dragonfly.getDirectory().resolve(dependency.getFileName()).toUri().toURL());
		} catch (MalformedURLException ex) {
			throw new LoadFailureException(ex);
		}
	}",1
"@Override
    public List<String> searchDocumentsNames(String wheresql, int nb, int start, XWikiContext context)
        throws XWikiException
    {
        return searchDocumentsNames(wheresql, nb, start, """", context);
    }",0
"@Override
    public Optional<CorsOriginConfiguration> convert(Object object, Class<CorsOriginConfiguration> targetType, ConversionContext context) {
        CorsOriginConfiguration configuration = new CorsOriginConfiguration();
        if (object instanceof Map) {
            Map mapConfig = (Map) object;
            ConvertibleValues<Object> convertibleValues = new ConvertibleValuesMap<>(mapConfig);

            convertibleValues
                .get(ALLOWED_ORIGINS, ConversionContext.LIST_OF_STRING)
                .ifPresent(configuration::setAllowedOrigins);

            convertibleValues
                .get(ALLOWED_METHODS, CONVERSION_CONTEXT_LIST_OF_HTTP_METHOD)
                .ifPresent(configuration::setAllowedMethods);

            convertibleValues
                .get(ALLOWED_HEADERS, ConversionContext.LIST_OF_STRING)
                .ifPresent(configuration::setAllowedHeaders);

            convertibleValues
                .get(EXPOSED_HEADERS, ConversionContext.LIST_OF_STRING)
                .ifPresent(configuration::setExposedHeaders);

            convertibleValues
                .get(ALLOW_CREDENTIALS, ConversionContext.BOOLEAN)
                .ifPresent(configuration::setAllowCredentials);

            convertibleValues
                .get(MAX_AGE, ConversionContext.LONG)
                .ifPresent(configuration::setMaxAge);
        }
        return Optional.of(configuration);
    }",1
"public static boolean copyResource(File file, String filename, File targetDirectory, PathMatcher filter) {
		try {
			Path path = getResource(file, filename);
			if(path == null) {
				return false;
			}
			
			Path destDir = targetDirectory.toPath();
			Files.walkFileTree(path, EnumSet.noneOf(FileVisitOption.class), 24, new CopyVisitor(path, destDir, filter));
			PathUtils.closeSubsequentFS(path);
			return true;
		} catch (IOException e) {
			log.error("""", e);
			return false;
		}
	}",1
"private void resetConfigSetting(int mode, String prefix) {
        if (DEBUG) {
            Slog.v(LOG_TAG, ""resetConfigSetting("" + mode + "", "" + prefix + "")"");
        }
        mutateConfigSetting(null, null, prefix, false,
                MUTATION_OPERATION_RESET, mode);
    }",0
"public boolean checkPassword(String password, int userId) throws RequestThrottledException {
        throwIfCalledOnMainThread();
        try {
            VerifyCredentialResponse response =
                    getLockSettings().checkPassword(password, userId);
            if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) {
                return true;
            } else if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_RETRY) {
                throw new RequestThrottledException(response.getTimeout());
            } else {
                return false;
            }
        } catch (RemoteException re) {
            return false;
        }
    }",1
"@Override
    public void setManagedSubscriptionsPolicy(ManagedSubscriptionsPolicy policy) {
        CallerIdentity caller = getCallerIdentity();

        if (!isCallerDevicePolicyManagementRoleHolder(caller)
                && !Objects.equals(mInjector.settingsGlobalGetString(
                        Global.ALLOW_WORK_PROFILE_TELEPHONY_FOR_NON_DPM_ROLE_HOLDERS), ""1"")) {
            throw new UnsupportedOperationException(""This api is not enabled"");
        }

        Preconditions.checkCallAuthorization(isProfileOwnerOfOrganizationOwnedDevice(caller),
                ""This policy can only be set by a profile owner on an organization-owned ""
                        + ""device."");

        int parentUserId = getProfileParentId(caller.getUserId());
        synchronized (getLockObject()) {
            final ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());
            if (hasUserSetupCompleted(parentUserId) && !isAdminTestOnlyLocked(
                    admin.info.getComponent(), caller.getUserId())) {
                throw new IllegalStateException(""Not allowed to apply this policy after setup"");
            }
            boolean changed = false;
            if (!Objects.equals(policy, admin.mManagedSubscriptionsPolicy)) {
                admin.mManagedSubscriptionsPolicy = policy;
                changed = true;
            }
            if (changed) {
                saveSettingsLocked(caller.getUserId());
            } else {
                return;
            }
        }

        applyManagedSubscriptionsPolicyIfRequired();

        int policyType = getManagedSubscriptionsPolicy().getPolicyType();
        final long id = mInjector.binderClearCallingIdentity();
        try {
            if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_MANAGED_SUBSCRIPTIONS) {
                installOemDefaultDialerAndSmsApp(caller.getUserId());
                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), true);
            } else if (policyType == ManagedSubscriptionsPolicy.TYPE_ALL_PERSONAL_SUBSCRIPTIONS) {
                updateTelephonyCrossProfileIntentFilters(parentUserId, caller.getUserId(), false);
            }
        } finally {
            mInjector.binderRestoreCallingIdentity(id);
        }
    }",0
public int getProcessLimit() throws RemoteException;,0
"public void updateSessionParameters(long timeoutMillis, long revokeAfterKilledDelayMillis) {
            synchronized (mInnerLock) {
                mTimeout = Math.min(mTimeout, timeoutMillis);
                mRevokeAfterKilledDelay = Math.min(mRevokeAfterKilledDelay,
                        revokeAfterKilledDelayMillis == -1
                                ? DeviceConfig.getLong(
                                DeviceConfig.NAMESPACE_PERMISSIONS,
                                PROPERTY_KILLED_DELAY_CONFIG_KEY, DEFAULT_KILLED_DELAY_MILLIS)
                                : revokeAfterKilledDelayMillis);
                Log.v(LOG_TAG,
                        ""Updated params for "" + mPackageName + "". timeout="" + mTimeout
                                + "" killedDelay="" + mRevokeAfterKilledDelay);
                updateUidState();
            }
        }",1
"private static void unimplemented(AsyncMethodCallback resultHandler) {
        resultHandler.onError(new CentralDogmaException(ErrorCode.UNIMPLEMENTED));
    }",0
"<T> List<T> search(String userSearchFilter, String[] filterArgs, Mapper<T> mapper, int maxResult);",1
"public ApiClient addDefaultHeader(String key, String value) {
    defaultHeaderMap.put(key, value);
    return this;
  }",0
"public Builder setMinIntervalMillis(Integer minIntervalMillis) {
            this.minIntervalMillis = minIntervalMillis;
            return this;
        }",0
"private Collection<Long> getSubtreeIds(Long projectId) {
		Collection<Long> treeIds = Sets.newHashSet(projectId);
		for (ProjectFacade facade: cache.values()) {
			if (projectId.equals(facade.getParentId()))
				treeIds.addAll(getSubtreeIds(facade.getId()));
		}
		return treeIds;
	}",0
"@Override
        public String toXML() throws Exception {

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.newDocument();

            Element element = toDOM(document);
            document.appendChild(element);

            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
            Transformer transformer = transformerFactory.newTransformer();
            transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
            transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""4"");

            DOMSource domSource = new DOMSource(document);
            StringWriter sw = new StringWriter();
            StreamResult streamResult = new StreamResult(sw);
            transformer.transform(domSource, streamResult);

            return sw.toString();
        }",1
"@CalledByNative
    private void onBackgroundColorChanged(int color) {
        getContentViewClient().onBackgroundColorChanged(color);
    }",0
"public static String renderNav(HttpServletRequest request, String activeNav) {
        try {
            return renderNav2(request, activeNav);
        } catch (Exception ex) {
            log.error(""Error on `renderNav`"", ex);
            return ""<!-- ERROR : "" + ThrowableUtils.getRootCause(ex).getLocalizedMessage() + "" -->"";
        }
    }",0
"public OidcConfiguration getConfiguration() {
        return configuration;
    }",0
"@ResponseBody
    @RequestMapping(""/machine"")
    public Result<?> receiveHeartBeat(String app,
                                      @RequestParam(value = ""app_type"", required = false, defaultValue = ""0"")
                                          Integer appType, Long version, String v, String hostname, String ip,
                                      Integer port) {
        if (StringUtil.isBlank(app) || app.length() > 256) {
            return Result.ofFail(-1, ""invalid appName"");
        }
        if (StringUtil.isBlank(ip) || ip.length() > 128) {
            return Result.ofFail(-1, ""invalid ip: "" + ip);
        }
        if (!IPAddressUtil.isIPv4LiteralAddress(ip) && !IPAddressUtil.isIPv6LiteralAddress(ip)) {
            return Result.ofFail(-1, ""invalid ip: "" + ip);
        }
        if (port == null || port < -1) {
            return Result.ofFail(-1, ""invalid port"");
        }
        if (hostname != null && hostname.length() > 256) {
            return Result.ofFail(-1, ""hostname too long"");
        }
        if (port == -1) {
            logger.warn(""Receive heartbeat from "" + ip + "" but port not set yet"");
            return Result.ofFail(-1, ""your port not set yet"");
        }
        String sentinelVersion = StringUtil.isBlank(v) ? ""unknown"" : v;

        version = version == null ? System.currentTimeMillis() : version;
        try {
            MachineInfo machineInfo = new MachineInfo();
            machineInfo.setApp(app);
            machineInfo.setAppType(appType);
            machineInfo.setHostname(hostname);
            machineInfo.setIp(ip);
            machineInfo.setPort(port);
            machineInfo.setHeartbeatVersion(version);
            machineInfo.setLastHeartbeat(System.currentTimeMillis());
            machineInfo.setVersion(sentinelVersion);
            appManagement.addMachine(machineInfo);
            return Result.ofSuccessMsg(""success"");
        } catch (Exception e) {
            logger.error(""Receive heartbeat error"", e);
            return Result.ofFail(-1, e.getMessage());
        }
    }",1
"private static void addExtraKexAlgorithms(CryptoWishList cwl) {
		String[] oldKexAlgorithms = cwl.kexAlgorithms;
		List<String> kexAlgorithms = new ArrayList<>(oldKexAlgorithms.length + 2);
		for (String algo : oldKexAlgorithms)
		{
			if (!algo.equals(EXT_INFO_C) && !algo.equals(KEX_STRICT_C_OPENSSH))
				kexAlgorithms.add(algo);
		}
		kexAlgorithms.add(EXT_INFO_C);
		kexAlgorithms.add(KEX_STRICT_C_OPENSSH);
		cwl.kexAlgorithms = kexAlgorithms.toArray(new String[0]);
	}",1
"private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType,
            int callingUid, int[] users) {
        List<ResolveInfo> receivers = null;
        try {
            HashSet<ComponentName> singleUserReceivers = null;
            boolean scannedFirstReceivers = false;
            for (int user : users) {
                // Skip users that have Shell restrictions
                if (callingUid == Process.SHELL_UID
                        && getUserManagerLocked().hasUserRestriction(
                                UserManager.DISALLOW_DEBUGGING_FEATURES, user)) {
                    continue;
                }
                List<ResolveInfo> newReceivers = AppGlobals.getPackageManager()
                        .queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);
                if (user != UserHandle.USER_OWNER && newReceivers != null) {
                    // If this is not the primary user, we need to check for
                    // any receivers that should be filtered out.
                    for (int i=0; i<newReceivers.size(); i++) {
                        ResolveInfo ri = newReceivers.get(i);
                        if ((ri.activityInfo.flags&ActivityInfo.FLAG_PRIMARY_USER_ONLY) != 0) {
                            newReceivers.remove(i);
                            i--;
                        }
                    }
                }
                if (newReceivers != null && newReceivers.size() == 0) {
                    newReceivers = null;
                }
                if (receivers == null) {
                    receivers = newReceivers;
                } else if (newReceivers != null) {
                    // We need to concatenate the additional receivers
                    // found with what we have do far.  This would be easy,
                    // but we also need to de-dup any receivers that are
                    // singleUser.
                    if (!scannedFirstReceivers) {
                        // Collect any single user receivers we had already retrieved.
                        scannedFirstReceivers = true;
                        for (int i=0; i<receivers.size(); i++) {
                            ResolveInfo ri = receivers.get(i);
                            if ((ri.activityInfo.flags&ActivityInfo.FLAG_SINGLE_USER) != 0) {
                                ComponentName cn = new ComponentName(
                                        ri.activityInfo.packageName, ri.activityInfo.name);
                                if (singleUserReceivers == null) {
                                    singleUserReceivers = new HashSet<ComponentName>();
                                }
                                singleUserReceivers.add(cn);
                            }
                        }
                    }
                    // Add the new results to the existing results, tracking
                    // and de-dupping single user receivers.
                    for (int i=0; i<newReceivers.size(); i++) {
                        ResolveInfo ri = newReceivers.get(i);
                        if ((ri.activityInfo.flags&ActivityInfo.FLAG_SINGLE_USER) != 0) {
                            ComponentName cn = new ComponentName(
                                    ri.activityInfo.packageName, ri.activityInfo.name);
                            if (singleUserReceivers == null) {
                                singleUserReceivers = new HashSet<ComponentName>();
                            }
                            if (!singleUserReceivers.contains(cn)) {
                                singleUserReceivers.add(cn);
                                receivers.add(ri);
                            }
                        } else {
                            receivers.add(ri);
                        }
                    }
                }
            }
        } catch (RemoteException ex) {
            // pm is in same process, this will never happen.
        }
        return receivers;
    }",0
"@Override
    public void push(String projectName, String repositoryName, Revision baseRevision, Author author,
                     String summary, Comment detail, List<Change> changes, AsyncMethodCallback resultHandler) {
        final List<com.linecorp.centraldogma.common.Change<?>> convertedChanges =
                convert(changes, Converter::convert);
        try {
            checkMirrorLocalRepo(repositoryName, convertedChanges);
        } catch (Exception e) {
            resultHandler.onError(e);
            return;
        }
        // TODO(trustin): Change Repository.commit() to return a Commit.
        handle(executor.execute(Command.push(convert(author), projectName, repositoryName,
                                             convert(baseRevision), summary, detail.getContent(),
                                             convert(detail.getMarkup()), convertedChanges))
                       .thenCompose(commitResult -> {
                           final com.linecorp.centraldogma.common.Revision newRev = commitResult.revision();
                           return projectManager.get(projectName).repos().get(repositoryName)
                                                .history(newRev, newRev, ""/**"");
                       })
                       .thenApply(commits -> convert(commits.get(0))),
               resultHandler);
    }",1
"public String tag() {
        if (getPara(0) != null) {
            String tag = convertRequestParam(getPara(0));
            setPageInfo(Constants.getArticleUri() + ""tag/"" + getPara(0) + ""-"", new Log().findByTag(getParaToInt(1, 1), getDefaultRows(), tag), getParaToInt(1, 1));

            setAttr(""tipsType"", I18nUtil.getStringFromRes(""tag""));
            setAttr(""tipsName"", tag);
        }
        return ""page"";
    }",0
"private void encryptionAtRestXmlGenerator(XmlGenerator gen, EncryptionAtRestConfig encryptionAtRestConfig) {
        if (encryptionAtRestConfig == null) {
            gen.node(""encryption-at-rest"", ""enabled"", ""false"");
            return;
        }
        gen.open(""encryption-at-rest"", ""enabled"", encryptionAtRestConfig.isEnabled())
                .node(""key-size"", encryptionAtRestConfig.getKeySize());
        commonSymmetricEncInterceptorConfigXmlBodyGenerator(gen, encryptionAtRestConfig);
        secureStoreXmlGenerator(gen, encryptionAtRestConfig.getSecureStoreConfig());
        gen.close();
    }",0
"public String getLabel() {
    return HtmlSanitizer.get().sanitize(label);
  }",1
"public SSLContext getSSLContext(boolean acceptAnyCertificate) throws GeneralSecurityException, IOException {
        return acceptAnyCertificate? looseTrustManagerSSLContext: SSLContext.getDefault();
    }",1
"public NodeDescriptor getDescriptor() {
        return DescriptorImpl.INSTANCE;
    }",0
"public GroupMapping getGroupMapping()
    {
        List<String> groupsMapping = getProperty(PROP_GROUPS_MAPPING, List.class);

        GroupMapping groups;

        if (groupsMapping != null && !groupsMapping.isEmpty()) {
            groups = new GroupMapping(groupsMapping.size());

            for (String groupMapping : groupsMapping) {
                int index = groupMapping.indexOf('=');

                if (index != -1) {
                    String xwikiGroup = toXWikiGroup(groupMapping.substring(0, index));
                    String providerGroup = groupMapping.substring(index + 1);

                    // Add to XWiki mapping
                    Set<String> providerGroups = groups.xwikiMapping.computeIfAbsent(xwikiGroup, k -> new HashSet<>());
                    providerGroups.add(providerGroup);

                    // Add to provider mapping
                    Set<String> xwikiGroups =
                        groups.providerMapping.computeIfAbsent(providerGroup, k -> new HashSet<>());
                    xwikiGroups.add(xwikiGroup);
                }
            }
        } else {
            groups = null;
        }

        return groups;
    }",0
"public boolean checkUserPassword(String userId, String password) {
        if (StringUtils.isBlank(userId)) {
            MSException.throwException(Translator.get(""user_name_is_null""));
        }
        if (StringUtils.isBlank(password)) {
            MSException.throwException(Translator.get(""password_is_null""));
        }
        if (userId.length() > 64) {
            MSException.throwException(Translator.get(""user_id_length_too_long""));
        }
        if (password.length() > 30) {
            MSException.throwException(Translator.get(""password_length_too_long""));
        }
        UserExample example = new UserExample();
        example.createCriteria().andIdEqualTo(userId).andPasswordEqualTo(CodingUtil.md5(password));
        return userMapper.countByExample(example) > 0;
    }",1
"protected void engineSetSeed(byte[] bytes)
        {
            random.setSeed(bytes);
        }",1
"@ApiOperation(value = ""Validate Composite Solution"")
	@RequestMapping(value = ""/validateCompositeSolution"", method = RequestMethod.POST, produces = ""text/plain"")
	@ResponseBody
	public String validateCompositeSolution(@RequestParam(value = ""userId"", required = true) String userId,
			@RequestParam(value = ""solutionName"", required = true) String solutionName,
			@RequestParam(value = ""solutionId"", required = true) String solutionId,
			@RequestParam(value = ""version"", required = true) String version) {
		logger.debug(EELFLoggerDelegator.debugLogger, ""validateCompositeSolution() : Begin "");
		String result = """";
		try {
			result = compositeServiceImpl.validateCompositeSolution(userId, solutionName, SanitizeUtils.sanitize(solutionId), version);
			result = String.format(result);
		} catch (Exception e) {
			result = ""{\""success\"" : \""false\"", \""errorDescription\"" : \""Failed to Validate Composite Solution\""}"";
			result = String.format(result);
			logger.debug(EELFLoggerDelegator.errorLogger, "" Exception in validateCompositeSolution() "", e);
			e.printStackTrace();
		}
		logger.debug(EELFLoggerDelegator.debugLogger, ""validateCompositeSolution() : End "");
		return result;
	}",1
"private PdfArray findOrphanPages() {
        PdfArray pages = new PdfArray();
        for (int idx = 0; idx < xrefObj.size(); ++idx) {
            PdfObject obj = getPdfObject(idx);
            if (obj == null || !obj.isDictionary()) continue;
            PdfDictionary dict = (PdfDictionary)(obj);
            if (!PdfName.PAGE.equals(dict.get(PdfName.TYPE))) continue;
            pages.add(new PRIndirectReference(this, idx));
        }
        return pages;
    }",0
"public void enableServiceAccount(ClientModel client) {
        client.setServiceAccountsEnabled(true);

        // Add dedicated user for this service account
        if (realmManager.getSession().users().getServiceAccount(client) == null) {
            String username = ServiceAccountConstants.SERVICE_ACCOUNT_USER_PREFIX + client.getClientId();
            logger.debugf(""Creating service account user '%s'"", username);

            // Don't use federation for service account user
            UserModel user = realmManager.getSession().userLocalStorage().addUser(client.getRealm(), username);
            user.setEnabled(true);
            user.setServiceAccountClientLink(client.getId());
        }

        // Add protocol mappers to retrieve clientId in access token
        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER) == null) {
            logger.debugf(""Creating service account protocol mapper '%s' for client '%s'"", ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER, client.getClientId());
            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER,
                    ServiceAccountConstants.CLIENT_ID,
                    ServiceAccountConstants.CLIENT_ID, ""String"",
                    true, true);
            client.addProtocolMapper(protocolMapper);
        }

        // Add protocol mappers to retrieve hostname and IP address of client in access token
        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER) == null) {
            logger.debugf(""Creating service account protocol mapper '%s' for client '%s'"", ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER, client.getClientId());
            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER,
                    ServiceAccountConstants.CLIENT_HOST,
                    ServiceAccountConstants.CLIENT_HOST, ""String"",
                    true, true);
            client.addProtocolMapper(protocolMapper);
        }

        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER) == null) {
            logger.debugf(""Creating service account protocol mapper '%s' for client '%s'"", ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER, client.getClientId());
            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER,
                    ServiceAccountConstants.CLIENT_ADDRESS,
                    ServiceAccountConstants.CLIENT_ADDRESS, ""String"",
                    true, true);
            client.addProtocolMapper(protocolMapper);
        }
    }",1
"private void updateAudioOutputButton(MagicAudioManager.AudioDevice activeAudioDevice) {
        switch (activeAudioDevice) {
            case BLUETOOTH:
                binding.audioOutputButton.getHierarchy().setPlaceholderImage(
                    AppCompatResources.getDrawable(context, R.drawable.ic_baseline_bluetooth_audio_24));
                break;
            case SPEAKER_PHONE:
                binding.audioOutputButton.getHierarchy().setPlaceholderImage(
                    AppCompatResources.getDrawable(context, R.drawable.ic_volume_up_white_24dp));
                break;
            case EARPIECE:
                binding.audioOutputButton.getHierarchy().setPlaceholderImage(
                    AppCompatResources.getDrawable(context, R.drawable.ic_baseline_phone_in_talk_24));
                break;
            case WIRED_HEADSET:
                binding.audioOutputButton.getHierarchy().setPlaceholderImage(
                    AppCompatResources.getDrawable(context, R.drawable.ic_baseline_headset_mic_24));
                break;
            default:
                Log.e(TAG, ""Icon for audio output not available"");
                break;
        }
        DrawableCompat.setTint(binding.audioOutputButton.getDrawable(), Color.WHITE);
    }",0
"@SuppressWarnings(""resource"")
    protected byte[] _finishBytes(int len) throws IOException
    {
        // Chunked?
        // First, simple: non-chunked
        if (len <= 0) {
            if (len == 0) {
                return NO_BYTES;
            }
            return _finishChunkedBytes();
        }
        // Non-chunked, contiguous
        if (len > LONGEST_NON_CHUNKED_BINARY) {
            // [dataformats-binary#186]: avoid immediate allocation for longest
            return _finishLongContiguousBytes(len);
        }

        final byte[] b = new byte[len];
        final int expLen = len;
        if (_inputPtr >= _inputEnd) {
            if (!loadMore()) {
                _reportIncompleteBinaryRead(expLen, 0);
            }
        }

        int ptr = 0;
        while (true) {
            int toAdd = Math.min(len, _inputEnd - _inputPtr);
            System.arraycopy(_inputBuffer, _inputPtr, b, ptr, toAdd);
            _inputPtr += toAdd;
            ptr += toAdd;
            len -= toAdd;
            if (len <= 0) {
                return b;
            }
            if (!loadMore()) {
                _reportIncompleteBinaryRead(expLen, ptr);
            }
        }
    }",1
"private int getAggregatedPasswordComplexityLocked(@UserIdInt int userHandle) {
        return getAggregatedPasswordComplexityLocked(userHandle, false);
    }",0
"public static XMLBuilder2 parse(InputSource inputSource)
    {
        return XMLBuilder2.parse(inputSource, false);
    }",1
"public String getEmailFromAddress() {
		return myModelConfig.getEmailFromAddress();
	}",0
"private static String dumpHex(byte[] data) {
        final int n = data.length;
        final StringBuilder sb = new StringBuilder(n * 3 - 1);
        for (int i = 0; i < n; i++) {
            if (i > 0) {
                sb.append(' ');
            }
            sb.append(HEX_CHARS[(data[i] >> 4) & 0x0F]);
            sb.append(HEX_CHARS[data[i] & 0x0F]);
        }
        return sb.toString();
    }",0
"private java.nio.file.Path ensureFileIsAllowed(String fileName, SecurityContext securityContext) {
        final java.nio.file.Path etcFolderNormalized = etcFolder.normalize();
        final java.nio.file.Path fileNormalized = etcFolder.resolve(fileName).normalize();

        if (fileNormalized.equals(USERS_XML) && !securityContext.isUserInRole(Authentication.ROLE_ADMIN)) {
            throw new ForbiddenException(""ADMIN role is required for accessing users.xml file contents."");
        }

        if (!(fileNormalized.getNameCount() > etcFolderNormalized.getNameCount() && fileNormalized.startsWith(etcFolderNormalized))) {
            throw new BadRequestException(""Cannot access files outside of folder! Filename given: "" + fileName);
        }
        if (!SUPPORTED_FILE_EXTENSIONS.contains(FilenameUtils.getExtension(fileNormalized.getFileName().toString()))) {
            throw new BadRequestException(""Unsupported file extension: "" + fileName);
        }
        return fileNormalized;
    }",1
"@Override
	public Object unmarshal(Source source, MimeContainer mimeContainer) throws XmlMappingException {
		source = processSource(source);

		try {
			Unmarshaller unmarshaller = createUnmarshaller();
			if (this.mtomEnabled && mimeContainer != null) {
				unmarshaller.setAttachmentUnmarshaller(new Jaxb2AttachmentUnmarshaller(mimeContainer));
			}
			if (StaxUtils.isStaxSource(source)) {
				return unmarshalStaxSource(unmarshaller, source);
			}
			else if (this.mappedClass != null) {
				return unmarshaller.unmarshal(source, this.mappedClass).getValue();
			}
			else {
				return unmarshaller.unmarshal(source);
			}
		}
		catch (JAXBException ex) {
			throw convertJaxbException(ex);
		}
	}",1
"public void jumpTask(String procInsId, String targetTaskDefinitionKey, Map<String, Object> variables) {
		jumpTask(getCurrentTask(procInsId), targetTaskDefinitionKey, variables);
	}",0
"@SneakyThrows
    public void migrate(String tenantKey) {
        final StopWatch stopWatch = createStarted();
        try {
            log.info(""START - SETUP:CreateTenant:liquibase tenantKey: {}"", tenantKey);
            assertTenantKeyValid(tenantKey);
            SpringLiquibase liquibase = new SpringLiquibase();
            liquibase.setResourceLoader(resourceLoader);
            liquibase.setDataSource(dataSource);
            liquibase.setChangeLog(CHANGE_LOG_PATH);
            liquibase.setContexts(liquibaseProperties.getContexts());
            liquibase.setDefaultSchema(tenantKey);
            liquibase.setDropFirst(liquibaseProperties.isDropFirst());
            liquibase.setChangeLogParameters(DatabaseUtil.defaultParams(tenantKey));
            liquibase.setShouldRun(true);
            liquibase.afterPropertiesSet();
            log.info(""STOP  - SETUP:CreateTenant:liquibase tenantKey: {}, result: OK, time = {} ms"", tenantKey,
                stopWatch.getTime());
        } catch (Exception e) {
            log.info(""STOP  - SETUP:CreateTenant:liquibase tenantKey: {}, result: FAIL, error: {}, time = {} ms"",
                tenantKey, e.getMessage(), stopWatch.getTime());
            throw e;
        }
    }",1
"private void registerMessageListener() {
		// do not register multiple packet listeners
		if (mPacketListener != null)
			mXMPPConnection.removePacketListener(mPacketListener);

		PacketTypeFilter filter = new PacketTypeFilter(Message.class);

		mPacketListener = new PacketListener() {
			public void processPacket(Packet packet) {
				try {
				if (packet instanceof Message) {
					Message msg = (Message) packet;

					String[] fromJID = getJabberID(msg.getFrom());
					
					int direction = ChatConstants.INCOMING;
					Carbon cc = CarbonManager.getCarbon(msg);
					if (cc != null && !msg.getFrom().equalsIgnoreCase(mConfig.jabberID)) {
						Log.w(TAG, ""Received illegal carbon from "" + msg.getFrom() + "": "" + cc.toXML());
						cc = null;
					}

					// extract timestamp
					long ts;
					DelayInfo timestamp = (DelayInfo)msg.getExtension(""delay"", ""urn:xmpp:delay"");
					if (timestamp == null)
						timestamp = (DelayInfo)msg.getExtension(""x"", ""jabber:x:delay"");
					if (cc != null) // Carbon timestamp overrides packet timestamp
						timestamp = cc.getForwarded().getDelayInfo();
					if (timestamp != null)
						ts = timestamp.getStamp().getTime();
					else
						ts = System.currentTimeMillis();

					// try to extract a carbon
					if (cc != null) {
						Log.d(TAG, ""carbon: "" + cc.toXML());
						msg = (Message)cc.getForwarded().getForwardedPacket();

						// outgoing carbon: fromJID is actually chat peer's JID
						if (cc.getDirection() == Carbon.Direction.sent) {
							fromJID = getJabberID(msg.getTo());
							direction = ChatConstants.OUTGOING;
						} else {
							fromJID = getJabberID(msg.getFrom());

							// hook off carbonated delivery receipts
							DeliveryReceipt dr = (DeliveryReceipt)msg.getExtension(
									DeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE);
							if (dr != null) {
								Log.d(TAG, ""got CC'ed delivery receipt for "" + dr.getId());
								changeMessageDeliveryStatus(dr.getId(), ChatConstants.DS_ACKED);
							}
						}

						// ignore carbon copies of OTR messages sent by broken clients
						if (msg.getBody() != null && msg.getBody().startsWith(""?OTR"")) {
							Log.i(TAG, ""Ignoring OTR carbon from "" + msg.getFrom() + "" to "" + msg.getTo());
							return;
						}
					}

					// check for jabber MUC invitation
					if(direction == ChatConstants.INCOMING && handleMucInvitation(msg)) {
						sendReceiptIfRequested(packet);
						return;
					}

					String chatMessage = msg.getBody();

					// display error inline
					if (msg.getType() == Message.Type.error) {
						if (changeMessageDeliveryStatus(msg.getPacketID(), ChatConstants.DS_FAILED))
							mServiceCallBack.notifyMessage(fromJID, msg.getError().toString(), (cc != null), Message.Type.error);
						else if (mucJIDs.contains(msg.getFrom())) {
							handleKickedFromMUC(msg.getFrom(), false, null,
									msg.getError().toString());
						}
						return; // we do not want to add errors as ""incoming messages""
					}

					// ignore empty messages
					if (chatMessage == null) {
						if (msg.getSubject() != null && msg.getType() == Message.Type.groupchat
								&& mucJIDs.contains(fromJID[0])) {
							// this is a MUC subject, update our DB
							ContentValues cvR = new ContentValues();
							cvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, msg.getSubject());
							cvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());
							Log.d(TAG, ""MUC subject for "" + fromJID[0] + "" set to: "" + msg.getSubject());
							upsertRoster(cvR, fromJID[0]);
							return;
						}
						Log.d(TAG, ""empty message."");
						return;
					}

					// obtain Last Message Correction, if present
					Replace replace = (Replace)msg.getExtension(Replace.NAMESPACE);
					String replace_id = (replace != null) ? replace.getId() : null;

					// carbons are old. all others are new
					int is_new = (cc == null) ? ChatConstants.DS_NEW : ChatConstants.DS_SENT_OR_READ;
					if (msg.getType() == Message.Type.error)
						is_new = ChatConstants.DS_FAILED;

					boolean is_muc = (msg.getType() == Message.Type.groupchat);
					boolean is_from_me = (direction == ChatConstants.OUTGOING) ||
						(is_muc && fromJID[1].equals(getMyMucNick(fromJID[0])));

					// handle MUC-PMs: messages from a nick from a known MUC or with
					// an <x> element
					MUCUser muc_x = (MUCUser)msg.getExtension(""x"", ""http://jabber.org/protocol/muc#user"");
					boolean is_muc_pm = !is_muc  && !TextUtils.isEmpty(fromJID[1]) &&
							(muc_x != null || mucJIDs.contains(fromJID[0]));

					// TODO: ignoring 'received' MUC-PM carbons, until XSF sorts out shit:
					// - if yaxim is in the MUC, it will receive a non-carbonated copy of
					//   incoming messages, but not of outgoing ones
					// - if yaxim isn't in the MUC, it can't respond anyway
					if (is_muc_pm && !is_from_me && cc != null)
						return;

					if (is_muc_pm) {
						// store MUC-PMs under the participant's full JID, not bare
						//is_from_me = fromJID[1].equals(getMyMucNick(fromJID[0]));
						fromJID[0] = fromJID[0] + ""/"" + fromJID[1];
						fromJID[1] = null;
						Log.d(TAG, ""MUC-PM: "" + fromJID[0] + "" d="" + direction + "" fromme="" + is_from_me);
					}

					// Carbons and MUC history are 'silent' by default
					boolean is_silent = (cc != null) || (is_muc && timestamp != null);

					if (!is_muc || checkAddMucMessage(msg, msg.getPacketID(), fromJID, timestamp)) {
						addChatMessageToDB(direction, fromJID, chatMessage, is_new, ts, msg.getPacketID(), replace_id);
						// only notify on private messages or when MUC notification requested
						boolean need_notify = !is_muc || mConfig.needMucNotification(getMyMucNick(fromJID[0]), chatMessage);
						// outgoing carbon -> clear notification by signalling 'null' message
						if (is_from_me) {
							mServiceCallBack.notifyMessage(fromJID, null, true, msg.getType());
							// TODO: MUC PMs
							ChatHelper.markAsRead(mService, fromJID[0]);
						} else if (direction == ChatConstants.INCOMING && need_notify)
							mServiceCallBack.notifyMessage(fromJID, chatMessage, is_silent, msg.getType());
					}
					sendReceiptIfRequested(packet);
				}
				} catch (Exception e) {
					// SMACK silently discards exceptions dropped from processPacket :(
					Log.e(TAG, ""failed to process packet:"");
					e.printStackTrace();
				}
			}
		};

		mXMPPConnection.addPacketListener(mPacketListener, filter);
	}",1
"public void service() throws ONetworkProtocolException, IOException {
    ++connection.data.totalRequests;
    connection.data.commandInfo = null;
    connection.data.commandDetail = null;

    final String callbackF;
    if (OGlobalConfiguration.NETWORK_HTTP_JSONP_ENABLED.getValueAsBoolean() && request.parameters != null && request.parameters.containsKey(OHttpUtils.CALLBACK_PARAMETER_NAME))
      callbackF = request.parameters.get(OHttpUtils.CALLBACK_PARAMETER_NAME);
    else
      callbackF = null;

    response = new OHttpResponse(channel.outStream, request.httpVersion, additionalResponseHeaders, responseCharSet,
        connection.data.serverInfo, request.sessionId, callbackF, request.keepAlive, connection);
    response.setJsonErrorResponse(jsonResponseError);
    if (request.contentEncoding != null && request.contentEncoding.equals(OHttpUtils.CONTENT_ACCEPT_GZIP_ENCODED)) {
      response.setContentEncoding(OHttpUtils.CONTENT_ACCEPT_GZIP_ENCODED);
    }

    waitNodeIsOnline();

    final long begin = System.currentTimeMillis();

    boolean isChain;
    do {
      isChain = false;
      final String command;
      if (request.url.length() < 2) {
        command = """";
      } else {
        command = request.url.substring(1);
      }

      final String commandString = getCommandString(command);

      final OServerCommand cmd = (OServerCommand) cmdManager.getCommand(commandString);
      Map<String, String> requestParams = cmdManager.extractUrlTokens(commandString);
      if (requestParams != null) {
        if (request.parameters == null) {
          request.parameters = new HashMap<String, String>();
        }
        for (Map.Entry<String, String> entry : requestParams.entrySet()) {
          request.parameters.put(entry.getKey(), URLDecoder.decode(entry.getValue(), ""UTF-8""));
        }
      }

      if (cmd != null)
        try {
          if (cmd.beforeExecute(request, response))
            try {
              // EXECUTE THE COMMAND
              isChain = cmd.execute(request, response);
            } finally {
              cmd.afterExecute(request, response);
            }

        } catch (Exception e) {
          handleError(e);
        }
      else {
        try {
          OLogManager.instance().warn(
              this,
              ""->"" + channel.socket.getInetAddress().getHostAddress() + "": Command not found: "" + request.httpMethod + "".""
                  + URLDecoder.decode(command, ""UTF-8""));

          sendError(OHttpUtils.STATUS_INVALIDMETHOD_CODE, OHttpUtils.STATUS_INVALIDMETHOD_DESCRIPTION, null,
              OHttpUtils.CONTENT_TEXT_PLAIN, ""Command not found: "" + command, request.keepAlive);
        } catch (IOException e1) {
          sendShutdown();
        }
      }
    } while (isChain);

    connection.data.lastCommandInfo = connection.data.commandInfo;
    connection.data.lastCommandDetail = connection.data.commandDetail;

    connection.data.lastCommandExecutionTime = System.currentTimeMillis() - begin;
    connection.data.totalCommandExecutionTime += connection.data.lastCommandExecutionTime;
  }",1
"public byte[] loadFileAsBytes(FileOperationRequest fileOperationRequest) {
        if (fileOperationRequest.getId().contains(""/"") || fileOperationRequest.getName().contains(""/""))
            MSException.throwException(Translator.get(""invalid_parameter""));
        File file = new File(FileUtils.BODY_FILE_DIR + ""/"" + fileOperationRequest.getId() + ""_"" + fileOperationRequest.getName());
        try (FileInputStream fis = new FileInputStream(file);
             ByteArrayOutputStream bos = new ByteArrayOutputStream(1000);) {
            byte[] b = new byte[1000];
            int n;
            while ((n = fis.read(b)) != -1) {
                bos.write(b, 0, n);
            }
            return bos.toByteArray();
        } catch (Exception ex) {
            LogUtil.error(ex);
        }
        return null;
    }",1
"protected void loadMetadata(Context c, Item myitem, String path)
            throws SQLException, IOException, ParserConfigurationException,
            SAXException, TransformerException, AuthorizeException
    {
        // Load the dublin core metadata
        loadDublinCore(c, myitem, path + ""dublin_core.xml"");

        // Load any additional metadata schemas
        File folder = new File(path);
        File file[] = folder.listFiles(metadataFileFilter);
        for (int i = 0; i < file.length; i++)
        {
            loadDublinCore(c, myitem, file[i].getAbsolutePath());
        }
    }",0
"private void resetSingleSrcBuffer() {
        singleSrcBuffer[0] = null;
    }",0
"@Override
	public void registerUser(Account user){
		Driver driver = new SQLServerDriver();
		try {
			Connection con = driver.connect(connectionUrl, new Properties());
			PreparedStatement statement = con.prepareStatement(""Insert INTO UserTable (userName, userPassword, userEmail, userRole) ""
					+ ""VALUES (?, ?, ?, ?);"");
			statement.setString(1, user.getUsername());
			statement.setString(2, user.getPassword());
			statement.setString(3, user.getEmail());
			statement.setString(4, user.getRole().toString());
			statement.execute();
			System.out.println(""Registration Successful"");
		} catch (SQLException e) {
			if(e.getMessage().contains(""UNIQUE KEY"")){
				System.err.println(""User has already been registered."");
				throw new UsernameAlreadyExistsException();
			}
			else{
				e.printStackTrace();
			}
		}
	}",1
"private static void parseAction(final XmlPullParser parser, final HostAuth hostAuth)
            throws XmlPullParserException, IOException {
        while (true) {
            final int type = parser.next();
            if (type == XmlPullParser.END_TAG && parser.getName().equals(ELEMENT_NAME_ACTION)) {
                break;
            } else if (type == XmlPullParser.START_TAG) {
                final String name = parser.getName();
                if (name.equals(ELEMENT_NAME_ERROR)) {
                    // Should parse the error
                } else if (name.equals(ELEMENT_NAME_REDIRECT)) {
                    LogUtils.d(TAG, ""Redirect: "" + parser.nextText());
                } else if (name.equals(ELEMENT_NAME_SETTINGS)) {
                    parseSettings(parser, hostAuth);
                }
            }
        }
    }",0
"private boolean buildSourcesRaw(String filename) throws AndrolibException {
        File working = new File(mApkDir, filename);
        if (!working.exists()) {
            return false;
        }
        File stored = new File(mApkDir, APK_DIRNAME + ""/"" + filename);
        if (mConfig.forceBuildAll || isModified(working, stored)) {
            LOGGER.info(""Copying "" + mApkDir.toString() + "" "" + filename + "" file..."");
            try {
                BrutIO.copyAndClose(Files.newInputStream(working.toPath()), Files.newOutputStream(stored.toPath()));
                return true;
            } catch (IOException ex) {
                throw new AndrolibException(ex);
            }
        }
        return true;
    }",0
"public static SortDirection fromOptionalString(Optional<String> direction) {
        if (""DESC"".equalsIgnoreCase(direction.orElse(null))) {
            return DESC;
        }
        return ASC;
    }",1
"public void initialize(ViewGroup containerView, InternalAccessDelegate internalDispatcher,
            WebContents webContents, WindowAndroid windowAndroid) {
        createContentViewAndroidDelegate();
        setContainerView(containerView);
        long windowNativePointer = windowAndroid.getNativePointer();
        assert windowNativePointer != 0;
        createViewAndroid(windowAndroid);

        long viewAndroidNativePointer = mViewAndroid.getNativePointer();
        assert viewAndroidNativePointer != 0;

        mZoomControlsDelegate = NO_OP_ZOOM_CONTROLS_DELEGATE;

        mNativeContentViewCore = nativeInit(
                webContents, viewAndroidNativePointer, windowNativePointer,
                mRetainedJavaScriptObjects);
        mWebContents = nativeGetWebContentsAndroid(mNativeContentViewCore);
        mContentSettings = new ContentSettings(this, mNativeContentViewCore);

        setContainerViewInternals(internalDispatcher);
        mRenderCoordinates.reset();
        initPopupZoomer(mContext);
        mImeAdapter = createImeAdapter(mContext);
        attachImeAdapter();

        mAccessibilityInjector = AccessibilityInjector.newInstance(this);

        mWebContentsObserver = new WebContentsObserver(mWebContents) {
            @Override
            public void didFailLoad(boolean isProvisionalLoad, boolean isMainFrame, int errorCode,
                    String description, String failingUrl) {
                // Navigation that fails the provisional load will have the strong binding removed
                // here. One for which the provisional load is commited will have the strong binding
                // removed in navigationEntryCommitted() below.
                if (isProvisionalLoad) determinedProcessVisibility();
            }

            @Override
            public void didNavigateMainFrame(String url, String baseUrl,
                    boolean isNavigationToDifferentPage, boolean isFragmentNavigation) {
                if (!isNavigationToDifferentPage) return;
                hidePopupsAndClearSelection();
                resetScrollInProgress();
            }

            @Override
            public void renderProcessGone(boolean wasOomProtected) {
                hidePopupsAndClearSelection();
                resetScrollInProgress();
                // No need to reset gesture detection as the detector will have
                // been destroyed in the RenderWidgetHostView.
            }

            @Override
            public void navigationEntryCommitted() {
                determinedProcessVisibility();
            }

            private void determinedProcessVisibility() {
                // Signal to the process management logic that we can now rely on the process
                // visibility signal for binding management. Before the navigation commits, its
                // renderer is considered background even if the pending navigation happens in the
                // foreground renderer.
                ChildProcessLauncher.determinedVisibility(getCurrentRenderProcessId());
            }
        };
    }",1
"private void saveShortcutsAsync(
            @NonNull final Collection<ShortcutInfo> shortcuts) {
        Objects.requireNonNull(shortcuts);
        if (!isAppSearchEnabled() || shortcuts.isEmpty()) {
            // No need to invoke AppSearch when there's nothing to save.
            return;
        }
        if (ShortcutService.DEBUG_REBOOT) {
            Slog.d(TAG, ""Saving shortcuts async for user="" + mShortcutUser.getUserId()
                    + "" pkg="" + getPackageName() + "" ids="" + shortcuts.stream()
                    .map(ShortcutInfo::getId).collect(Collectors.joining("","", ""["", ""]"")));
        }
        runAsSystem(() -> fromAppSearch().thenAccept(session -> {
            if (shortcuts.isEmpty()) {
                return;
            }
            session.put(new PutDocumentsRequest.Builder()
                            .addGenericDocuments(
                                    AppSearchShortcutInfo.toGenericDocuments(shortcuts))
                            .build(),
                    mShortcutUser.mExecutor,
                    new BatchResultCallback<String, Void>() {
                        @Override
                        public void onResult(
                                @NonNull AppSearchBatchResult<String, Void> result) {
                            if (!result.isSuccess()) {
                                for (AppSearchResult<Void> k : result.getFailures().values()) {
                                    Slog.e(TAG, k.getErrorMessage());
                                }
                            }
                        }
                        @Override
                        public void onSystemError(@Nullable Throwable throwable) {
                            Slog.d(TAG, ""Error persisting shortcuts"", throwable);
                        }
                    });
        }));
    }",0
"public List<ActivityManager.RunningAppProcessInfo> getRunningAppProcesses() {
        enforceNotIsolatedCaller(""getRunningAppProcesses"");

        final int callingUid = Binder.getCallingUid();

        // Lazy instantiation of list
        List<ActivityManager.RunningAppProcessInfo> runList = null;
        final boolean allUsers = ActivityManager.checkUidPermission(INTERACT_ACROSS_USERS_FULL,
                callingUid) == PackageManager.PERMISSION_GRANTED;
        final int userId = UserHandle.getUserId(callingUid);
        final boolean allUids = isGetTasksAllowed(
                ""getRunningAppProcesses"", Binder.getCallingPid(), callingUid);

        synchronized (this) {
            // Iterate across all processes
            for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                ProcessRecord app = mLruProcesses.get(i);
                if ((!allUsers && app.userId != userId)
                        || (!allUids && app.uid != callingUid)) {
                    continue;
                }
                if ((app.thread != null) && (!app.crashing && !app.notResponding)) {
                    // Generate process state info for running application
                    ActivityManager.RunningAppProcessInfo currApp = 
                        new ActivityManager.RunningAppProcessInfo(app.processName,
                                app.pid, app.getPackageList());
                    fillInProcMemInfo(app, currApp);
                    if (app.adjSource instanceof ProcessRecord) {
                        currApp.importanceReasonPid = ((ProcessRecord)app.adjSource).pid;
                        currApp.importanceReasonImportance =
                                ActivityManager.RunningAppProcessInfo.procStateToImportance(
                                        app.adjSourceProcState);
                    } else if (app.adjSource instanceof ActivityRecord) {
                        ActivityRecord r = (ActivityRecord)app.adjSource;
                        if (r.app != null) currApp.importanceReasonPid = r.app.pid;
                    }
                    if (app.adjTarget instanceof ComponentName) {
                        currApp.importanceReasonComponent = (ComponentName)app.adjTarget;
                    }
                    //Slog.v(TAG, ""Proc "" + app.processName + "": imp="" + currApp.importance
                    //        + "" lru="" + currApp.lru);
                    if (runList == null) {
                        runList = new ArrayList<>();
                    }
                    runList.add(currApp);
                }
            }
        }
        return runList;
    }",1
"@Override
	public String getRequestPath() {
		return ApplicationInfo.cutPathPrefix(request.getPath().toString());
	}",1
"@Override
	public void onResume() {
		super.onResume();
	}",0
"@PostMapping(""comments"")
    @ApiOperation(""Comments a post"")
    @CacheLock(autoDelete = false, traceRequest = true)
    public BaseCommentDTO comment(@RequestBody PostCommentParam postCommentParam) {
        postCommentService.validateCommentBlackListStatus();

        // Escape content
        postCommentParam.setContent(HtmlUtils.htmlEscape(postCommentParam.getContent(), StandardCharsets.UTF_8.displayName()));
        return postCommentService.convertTo(postCommentService.createBy(postCommentParam));
    }",1
"public boolean allowAliasInStatements() {
        return false;
    }",0
"@Override
	public Post retrievePost(String postTitle){
		Post post = null;
		Driver driver = new SQLServerDriver();
		try {
			Connection con = driver.connect(connectionUrl, new Properties());
			PreparedStatement statement = con.prepareStatement(""Select postTitle, postAuthorId, postTime, postContent from PostTable where postTitle = '"" + postTitle + ""'"");
			ResultSet rs = statement.executeQuery();
			rs.next();
			post = new Post(rs.getString(""postTitle""), rs.getString(""postContent""), this.getUserName(rs.getInt(""postAuthorId"")));

		} catch (SQLException e) {
			e.printStackTrace();
		}	
		
		return post;
	}",1
"@Override
    public Review getByMovieIdAndUsername(int movieId, String username) {
        return find.where().and(Expr.eq(""movieId"", movieId), Expr.eq(""username"", username)).findUnique();
    }",1
"@LargeTest
    @Test
    public void testOutgoingVideoCallAnsweredAsAudio() throws Exception {
        IdPair ids = startOutgoingPhoneCall(""650-555-1212"", mPhoneAccountA0.getAccountHandle(),
                mConnectionServiceFixtureA, Process.myUserHandle(),
                VideoProfile.STATE_BIDIRECTIONAL, null);
        com.android.server.telecom.Call call = mTelecomSystem.getCallsManager().getCalls()
                .iterator().next();

        mConnectionServiceFixtureA.mConnectionById.get(ids.mConnectionId).videoState
                = VideoProfile.STATE_AUDIO_ONLY;
        mConnectionServiceFixtureA.sendSetVideoState(ids.mConnectionId);
        mConnectionServiceFixtureA.sendSetActive(ids.mConnectionId);

        assertFalse(VideoProfile.isVideo(call.getVideoStateHistory()));
    }",1
"public void setDetailsGenerator(DetailsGenerator<T> generator) {
        this.detailsManager.setDetailsGenerator(generator);
    }",0
"private AsymmetricCipherKeyPair genKeyPair()
    {
        if (!initialized)
        {
            initializeDefault();
        }

        // initialize authenticationPaths and treehash instances
        byte[][][] currentAuthPaths = new byte[numLayer][][];
        byte[][][] nextAuthPaths = new byte[numLayer - 1][][];
        Treehash[][] currentTreehash = new Treehash[numLayer][];
        Treehash[][] nextTreehash = new Treehash[numLayer - 1][];

        Vector[] currentStack = new Vector[numLayer];
        Vector[] nextStack = new Vector[numLayer - 1];

        Vector[][] currentRetain = new Vector[numLayer][];
        Vector[][] nextRetain = new Vector[numLayer - 1][];

        for (int i = 0; i < numLayer; i++)
        {
            currentAuthPaths[i] = new byte[heightOfTrees[i]][mdLength];
            currentTreehash[i] = new Treehash[heightOfTrees[i] - K[i]];

            if (i > 0)
            {
                nextAuthPaths[i - 1] = new byte[heightOfTrees[i]][mdLength];
                nextTreehash[i - 1] = new Treehash[heightOfTrees[i] - K[i]];
            }

            currentStack[i] = new Vector();
            if (i > 0)
            {
                nextStack[i - 1] = new Vector();
            }
        }

        // initialize roots
        byte[][] currentRoots = new byte[numLayer][mdLength];
        byte[][] nextRoots = new byte[numLayer - 1][mdLength];
        // initialize seeds
        byte[][] seeds = new byte[numLayer][mdLength];
        // initialize seeds[] by copying starting-seeds of first trees of each
        // layer
        for (int i = 0; i < numLayer; i++)
        {
            System.arraycopy(currentSeeds[i], 0, seeds[i], 0, mdLength);
        }

        // initialize rootSigs
        currentRootSigs = new byte[numLayer - 1][mdLength];

        // -------------------------
        // -------------------------
        // --- calculation of current authpaths and current rootsigs (AUTHPATHS,
        // SIG)------
        // from bottom up to the root
        for (int h = numLayer - 1; h >= 0; h--)
        {
            GMSSRootCalc tree;

            // on lowest layer no lower root is available, so just call
            // the method with null as first parameter
            if (h == numLayer - 1)
            {
                tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);
            }
            else
            // otherwise call the method with the former computed root
            // value
            {
                tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);
            }

            // set initial values needed for the private key construction
            for (int i = 0; i < heightOfTrees[h]; i++)
            {
                System.arraycopy(tree.getAuthPath()[i], 0, currentAuthPaths[h][i], 0, mdLength);
            }
            currentRetain[h] = tree.getRetain();
            currentTreehash[h] = tree.getTreehash();
            System.arraycopy(tree.getRoot(), 0, currentRoots[h], 0, mdLength);
        }

        // --- calculation of next authpaths and next roots (AUTHPATHS+, ROOTS+)
        // ------
        for (int h = numLayer - 2; h >= 0; h--)
        {
            GMSSRootCalc tree = this.generateNextAuthpathAndRoot(nextStack[h], seeds[h + 1], h + 1);

            // set initial values needed for the private key construction
            for (int i = 0; i < heightOfTrees[h + 1]; i++)
            {
                System.arraycopy(tree.getAuthPath()[i], 0, nextAuthPaths[h][i], 0, mdLength);
            }
            nextRetain[h] = tree.getRetain();
            nextTreehash[h] = tree.getTreehash();
            System.arraycopy(tree.getRoot(), 0, nextRoots[h], 0, mdLength);

            // create seed for the Merkle tree after next (nextNextSeeds)
            // SEEDs++
            System.arraycopy(seeds[h + 1], 0, this.nextNextSeeds[h], 0, mdLength);
        }
        // ------------

        // generate JDKGMSSPublicKey
        GMSSPublicKeyParameters publicKey = new GMSSPublicKeyParameters(currentRoots[0], gmssPS);

        // generate the JDKGMSSPrivateKey
        GMSSPrivateKeyParameters privateKey = new GMSSPrivateKeyParameters(currentSeeds, nextNextSeeds, currentAuthPaths,
            nextAuthPaths, currentTreehash, nextTreehash, currentStack, nextStack, currentRetain, nextRetain, nextRoots, currentRootSigs, gmssPS, digestProvider);

        // return the KeyPair
        return (new AsymmetricCipherKeyPair(publicKey, privateKey));
    }",1
"public String getAdType()
    {
        return this.xwiki.getAdType(getXWikiContext());
    }",0
"public static boolean jsFunction_removeSubscription(Context cx, Scriptable thisObj,
                                                        Object[] args, Function funObj)
            throws APIManagementException {
        if (args == null || args.length == 0) {
            handleException(""Invalid number of input parameters."");
        }
        String username = (String) args[0];
        int applicationId = ((Number) args[1]).intValue();
        NativeObject apiData = (NativeObject) args[2];
        String provider = APIUtil.replaceEmailDomain((String) apiData.get(""provider"", apiData));
        String name = (String) apiData.get(""apiName"", apiData);
        String version = (String) apiData.get(""version"", apiData);
        String groupId = null;
        if (args.length > 3 && args[3] != null) {
            groupId = (String) args[3];
        }
        APIIdentifier apiId = new APIIdentifier(provider, name, version);

        APIConsumer apiConsumer = getAPIConsumer(thisObj);
        boolean isTenantFlowStarted = false;

        try {
            String tenantDomain = MultitenantUtils.getTenantDomain(APIUtil.replaceEmailDomainBack(username));
            if (tenantDomain != null && !MultitenantConstants.SUPER_TENANT_DOMAIN_NAME.equals(tenantDomain)) {
                isTenantFlowStarted = true;
                PrivilegedCarbonContext.startTenantFlow();
                PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true);
            }
            apiConsumer.removeSubscription(apiId, username, applicationId, groupId);
            return true;
        } catch (APIManagementException e) {
            handleException(""Error while removing the subscription of"" + name + ""-"" + version, e);
            return false;
        } finally {
            if (isTenantFlowStarted) {
                PrivilegedCarbonContext.endTenantFlow();
            }
        }
    }",0
"@Deprecated
	public Long duplicateCheckCountSql(DuplicateCheckVo duplicateCheckVo);",0
"@Override
        public void registerScreenObserver(ScreenObserver observer) {
            mScreenObservers.add(observer);
        }",0
"public ContentProviderHolder getContentProvider(IApplicationThread caller,
            String name, int userId, boolean stable) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeString(name);
        data.writeInt(userId);
        data.writeInt(stable ? 1 : 0);
        mRemote.transact(GET_CONTENT_PROVIDER_TRANSACTION, data, reply, 0);
        reply.readException();
        int res = reply.readInt();
        ContentProviderHolder cph = null;
        if (res != 0) {
            cph = ContentProviderHolder.CREATOR.createFromParcel(reply);
        }
        data.recycle();
        reply.recycle();
        return cph;
    }",0
"public static <T extends Describable<T>>
    List<T> newInstancesFromHeteroList(StaplerRequest req, Object formData,
                Collection<? extends Descriptor<T>> descriptors) throws FormException {

        List<T> items = new ArrayList<T>();

        if (formData!=null) {
            for (Object o : JSONArray.fromObject(formData)) {
                JSONObject jo = (JSONObject)o;
                String kind = jo.getString(""kind"");
                Descriptor<T> d = find(descriptors, kind);
                if (d != null) {
                    items.add(d.newInstance(req, jo));
                }
            }
        }

        return items;
    }",1
"public static byte[] compress(String s, String encoding)
            throws UnsupportedEncodingException, IOException
    {
        byte[] data = s.getBytes(encoding);
        return compress(data);
    }",0
"@Override
    public UserInfo createUser(String name, int flags) {
        checkManageOrCreateUsersPermission(flags);
        return createUserInternal(name, flags, UserHandle.USER_NULL);
    }",1
"public void setColumnOrder(Column<T, ?>... columns) {
        setColumnOrder(Stream.of(columns));
    }",0
"public void privateMsgInMuc(Conversation conversation, String nick) {
		switchToConversation(conversation, null, false, nick, true, false);
	}",1
"static String getSubsetPrefix(PdfDictionary dic) {
        if (dic == null)
            return null;
        String s = getFontName(dic);
        if (s == null)
            return null;
        if (s.length() < 8 || s.charAt(6) != '+')
            return null;
        for (int k = 0; k < 6; ++k) {
            char c = s.charAt(k);
            if (c < 'A' || c > 'Z')
                return null;
        }
        return s;
    }",0
"public void addFlags(String flagSet) {
        StringBuilder sb = new StringBuilder();
        sb.append(flagSet);
        if (!flagSet.contains(""-oX"")) {
            sb.append("" -oX -"");
        }
        flags.addFlag(sb.toString());
    }",1
"@LargeTest
    @Test
    public void testIncomingVideoCallRejectedCheckVideoHistory() throws Exception {
        IdPair ids = startIncomingPhoneCall(""650-555-1212"", mPhoneAccountA0.getAccountHandle(),
                VideoProfile.STATE_BIDIRECTIONAL, mConnectionServiceFixtureA, null);
        com.android.server.telecom.Call call = mTelecomSystem.getCallsManager().getCalls()
                .iterator().next();

        mConnectionServiceFixtureA.sendSetDisconnected(ids.mConnectionId, DisconnectCause.REJECTED);

        assertTrue(VideoProfile.isVideo(call.getVideoStateHistory()));
    }",1
"public static byte[] FlateDecode(byte in[]) {
        byte b[] = FlateDecode(in, true);
        if (b == null)
            return FlateDecode(in, false);
        return b;
    }",0
"private void initDiscoveryMulticast(Configuration pConfig) {
        String url = findAgentUrl(pConfig);
        if (url != null || listenForDiscoveryMcRequests(pConfig)) {
            if (url == null) {
                initAgentUrlFromRequest = true;
            } else {
                initAgentUrlFromRequest = false;
                backendManager.getAgentDetails().updateAgentParameters(url, null);
            }
            try {
                discoveryMulticastResponder = new DiscoveryMulticastResponder(backendManager,restrictor,logHandler);
                discoveryMulticastResponder.start();
            } catch (IOException e) {
                logHandler.error(""Cannot start discovery multicast handler: "" + e,e);
            }
        }
    }",0
"@Override
        public void setEncoding(String encoding) {
            fEncoding = encoding;
        }",0
"@VisibleForTesting
    boolean isCallingAppPermitted(String permission, int callerUid) {
        return TextUtils.isEmpty(permission)
                || checkPermission(permission, /* pid= */ -1, callerUid)
                        == PackageManager.PERMISSION_GRANTED;
    }",1
"private void fixupAutoTimeRestrictionDuringOrganizationOwnedDeviceMigration() {
        for (UserInfo ui : mUserManager.getUsers()) {
            final int userId = ui.id;
            if (isProfileOwnerOfOrganizationOwnedDevice(userId)) {
                final ActiveAdmin parent = getProfileOwnerAdminLocked(userId).parentAdmin;
                if (parent != null && parent.requireAutoTime) {
                    // Remove deprecated requireAutoTime
                    parent.requireAutoTime = false;
                    saveSettingsLocked(userId);

                    // Remove user restrictions set by the device owner before the upgrade to
                    // Android 11.
                    mUserManagerInternal.setDevicePolicyUserRestrictions(UserHandle.USER_SYSTEM,
                            new Bundle(), new RestrictionsSet(), /* isDeviceOwner */ false);

                    // Apply user restriction to parent active admin instead
                    parent.ensureUserRestrictions().putBoolean(
                            UserManager.DISALLOW_CONFIG_DATE_TIME, true);
                    pushUserRestrictions(userId);
                }
            }
        }
    }",0
"default List<MediaType> accept() {
        return getAll(HttpHeaders.ACCEPT)
            .stream()
            .flatMap(x -> Arrays.stream(x.split("","")))
            .flatMap(s -> ConversionService.SHARED.convert(s, MediaType.CONVERSION_CONTEXT).map(Stream::of).orElse(Stream.empty()))
            .distinct()
            .collect(Collectors.toList());
    }",1
"private void setPermission(Context c, Group g, int actionID, Bitstream bs)
            throws SQLException, AuthorizeException
    {
        if (!isTest)
        {
            // remove the default policy
            AuthorizeManager.removeAllPolicies(c, bs);

            // add the policy
            ResourcePolicy rp = ResourcePolicy.create(c);

            rp.setResource(bs);
            rp.setAction(actionID);
            rp.setGroup(g);

            rp.update();
        }
        else
        {
            if (actionID == Constants.READ)
            {
                System.out.println(""\t\tpermissions: READ for "" + g.getName());
            }
            else if (actionID == Constants.WRITE)
            {
                System.out.println(""\t\tpermissions: WRITE for "" + g.getName());
            }
        }

    }",0
"@Override
	public void event(UserRequest ureq, Component source, Event event) {
		if(cancelButton == source) {
			status = FolderCommandStatus.STATUS_CANCELED;
			fireEvent(ureq, FOLDERCOMMAND_FINISHED);
		} else if (selectButton == source) {
			doMove(ureq);
		}
	}",0
"public void handle(HttpServletRequest request, final HttpServletResponse response)
      throws Exception
  {
      // We're sending an XML response, so set the response content type to text/xml
      response.setContentType(""text/xml"");
      
      ByteArrayOutputStream out = new ByteArrayOutputStream();
      
      byte[] buffer = new byte[256];
      int read = request.getInputStream().read(buffer);
      while (read != -1)
      {
         out.write(buffer, 0, read);
         read = request.getInputStream().read(buffer);
      }
      
      String requestData = new String(out.toByteArray());
      log.debug(""Processing remote request: "" + requestData);
      
      // Parse the incoming request as XML
      SAXReader xmlReader = XML.getSafeSaxReader();
      Document doc = xmlReader.read( new StringReader(requestData) );
      final Element env = doc.getRootElement();
      final RequestContext ctx = unmarshalContext(env);

      // TODO - we really want to extract the page context from our request
      RemotingLifecycle.restorePageContext();

      new ContextualHttpServletRequest(request)
      {
         @Override
         public void process() throws Exception
         {
            // Extract the calls from the request            
            List<Call> calls = unmarshalCalls(env);

            // Execute each of the calls
            for (Call call : calls) 
            {
               call.execute();
            }               

            // Store the conversation ID in the outgoing context
            ctx.setConversationId( Manager.instance().getCurrentConversationId() );               
            
            // Package up the response
            marshalResponse(calls, ctx, response.getOutputStream());               
         }
         
         @Override
         protected void restoreConversationId()
         {
            ConversationPropagation.instance().setConversationId( ctx.getConversationId() );
         }
         
         @Override
         protected void handleConversationPropagation() {}
         
      }.run();
      
  }",1
"private static boolean parse(XMLTokener x, JSONObject context, String name, XMLParserConfiguration config, int currentNestingDepth)
            throws JSONException {
        char c;
        int i;
        JSONObject jsonObject = null;
        String string;
        String tagName;
        Object token;
        XMLXsiTypeConverter<?> xmlXsiTypeConverter;

        // Test for and skip past these forms:
        // <!-- ... -->
        // <! ... >
        // <![ ... ]]>
        // <? ... ?>
        // Report errors for these forms:
        // <>
        // <=
        // <<

        token = x.nextToken();

        // <!

        if (token == BANG) {
            c = x.next();
            if (c == '-') {
                if (x.next() == '-') {
                    x.skipPast(""-->"");
                    return false;
                }
                x.back();
            } else if (c == '[') {
                token = x.nextToken();
                if (""CDATA"".equals(token)) {
                    if (x.next() == '[') {
                        string = x.nextCDATA();
                        if (string.length() > 0) {
                            context.accumulate(config.getcDataTagName(), string);
                        }
                        return false;
                    }
                }
                throw x.syntaxError(""Expected 'CDATA['"");
            }
            i = 1;
            do {
                token = x.nextMeta();
                if (token == null) {
                    throw x.syntaxError(""Missing '>' after '<!'."");
                } else if (token == LT) {
                    i += 1;
                } else if (token == GT) {
                    i -= 1;
                }
            } while (i > 0);
            return false;
        } else if (token == QUEST) {

            // <?
            x.skipPast(""?>"");
            return false;
        } else if (token == SLASH) {

            // Close tag </

            token = x.nextToken();
            if (name == null) {
                throw x.syntaxError(""Mismatched close tag "" + token);
            }
            if (!token.equals(name)) {
                throw x.syntaxError(""Mismatched "" + name + "" and "" + token);
            }
            if (x.nextToken() != GT) {
                throw x.syntaxError(""Misshaped close tag"");
            }
            return true;

        } else if (token instanceof Character) {
            throw x.syntaxError(""Misshaped tag"");

            // Open tag <

        } else {
            tagName = (String) token;
            token = null;
            jsonObject = new JSONObject();
            boolean nilAttributeFound = false;
            xmlXsiTypeConverter = null;
            for (;;) {
                if (token == null) {
                    token = x.nextToken();
                }
                // attribute = value
                if (token instanceof String) {
                    string = (String) token;
                    token = x.nextToken();
                    if (token == EQ) {
                        token = x.nextToken();
                        if (!(token instanceof String)) {
                            throw x.syntaxError(""Missing value"");
                        }

                        if (config.isConvertNilAttributeToNull()
                                && NULL_ATTR.equals(string)
                                && Boolean.parseBoolean((String) token)) {
                            nilAttributeFound = true;
                        } else if(config.getXsiTypeMap() != null && !config.getXsiTypeMap().isEmpty()
                                && TYPE_ATTR.equals(string)) {
                            xmlXsiTypeConverter = config.getXsiTypeMap().get(token);
                        } else if (!nilAttributeFound) {
                            jsonObject.accumulate(string,
                                    config.isKeepStrings()
                                            ? ((String) token)
                                            : stringToValue((String) token));
                        }
                        token = null;
                    } else {
                        jsonObject.accumulate(string, """");
                    }


                } else if (token == SLASH) {
                    // Empty tag <.../>
                    if (x.nextToken() != GT) {
                        throw x.syntaxError(""Misshaped tag"");
                    }
                    if (config.getForceList().contains(tagName)) {
                        // Force the value to be an array
                        if (nilAttributeFound) {
                            context.append(tagName, JSONObject.NULL);
                        } else if (jsonObject.length() > 0) {
                            context.append(tagName, jsonObject);
                        } else {
                            context.put(tagName, new JSONArray());
                        }
                    } else {
                        if (nilAttributeFound) {
                            context.accumulate(tagName, JSONObject.NULL);
                        } else if (jsonObject.length() > 0) {
                            context.accumulate(tagName, jsonObject);
                        } else {
                            context.accumulate(tagName, """");
                        }
                    }
                    return false;

                } else if (token == GT) {
                    // Content, between <...> and </...>
                    for (;;) {
                        token = x.nextContent();
                        if (token == null) {
                            if (tagName != null) {
                                throw x.syntaxError(""Unclosed tag "" + tagName);
                            }
                            return false;
                        } else if (token instanceof String) {
                            string = (String) token;
                            if (string.length() > 0) {
                                if(xmlXsiTypeConverter != null) {
                                    jsonObject.accumulate(config.getcDataTagName(),
                                            stringToValue(string, xmlXsiTypeConverter));
                                } else {
                                    jsonObject.accumulate(config.getcDataTagName(),
                                            config.isKeepStrings() ? string : stringToValue(string));
                                }
                            }

                        } else if (token == LT) {
                            // Nested element
                            if (currentNestingDepth == config.getMaxNestingDepth()) {
                                throw x.syntaxError(""Maximum nesting depth of "" + config.getMaxNestingDepth() + "" reached"");
                            }

                            if (parse(x, jsonObject, tagName, config, currentNestingDepth + 1)) {
                                if (config.getForceList().contains(tagName)) {
                                    // Force the value to be an array
                                    if (jsonObject.length() == 0) {
                                        context.put(tagName, new JSONArray());
                                    } else if (jsonObject.length() == 1
                                            && jsonObject.opt(config.getcDataTagName()) != null) {
                                        context.append(tagName, jsonObject.opt(config.getcDataTagName()));
                                    } else {
                                        context.append(tagName, jsonObject);
                                    }
                                } else {
                                    if (jsonObject.length() == 0) {
                                        context.accumulate(tagName, """");
                                    } else if (jsonObject.length() == 1
                                            && jsonObject.opt(config.getcDataTagName()) != null) {
                                        context.accumulate(tagName, jsonObject.opt(config.getcDataTagName()));
                                    } else {
                                        context.accumulate(tagName, jsonObject);
                                    }
                                }
                                
                                return false;
                            }
                        }
                    }
                } else {
                    throw x.syntaxError(""Misshaped tag"");
                }
            }
        }
    }",1
public ActivityOptions getActivityOptions(IBinder token) throws RemoteException;,0
"void dumpPolicyLocked(PrintWriter pw, String[] args, boolean dumpAll) {
        pw.println(""WINDOW MANAGER POLICY STATE (dumpsys window policy)"");
        mPolicy.dump(""    "", pw, args);
    }",0
"@Override
    public String getContentContainer(Map<String, Object> data) {
        if (!getPropertyString(""horizontal_menu"").isEmpty()) {
            data.put(""hide_nav"", true);
        }
        
        if (showHomeBanner()) {
            data.put(""main_container_before"", ""<div class=\""home_banner\""><div class=\""home_banner_inner\"">""+getPropertyString(""homeAttractBanner"")+""</div></div>"");
        }
        
        data.put(""main_container_classes"", ""container-fluid-full"");
        data.put(""main_container_inner_classes"", ""row-fluid"");
        data.put(""sidebar_classes"", ""span2"");
        if (((Boolean) data.get(""embed"")) || ((Boolean) data.get(""hide_nav""))) {
            data.put(""content_classes"", ""span12"");
        } else {
            data.put(""content_classes"", ""span10"");
        }
        
        String ContentInnerBefore = getBreadcrumb(data);
        if (getPropertyString(""fontControl"").equalsIgnoreCase(""true"")) {
            ContentInnerBefore += getFontSizeController(data);
        }
        data.put(""content_inner_before"", ContentInnerBefore);
        return super.getContentContainer(data);
    }",0
"public void setContentEncoding(String contentEncoding) {
    this.contentEncoding = contentEncoding;
  }",0
"public String toXML() throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();

        Element element = toDOM(document);
        document.appendChild(element);

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
        transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""4"");

        DOMSource domSource = new DOMSource(document);
        StringWriter sw = new StringWriter();
        StreamResult streamResult = new StreamResult(sw);
        transformer.transform(domSource, streamResult);

        return sw.toString();
    }",1
"private void endOfCompressedDataReached() throws IOException {
    //With inflater, without knowing the compressed or uncompressed size, we over read necessary data
    //In such cases, we have to push back the inputstream to the end of data
    int numberOfBytesPushedBack = decompressedInputStream.pushBackInputStreamIfNecessary(inputStream);

    //First signal the end of data for this entry so that ciphers can read any header data if applicable
    decompressedInputStream.endOfEntryReached(inputStream, numberOfBytesPushedBack);

    readExtendedLocalFileHeaderIfPresent();
    verifyCrc();
    resetFields();
    this.entryEOFReached = true;
  }",1
"public int getConcurrency() throws SQLException {
    checkClosed();
    return resultsetconcurrency;
  }",0
"@Override
        public void characters(final char[] ch, final int start, final int length) {
            content.append(ch, start, length);
        }",1
"@Override
    public Intent getIntent() {
        Intent modIntent = new Intent(super.getIntent());
        modIntent.putExtra(EXTRA_SHOW_FRAGMENT, getFragmentClass().getName());
        return modIntent;
    }",0
"@PipelineProperty(description = ""The XML fragment wrapper that should be used to wrap the input XML."")
    @PipelinePropertyDocRef(types = TextConverter.ENTITY_TYPE)
    public void setTextConverter(final DocRef textConverterRef) {
        this.textConverterRef = textConverterRef;
    }",1
"public String dialogButtonsOk(String okAttribute) {

        return dialogButtons(new int[] {BUTTON_OK}, new String[] {okAttribute});
    }",0
"public byte[] getSecretKeySeed()
    {
        return XMSSUtil.cloneArray(secretKeySeed);
    }",0
"@Override
    public boolean canPlaceAt(BlockVector3 position, com.sk89q.worldedit.world.block.BlockState blockState) {
        //FAWE start - safe edit region
        testCoords(position);
        //FAWE end
        BukkitImplAdapter adapter = WorldEditPlugin.getInstance().getBukkitImplAdapter();
        if (adapter != null) {
            return adapter.canPlaceAt(getWorld(), position, blockState);
        }
        // We can't check, so assume yes.
        return true;
    }",1
"public File prepareDownloadFile(Response response) throws IOException {
    String filename = null;
    String contentDisposition = (String) response.getHeaders().getFirst(""Content-Disposition"");
    if (contentDisposition != null && !"""".equals(contentDisposition)) {
      // Get filename from the Content-Disposition header.
      Pattern pattern = Pattern.compile(""filename=['\""]?([^'\""\\s]+)['\""]?"");
      Matcher matcher = pattern.matcher(contentDisposition);
      if (matcher.find())
        filename = matcher.group(1);
    }

    String prefix;
    String suffix = null;
    if (filename == null) {
      prefix = ""download-"";
      suffix = """";
    } else {
      int pos = filename.lastIndexOf('.');
      if (pos == -1) {
        prefix = filename + ""-"";
      } else {
        prefix = filename.substring(0, pos) + ""-"";
        suffix = filename.substring(pos);
      }
      // Files.createTempFile requires the prefix to be at least three characters long
      if (prefix.length() < 3)
        prefix = ""download-"";
    }

    if (tempFolderPath == null)
      return Files.createTempFile(prefix, suffix).toFile();
    else
      return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
  }",1
"default Optional<Integer> findInt(CharSequence name) {
        return get(name, ConversionContext.INT);
    }",1
"public RowScale setInterpolator(Interpolator interpolator) {
            if (mAnimator != null) {
                mAnimator.setInterpolator(interpolator);
            }
            return this;
        }",0
"public boolean isValidationFailure() {
            return cause.getCause() instanceof InvalidValueException;
        }",0
"RestorePolicy readAppManifest(FileMetadata info, InputStream instream)
                throws IOException {
            // Fail on suspiciously large manifest files
            if (info.size > 64 * 1024) {
                throw new IOException(""Restore manifest too big; corrupt? size="" + info.size);
            }

            byte[] buffer = new byte[(int) info.size];
            if (readExactly(instream, buffer, 0, (int)info.size) == info.size) {
                mBytes += info.size;
            } else throw new IOException(""Unexpected EOF in manifest"");

            RestorePolicy policy = RestorePolicy.IGNORE;
            String[] str = new String[1];
            int offset = 0;

            try {
                offset = extractLine(buffer, offset, str);
                int version = Integer.parseInt(str[0]);
                if (version == BACKUP_MANIFEST_VERSION) {
                    offset = extractLine(buffer, offset, str);
                    String manifestPackage = str[0];
                    // TODO: handle <original-package>
                    if (manifestPackage.equals(info.packageName)) {
                        offset = extractLine(buffer, offset, str);
                        version = Integer.parseInt(str[0]);  // app version
                        offset = extractLine(buffer, offset, str);
                        // This is the platform version, which we don't use, but we parse it
                        // as a safety against corruption in the manifest.
                        Integer.parseInt(str[0]);
                        offset = extractLine(buffer, offset, str);
                        info.installerPackageName = (str[0].length() > 0) ? str[0] : null;
                        offset = extractLine(buffer, offset, str);
                        boolean hasApk = str[0].equals(""1"");
                        offset = extractLine(buffer, offset, str);
                        int numSigs = Integer.parseInt(str[0]);
                        if (numSigs > 0) {
                            Signature[] sigs = new Signature[numSigs];
                            for (int i = 0; i < numSigs; i++) {
                                offset = extractLine(buffer, offset, str);
                                sigs[i] = new Signature(str[0]);
                            }
                            mManifestSignatures.put(info.packageName, sigs);

                            // Okay, got the manifest info we need...
                            try {
                                PackageInfo pkgInfo = mPackageManager.getPackageInfo(
                                        info.packageName, PackageManager.GET_SIGNATURES);
                                // Fall through to IGNORE if the app explicitly disallows backup
                                final int flags = pkgInfo.applicationInfo.flags;
                                if ((flags & ApplicationInfo.FLAG_ALLOW_BACKUP) != 0) {
                                    // Restore system-uid-space packages only if they have
                                    // defined a custom backup agent
                                    if ((pkgInfo.applicationInfo.uid >= Process.FIRST_APPLICATION_UID)
                                            || (pkgInfo.applicationInfo.backupAgentName != null)) {
                                        // Verify signatures against any installed version; if they
                                        // don't match, then we fall though and ignore the data.  The
                                        // signatureMatch() method explicitly ignores the signature
                                        // check for packages installed on the system partition, because
                                        // such packages are signed with the platform cert instead of
                                        // the app developer's cert, so they're different on every
                                        // device.
                                        if (signaturesMatch(sigs, pkgInfo)) {
                                            if (pkgInfo.versionCode >= version) {
                                                Slog.i(TAG, ""Sig + version match; taking data"");
                                                policy = RestorePolicy.ACCEPT;
                                            } else {
                                                // The data is from a newer version of the app than
                                                // is presently installed.  That means we can only
                                                // use it if the matching apk is also supplied.
                                                Slog.d(TAG, ""Data version "" + version
                                                        + "" is newer than installed version ""
                                                        + pkgInfo.versionCode + "" - requiring apk"");
                                                policy = RestorePolicy.ACCEPT_IF_APK;
                                            }
                                        } else {
                                            Slog.w(TAG, ""Restore manifest signatures do not match ""
                                                    + ""installed application for "" + info.packageName);
                                        }
                                    } else {
                                        Slog.w(TAG, ""Package "" + info.packageName
                                                + "" is system level with no agent"");
                                    }
                                } else {
                                    if (DEBUG) Slog.i(TAG, ""Restore manifest from ""
                                            + info.packageName + "" but allowBackup=false"");
                                }
                            } catch (NameNotFoundException e) {
                                // Okay, the target app isn't installed.  We can process
                                // the restore properly only if the dataset provides the
                                // apk file and we can successfully install it.
                                if (DEBUG) Slog.i(TAG, ""Package "" + info.packageName
                                        + "" not installed; requiring apk in dataset"");
                                policy = RestorePolicy.ACCEPT_IF_APK;
                            }

                            if (policy == RestorePolicy.ACCEPT_IF_APK && !hasApk) {
                                Slog.i(TAG, ""Cannot restore package "" + info.packageName
                                        + "" without the matching .apk"");
                            }
                        } else {
                            Slog.i(TAG, ""Missing signature on backed-up package ""
                                    + info.packageName);
                        }
                    } else {
                        Slog.i(TAG, ""Expected package "" + info.packageName
                                + "" but restore manifest claims "" + manifestPackage);
                    }
                } else {
                    Slog.i(TAG, ""Unknown restore manifest version "" + version
                            + "" for package "" + info.packageName);
                }
            } catch (NumberFormatException e) {
                Slog.w(TAG, ""Corrupt restore manifest for package "" + info.packageName);
            } catch (IllegalArgumentException e) {
                Slog.w(TAG, e.getMessage());
            }

            return policy;
        }",0
"@GetMapping(value = ""export/{modelId}/{type}"")
    @ApiOperation(""导出模型"")
    @Authorize(action = ""export"")
    @SneakyThrows
    public void export(@PathVariable(""modelId"") @ApiParam(""模型ID"") String modelId,
                       @PathVariable(""type"") @ApiParam(value = ""类型"", allowableValues = ""bpmn,json"", example = ""json"")
                               ModelType type,
                       @ApiParam(hidden = true) HttpServletResponse response) {
        Model modelData = repositoryService.getModel(modelId);
        if (modelData == null) {
            throw new NotFoundException(""模型不存在"");
        }
        BpmnJsonConverter jsonConverter = new BpmnJsonConverter();
        byte[] modelEditorSource = repositoryService.getModelEditorSource(modelData.getId());

        JsonNode editorNode = new ObjectMapper().readTree(modelEditorSource);
        BpmnModel bpmnModel = jsonConverter.convertToBpmnModel(editorNode);

        // 处理异常
        if (bpmnModel.getMainProcess() == null) {
            throw new UnsupportedOperationException(""无法导出模型文件:"" + type);
        }

        String filename = """";
        byte[] exportBytes = null;

        String mainProcessId = bpmnModel.getMainProcess().getId();

        if (type == ModelType.bpmn) {
            BpmnXMLConverter xmlConverter = new BpmnXMLConverter();
            exportBytes = xmlConverter.convertToXML(bpmnModel);
            filename = mainProcessId + "".bpmn20.xml"";
        } else if (type == ModelType.json) {
            exportBytes = modelEditorSource;
            filename = mainProcessId + "".json"";

        } else {
            throw new UnsupportedOperationException(""不支持的格式:"" + type);
        }

        response.setCharacterEncoding(""UTF-8"");
        response.setContentType(""application/octet-stream"");
        response.setHeader(""Content-Disposition"", ""attachment; filename="" + URLEncoder.encode(filename, ""UTF-8""));

        /*创建输入流*/
        try (ByteArrayInputStream in = new ByteArrayInputStream(exportBytes)) {
            IOUtils.copy(in, response.getOutputStream());
            response.flushBuffer();
        }
    }",1
"@Override
        public void run() {
            try {
                switch (mAction) {
                    case ACTION_FAVORITE:
                        mChannelToUpdate.setImportantConversation(true);
                        if (mChannelToUpdate.isImportantConversation()) {
                            mChannelToUpdate.setAllowBubbles(true);
                            if (mAppBubble == BUBBLE_PREFERENCE_NONE) {
                                mINotificationManager.setBubblesAllowed(mAppPkg, mAppUid,
                                        BUBBLE_PREFERENCE_SELECTED);
                            }
                            if (mBubblesManagerOptional.isPresent()) {
                                post(() -> mBubblesManagerOptional.get()
                                        .onUserSetImportantConversation(mEntry));
                            }
                        }
                        mChannelToUpdate.setImportance(Math.max(
                                mChannelToUpdate.getOriginalImportance(), IMPORTANCE_DEFAULT));
                        break;
                    case ACTION_DEFAULT:
                        mChannelToUpdate.setImportance(Math.max(
                                mChannelToUpdate.getOriginalImportance(), IMPORTANCE_DEFAULT));
                        if (mChannelToUpdate.isImportantConversation()) {
                            mChannelToUpdate.setImportantConversation(false);
                            mChannelToUpdate.setAllowBubbles(false);
                        }
                        break;
                    case ACTION_MUTE:
                        if (mChannelToUpdate.getImportance() == IMPORTANCE_UNSPECIFIED
                                || mChannelToUpdate.getImportance() >= IMPORTANCE_DEFAULT) {
                            mChannelToUpdate.setImportance(IMPORTANCE_LOW);
                        }
                        if (mChannelToUpdate.isImportantConversation()) {
                            mChannelToUpdate.setImportantConversation(false);
                            mChannelToUpdate.setAllowBubbles(false);
                        }
                        break;
                }

                mINotificationManager.updateNotificationChannelForPackage(
                            mAppPkg, mAppUid, mChannelToUpdate);
            } catch (RemoteException e) {
                Log.e(TAG, ""Unable to update notification channel"", e);
            }
        }",0
"@Override
    public XWikiAttachment uploadAttachment(DocumentReference documentReference, Part part)
        throws TemporaryAttachmentException
    {
        XWikiAttachment xWikiAttachment;
        long uploadMaxSize = getUploadMaxSize(documentReference);
        if (part.getSize() > uploadMaxSize) {
            throw new TemporaryAttachmentException(String.format(
                ""The file size [%s] is larger than the upload max size [%s]"", part.getSize(), uploadMaxSize));
        }
        TemporaryAttachmentSession temporaryAttachmentSession = getOrCreateSession();
        XWikiContext context = this.contextProvider.get();
        try {
            xWikiAttachment = new XWikiAttachment();
            xWikiAttachment.setFilename(part.getSubmittedFileName());
            xWikiAttachment.setContent(part.getInputStream());
            xWikiAttachment.setAuthorReference(context.getUserReference());
            // Initialize an empty document with the right document reference and locale. We don't set the actual 
            // document since it's a temporary attachment, but it is still useful to have a minimal knowledge of the
            // document it is stored for.
            xWikiAttachment.setDoc(new XWikiDocument(documentReference, documentReference.getLocale()), false);
            temporaryAttachmentSession.addAttachment(documentReference, xWikiAttachment);
        } catch (IOException e) {
            throw new TemporaryAttachmentException(""Error while reading the content of a request part"", e);
        }
        return xWikiAttachment;
    }",1
"@VisibleForTesting
    void saveState(Bundle outState) {
        if (mCategories.size() > 0) {
            outState.putParcelableArrayList(SAVE_KEY_CATEGORIES, mCategories);
        }
    }",0
"private void  broadcastCardStateAndIccRefreshResp(CardState cardState,
            IccRefreshResponse iccRefreshState) {
        Intent intent = new Intent(AppInterface.CAT_ICC_STATUS_CHANGE);
        boolean cardPresent = (cardState == CardState.CARDSTATE_PRESENT);

        if (iccRefreshState != null) {
            //This case is when MSG_ID_ICC_REFRESH is received.
            intent.putExtra(AppInterface.REFRESH_RESULT, iccRefreshState.refreshResult);
            CatLog.d(this, ""Sending IccResult with Result: ""
                    + iccRefreshState.refreshResult);
        }

        // This sends an intent with CARD_ABSENT (0 - false) /CARD_PRESENT (1 - true).
        intent.putExtra(AppInterface.CARD_STATUS, cardPresent);
        CatLog.d(this, ""Sending Card Status: ""
                + cardState + "" "" + ""cardPresent: "" + cardPresent);
        mContext.sendBroadcast(intent, AppInterface.STK_PERMISSION);
    }",1
"Messenger bindServiceIfNeededLocked(int userId, ComponentName service) {
        if (mPaymentServiceName != null && mPaymentServiceName.equals(service)
                && mPaymentServiceUserId == userId) {
            Log.d(TAG, ""Service already bound as payment service."");
            return mPaymentService;
        } else if (mServiceName != null && mServiceName.equals(service)
                && mServiceUserId == userId) {
            Log.d(TAG, ""Service already bound as regular service."");
            return mService;
        } else {
            Log.d(TAG, ""Binding to service "" + service + "" for userid:"" + userId);
            unbindServiceIfNeededLocked();
            Intent aidIntent = new Intent(HostApduService.SERVICE_INTERFACE);
            aidIntent.setComponent(service);
            try {
                mServiceBound = mContext.bindServiceAsUser(aidIntent, mConnection,
                        Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS,
                        UserHandle.of(userId));
                if (!mServiceBound) {
                    Log.e(TAG, ""Could not bind service."");
                } else {
                    mServiceUserId = userId;
                }
            } catch (SecurityException e) {
                Log.e(TAG, ""Could not bind service due to security exception."");
            }
            return null;
        }
    }",0
"@Override
        public void setNativePlayerMode(boolean nativePlayer) {
            this.nativePlayer = nativePlayer;
        }",0
"public void execute(Transaction t) throws SQLException {
			PreparedStatement prepStmt = t.getConnection().prepareStatement(query);
			prepStmt.setString(1, args[0]);
			prepStmt.setString(2, args[1]);
			try {
				ResultSet rs = prepStmt.executeQuery();
				ResultSetMetaData metaData = rs.getMetaData();
				while (rs.next()) {
					Map map = new HashMap();
					for (int i = 0; i < metaData.getColumnCount(); i++) {
						map.put(metaData.getColumnLabel(i + 1), rs.getString(i + 1));
					}
					list.add(map);
				}
	        } finally {
	        	prepStmt.close();
	        }
		}",1
"public Claims validateToken(String token) throws AuthenticationException {
        try {
            RsaKeyUtil rsaKeyUtil = new RsaKeyUtil();
            PublicKey publicKey = rsaKeyUtil.fromPemEncoded(keycloakPublicKey);

            return Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token.replace(""Bearer "", """")).getBody();
        } catch (Exception e){
            throw new AuthenticationException(String.format(""Failed to check user authorization for token: %s"", token), e);
        }
    }",1
"@Override
    public String toXML() throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();

        Element element = toDOM(document);
        document.appendChild(element);

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
        transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""4"");

        DOMSource domSource = new DOMSource(document);
        StringWriter sw = new StringWriter();
        StreamResult streamResult = new StreamResult(sw);
        transformer.transform(domSource, streamResult);

        return sw.toString();
    }",1
"private void appendExplicitSpaceAndComponent(StringBuilder breadcrumb) {
    if (getDomainName() != null) {
      breadcrumb.append(getDomainName());
    }
    if (getComponentName() != null) {
      if (getDomainName() != null) {
        breadcrumb.append(CONNECTOR);
      }
      if (getComponentLink() != null) {
        a href = new a(getComponentLink());
        href.addElement(getComponentName());
        breadcrumb.append(href.toString());
      } else {
        breadcrumb.append(getComponentName());
      }
    }
  }",0
"static void setPlotDimensions(final HttpQuery query, final Plot plot) {
    String wxh = query.getQueryStringParam(""wxh"");
    if (wxh != null && !wxh.isEmpty()) {
      wxh = URLDecoder.decode(wxh.trim());
      if (!WXH_VALIDATOR.matcher(wxh).find()) {
        throw new IllegalArgumentException(""'wxh' was invalid. ""
            + ""Must satisfy the pattern "" + WXH_VALIDATOR.toString());
      }
      final int wxhlength = wxh.length();
      if (wxhlength < 7) {  // 100x100 minimum.
        throw new BadRequestException(""Parameter wxh too short: "" + wxh);
      }
      final int x = wxh.indexOf('x', 3);  // Start at 2 as min size is 100x100
      if (x < 0) {
        throw new BadRequestException(""Invalid wxh parameter: "" + wxh);
      }
      try {
        final short width = Short.parseShort(wxh.substring(0, x));
        final short height = Short.parseShort(wxh.substring(x + 1, wxhlength));
        try {
          plot.setDimensions(width, height);
        } catch (IllegalArgumentException e) {
          throw new BadRequestException(""Invalid wxh parameter: "" + wxh + "", ""
                                        + e.getMessage());
        }
      } catch (NumberFormatException e) {
        throw new BadRequestException(""Can't parse wxh '"" + wxh + ""': ""
                                      + e.getMessage());
      }
    }
  }",1
"public void updateResources() {
        int panelWidth = getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
        int panelGravity = getResources().getInteger(R.integer.notification_panel_layout_gravity);
        FrameLayout.LayoutParams lp =
                (FrameLayout.LayoutParams) mQsFrame.getLayoutParams();
        if (lp.width != panelWidth || lp.gravity != panelGravity) {
            lp.width = panelWidth;
            lp.gravity = panelGravity;
            mQsFrame.setLayoutParams(lp);
        }

        lp = (FrameLayout.LayoutParams) mNotificationStackScroller.getLayoutParams();
        if (lp.width != panelWidth || lp.gravity != panelGravity) {
            lp.width = panelWidth;
            lp.gravity = panelGravity;
            mNotificationStackScroller.setLayoutParams(lp);
        }
    }",0
"public static void addActionsToNotification(PushActionsProvider provider, String categoryId, NotificationCompat.Builder builder, Intent targetIntent, Context context) throws IOException {
        // NOTE:  THis will likely run when the main activity isn't running so we won't have
        // access to any display properties... just native Android APIs will be accessible.
        
        PushActionCategory category = null;
        PushActionCategory[] categories;
        if (provider != null) {
            categories = provider.getPushActionCategories();
        } else {
            categories = getInstalledPushActionCategories(context);
        }
        for (PushActionCategory candidateCategory : categories) {
            if (categoryId.equals(candidateCategory.getId())) {
                category = candidateCategory;
                break;
            }
        }
        if (category == null) {
            return;
        }
        
        int requestCode = 1;
        for (PushAction action : category.getActions()) {
            Intent newIntent = (Intent)targetIntent.clone();
            newIntent.putExtra(""pushActionId"", action.getId());
            PendingIntent contentIntent = createPendingIntent(context, requestCode++, newIntent);
            try {
                int iconId = 0;
                try { iconId = Integer.parseInt(action.getIcon());} catch (Exception ex){}
                //android.app.Notification.Action.Builder actionBuilder = new android.app.Notification.Action.Builder(iconId, action.getTitle(), contentIntent);

                System.out.println(""Adding action ""+action.getId()+"", ""+action.getTitle()+"", icon=""+iconId);
                if (ActionWrapper.BuilderWrapper.isSupported()) {
                    // We need to take this abstracted ""wrapper"" approach because the Action.Builder class, and RemoteInput class
                    // aren't available until API 22.
                    // These classes use reflection to provide support for these classes safely.
                    ActionWrapper.BuilderWrapper actionBuilder = new ActionWrapper.BuilderWrapper(iconId, action.getTitle(), contentIntent);
                    if (action.getTextInputPlaceholder() != null && RemoteInputWrapper.isSupported()) {
                        RemoteInputWrapper.BuilderWrapper remoteInputBuilder = new RemoteInputWrapper.BuilderWrapper(action.getId()+""$Result"");
                        remoteInputBuilder.setLabel(action.getTextInputPlaceholder());

                        RemoteInputWrapper remoteInput = remoteInputBuilder.build();
                        actionBuilder.addRemoteInput(remoteInput);
                    }
                    ActionWrapper actionWrapper = actionBuilder.build();
                    new NotificationCompatWrapper.BuilderWrapper(builder).addAction(actionWrapper);
                } else {
                    builder.addAction(iconId, action.getTitle(), contentIntent);
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
        
    }",1
"public JSONArray put(Map value) throws JSONException {
        put(new JSONObject(value));
        return this;
    }",1
"private PyTorchJobSpec parsePyTorchJobSpec(ExperimentSpec experimentSpec)
          throws InvalidSpecException {
    PyTorchJobSpec pyTorchJobSpec = new PyTorchJobSpec();

    V1Container initContainer = this.getExperimentHandlerContainer(experimentSpec);
    Map<PyTorchJobReplicaType, MLJobReplicaSpec> replicaSpecMap = new HashMap<>();
    for (Map.Entry<String, ExperimentTaskSpec> entry : experimentSpec.getSpec().entrySet()) {
      String replicaType = entry.getKey();
      ExperimentTaskSpec taskSpec = entry.getValue();
      if (PyTorchJobReplicaType.isSupportedReplicaType(replicaType)) {
        MLJobReplicaSpec replicaSpec = new MLJobReplicaSpec();
        replicaSpec.setReplicas(taskSpec.getReplicas());
        V1PodTemplateSpec podTemplateSpec = ExperimentSpecParser.parseTemplateSpec(taskSpec, experimentSpec);

        if (initContainer != null && replicaType.equals(""Master"")) {
          podTemplateSpec.getSpec().addInitContainersItem(initContainer);
        }

        replicaSpec.setTemplate(podTemplateSpec);
        replicaSpecMap.put(PyTorchJobReplicaType.valueOf(replicaType), replicaSpec);
      } else {
        throw new InvalidSpecException(""Unrecognized replica type name: "" +
            entry.getKey() + "", it should be "" +
            String.join("","", PyTorchJobReplicaType.names()) +
            "" for PyTorch experiment."");
      }
    }
    pyTorchJobSpec.setReplicaSpecs(replicaSpecMap);
    return pyTorchJobSpec;
  }",1
"@Override
	public void run(TaskMonitor monitor) {
		long start_ts = System.currentTimeMillis();
		monitor.setMessage(""Extracting all..."");

		try (RefdFile refdFile = FileSystemService.getInstance().getRefdFile(srcFSRL, monitor)) {
			GFileSystem fs = refdFile.fsRef.getFilesystem();
			GFile file = refdFile.file;
			if (!file.isDirectory()) {
				Msg.warn(this, ""Extract All source not a directory!  "" + file.getFSRL());
				return;
			}

			if (verifyRootOutputDir(file.getName())) {
				startExtract(fs, file, monitor);
			}
		}
		catch (CancelledException ce) {
			Msg.warn(this, ""Extract all task canceled"");
		}
		catch (UnsupportedOperationException | IOException e) {
			Msg.showError(this, parentComponent, ""Error extracting file"", e.getMessage());
		}
		Msg.info(this,
			""Exported "" + getTotalFilesExportedCount() + "" files, "" + getTotalDirsExportedCount() +
				"" directories, "" + getTotalBytesExportedCount() + "" bytes"");

		long elapsed = System.currentTimeMillis() - start_ts;

		//@formatter:off
		int option = OptionDialog.showOptionDialog(parentComponent, ""Export Summary"",
			""<html><div style='margin-bottom: 20pt; text-align: center; font-weight: bold'>Export files summary:</div>"" +
					""<div style='margin-bottom: 20pt'>Source location:</div>"" +
					""<div style='margin-bottom: 20pt; margin-left: 50pt'>"" + HTMLUtilities.friendlyEncodeHTML(srcFSRL.toPrettyString()) + ""</div>"" +
					""<div style='margin-bottom: 20pt;'>Destination:</div>"" +
					""<div style='margin-bottom: 20pt; margin-left: 50pt'>"" + HTMLUtilities.friendlyEncodeHTML(rootOutputDirectory.getPath() )+ ""</div>"" +
					""<div style='margin-bottom: 20pt;'>Elapsed time: "" + DateUtils.formatDuration(elapsed) + ""</div>"" +
					""<table style='margin-bottom: 20pt;' width='100%'>"" +
					""<tr><td></td><td>Files</td><td>Directories</td><td>Bytes</td></tr>"" +
					""<tr><td>Successful</td><td>"" + getTotalFilesExportedCount() + ""</td><td>"" + getTotalDirsExportedCount() + 
						""</td><td>"" + FileUtilities.formatLength(getTotalBytesExportedCount()) + ""</td></tr>"" +
					""<tr><td>Failed</td><td>"" + errorredFiles.size() + ""</td><td></td><td></td></tr>"" +
					""</table>"" +
					""</div></html>"", ""OK"", ""Show exported files"");
		//@formatter:on
		if (option == OptionDialog.OPTION_TWO) {
			try {
				FileUtilities.openNative(rootOutputDirectory);
			}
			catch (IOException e) {
				Msg.showError(this, parentComponent, ""Problem Starting Explorer"",
					""Problem starting file explorer: "" + e.getMessage());
			}

		}
	}",1
"@Nonnull
  private TwoStrings _readString (@Nonnull final EStringQuoteMode eQuoteMode) throws JsonParseException
  {
    final IJsonParsePosition aStartPos = _getCurrentParsePos ();
    final JsonStringBuilder aStrStringOriginalContent = m_aSB1.reset ();
    final JsonStringBuilder aStrStringUnescapedContent = m_aSB2.reset ();

    final int cQuoteChar = eQuoteMode.getQuoteChar ();

    final int cStart = _readChar ();
    final boolean bStringIsQuoted = cStart == cQuoteChar;
    if (bStringIsQuoted)
    {
      aStrStringOriginalContent.append ((char) cQuoteChar);
    }
    else
    {
      if (m_bRequireStringQuotes)
        throw _parseEx (aStartPos,
                        ""Invalid JSON String start character "" +
                                   _getPrintableChar (cStart) +
                                   "" - expected "" +
                                   _getPrintableChar (cQuoteChar));

      _backupChar (cStart);
      aStrStringOriginalContent.append ((char) cQuoteChar);
    }

    outer: while (true)
    {
      final int c = _readChar ();
      aStrStringOriginalContent.append ((char) c);

      switch (c)
      {
        case '\\':
        {
          // Escape char
          _readStringEscapeChar (aStartPos, aStrStringOriginalContent, aStrStringUnescapedContent);
          break;
        }
        case EOI:
          throw _parseEx (aStartPos, ""Unclosed JSON String at end of input"");
        case '\b':
        case '\f':
        case '\n':
        case '\r':
        case '\t':
          if (!m_bAllowSpecialCharsInStrings)
            throw _parseEx (aStartPos, ""Invalid JSON String character "" + _getPrintableChar (c));
          // else fall-though!
        default:
          if (bStringIsQuoted)
          {
            if (c == cQuoteChar)
            {
              // End of quoted string
              // No append to unescaped content
              break outer;
            }
          }
          else
          {
            if (!_isUnquotedStringValidChar (c))
            {
              // End of unquoted string

              // Remove from original content
              _backupChar (c);
              aStrStringOriginalContent.backup (1);

              if (aStrStringUnescapedContent.getLength () == 0)
                throw _parseEx (aStartPos, ""Empty unquoted JSON String encountered"");

              // Since it is present on open, it must also be present on close
              aStrStringOriginalContent.append ((char) cQuoteChar);
              break outer;
            }
          }

          // Regular string character
          aStrStringUnescapedContent.append ((char) c);
          break;
      }
    }

    return new TwoStrings (aStrStringOriginalContent.getAsString (), aStrStringUnescapedContent.getAsString ());
  }",0
"private PluginArtifactPullReq getPluginArtifactPullRequestEntity(PluginArtifactPullContext ctx) {
        PluginArtifactPullReq reqEntity = pluginArtifactPullReqMapper.selectByPrimaryKey(ctx.getRequestId());

        if (reqEntity == null) {
            reqEntity = ctx.getEntity();
        }
        if (reqEntity == null) {
            throw new WecubeCoreException(""3102"", String.format(""Request entity %s does not exist"", ctx.getRequestId()),
                    ctx.getRequestId());
        }

        return reqEntity;
    }",0
"public void waitForPixelColorAtCenterOfView(final AwContents awContents,
            final AwTestContainerView testContainerView, final int expectedColor) throws Exception {
        pollUiThread(new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                Bitmap bitmap = GraphicsTestUtils.drawAwContents(awContents, 2, 2,
                        -(float) testContainerView.getWidth() / 2,
                        -(float) testContainerView.getHeight() / 2);
                return bitmap.getPixel(0, 0) == expectedColor;
            }
        });
    }",0
"private ModelAndView renameGroup(HttpServletRequest request, HttpServletResponse response) throws Exception {
        
        String oldName = request.getParameter(""groupName"");
        String newName = request.getParameter(""newName"");

        if (newName != null && newName.matches("".*[&<>\""`']+.*"")) {
            throw new ServletException(""Group ID must not contain any HTML markup."");
        }

        if (StringUtils.hasText(oldName) && StringUtils.hasText(newName)) {
            m_groupRepository.renameGroup(oldName, newName);
        }
        
        return listGroups(request, response);
    }",1
"public Page<E> setPageNum(int pageNum) {
        //分页合理化，针对不合理的页码自动处理
        this.pageNum = ((reasonable != null && reasonable) && pageNum <= 0) ? 1 : pageNum;
        return this;
    }",0
"public static boolean isCsrfTokenValid(VaadinSession session,
            String requestToken) {

        if (session.getService().getDeploymentConfiguration()
                .isXsrfProtectionEnabled()) {
            String sessionToken = session.getCsrfToken();

            if (sessionToken == null || !MessageDigest.isEqual(
                    sessionToken.getBytes(StandardCharsets.UTF_8),
                    requestToken.getBytes(StandardCharsets.UTF_8))) {
                return false;
            }
        }
        return true;
    }",1
"@Override
    public XWikiDocument getRevision(DocumentReference reference, String revision) throws XWikiException
    {
        XWikiContext xcontext = this.xcontextProvider.get();

        XWikiDeletedDocument deletedDocument = xcontext.getWiki().getDeletedDocument(Long.valueOf(revision), xcontext);

        // Only local the document if it matches the asked document reference
        if (deletedDocument != null
            && (reference == null || deletedDocument.getDocumentReference().equals(reference))) {
            return deletedDocument.restoreDocument(xcontext);
        }

        return null;
    }",1
protected abstract void checkKeys() throws IOException;,0
"public Jooby executor(final Executor executor) {
    this.defaultExecSet = true;
    this.executors.add(binder -> {
      binder.bind(Key.get(String.class, Names.named(""deferred""))).toInstance(""deferred"");
      binder.bind(Key.get(Executor.class, Names.named(""deferred""))).toInstance(executor);
    });
    return this;
  }",0
"boolean deviceIsEncrypted() {
        try {
            return mMountService.getEncryptionState()
                     != IMountService.ENCRYPTION_STATE_NONE
                && mMountService.getPasswordType()
                     != StorageManager.CRYPT_TYPE_DEFAULT;
        } catch (Exception e) {
            // If we can't talk to the mount service we have a serious problem; fail
            // ""secure"" i.e. assuming that the device is encrypted.
            Slog.e(TAG, ""Unable to communicate with mount service: "" + e.getMessage());
            return true;
        }
    }",0
"private void gotKexInit(SSHPacket buf)
            throws TransportException {
        buf.rpos(buf.rpos() - 1);
        final Proposal serverProposal = new Proposal(buf);
        gotStrictKexInfo(serverProposal);
        negotiatedAlgs = clientProposal.negotiate(serverProposal);
        log.debug(""Negotiated algorithms: {}"", negotiatedAlgs);
        for(AlgorithmsVerifier v: algorithmVerifiers) {
            log.debug(""Trying to verify algorithms with {}"", v);
            if(!v.verify(negotiatedAlgs)) {
                throw new TransportException(DisconnectReason.KEY_EXCHANGE_FAILED,
                        ""Failed to verify negotiated algorithms `"" + negotiatedAlgs + ""`"");
            }
        }
        kex = Factory.Named.Util.create(transport.getConfig().getKeyExchangeFactories(),
                                        negotiatedAlgs.getKeyExchangeAlgorithm());
        transport.setHostKeyAlgorithm(Factory.Named.Util.create(transport.getConfig().getKeyAlgorithms(),
                                      negotiatedAlgs.getSignatureAlgorithm()));

        try {
            kex.init(transport,
                     transport.getServerID(), transport.getClientID(),
                     serverProposal.getPacket().getCompactData(), clientProposal.getPacket().getCompactData());
        } catch (GeneralSecurityException e) {
            throw new TransportException(DisconnectReason.KEY_EXCHANGE_FAILED, e);
        }
    }",1
"boolean startSipService(SipManager sipManager, Context context, boolean isReceivingCalls) {
            if (VERBOSE) log(""startSipService, profile: "" + mProfile);
            try {
                // Stop the Sip service for the profile if it is already running.  This is important
                // if we are changing the state of the ""receive calls"" option.
                sipManager.close(mProfile.getUriString());

                // Start the sip service for the profile.
                if (isReceivingCalls) {
                    sipManager.open(
                            mProfile,
                            SipUtil.createIncomingCallPendingIntent(context,
                                    mProfile.getProfileName()),
                            null);
                } else {
                    sipManager.open(mProfile);
                }
                return true;
            } catch (SipException e) {
                log(""startSipService, profile: "" + mProfile.getProfileName() +
                        "", exception: "" + e);
            }
            return false;
        }",1
"public static Document readDocument(File f) throws IOException, SAXException, ParserConfigurationException {
		Document document = null;

		DocumentBuilderFactory factory = XMLUtils.safeDocumentBuilderFactory();
		// factory.setValidating(true);
		// factory.setNamespaceAware(true);

		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.parse(f);

			// displayDocument(document);

		} catch (SAXException sxe) {
			// Error generated during parsing)
			Exception x = sxe;
			if (sxe.getException() != null)
				x = sxe.getException();
			x.printStackTrace();
			throw sxe;
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
			throw pce;
		} catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
			throw ioe;
		}

		return document;
	}",1
"public void unregisterContentObserver(IContentObserver observer) {
        if (observer == null) {
            throw new IllegalArgumentException(""You must pass a valid observer"");
        }
        synchronized (mRootNode) {
            mRootNode.removeObserverLocked(observer);
            if (false) Log.v(TAG, ""Unregistered observer "" + observer);
        }
    }",0
"@Override
    public void setShortSupportMessage(@NonNull ComponentName who, CharSequence message) {
        if (!mHasFeature) {
            return;
        }
        Objects.requireNonNull(who, ""ComponentName is null"");
        message = truncateIfLonger(message, MAX_SHORT_SUPPORT_MESSAGE_LENGTH);

        final CallerIdentity caller = getCallerIdentity(who);
        synchronized (getLockObject()) {
            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());
            if (!TextUtils.equals(admin.shortSupportMessage, message)) {
                admin.shortSupportMessage = message;
                saveSettingsLocked(caller.getUserId());
            }
        }
        DevicePolicyEventLogger
                .createEvent(DevicePolicyEnums.SET_SHORT_SUPPORT_MESSAGE)
                .setAdmin(who)
                .write();
    }",1
"@Override
  public Class<?> getType(ELContext context, Object base, Object property) {
    return super.getType(context, base, validatePropertyName(property));
  }",0
"private byte[] decryptBlock(
        byte[] in_enc,
        int inOff,
        int inLen)
        throws InvalidCipherTextException
    {
        byte[] M, K, K1, K2;
        int len = 0;

        // Ensure that the length of the input is greater than the MAC in bytes
        if (inLen < V.length + mac.getMacSize())
        {
            throw new InvalidCipherTextException(""Length of input must be greater than the MAC and V combined"");
        }

        // note order is important: set up keys, do simple encryptions, check mac, do final encryption.
        if (cipher == null)
        {
            // Streaming mode.
            K1 = new byte[inLen - V.length - mac.getMacSize()];
            K2 = new byte[param.getMacKeySize() / 8];
            K = new byte[K1.length + K2.length];

            kdf.generateBytes(K, 0, K.length);

            if (V.length != 0)
            {
                System.arraycopy(K, 0, K2, 0, K2.length);
                System.arraycopy(K, K2.length, K1, 0, K1.length);
            }
            else
            {
                System.arraycopy(K, 0, K1, 0, K1.length);
                System.arraycopy(K, K1.length, K2, 0, K2.length);
            }

            // process the message
            M = new byte[K1.length];

            for (int i = 0; i != K1.length; i++)
            {
                M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);
            }
        }
        else
        {
            // Block cipher mode.        
            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];
            K2 = new byte[param.getMacKeySize() / 8];
            K = new byte[K1.length + K2.length];

            kdf.generateBytes(K, 0, K.length);
            System.arraycopy(K, 0, K1, 0, K1.length);
            System.arraycopy(K, K1.length, K2, 0, K2.length);

            // If IV provide use it to initialize the cipher
            if (IV != null)
            {
                cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));
            }
            else
            {
                cipher.init(false, new KeyParameter(K1));
            }

            M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];

            // do initial processing
            len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);
        }

        // Convert the length of the encoding vector into a byte array.
        byte[] P2 = param.getEncodingV();
        byte[] L2 = null;
        if (V.length != 0)
        {
            L2 = getLengthTag(P2);
        }

        // Verify the MAC.
        int end = inOff + inLen;
        byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);

        byte[] T2 = new byte[T1.length];
        mac.init(new KeyParameter(K2));
        mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);

        if (P2 != null)
        {
            mac.update(P2, 0, P2.length);
        }
        if (V.length != 0)
        {
            mac.update(L2, 0, L2.length);
        }
        mac.doFinal(T2, 0);

        if (!Arrays.constantTimeAreEqual(T1, T2))
        {
            throw new InvalidCipherTextException(""invalid MAC"");
        }

        if (cipher == null)
        {
            return M;
        }
        else
        {
            len += cipher.doFinal(M, len);

            return Arrays.copyOfRange(M, 0, len);
        }
    }",1
"@Override
    public Response processControlCommand(ControlCommand command) throws Exception {
        return null;
    }",1
"public ApiClient setBasePath(String basePath) {
    this.basePath = basePath;
    setOauthBasePath(basePath);
    return this;
  }",0
"public String getJdbc() {
        if (StringUtils.isEmpty(extraParams.trim())) {
            return ""jdbc:mysql://HOSTNAME:PORT/DATABASE""
                    .replace(""HOSTNAME"", getHost().trim())
                    .replace(""PORT"", getPort().toString().trim())
                    .replace(""DATABASE"", getDataBase().trim());
        } else {
            for (String illegalParameter : illegalParameters) {
                if (getExtraParams().contains(illegalParameter)) {
                    throw new RuntimeException(""Illegal parameter: "" + illegalParameter);
                }
            }

            return ""jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS""
                    .replace(""HOSTNAME"", getHost().trim())
                    .replace(""PORT"", getPort().toString().trim())
                    .replace(""DATABASE"", getDataBase().trim())
                    .replace(""EXTRA_PARAMS"", getExtraParams().trim());
        }
    }",1
"@Override
    public Collection<CertRequestInfo> getEntries() {
        return super.getEntries();
    }",0
"public ApiClient configureApiKeys(Map<String, String> secrets) {
    for (Map.Entry<String, Authentication> authEntry : authentications.entrySet()) {
      Authentication auth = authEntry.getValue();
      if (auth instanceof ApiKeyAuth) {
        String name = authEntry.getKey();
        // respect x-auth-id-alias property
        name = authenticationLookup.containsKey(name) ? authenticationLookup.get(name) : name;
        if (secrets.containsKey(name)) {
          ((ApiKeyAuth) auth).setApiKey(secrets.get(name));
        }
      }
    }
    return this;
  }",0
"void keyValueAgentCleanup() {
            mBackupDataName.delete();
            mStageName.delete();
            try { if (mBackupData != null) mBackupData.close(); } catch (IOException e) {}
            try { if (mNewState != null) mNewState.close(); } catch (IOException e) {}
            mBackupData = mNewState = null;

            // if everything went okay, remember the recorded state now
            //
            // !!! TODO: the restored data could be migrated on the server
            // side into the current dataset.  In that case the new state file
            // we just created would reflect the data already extant in the
            // backend, so there'd be nothing more to do.  Until that happens,
            // however, we need to make sure that we record the data to the
            // current backend dataset.  (Yes, this means shipping the data over
            // the wire in both directions.  That's bad, but consistency comes
            // first, then efficiency.)  Once we introduce server-side data
            // migration to the newly-restored device's dataset, we will change
            // the following from a discard of the newly-written state to the
            // ""correct"" operation of renaming into the canonical state blob.
            mNewStateName.delete();                      // TODO: remove; see above comment
            //mNewStateName.renameTo(mSavedStateName);   // TODO: replace with this

            // If this wasn't the PM pseudopackage, tear down the agent side
            if (mCurrentPackage.applicationInfo != null) {
                // unbind and tidy up even on timeout or failure
                try {
                    mActivityManager.unbindBackupAgent(mCurrentPackage.applicationInfo);

                    // The agent was probably running with a stub Application object,
                    // which isn't a valid run mode for the main app logic.  Shut
                    // down the app so that next time it's launched, it gets the
                    // usual full initialization.  Note that this is only done for
                    // full-system restores: when a single app has requested a restore,
                    // it is explicitly not killed following that operation.
                    //
                    // We execute this kill when these conditions hold:
                    //    1. the app did not request its own restore (mTargetPackage == null), and either
                    //    2a. the app is a full-data target (TYPE_FULL_STREAM) or
                    //     b. the app does not state android:killAfterRestore=""false"" in its manifest
                    final int appFlags = mCurrentPackage.applicationInfo.flags;
                    final boolean killAfterRestore =
                            (mRestoreDescription.getDataType() == RestoreDescription.TYPE_FULL_STREAM)
                            || ((appFlags & ApplicationInfo.FLAG_KILL_AFTER_RESTORE) != 0);

                    if (mTargetPackage == null && killAfterRestore) {
                        if (DEBUG) Slog.d(TAG, ""Restore complete, killing host process of ""
                                + mCurrentPackage.applicationInfo.processName);
                        mActivityManager.killApplicationProcess(
                                mCurrentPackage.applicationInfo.processName,
                                mCurrentPackage.applicationInfo.uid);
                    }
                } catch (RemoteException e) {
                    // can't happen; we run in the same process as the activity manager
                }
            }

            // The caller is responsible for reestablishing the state machine; our
            // responsibility here is to clear the decks for whatever comes next.
            mBackupHandler.removeMessages(MSG_TIMEOUT, this);
            synchronized (mCurrentOpLock) {
                mCurrentOperations.clear();
            }
        }",0
"static String renderTopNav2(HttpServletRequest request) {
        String topNav = KVStorage.getCustomValue(""TopNav32"");
        if (!JSONUtils.wellFormat(topNav)) return StringUtils.EMPTY;

        JSONArray sets = JSON.parseArray(topNav);
        if (sets.isEmpty()) return StringUtils.EMPTY;

        final ID user = AppUtils.getRequestUser(request);
        final boolean isAdmin = UserHelper.isAdmin(user);
        final Object[][] alls = instance.getAllConfig(null, TYPE_NAV);

        StringBuilder topNavHtml = new StringBuilder();

        for (Object nd : sets) {
            JSONArray ndAnd = (JSONArray) nd;
            String nav = ndAnd.getString(0);
            String dash = ndAnd.getString(1);

            ID useNav = ID.isId(nav) ? ID.valueOf(nav) : null;
            if (useNav == null) continue;

            for (Object[] d : alls) {
                if (!useNav.equals(d[0])) continue;
                // 管理员、有共享的
                if ((isAdmin && RoleService.ADMIN_ROLE.equals(d[5])) || instance.isShareTo((String) d[1], user)) {
                    String url = AppUtils.getContextPath(""/app/home?n="" + useNav);
                    if (ID.isId(dash)) url += ""&d="" + dash;
                    String name = StringUtils.defaultIfBlank((String) d[4], Language.L(""未命名""));

                    topNavHtml.append(
                            String.format(""<li class=\""nav-item\"" data-id=\""%s\""><a class=\""nav-link text-ellipsis\"" href=\""%s\"">%s</a></li>"", useNav, url, name));
                    break;
                }
            }
        }
        return topNavHtml.toString();
    }",1
"public void add(Structure st){
    	if(st==null || !UtilMethods.isSet(st.getInode())){
    		return;
    	}
		// we use the identifier uri for our mappings.
		String inode = st.getInode();
        String structureName = st.getName();
        String velocityVarName = st.getVelocityVarName();
		cache.put(primaryGroup + inode, st, primaryGroup);
        cache.put(primaryGroup + structureName, st, primaryGroup);
        cache.put(primaryGroup + velocityVarName, st, primaryGroup);
        if (UtilMethods.isSet(velocityVarName))
        	cache.put(primaryGroup + velocityVarName.toLowerCase(), st, primaryGroup);
        removeStructuresByType(st.getStructureType());
	}",1
"@Override
        public void handleMessage(android.os.Message msg) {
            switch(msg.what) {
                case MSG_ENROLL_RESULT:
                    sendEnrollResult((Fingerprint) msg.obj, msg.arg1 /* remaining */);
                    break;
                case MSG_ACQUIRED:
                    sendAcquiredResult((Long) msg.obj /* deviceId */, msg.arg1 /* acquire info */);
                    break;
                case MSG_AUTHENTICATION_SUCCEEDED:
                    sendAuthenticatedSucceeded((Fingerprint) msg.obj, msg.arg1 /* userId */);
                    break;
                case MSG_AUTHENTICATION_FAILED:
                    sendAuthenticatedFailed();
                    break;
                case MSG_ERROR:
                    sendErrorResult((Long) msg.obj /* deviceId */, msg.arg1 /* errMsgId */);
                    break;
                case MSG_REMOVED:
                    sendRemovedResult((Long) msg.obj /* deviceId */, msg.arg1 /* fingerId */,
                            msg.arg2 /* groupId */);
            }
        }",1
"@Override
    public final boolean finishActivity(IBinder token, int resultCode, Intent resultData,
            boolean finishTask) {
        // Refuse possible leaked file descriptors
        if (resultData != null && resultData.hasFileDescriptors() == true) {
            throw new IllegalArgumentException(""File descriptors passed in Intent"");
        }

        synchronized(this) {
            ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r == null) {
                return true;
            }
            // Keep track of the root activity of the task before we finish it
            TaskRecord tr = r.task;
            ActivityRecord rootR = tr.getRootActivity();
            if (rootR == null) {
                Slog.w(TAG, ""Finishing task with all activities already finished"");
            }
            // Do not allow task to finish in Lock Task mode.
            if (tr == mStackSupervisor.mLockTaskModeTask) {
                if (rootR == r) {
                    Slog.i(TAG, ""Not finishing task in lock task mode"");
                    mStackSupervisor.showLockTaskToast();
                    return false;
                }
            }
            if (mController != null) {
                // Find the first activity that is not finishing.
                ActivityRecord next = r.task.stack.topRunningActivityLocked(token, 0);
                if (next != null) {
                    // ask watcher if this is allowed
                    boolean resumeOK = true;
                    try {
                        resumeOK = mController.activityResuming(next.packageName);
                    } catch (RemoteException e) {
                        mController = null;
                        Watchdog.getInstance().setActivityController(null);
                    }

                    if (!resumeOK) {
                        Slog.i(TAG, ""Not finishing activity because controller resumed"");
                        return false;
                    }
                }
            }
            final long origId = Binder.clearCallingIdentity();
            try {
                boolean res;
                if (finishTask && r == rootR) {
                    // If requested, remove the task that is associated to this activity only if it
                    // was the root activity in the task. The result code and data is ignored
                    // because we don't support returning them across task boundaries.
                    res = removeTaskByIdLocked(tr.taskId, false);
                    if (!res) {
                        Slog.i(TAG, ""Removing task failed to finish activity"");
                    }
                } else {
                    res = tr.stack.requestFinishActivityLocked(token, resultCode,
                            resultData, ""app-request"", true);
                    if (!res) {
                        Slog.i(TAG, ""Failed to finish by app-request"");
                    }
                }
                return res;
            } finally {
                Binder.restoreCallingIdentity(origId);
            }
        }
    }",0
"private Stream<MapResult> xmlXpathToMapResult(@Name(""url"") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {
        if (config == null) config = Collections.emptyMap();
        boolean failOnError = (boolean) config.getOrDefault(""failOnError"", true);
        List<MapResult> result = new ArrayList<>();
        try {
            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
            documentBuilderFactory.setNamespaceAware(true);
            documentBuilderFactory.setIgnoringElementContentWhitespace(true);
            documentBuilderFactory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();

            FileUtils.checkReadAllowed(url);

            Map<String, Object> headers = (Map) config.getOrDefault( ""headers"", Collections.emptyMap() );

            Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));
            XPathFactory xPathFactory = XPathFactory.newInstance();

            XPath xPath = xPathFactory.newXPath();

            path = StringUtils.isEmpty(path) ? ""/"" : path;
            XPathExpression xPathExpression = xPath.compile(path);
            NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);

            for (int i = 0; i < nodeList.getLength(); i++) {
                final Deque<Map<String, Object>> stack = new LinkedList<>();

                handleNode(stack, nodeList.item(i), simpleMode);
                for (int index = 0; index < stack.size(); index++) {
                    result.add(new MapResult(stack.pollFirst()));
                }
            }
        }
        catch (FileNotFoundException e){
            if(!failOnError)
                return Stream.of(new MapResult(Collections.emptyMap()));
            else
                throw new FileNotFoundException(e.getMessage());
        }
        catch (Exception e){
            if(!failOnError)
                return Stream.of(new MapResult(Collections.emptyMap()));
            else
                throw new Exception(e);
        }
        return result.stream();
    }",1
"@Override
	protected int getExpectedErrors() {
		return 2;
	}",1
"public void setURLPrefix(String newURLPrefix)
        {
            RestTestUtils.urlPrefix = newURLPrefix;
        }",0
"@GetMapping(""/ws/current/member/list"")
    public List<User> getCurrentWorkspaceMember() {
        SessionUser user = SessionUtils.getUser();
        Optional<UserGroup> any = user.getUserGroups().stream()
                .filter(ug -> (ug.getSourceId().equals(SessionUtils.getCurrentWorkspaceId()) || ug.getGroupId().equals(UserGroupConstants.SUPER_GROUP)))
                .findAny();
        if (any.isEmpty()) {
            return new ArrayList<>();
        }
        QueryMemberRequest request = new QueryMemberRequest();
        request.setWorkspaceId(SessionUtils.getCurrentWorkspaceId());
        return baseUserService.getMemberList(request);
    }",1
"public JNLPClassLoader getParentJNLPClassLoader() {
            return parentJNLPClassLoader;
        }",0
"protected void createPage(List<String> spaces, String pageName, String content) throws Exception
    {
        String uri = buildURI(PageResource.class, getWiki(), spaces, pageName);

        Page page = this.objectFactory.createPage();
        page.setContent(content);

        PutMethod putMethod = executePutXml(uri, page, TestUtils.SUPER_ADMIN_CREDENTIALS.getUserName(),
            TestUtils.SUPER_ADMIN_CREDENTIALS.getPassword());
        Assert.assertEquals(getHttpMethodInfo(putMethod), HttpStatus.SC_CREATED, putMethod.getStatusCode());
    }",0
"public User getUser() {
            return userId == null
                    ? User.getUnknown()
                    : User.getById(userId, true)
            ;
        }",1
"@Override
  public Route.Collection put(final String path1, final String path2,
      final Route.ZeroArgHandler handler) {
    return new Route.Collection(
        new Route.Definition[]{put(path1, handler), put(path2, handler)});
  }",0
"@HotPath(caller = HotPath.OOM_ADJUSTMENT)
        @Override
        public void onUidProcStateChanged(int uid, int procState) {
            mActiveUids.onUidProcStateChanged(uid, procState);
        }",0
"@Override
	public Controller execute(FolderComponent fc, UserRequest ureq, WindowControl windowControl, Translator trans) {
		this.folderComponent = fc;
		this.translator = trans;
		this.fileSelection = new FileSelection(ureq, fc.getCurrentContainer(), fc.getCurrentContainerPath());
				
		VelocityContainer main = new VelocityContainer(""mc"", VELOCITY_ROOT + ""/movecopy.html"", translator, this);
		main.contextPut(""fileselection"", fileSelection);
		
		//check if command is executed on a file list containing invalid filenames or paths
		if(!fileSelection.getInvalidFileNames().isEmpty()) {		
			main.contextPut(""invalidFileNames"", fileSelection.getInvalidFileNames());
		}		

		selTree = new MenuTree(null, ""seltree"", this);
		FolderTreeModel ftm = new FolderTreeModel(ureq.getLocale(), fc.getRootContainer(),
				true, false, true, fc.getRootContainer().canWrite() == VFSConstants.YES, new EditableFilter());
		selTree.setTreeModel(ftm);
		selectButton = LinkFactory.createButton(move ? ""move"" : ""copy"", main, this);
		cancelButton = LinkFactory.createButton(""cancel"", main, this);

		main.put(""seltree"", selTree);
		if (move) {
			main.contextPut(""move"", Boolean.TRUE);
		}

		setInitialComponent(main);
		return this;
	}",1
"public StringWriter convertToMmt(InputStream stream)
    {
        ViewUtils.Debug(this, ""Converting SMath Studio file "" + fileName);
        try
        {
            // Source document
            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            // https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet
            factory.setExpandEntityReferences(false);
            final DocumentBuilder builder = factory.newDocumentBuilder();
            final Document doc = builder.parse(stream);
            final Node objects = doc.getDocumentElement();
            List<Element> metadata = null;
            final List<Element> regions = new ArrayList<>();
            for (Node object = objects.getFirstChild(); object != null; object = object.getNextSibling())
            {
                if (object instanceof Element)
                {
                    final Element e = (Element) object;
                    if (e.getTagName().equals(""settings""))
                    {
                        metadata = XmlUtils.getElements(e, ""metadata"");
                    }
                    else
                    {
                        regions.add(e);
                    }
                }
            }

            // Target document
            final StringWriter writer = new StringWriter();
            final XmlSerializer serializer = Xml.newSerializer();
            serializer.setFeature(""http://xmlpull.org/v1/doc/features.html#indent-output"", true);
            serializer.setOutput(writer);
            serializer.startDocument(""UTF-8"", true);
            serializer.setPrefix(FormulaList.XML_PROP_MMT, FormulaList.XML_MMT_SCHEMA);
            serializer.startTag(FormulaList.XML_NS, FormulaList.XML_MAIN_TAG);
            serializer.startTag(FormulaList.XML_NS, FormulaList.XML_LIST_TAG);
            serializer.attribute(FormulaList.XML_NS, DocumentProperties.XML_PROP_VERSION, ""2"");
            if (metadata != null)
            {
                parseMetadata(metadata, serializer);
            }
            serializer.attribute(FormulaList.XML_NS, DocumentProperties.XML_PROP_REDEFINE_ALLOWED, ""true"");

            Element prevRegion = null;
            for (Element e : regions)
            {
                if (""region"".equals(e.getTagName()))
                {
                    parseRegion(e, prevRegion, serializer);
                    prevRegion = e;
                }
            }

            serializer.endTag(FormulaList.XML_NS, FormulaList.XML_LIST_TAG);
            serializer.endTag(FormulaList.XML_NS, FormulaList.XML_MAIN_TAG);
            serializer.endDocument();

            /*
            InputStream s = new ByteArrayInputStream(writer.toString().getBytes());
            BufferedReader reader = new BufferedReader(new InputStreamReader(s));
            while (reader.ready())
            {
                String line = reader.readLine();
                ViewUtils.Debug(this, line);
            }
            */

            return writer;
        }
        catch (Exception e)
        {
            ViewUtils.Debug(this, ""Error: "" + e.getLocalizedMessage());
            return null;
        }
    }",1
"public @Nullable SystemUpdateInfo getPendingSystemUpdate(@NonNull ComponentName admin) {
        throwIfParentInstance(""getPendingSystemUpdate"");
        try {
            return mService.getPendingSystemUpdate(admin);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }",0
"default Document parseXmlSafely(final int contentLength, final Reader reader) throws WebdavException {
    if (contentLength == 0) {
      return null;
    }

    if (reader == null) {
      // No content?
      return null;
    }

    try {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      factory.setNamespaceAware(false);
      factory.setFeature(""http://javax.xml.XMLConstants/feature/secure-processing"", true);
      factory.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
      factory.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
      factory.setAttribute(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);

      DocumentBuilder builder = factory.newDocumentBuilder();

      return builder.parse(new InputSource(reader));
    } catch (SAXException exception) {
      throw new WebdavBadRequest(exception.getMessage());
    } catch (Throwable t) {
      throw new WebdavException(t);
    }
  }",1
"private void sendStreamingResponse(HttpExchange pExchange, ParsedUri pParsedUri, JSONStreamAware pJson) throws IOException {
        Headers headers = pExchange.getResponseHeaders();
        if (pJson != null) {
            headers.set(""Content-Type"", getMimeType(pParsedUri) + ""; charset=utf-8"");
            pExchange.sendResponseHeaders(200, 0);
            Writer writer = new OutputStreamWriter(pExchange.getResponseBody(), ""UTF-8"");

            String callback = pParsedUri.getParameter(ConfigKey.CALLBACK.getKeyValue());
            IoUtil.streamResponseAndClose(writer, pJson, callback != null && MimeTypeUtil.isValidCallback(callback) ? callback : null);
        } else {
            headers.set(""Content-Type"", ""text/plain"");
            pExchange.sendResponseHeaders(200,-1);
        }
    }",1
"private void readAccountInfoLocked() {
        int highestAuthorityId = -1;
        FileInputStream fis = null;
        try {
            fis = mAccountInfoFile.openRead();
            if (Log.isLoggable(TAG_FILE, Log.VERBOSE)) {
                Log.v(TAG_FILE, ""Reading "" + mAccountInfoFile.getBaseFile());
            }
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(fis, null);
            int eventType = parser.getEventType();
            while (eventType != XmlPullParser.START_TAG &&
                    eventType != XmlPullParser.END_DOCUMENT) {
                eventType = parser.next();
            }
            if (eventType == XmlPullParser.END_DOCUMENT) {
                Log.i(TAG, ""No initial accounts"");
                return;
            }

            String tagName = parser.getName();
            if (""accounts"".equals(tagName)) {
                String listen = parser.getAttributeValue(null, XML_ATTR_LISTEN_FOR_TICKLES);
                String versionString = parser.getAttributeValue(null, ""version"");
                int version;
                try {
                    version = (versionString == null) ? 0 : Integer.parseInt(versionString);
                } catch (NumberFormatException e) {
                    version = 0;
                }
                String nextIdString = parser.getAttributeValue(null, XML_ATTR_NEXT_AUTHORITY_ID);
                try {
                    int id = (nextIdString == null) ? 0 : Integer.parseInt(nextIdString);
                    mNextAuthorityId = Math.max(mNextAuthorityId, id);
                } catch (NumberFormatException e) {
                    // don't care
                }
                String offsetString = parser.getAttributeValue(null, XML_ATTR_SYNC_RANDOM_OFFSET);
                try {
                    mSyncRandomOffset = (offsetString == null) ? 0 : Integer.parseInt(offsetString);
                } catch (NumberFormatException e) {
                    mSyncRandomOffset = 0;
                }
                if (mSyncRandomOffset == 0) {
                    Random random = new Random(System.currentTimeMillis());
                    mSyncRandomOffset = random.nextInt(86400);
                }
                mMasterSyncAutomatically.put(0, listen == null || Boolean.parseBoolean(listen));
                eventType = parser.next();
                AuthorityInfo authority = null;
                PeriodicSync periodicSync = null;
                do {
                    if (eventType == XmlPullParser.START_TAG) {
                        tagName = parser.getName();
                        if (parser.getDepth() == 2) {
                            if (""authority"".equals(tagName)) {
                                authority = parseAuthority(parser, version);
                                periodicSync = null;
                                if (authority != null) {
                                    if (authority.ident > highestAuthorityId) {
                                        highestAuthorityId = authority.ident;
                                    }
                                } else {
                                    EventLog.writeEvent(0x534e4554, ""26513719"", -1,
                                            ""Malformed authority"");
                                }
                            } else if (XML_TAG_LISTEN_FOR_TICKLES.equals(tagName)) {
                                parseListenForTickles(parser);
                            }
                        } else if (parser.getDepth() == 3) {
                            if (""periodicSync"".equals(tagName) && authority != null) {
                                periodicSync = parsePeriodicSync(parser, authority);
                            }
                        } else if (parser.getDepth() == 4 && periodicSync != null) {
                            if (""extra"".equals(tagName)) {
                                parseExtra(parser, periodicSync.extras);
                            }
                        }
                    }
                    eventType = parser.next();
                } while (eventType != XmlPullParser.END_DOCUMENT);
            }
        } catch (XmlPullParserException e) {
            Log.w(TAG, ""Error reading accounts"", e);
            return;
        } catch (java.io.IOException e) {
            if (fis == null) Log.i(TAG, ""No initial accounts"");
            else Log.w(TAG, ""Error reading accounts"", e);
            return;
        } finally {
            mNextAuthorityId = Math.max(highestAuthorityId + 1, mNextAuthorityId);
            if (fis != null) {
                try {
                    fis.close();
                } catch (java.io.IOException e1) {
                }
            }
        }

        maybeMigrateSettingsForRenamedAuthorities();
    }",1
"@Override
    public void close() {
        synchronized (this) {
            if (mOpen) {
                mOpen = false;

                if (mOwnsNative) {
                    nativeDestroy(mNative);
                }
                mNative = 0;
            }
        }
    }",1
"@Override
    public boolean isRecognizedFormat(BufferedReader reader) throws IOException {
        Objects.requireNonNull(reader);

        /*
            The correct behavior is to return false if it is certain that the file is
            not of the MsBib type, and true otherwise. Returning true is the safe choice
            if not certain.
         */
        Document docin;
        try {
            DocumentBuilder dbuild = makeSafeDocBuilderFactory(DocumentBuilderFactory.newInstance()).newDocumentBuilder();
            dbuild.setErrorHandler(new ErrorHandler() {

                @Override
                public void warning(SAXParseException exception) throws SAXException {
                    // ignore warnings
                }

                @Override
                public void fatalError(SAXParseException exception) throws SAXException {
                    throw exception;
                }

                @Override
                public void error(SAXParseException exception) throws SAXException {
                    throw exception;
                }
            });

            docin = dbuild.parse(new InputSource(reader));
        } catch (Exception e) {
            return false;
        }
        return (docin == null) || docin.getDocumentElement().getTagName().contains(""Sources"");
    }",1
"private XMLReader createXMLReader() throws SAXException {
        SAXParser parser;
        try {
            parser = PARSER_FACTORY.newSAXParser();
        } catch (final ParserConfigurationException e) {
            throw ProcessException.wrap(e);
        }
        return parser.getXMLReader();
    }",1
"private void addResources() {
		add(new BaseResourceMapper(""downloads/server-log"", new ServerLogResourceReference()));
		add(new BaseResourceMapper(""downloads/projects/${project}/builds/${build}/log"", new BuildLogResourceReference()));
		add(new BaseResourceMapper(""projects/${project}/archive/${revision}"", new ArchiveResourceReference()));
		add(new DynamicPathResourceMapper(""projects/${project}/raw/${revision}/${path}"", new RawBlobResourceReference()));
		add(new BaseResourceMapper(""projects/${project}/attachment/${uuid}/${attachment}"", new AttachmentResourceReference()));
		add(new DynamicPathResourceMapper(""downloads/projects/${project}/builds/${build}/artifacts/${path}"", 
				new ArtifactResourceReference()));
		add(new BaseResourceMapper(SvgSpriteResourceReference.DEFAULT_MOUNT_PATH, new SvgSpriteResourceReference(IconScope.class)));
	}",0
"@Override
        public void setUserSelectedOutgoingPhoneAccount(PhoneAccountHandle accountHandle) {
            try {
                Log.startSession(""TSI.sUSOPA"");
                synchronized (mLock) {
                    enforceModifyPermission();
                    UserHandle callingUserHandle = Binder.getCallingUserHandle();
                    long token = Binder.clearCallingIdentity();
                    try {
                        mPhoneAccountRegistrar.setUserSelectedOutgoingPhoneAccount(
                                accountHandle, callingUserHandle);
                    } catch (Exception e) {
                        Log.e(this, e, ""setUserSelectedOutgoingPhoneAccount"");
                        throw e;
                    } finally {
                        Binder.restoreCallingIdentity(token);
                    }
                }
            } finally {
                Log.endSession();
            }
        }",0
"public static TransformerHandler createTransformerHandler(final boolean indentOutput)
            throws TransformerConfigurationException {
        return createTransformerHandler(null, indentOutput);
    }",0
"private boolean changeEncoding(String charset) {
			if (charset == null || fByteStream == null) {
				return false;
			}
			charset = charset.trim();
			boolean encodingChanged = false;
			try {
			    String ianaEncoding = charset;
			    String javaEncoding = EncodingMap.getIANA2JavaMapping(ianaEncoding.toUpperCase(Locale.ENGLISH));
			    if (DEBUG_CHARSET) {
			        System.out.println(""+++ ianaEncoding: ""+ianaEncoding);
			        System.out.println(""+++ javaEncoding: ""+javaEncoding);
			    }
			    if (javaEncoding == null) {
			        javaEncoding = ianaEncoding;
			        if (fReportErrors) {
			            fErrorReporter.reportError(""HTML1001"", new Object[]{ianaEncoding});
			        }
			    }
			    // patch: Marc Guillemot
			    if (!javaEncoding.equals(fJavaEncoding)) { 
			      	if (!isEncodingCompatible(javaEncoding, fJavaEncoding)) {
			            if (fReportErrors) {
			                fErrorReporter.reportError(""HTML1015"", new Object[]{javaEncoding,fJavaEncoding});
			            }
			     	}
			  		// change the charset
			     	else {
			            fIso8859Encoding = ianaEncoding == null 
			                    || ianaEncoding.toUpperCase(Locale.ENGLISH).startsWith(""ISO-8859"")
			                    || ianaEncoding.equalsIgnoreCase(fDefaultIANAEncoding);
			            fJavaEncoding = javaEncoding;
			            fCurrentEntity.setStream(new InputStreamReader(fByteStream, javaEncoding));
			            fByteStream.playback();
			            fElementDepth = fElementCount;
			            fElementCount = 0;
	                    encodingChanged = true;
			     	}
			     }
			}
			catch (UnsupportedEncodingException e) {
			    if (fReportErrors) {
			        fErrorReporter.reportError(""HTML1010"", new Object[]{charset});
			    }
			    // NOTE: If the encoding change doesn't work, 
			    //       then there's no point in continuing to 
			    //       buffer the input stream.
			    fByteStream.clear();
			    fByteStream = null;
			}
			return encodingChanged;
		}",0
"private void processForm (Context context,
        HttpServletRequest request,
        HttpServletResponse response)
        throws ServletException, IOException, SQLException, AuthorizeException
    {
    	boolean showRequestCopy = false;
		if (""all"".equalsIgnoreCase(ConfigurationManager.getProperty(""request.item.type"")) || 
				(""logged"".equalsIgnoreCase(ConfigurationManager.getProperty(""request.item.type"")) &&
						context.getCurrentUser() != null))
		{
			showRequestCopy = true;
		}
		
		if (!showRequestCopy)
		{
			throw new AuthorizeException(""The request copy feature is disabled"");
		}
		
        // handle
        String handle = request.getParameter(""handle"");
        
        int  bitstream_id= UIUtil.getIntParameter(request, ""bitstream-id"");
        
        // Title
        String title = null;
        Item item = null;
        if (StringUtils.isNotBlank(handle))
        {
            item = (Item) HandleManager.resolveToObject(context, handle);
            
        }
        if (item == null)
        {   
        	JSPManager.showInvalidIDError(request, response, handle, -1);
        }
        Metadatum[] titleDC = item.getDC(""title"", null, Item.ANY);
        if (titleDC != null || titleDC.length > 0)
        {
            title = titleDC[0].value;
        }
        else
		{
			title = I18nUtil.getMessage(""jsp.general.untitled"", context);
		}
          
        // User email from context
        String requesterEmail = StringEscapeUtils.escapeHtml4(request.getParameter(""email""));
        EPerson currentUser = context.getCurrentUser();
        String userName = null;
        
        if (currentUser != null)
        {
            requesterEmail = currentUser.getEmail();
            userName = currentUser.getFullName();
        }
        
        if (request.getParameter(""submit"") != null)
        {
            String reqname = StringEscapeUtils.escapeHtml4(request.getParameter(""reqname""));
            String coment = StringEscapeUtils.escapeHtml4(request.getParameter(""coment""));
            if (coment == null || coment.equals(""""))
                coment = """";
            boolean allfiles = ""true"".equals(request.getParameter(""allfiles""));
            
            // Check all data is there
            if (requesterEmail == null || requesterEmail.equals("""") ||
                reqname == null || reqname.equals("""")) 
            {
                request.setAttribute(""handle"",handle);
                request.setAttribute(""bitstream-id"", bitstream_id);
                request.setAttribute(""reqname"", reqname);
                request.setAttribute(""email"", requesterEmail);
                request.setAttribute(""coment"", coment);
                request.setAttribute(""title"", title); 
                request.setAttribute(""allfiles"", allfiles?""true"":null); 
                
                request.setAttribute(""requestItem.problem"", new Boolean(true));
                JSPManager.showJSP(request, response, ""/requestItem/request-form.jsp"");
                return;
            }

            try
            {
                // All data is there, send the email
				Email email = Email.getEmail(I18nUtil.getEmailFilename(
						context.getCurrentLocale(), ""request_item.author""));
				
				RequestItemAuthor author = new DSpace()
						.getServiceManager()
						.getServiceByName(
								RequestItemAuthorExtractor.class.getName(),
								RequestItemAuthorExtractor.class)
						.getRequestItemAuthor(context, item);
				
				String authorEmail = author.getEmail();
				String authorName = author.getFullName();
				
				email.addRecipient(authorEmail);

				email.addArgument(reqname);
				email.addArgument(requesterEmail);
				email.addArgument(allfiles ? I18nUtil
						.getMessage(""itemRequest.all"") : Bitstream.find(
						context, bitstream_id).getName());
				email.addArgument(HandleManager.getCanonicalForm(item
						.getHandle()));
				email.addArgument(title); // request item title
				email.addArgument(coment); // message
				email.addArgument(RequestItemManager.getLinkTokenEmail(context,
						bitstream_id, item.getID(), requesterEmail, reqname,
						allfiles));
				
				email.addArgument(authorName); // corresponding author name
				email.addArgument(authorEmail); // corresponding author email
				email.addArgument(ConfigurationManager
						.getProperty(""dspace.name""));
				email.addArgument(ConfigurationManager
						.getProperty(""mail.helpdesk""));
				email.setReplyTo(requesterEmail);
				email.send();

                log.info(LogManager.getHeader(context,
                    ""sent_email_requestItem"",
                    ""submitter_id="" + requesterEmail
                        + "",bitstream_id=""+bitstream_id
                        + "",requestEmail=""+requesterEmail));

                request.setAttribute(""handle"", handle);
                JSPManager.showJSP(request, response,
                    ""/requestItem/request-send.jsp"");
            }
            catch (MessagingException me)
            {
                log.warn(LogManager.getHeader(context,
                    ""error_mailing_requestItem"",
                    """"), me);
               JSPManager.showInternalError(request, response);
            }
        }
        else
        {
            // Display request copy form
            log.info(LogManager.getHeader(context,
                ""show_requestItem_form"",
                ""problem=false""));
            request.setAttribute(""handle"", handle);
            request.setAttribute(""bitstream-id"", bitstream_id);
            request.setAttribute(""email"", requesterEmail);
            request.setAttribute(""reqname"", userName);
            request.setAttribute(""title"", title);
            request.setAttribute(""allfiles"", ""true"");
            JSPManager.showJSP(request, response, ""/requestItem/request-form.jsp""); 
        }
   }",1
"public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)
            throws PresentationException, IndexUnreachableException {
        //make sure fileName is a pure filename and not a path
        fileName = Paths.get(fileName).getFileName().toString();
        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);
        if (StringUtils.isNotBlank(fileName)) {
            dataFolderPath = dataFolderPath.resolve(fileName);
        }
        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {
            return getDataFilePath(pi, altDataFolderName, null, fileName);
        }

        return dataFolderPath;
    }",1
"@SystemApi
    @RequiresPermission(Manifest.permission.MANAGE_ONE_TIME_PERMISSION_SESSIONS)
    public void startOneTimePermissionSession(@NonNull String packageName,
            @DurationMillisLong long timeoutMillis,
            @DurationMillisLong long revokeAfterKilledDelayMillis,
            @ActivityManager.RunningAppProcessInfo.Importance int importanceToResetTimer,
            @ActivityManager.RunningAppProcessInfo.Importance int importanceToKeepSessionAlive) {
        try {
            mPermissionManager.startOneTimePermissionSession(packageName, mContext.getUserId(),
                    timeoutMillis, revokeAfterKilledDelayMillis);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
    }",1
"@Column(name = ""ip"", length = 130)
    public String getIp() {
        return this.ip;
    }",1
"protected void copyResponse(InputStream is, OutputStream out, byte[] head,
			boolean base64) throws IOException
	{
		if (base64)
		{
			int total = 0;

			try (BufferedInputStream in = new BufferedInputStream(is,
					BUFFER_SIZE))
			{
				ByteArrayOutputStream os = new ByteArrayOutputStream();
			    byte[] buffer = new byte[0xFFFF];

				os.write(head, 0, head.length);
				
			    for (int len = is.read(buffer); len != -1; len = is.read(buffer))
			    {
					total += len;

					if (total > MAX_FETCH_SIZE)
					{
						throw new IOException(""Size limit exceeded"");
					}

			        os.write(buffer, 0, len);
			    }

				out.write(mxBase64.encodeToString(os.toByteArray(), false).getBytes());
			}
		}
		else
		{
			out.write(head);
			Utils.copyRestricted(is, out, MAX_FETCH_SIZE);
		}
	}",1
"@Override
	public OnGoingLogicalCondition notBetween(T from, T to) {
		Condition conditionLocal = new BetweenCondition<T>(new NotSelector(selector),
				Arrays.asList(selector.generateParameter(from), selector.generateParameter(to)));
		return getOnGoingLogicalCondition(conditionLocal);
	}",0
"@Nullable
	protected AttachmentSupport getAttachmentSupport() {
		return null;
	}",0
"@Override
    public AppWidgetProviderInfo getAppWidgetInfo(String callingPackage, int appWidgetId) {
        final int userId = UserHandle.getCallingUserId();

        if (DEBUG) {
            Slog.i(TAG, ""getAppWidgetInfo() "" + userId);
        }

        // Make sure the package runs under the caller uid.
        mSecurityPolicy.enforceCallFromPackage(callingPackage);

        synchronized (mLock) {
            ensureGroupStateLoadedLocked(userId);

            // NOTE: The lookup is enforcing security across users by making
            // sure the caller can only access widgets it hosts or provides.
            Widget widget = lookupWidgetLocked(appWidgetId,
                    Binder.getCallingUid(), callingPackage);

            if (widget != null && widget.provider != null && !widget.provider.zombie) {
                return cloneIfLocalBinder(widget.provider.info);
            }

            return null;
        }
    }",0
"@ApiOperation(value = ""Clear Composite Solution Operation"")
	@RequestMapping(value = ""/clearCompositeSolution"", method = RequestMethod.POST)
	@ResponseBody
	public String clearCompositeSolution(@RequestParam(value = ""userId"", required = true) String userId,
			@RequestParam(value = ""solutionId"", required = false) String solutionId,
			@RequestParam(value = ""solutionVersion"", required = false) String solutionVersion,
			@RequestParam(value = ""cid"", required = false) String cid) {
		logger.debug(EELFLoggerDelegator.debugLogger, "" clearCompositeSolution(): Begin "");
		String result = """";
		try {
			result = compositeServiceImpl.clearCompositeSolution(userId, SanitizeUtils.sanitize(solutionId), solutionVersion, cid);
		} catch (Exception e) {
			logger.error(EELFLoggerDelegator.errorLogger, "" Exception in clearCompositeSolution() "", e);
		}
		logger.debug(EELFLoggerDelegator.debugLogger, "" clearCompositeSolution(): End "");
		return result;

	}",1
"public HttpRequest verifyHttpsHost(final boolean verifyHttpsHost) {
		this.verifyHttpsHost = verifyHttpsHost;
		return this;
	}",0
"public TList readListBegin() throws TException {
    byte type = readByte();
    int size = readI32();
    ensureContainerHasEnough(size, type);
    return new TList(type, size);
  }",1
"public String getExternalURL(String action, String querystring, XWikiContext context)
    {
        URL url = context.getURLFactory().createExternalURL(getSpace(), getName(), action, querystring, null,
            getDatabase(), context);
        return url.toString();
    }",0
"private CleanerProperties getDefaultCleanerProperties(HTMLCleanerConfiguration configuration)
    {
        CleanerProperties defaultProperties = new CleanerProperties();
        defaultProperties.setOmitUnknownTags(true);

        // HTML Cleaner uses the compact notation by default but we don't want that since:
        // - it's more work and not required since not compact notation is valid XHTML
        // - expanded elements can also be rendered fine in browsers that only support HTML.
        defaultProperties.setUseEmptyElementTags(false);

        // Wrap script and style content in CDATA blocks
        defaultProperties.setUseCdataForScriptAndStyle(true);

        // We need this for example to ignore CDATA sections not inside script or style elements.
        defaultProperties.setIgnoreQuestAndExclam(true);

        // Remove CDATA outside of script and style since according to the spec it has no effect there.
        defaultProperties.setOmitCdataOutsideScriptAndStyle(true);

        // If the caller has defined NAMESPACE_AWARE configuration property then use it, otherwise use our default.
        String param = configuration.getParameters().get(HTMLCleanerConfiguration.NAMESPACES_AWARE);
        boolean namespacesAware = (param == null) || Boolean.parseBoolean(param);
        defaultProperties.setNamespacesAware(namespacesAware);

        // Set Cleaner transformations
        defaultProperties.setCleanerTransformations(getDefaultCleanerTransformations(configuration));

        // Don't convert special HTML entities (i.e. &ocirc;, &permil;, &times;) with unicode characters they represent.
        defaultProperties.setTranslateSpecialEntities(false);

        // Use character references rather than entity references if needed (for instance if you need to parse the
        // output as XML)
        param = configuration.getParameters().get(HTMLCleanerConfiguration.USE_CHARACTER_REFERENCES);
        boolean useCharacterReferences = (param != null) && Boolean.parseBoolean(param);
        defaultProperties.setTransResCharsToNCR(useCharacterReferences);

        // Sets the HTML version from the configuration (by default 4).
        defaultProperties.setHtmlVersion(getHTMLVersion(configuration));

        // We trim values by default for all attributes but the input value attribute.
        // The only way to currently do that is to switch off this flag, and to create a dedicated TagTransformation.
        // See TrimAttributeCleanerTransformation for more information.
        defaultProperties.setTrimAttributeValues(false);

        // This flag should be set to true once https://sourceforge.net/p/htmlcleaner/bugs/221/ is fixed.
        defaultProperties.setRecognizeUnicodeChars(false);

        param = configuration.getParameters().get(HTMLCleanerConfiguration.TRANSLATE_SPECIAL_ENTITIES);
        boolean translateSpecialEntities = (param != null) && Boolean.parseBoolean(param);
        defaultProperties.setTranslateSpecialEntities(translateSpecialEntities);

        defaultProperties.setDeserializeEntities(true);

        // Omit comments in restricted mode to avoid any potential parser confusion.
        // Any part of the filtered HTML that contains unfiltered input is potentially dangerous/a candidate for
        // parser confusion. Comments, style and script elements seem to be frequently found ingredients in successful
        // attacks against good sanitizers. We're already removing style and script elements, so removing comments
        // seems like a good defense against future attacks.
        defaultProperties.setOmitComments(isRestricted(configuration));

        return defaultProperties;
    }",1
"private static native void nativeSetApkAssets(long ptr, @NonNull ApkAssets[] apkAssets,
            boolean invalidateCaches);",0
"public void visitUris(@NonNull Consumer<Uri> visitor) {
        if (publicVersion != null) {
            publicVersion.visitUris(visitor);
        }

        visitor.accept(sound);

        if (tickerView != null) tickerView.visitUris(visitor);
        if (contentView != null) contentView.visitUris(visitor);
        if (bigContentView != null) bigContentView.visitUris(visitor);
        if (headsUpContentView != null) headsUpContentView.visitUris(visitor);

        visitIconUri(visitor, mSmallIcon);
        visitIconUri(visitor, mLargeIcon);

        if (actions != null) {
            for (Action action : actions) {
                visitIconUri(visitor, action.getIcon());
            }
        }

        if (extras != null) {
            visitIconUri(visitor, extras.getParcelable(EXTRA_LARGE_ICON_BIG, Icon.class));
            visitIconUri(visitor, extras.getParcelable(EXTRA_PICTURE_ICON, Icon.class));

            // NOTE: The documentation of EXTRA_AUDIO_CONTENTS_URI explicitly says that it is a
            // String representation of a Uri, but the previous implementation (and unit test) of
            // this method has always treated it as a Uri object. Given the inconsistency,
            // supporting both going forward is the safest choice.
            Object audioContentsUri = extras.get(EXTRA_AUDIO_CONTENTS_URI);
            if (audioContentsUri instanceof Uri) {
                visitor.accept((Uri) audioContentsUri);
            } else if (audioContentsUri instanceof String) {
                visitor.accept(Uri.parse((String) audioContentsUri));
            }

            if (extras.containsKey(EXTRA_BACKGROUND_IMAGE_URI)) {
                visitor.accept(Uri.parse(extras.getString(EXTRA_BACKGROUND_IMAGE_URI)));
            }

            ArrayList<Person> people = extras.getParcelableArrayList(EXTRA_PEOPLE_LIST);
            if (people != null && !people.isEmpty()) {
                for (Person p : people) {
                    visitor.accept(p.getIconUri());
                }
            }

            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON, Person.class);
            if (person != null) {
                visitor.accept(person.getIconUri());
            }
        }

        if (isStyle(MessagingStyle.class) && extras != null) {
            final Parcelable[] messages = extras.getParcelableArray(EXTRA_MESSAGES);
            if (!ArrayUtils.isEmpty(messages)) {
                for (MessagingStyle.Message message : MessagingStyle.Message
                        .getMessagesFromBundleArray(messages)) {
                    visitor.accept(message.getDataUri());

                    Person senderPerson = message.getSenderPerson();
                    if (senderPerson != null) {
                        visitor.accept(senderPerson.getIconUri());
                    }
                }
            }

            final Parcelable[] historic = extras.getParcelableArray(EXTRA_HISTORIC_MESSAGES);
            if (!ArrayUtils.isEmpty(historic)) {
                for (MessagingStyle.Message message : MessagingStyle.Message
                        .getMessagesFromBundleArray(historic)) {
                    visitor.accept(message.getDataUri());

                    Person senderPerson = message.getSenderPerson();
                    if (senderPerson != null) {
                        visitor.accept(senderPerson.getIconUri());
                    }
                }
            }

            visitIconUri(visitor, extras.getParcelable(EXTRA_CONVERSATION_ICON));
        }

        if (isStyle(CallStyle.class) & extras != null) {
            Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);
            if (callPerson != null) {
                visitor.accept(callPerson.getIconUri());
            }
            visitIconUri(visitor, extras.getParcelable(EXTRA_VERIFICATION_ICON));
        }

        if (mBubbleMetadata != null) {
            visitIconUri(visitor, mBubbleMetadata.getIcon());
        }
    }",1
"public static boolean deleteDatabase(@NonNull File file) {
        if (file == null) {
            throw new IllegalArgumentException(""file must not be null"");
        }

        boolean deleted = false;
        deleted |= file.delete();
        deleted |= new File(file.getPath() + ""-journal"").delete();
        deleted |= new File(file.getPath() + ""-shm"").delete();
        deleted |= new File(file.getPath() + ""-wal"").delete();

        File dir = file.getParentFile();
        if (dir != null) {
            final String prefix = file.getName() + ""-mj"";
            File[] files = dir.listFiles(new FileFilter() {
                @Override
                public boolean accept(File candidate) {
                    return candidate.getName().startsWith(prefix);
                }
            });
            if (files != null) {
                for (File masterJournal : files) {
                    deleted |= masterJournal.delete();
                }
            }
        }
        return deleted;
    }",0
"@RequestMapping(value = { ""/page"" })
	public String actionPage(HttpServletRequest theReq, HomeRequest theRequest, BindingResult theBindingResult, ModelMap theModel) {
		addCommonParams(theReq, theRequest, theModel);

		CaptureInterceptor interceptor = new CaptureInterceptor();
		FhirContext context = getContext(theRequest);
		GenericClient client = theRequest.newClient(theReq, context, myConfig, interceptor);

		String url = sanitizeUrlPart(defaultString(theReq.getParameter(""page-url"")));
		if (myConfig.isRefuseToFetchThirdPartyUrls()) {
			if (!url.startsWith(theModel.get(""base"").toString())) {
				ourLog.warn(logPrefix(theModel) + ""Refusing to load page URL: {}"", url);
				theModel.put(""errorMsg"", toDisplayError(""Invalid page URL: "" + url, null));
				return ""result"";
			}
		}

		url = url.replace(""&amp;"", ""&"");

		ResultType returnsResource = ResultType.BUNDLE;

		long start = System.currentTimeMillis();
		try {
			ourLog.info(logPrefix(theModel) + ""Loading paging URL: {}"", url);
			@SuppressWarnings(""unchecked"")
			Class<? extends IBaseBundle> bundleType = (Class<? extends IBaseBundle>) context.getResourceDefinition(""Bundle"").getImplementingClass();
			client.loadPage().byUrl(url).andReturnBundle(bundleType).execute();
		} catch (Exception e) {
			returnsResource = handleClientException(client, e, theModel);
		}
		long delay = System.currentTimeMillis() - start;

		String outcomeDescription = ""Bundle Page"";

		processAndAddLastClientInvocation(client, returnsResource, theModel, delay, outcomeDescription, interceptor, theRequest);

		return ""result"";
	}",1
"@Override
    public String toXML() throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.newDocument();

        Element element = toDOM(document);
        document.appendChild(element);

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
        transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""4"");

        DOMSource domSource = new DOMSource(document);
        StringWriter sw = new StringWriter();
        StreamResult streamResult = new StreamResult(sw);
        transformer.transform(domSource, streamResult);

        return sw.toString();
    }",1
"@Override
    public IntValues[] getMultipleLinearIntValues(String tableName,
                                                  DownSampling downsampling,
                                                  List<String> ids,
                                                  final List<Integer> linearIndex,
                                                  String valueCName) throws IOException {
        StringBuilder sql = new StringBuilder(""select id, "" + valueCName + "" from "" + tableName + "" where id in ("");
        List<Object> parameters = new ArrayList();
        for (int i = 0; i < ids.size(); i++) {
            if (i == 0) {
                sql.append(""?"");
            } else {
                sql.append("",?"");
            }
            parameters.add(ids.get(i));
        }
        sql.append("")"");

        IntValues[] intValuesArray = new IntValues[linearIndex.size()];
        for (int i = 0; i < intValuesArray.length; i++) {
            intValuesArray[i] = new IntValues();
        }

        try (Connection connection = h2Client.getConnection()) {
            try (ResultSet resultSet = h2Client.executeQuery(
                connection, sql.toString(), parameters.toArray(new Object[0]))) {
                while (resultSet.next()) {
                    String id = resultSet.getString(""id"");

                    IntKeyLongValueHashMap multipleValues = new IntKeyLongValueHashMap(5);
                    multipleValues.toObject(resultSet.getString(valueCName));

                    for (int i = 0; i < linearIndex.size(); i++) {
                        Integer index = linearIndex.get(i);
                        KVInt kv = new KVInt();
                        kv.setId(id);
                        kv.setValue(multipleValues.get(index).getValue());
                        intValuesArray[i].addKVInt(kv);
                    }
                }
            }
        } catch (SQLException e) {
            throw new IOException(e);
        }

        return orderWithDefault0(intValuesArray, ids);
    }",1
"protected String quoteOneItem( String path, boolean isExecutable )
    {
        if ( path == null )
        {
            return null;
        }

        return ""'"" + path.replace( ""'"", ""'\""'\""'"" ) + ""'"";
    }",1
"@Override
    public int getBlockLightLevel(BlockVector3 pt) {
        //FAWE start - safe edit region
        testCoords(pt);
        //FAWE end
        return getWorld().getBlockAt(pt.getBlockX(), pt.getBlockY(), pt.getBlockZ()).getLightLevel();
    }",1
"@Override
    public boolean isInLockTaskMode() {
        return getLockTaskModeState() != LOCK_TASK_MODE_NONE;
    }",0
"@Override
		public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
	    throws IOException {
			String filename = file.getFileName().toString();

	        if(filename.endsWith(WikiManager.WIKI_PROPERTIES_SUFFIX)) {
	        	String f = convertAlternativeFilename(file.toString());
	        	final Path destFile = Paths.get(wikiDir.toString(), f);
	        	checkDestinationFile(destFile);
	        	resetAndCopyProperties(file, destFile);
	        } else if (filename.endsWith(WIKI_FILE_SUFFIX)) {
	        	String f = convertAlternativeFilename(file.toString());
	        	final Path destFile = Paths.get(wikiDir.toString(), f);
	        	checkDestinationFile(destFile);
	        	Files.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);
			} else if (!filename.contains(WIKI_FILE_SUFFIX + ""-"")
					&& !filename.contains(WIKI_PROPERTIES_SUFFIX + ""-"")) {
				final Path destFile = Paths.get(mediaDir.toString(), file.toString());
				checkDestinationFile(destFile);
				Files.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);
			}
	        return FileVisitResult.CONTINUE;
		}",1
"private TomlToken peek() throws TomlStreamReadException {
        TomlToken here = this.next;
        if (here == null) throw errorContext.atPosition(lexer).generic(""Premature end of file"");
        return here;
    }",0
"boolean isLaidOut() {
        return mLayoutSeq != -1;
    }",0
"public void setSecretKey(@Nullable String secretKey) {
    this.secretKey = secretKey;
  }",1
"public static ProfileDataInfos fromXML(String xml) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element element = document.getDocumentElement();
        return fromDOM(element);
    }",1
"@Override
    public <B extends BlockStateHolder<B>> boolean setBlock(BlockVector3 position, B block, SideEffectSet sideEffects) {
        //FAWE start - safe edit region
        testCoords(position);
        //FAWE end
        if (worldNativeAccess != null) {
            try {
                return worldNativeAccess.setBlock(position, block, sideEffects);
            } catch (Exception e) {
                if (block instanceof BaseBlock && ((BaseBlock) block).getNbt() != null) {
                    LOGGER.warn(""Tried to set a corrupt tile entity at "" + position.toString()
                            + "": "" + ((BaseBlock) block).getNbt(), e);
                } else {
                    LOGGER.warn(""Failed to set block via adapter, falling back to generic"", e);
                }
            }
        }
        Block bukkitBlock = getWorld().getBlockAt(position.getBlockX(), position.getBlockY(), position.getBlockZ());
        bukkitBlock.setBlockData(BukkitAdapter.adapt(block), sideEffects.doesApplyAny());
        return true;
    }",1
"public static boolean isValidImageCaptcha(HttpServletRequest request){

		HttpSession session = request.getSession();
		String captcha = request.getParameter(""captcha"");
		Captcha captchaObj = (Captcha) session.getAttribute(Captcha.NAME);
		//We need to remove the captcha info from the session.
		session.removeAttribute(Captcha.NAME);
		String captchaSession=captchaObj!=null ? captchaObj.getAnswer() : null;
		if(!UtilMethods.isSet(captcha) || !UtilMethods.isSet(captchaSession) || !captcha.equals(captchaSession)){
			return false;
		} else {
			return true;
		}

	}",1
"private NotificationContext getNotificationContext(final HttpRequest request) {
    final NotificationContext context = new NotificationContext(getCurrentRequester());
    Enumeration<String> parameters = request.getParameterNames();
    final HtmlSanitizer htmlSanitizer = HtmlSanitizer.get();
    while (parameters.hasMoreElements()) {
      final String name = parameters.nextElement();
      context.put(name, htmlSanitizer.sanitize(request.getParameter(name)));
    }
    return context;
  }",1
"public void start(String dnsServerIps) {
        LOG.debug(""Attempting to start DNS client"");
        this.resolverPool = new DnsResolverPool(dnsServerIps, queryTimeout, resolverPoolSize, resolverPoolRefreshSeconds);
        this.resolverPool.initialize();
    }",1
"private void startOwnerService(int userId, String actionForLog) {
        final ComponentName owner = getOwnerComponent(userId);
        if (owner != null) {
            mDeviceAdminServiceController.startServiceForAdmin(
                    owner.getPackageName(), userId, actionForLog);
            invalidateBinderCaches();
        }
    }",0
"private void internalSetReplicatedSubscriptionStatusForNonPartitionedTopic(AsyncResponse asyncResponse,
            String subName, boolean authoritative, boolean enabled) {
        try {
            // Redirect the request to the appropriate broker if this broker is not the owner of the topic
            validateTopicOwnership(topicName, authoritative);

            Topic topic = getTopicReference(topicName);
            if (topic == null) {
                asyncResponse.resume(new RestException(Status.NOT_FOUND, ""Topic not found""));
                return;
            }

            Subscription sub = topic.getSubscription(subName);
            if (sub == null) {
                asyncResponse.resume(new RestException(Status.NOT_FOUND, ""Subscription not found""));
                return;
            }

            if (topic instanceof PersistentTopic && sub instanceof PersistentSubscription) {
                if (!((PersistentSubscription) sub).setReplicated(enabled)) {
                    asyncResponse.resume(
                            new RestException(Status.INTERNAL_SERVER_ERROR, ""Failed to update cursor properties""));
                    return;
                }

                ((PersistentTopic) topic).checkReplicatedSubscriptionControllerState();
                log.info(""[{}] Changed replicated subscription status to {} - {} {}"", clientAppId(), enabled, topicName,
                        subName);
                asyncResponse.resume(Response.noContent().build());
            } else {
                asyncResponse.resume(new RestException(Status.METHOD_NOT_ALLOWED,
                        ""Cannot enable/disable replicated subscriptions on non-persistent topics""));
            }
        } catch (Exception e) {
            resumeAsyncResponseExceptionally(asyncResponse, e);
        }
    }",0
"private static Intent settings(String action) {
        return new Intent(action).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_MULTIPLE_TASK
                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
                | Intent.FLAG_ACTIVITY_NO_HISTORY
                | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    }",0
"private static boolean checkExternalDTD(DOMDocument document, LSPErrorReporterForXML reporter,
			XMLParserConfiguration configuration) {
		if (!document.hasDTD()) {
			return true;
		}
		DOMDocumentType docType = document.getDoctype();
		if (docType.getKindNode() == null) {
			return true;
		}

		// When XML is bound with a DTD path which doesn't exist, Xerces throws an
		// IOException which breaks the validation of XML syntax instead of reporting it
		// (like XML Schema). Here we parse only the
		// DOCTYPE to catch this error. If there is an error
		// the next validation with be disabled by using
		// http://xml.org/sax/features/validation &
		// http://apache.org/xml/features/nonvalidating/load-external-dtd (disable uses
		// of DTD for validation)

		// Parse only the DOCTYPE of the DOM document

		int end = document.getDoctype().getEnd();
		String xml = document.getText().substring(0, end);
		xml += ""<root/>"";
		try {

			// Customize the entity manager to collect the error when DTD doesn't exist.
			XMLEntityManager entityManager = new XMLEntityManager() {
				@Override
				public String setupCurrentEntity(String name, XMLInputSource xmlInputSource, boolean literal,
						boolean isExternal) throws IOException, XNIException {
					// Catch the setupCurrentEntity method which throws an IOException when DTD is
					// not found
					try {
						return super.setupCurrentEntity(name, xmlInputSource, literal, isExternal);
					} catch (IOException e) {
						// Report the DTD invalid error
						try {
							Range range = new Range(document.positionAt(docType.getSystemIdNode().getStart()),
									document.positionAt(docType.getSystemIdNode().getEnd()));
							reporter.addDiagnostic(range,
									MessageFormat.format(DTD_NOT_FOUND, xmlInputSource.getSystemId()),
									DiagnosticSeverity.Error, DTDErrorCode.dtd_not_found.getCode());
						} catch (BadLocationException e1) {
							// Do nothing
						}
						throw e;
					}
				}
			};
			entityManager.reset(configuration);

			SAXParser parser = new SAXParser(configuration);
			parser.setProperty(""http://apache.org/xml/properties/internal/entity-manager"", entityManager);
			parser.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", true);

			InputSource inputSource = new InputSource();
			inputSource.setByteStream(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));
			inputSource.setSystemId(document.getDocumentURI());
			parser.parse(inputSource);
		} catch (SAXException | CancellationException exception) {
			// ignore error
		} catch (IOException e) {
			return false;
		}
		return true;
	}",1
"private XDOM displayTitle(DocumentModelBridge document, DocumentDisplayerParameters parameters)
    {
        // 1. Try to use the title provided by the user.
        String rawTitle = document.getTitle();
        if (!StringUtils.isEmpty(rawTitle)) {
            try {
                String title = rawTitle;
                // Evaluate the title only if the document has script rights, otherwise use the raw title.
                if (authorizationManager.hasAccess(Right.SCRIPT, document.getContentAuthorReference(),
                    document.getDocumentReference())) {
                    title = evaluateTitle(rawTitle, document, parameters);
                }
                return parseTitle(title);
            } catch (Exception e) {
                logger.warn(""Failed to interpret title of document [{}]."", document.getDocumentReference(), e);
            }
        }

        // 2. Try to extract the title from the document content.
        if (""1"".equals(this.xwikicfg.getProperty(""xwiki.title.compatibility"", ""0""))) {
            try {
                XDOM title = extractTitleFromContent(document, parameters);
                if (title != null) {
                    return title;
                }
            } catch (Exception e) {
                logger.warn(""Failed to extract title from content of document [{}]."", document.getDocumentReference(),
                    e);
            }
        }

        // 3. The title was not specified or its evaluation failed. Use the document name as a fall-back.
        return getStaticTitle(document);
    }",1
"@Override
                public boolean onLongClick(View v) {
                    RecordUserAction.record(""MobileOmniboxDeleteGesture"");
                    if (!mSuggestion.isDeletable()) return true;

                    AlertDialog.Builder b =
                            new AlertDialog.Builder(getContext(), R.style.AlertDialogTheme);
                    b.setTitle(mSuggestion.getDisplayText());
                    b.setMessage(R.string.omnibox_confirm_delete);
                    DialogInterface.OnClickListener okListener =
                            new DialogInterface.OnClickListener() {
                                @Override
                                public void onClick(DialogInterface dialog, int which) {
                                    RecordUserAction.record(""MobileOmniboxDeleteRequested"");
                                    mSuggestionDelegate.onDeleteSuggestion(mPosition);
                                }
                            };
                    b.setPositiveButton(android.R.string.ok, okListener);
                    DialogInterface.OnClickListener cancelListener =
                            new DialogInterface.OnClickListener() {
                                @Override
                                public void onClick(DialogInterface dialog, int which) {
                                    dialog.cancel();
                                }
                            };
                    b.setNegativeButton(android.R.string.cancel, cancelListener);

                    AlertDialog dialog = b.create();
                    dialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
                        @Override
                        public void onDismiss(DialogInterface dialog) {
                            mSuggestionDelegate.onHideModal();
                        }
                    });

                    mSuggestionDelegate.onShowModal();
                    dialog.show();
                    return true;
                }",0
"public boolean isDebugging() {
    return debugging;
  }",0
"@Override
   public void save(MapSession session) {
      if (!session.getId().equals(session.getOriginalId())) {
         deleteById(session.getOriginalId());
      }
      cache.put(session.getId(), session, session.getMaxInactiveInterval().getSeconds(), TimeUnit.SECONDS);
   }",1
"private int nextHandle() {
        return nextHandle++;
    }",0
"public void setEnableInMemorySubscriptionMatching(boolean theEnableInMemorySubscriptionMatching) {
		myEnableInMemorySubscriptionMatching = theEnableInMemorySubscriptionMatching;
	}",0
"@Override
    public DataSource createNewDataSource(Map<String, ?> params) throws IOException {
        String refName = (String) JNDI_REFNAME.lookUp(params);
        try {
            return (DataSource) GeoTools.jndiLookup(refName);
        } catch (Exception e) {
            throw new DataSourceException(""Could not find the specified data source in JNDI"", e);
        }
    }",1
"void postStartActivityProcessing(ActivityRecord r, int result,
            Task startedActivityRootTask) {
        if (!ActivityManager.isStartResultSuccessful(result)) {
            if (mFrozeTaskList) {
                // If we specifically froze the task list as part of starting an activity, then
                // reset the frozen list state if it failed to start. This is normally otherwise
                // called when the freeze-timeout has elapsed.
                mSupervisor.mRecentTasks.resetFreezeTaskListReorderingOnTimeout();
            }
        }
        if (ActivityManager.isStartResultFatalError(result)) {
            return;
        }

        // We're waiting for an activity launch to finish, but that activity simply
        // brought another activity to front. We must also handle the case where the task is already
        // in the front as a result of the trampoline activity being in the same task (it will be
        // considered focused as the trampoline will be finished). Let them know about this, so
        // it waits for the new activity to become visible instead, {@link #waitResultIfNeeded}.
        mSupervisor.reportWaitingActivityLaunchedIfNeeded(r, result);

        final Task targetTask = r.getTask() != null
                ? r.getTask()
                : mTargetTask;
        if (startedActivityRootTask == null || targetTask == null || !targetTask.isAttached()) {
            return;
        }

        if (result == START_TASK_TO_FRONT || result == START_DELIVERED_TO_TOP) {
            // The activity was already running so it wasn't started, but either brought to the
            // front or the new intent was delivered to it since it was already in front. Notify
            // anyone interested in this piece of information.
            final Task rootHomeTask = targetTask.getDisplayArea().getRootHomeTask();
            final boolean homeTaskVisible = rootHomeTask != null
                    && rootHomeTask.shouldBeVisible(null);
            final ActivityRecord top = targetTask.getTopNonFinishingActivity();
            final boolean visible = top != null && top.isVisible();
            mService.getTaskChangeNotificationController().notifyActivityRestartAttempt(
                    targetTask.getTaskInfo(), homeTaskVisible, mIsTaskCleared, visible);
        }

        if (ActivityManager.isStartResultSuccessful(result)) {
            mInterceptor.onActivityLaunched(targetTask.getTaskInfo(), r);
        }
    }",0
"private boolean checkAuthorization(String authorization, List<String> availableSecrets,
      String timestamp, String path, String query) {

    String signature = null;
    if (authorization != null) {
      String[] split = authorization.split("":"");
      if (split.length > 1) {
        signature = split[1];
      }
    }

    for (String secret : availableSecrets) {
      String availableSignature = accessKeyUtil.buildSignature(path, query, timestamp, secret);
      if (Objects.equals(signature, availableSignature)) {
        return true;
      }
    }
    return false;
  }",0
"public boolean deployWar(File warFile, File deployTarDir) {
	String context = warFile.getName();
	assert context.toLowerCase().endsWith(DEPLOY_ARCH_EXT);
	context = context.substring(0, context.length() - DEPLOY_ARCH_EXT.length());
	File failedMark = new File(deployTarDir, context + DEPLOY_FAILED_EXT); 
	if (failedMark.exists() && failedMark.lastModified() > warFile.lastModified())
	    return false; // skipping deploy failed

	server.log(""Deploying "" + context);
	ZipFile zipFile = null;
	File deployDir = new File(deployTarDir, context);
	boolean noincremental = System.getProperty(DEF_DEPLOY_NOINCREMENTAL) != null;
	if (assureDir(deployDir) == false) {
	    server.log(""Can't reach deployment dir "" + deployDir);
	    return false;
	}
	Exception lastException = null;
	deploy: do {
	    try {
		// some overhead didn't check that doesn't exist
		zipFile = new ZipFile(warFile);
		Enumeration<? extends ZipEntry> entries = zipFile.entries();
		while (entries.hasMoreElements()) {
		    ZipEntry ze = entries.nextElement();
		    String en = ze.getName();
		    if (File.separatorChar == '/')
			en = en.replace('\\', File.separatorChar);
		    if (en.contains(""../"") || en.contains(""/.."")) 
		    	throw new IOException(""The file name "" + en + "" contains .. which can lead to a Path Traversal vulnerability"");
		    File outFile = new File(deployDir, en);
		    if (ze.isDirectory()) {
			outFile.mkdirs();
		    } else {
			OutputStream os = null;
			InputStream is = null;
			File parentFile = outFile.getParentFile();
			if (parentFile.exists() == false)
			    parentFile.mkdirs();
			if (outFile.exists() && outFile.lastModified() >= ze.getTime()) {
			    continue;
			}
			if (noincremental) {
			    deleteFiles(deployDir, deployDir.list());
			    noincremental = false;
			    continue deploy;
			}
			try {
			    os = new FileOutputStream(outFile);
			    is = zipFile.getInputStream(ze);
			    copyStream(is, os);
			} catch (IOException ioe2) {
			    server.log(""Problem in extracting "" + en + "" "" + ioe2);			    
			    // TODO decide to propagate the exception up and stop deployment?
			    lastException = ioe2;
			} finally {
			    try {
				os.close();
			    } catch (Exception e2) {

			    }
			    try {
				is.close();
			    } catch (Exception e2) {

			    }
			}
			outFile.setLastModified(ze.getTime());
		    }
		}
	    } catch (ZipException ze) {
		server.log(""Invalid .war format"");
		lastException = ze;
	    } catch (IOException ioe) {
		server.log(""Can't read "" + warFile + ""/ "" + ioe);
		lastException = ioe;
	    } finally {
		try {
		    zipFile.close();
		} catch (Exception e) {

		}
		zipFile = null;
	    }
	} while (false);
	if (lastException == null) {
		deployDir.setLastModified(warFile.lastModified());
		return true;
	} 
	deployDir.setLastModified(0);
	return false;
    }",1
"@Test
  public void postQueryNoMetricBadRequest() throws Exception {
    final DeferredGroupException dge = mock(DeferredGroupException.class);
    when(dge.getCause()).thenReturn(new NoSuchUniqueName(""foo"", ""metrics""));

    when(query_result.configureFromQuery((TSQuery)any(), anyInt()))
      .thenReturn(Deferred.fromError(dge));

    HttpQuery query = NettyMocks.postQuery(tsdb, ""/api/query"",
        ""{\""start\"":1425440315306,\""queries\"":"" +
          ""[{\""metric\"":\""nonexistent\"",\""aggregator\"":\""sum\"",\""rate\"":true,"" +
          ""\""rateOptions\"":{\""counter\"":false}}]}"");
    rpc.execute(tsdb, query);
    assertEquals(HttpResponseStatus.BAD_REQUEST, query.response().getStatus());
    final String json =
        query.response().getContent().toString(Charset.forName(""UTF-8""));
    assertTrue(json.contains(""No such name for &#39;foo&#39;: &#39;metrics&#39;""));
  }",1
"private <T> T doAddApplication(ServiceProvider serviceProvider, String tenantDomain, String username,
                                   ApplicationPersistFunction<ServiceProvider, T> applicationPersistFunction)
            throws IdentityApplicationManagementException {

        try {
            startTenantFlow(tenantDomain, username);

            String applicationName = serviceProvider.getApplicationName();
            // First we need to create a role with the application name. Only the users in this role will be able to
            // edit/update the application.
            ApplicationMgtUtil.createAppRole(applicationName, username);
            try {
                PermissionsAndRoleConfig permissionAndRoleConfig = serviceProvider.getPermissionAndRoleConfig();
                ApplicationMgtUtil.storePermissions(applicationName, username, permissionAndRoleConfig);
            } catch (IdentityApplicationManagementException ex) {
                if (log.isDebugEnabled()) {
                    log.debug(""Creating application: "" + applicationName + "" in tenantDomain: "" + tenantDomain +
                            "" failed. Rolling back by cleaning up partially created data."");
                }
                deleteApplicationRole(applicationName);
                throw ex;
            }

            try {
                return applicationPersistFunction.persistApplication(serviceProvider, tenantDomain);
            } catch (IdentityApplicationManagementException ex) {
                if (isRollbackRequired(ex)) {
                    if (log.isDebugEnabled()) {
                        log.debug(""Creating application: "" + applicationName + "" in tenantDomain: "" + tenantDomain +
                                "" failed. Rolling back by cleaning up partially created data."");
                    }
                    deleteApplicationRole(applicationName);
                    deleteApplicationPermission(applicationName);
                }
                throw ex;
            }
        } finally {
            endTenantFlow();
        }
    }",0
"private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,
            Object[] constructorParamValues) {
        try {
            Class type = Class.forName(className, false, classLoaderReference.getReference());
            Constructor constructor = type.getConstructor(constructorParamTypes);
            return (Mapper)constructor.newInstance(constructorParamValues);
        } catch (Exception e) {
            throw new com.thoughtworks.xstream.InitializationException(""Could not instantiate mapper : "" + className,
                e);
        } catch (LinkageError e) {
            throw new com.thoughtworks.xstream.InitializationException(""Could not instantiate mapper : "" + className,
                e);
        }
    }",0
"public io.netty.handler.codec.http.Cookie toNettyCookie() {
        io.netty.handler.codec.http.Cookie nettyCookie = new DefaultCookie(name, WebUtils.escapeCookieValue(value));
        if (path != null && !path.isEmpty()) {
            nettyCookie.setPath(path);
        }
        nettyCookie.setMaxAge(maxAgeSeconds);
        nettyCookie.setDiscard(discardAtEndOfBrowserSession);
        nettyCookie.setHttpOnly(true);  // TODO
        if (GribbitProperties.SSL) {
            // If SSL is enabled, force cookies to only be delivered over SSL, to prevent cookie hijacking
            // on public wifi networks
            nettyCookie.setSecure(true);
        }
        return nettyCookie;
    }",1
"@Test
  public void setSmoothParams() throws Exception {
    assertPlotParam(""smooth"", ""unique"");
    assertPlotParam(""smooth"", ""frequency"");
    assertPlotParam(""smooth"", ""fnormal"");
    assertPlotParam(""smooth"", ""cumulative"");
    assertPlotParam(""smooth"", ""cnormal"");
    assertPlotParam(""smooth"", ""bins"");
    assertPlotParam(""smooth"", ""csplines"");
    assertPlotParam(""smooth"", ""acsplines"");
    assertPlotParam(""smooth"", ""mcsplines"");
    assertPlotParam(""smooth"", ""bezier"");
    assertPlotParam(""smooth"", ""sbezier"");
    assertPlotParam(""smooth"", ""unwrap"");
    assertPlotParam(""smooth"", ""zsort"");
    assertInvalidPlotParam(""smooth"", ""bezier%20system(%20"");
    assertInvalidPlotParam(""smooth"", ""fnormal%0asystem(%20"");
  }",1
"@Override
    public void sendResponse(Throwable error) throws IOException {
        BytesStreamOutput stream = new BytesStreamOutput();
        if (ThrowableObjectOutputStream.canSerialize(error) == false) {
            assert false : ""Can not serialize exception: "" + error; // make sure tests fail
            error = new NotSerializableTransportException(error);
        }
        try {
            writeResponseExceptionHeader(stream);
            RemoteTransportException tx = new RemoteTransportException(targetTransport.nodeName(), targetTransport.boundAddress().boundAddress(), action, error);
            ThrowableObjectOutputStream too = new ThrowableObjectOutputStream(stream);
            too.writeObject(tx);
            too.close();
        } catch (NotSerializableException e) {
            stream.reset();
            writeResponseExceptionHeader(stream);
            RemoteTransportException tx = new RemoteTransportException(targetTransport.nodeName(), targetTransport.boundAddress().boundAddress(), action, new NotSerializableTransportException(error));
            ThrowableObjectOutputStream too = new ThrowableObjectOutputStream(stream);
            too.writeObject(tx);
            too.close();
        }
        final byte[] data = stream.bytes().toBytes();
        targetTransport.workers().execute(new Runnable() {
            @Override
            public void run() {
                targetTransport.messageReceived(data, action, sourceTransport, version, null);
            }
        });
        sourceTransportServiceAdapter.onResponseSent(requestId, action, error);
    }",1
"@Override
    public boolean shouldDelayChildPressedState() {
        return true;
    }",0
"public JSONArray put(Collection value) throws JSONException {
        put(new JSONArray(value));
        return this;
    }",1
"private long handleAttachmentUrisFromIntent(List<Uri> uris) {
        ArrayList<Attachment> attachments = Lists.newArrayList();
        for (Uri uri : uris) {
            try {
                if (uri != null) {
                    if (""file"".equals(uri.getScheme())) {
                        // We must not allow files from /data, even from our process.
                        final File f = new File(uri.getPath());
                        final String filePath = f.getCanonicalPath();
                        if (filePath.startsWith(DATA_DIRECTORY_ROOT)) {
                          showErrorToast(getString(R.string.attachment_permission_denied));
                          Analytics.getInstance().sendEvent(ANALYTICS_CATEGORY_ERRORS,
                                  ""send_intent_attachment"", ""data_dir"", 0);
                          continue;
                        }
                    }
                    if (!handleSpecialAttachmentUri(uri)) {
                        final Attachment a = mAttachmentsView.generateLocalAttachment(uri);
                        attachments.add(a);

                        Analytics.getInstance().sendEvent(""send_intent_attachment"",
                                Utils.normalizeMimeType(a.getContentType()), null, a.size);
                    }
                }
            } catch (AttachmentFailureException e) {
                LogUtils.e(LOG_TAG, e, ""Error adding attachment"");
                showAttachmentTooBigToast(e.getErrorRes());
            } catch (IOException | SecurityException e) {
                LogUtils.e(LOG_TAG, e, ""Error adding attachment"");
                showErrorToast(getString(R.string.attachment_permission_denied));
            }
        }
        return addAttachments(attachments);
    }",1
"@Override
        public String getShortDescription() {
            if(note != null) {
                try {
                    return Messages.Cause_RemoteCause_ShortDescriptionWithNote(addr, Jenkins.getInstance().getMarkupFormatter().translate(note));
                } catch (IOException x) {
                    // ignore
                }
            }
            return Messages.Cause_RemoteCause_ShortDescription(addr);
        }",1
"@Override
        protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
            if (child != mTextLine1 && child != mTextLine2 && child != mAnswerImage) {
                return super.drawChild(canvas, child, drawingTime);
            }

            int height = getMeasuredHeight();
            int line1Height = mTextLine1.getMeasuredHeight();
            int line2Height = mTextLine2.getVisibility() == VISIBLE
                    ? mTextLine2.getMeasuredHeight() : 0;

            int verticalOffset = 0;
            if (line1Height + line2Height > height) {
                // The text lines total height is larger than this view, snap them to the top and
                // bottom of the view.
                if (child == mTextLine1) {
                    verticalOffset = 0;
                } else {
                    verticalOffset = height - line2Height;
                }
            } else {
                // The text lines fit comfortably, so vertically center them.
                verticalOffset = (height - line1Height - line2Height) / 2;
                if (child == mTextLine2) {
                    verticalOffset += line1Height;
                    if (mSuggestion.hasAnswer()
                            && mSuggestion.getAnswer().getSecondLine().hasImage()) {
                        verticalOffset += getResources().getDimensionPixelOffset(
                                R.dimen.omnibox_suggestion_answer_line2_vertical_spacing);
                    }
                }
                // When one line is larger than the other, it contains extra vertical padding. This
                // produces more apparent whitespace above or below the text lines.  Add a small
                // offset to compensate.
                if (line1Height != line2Height) {
                    verticalOffset += (line2Height - line1Height) / 10;
                }

                // The image is positioned vertically aligned with the second text line but
                // requires a small additional offset to align with the ascent of the text instead
                // of the top of the text which includes some whitespace.
                if (child == mAnswerImage) {
                    verticalOffset += getResources().getDimensionPixelOffset(
                            R.dimen.omnibox_suggestion_answer_line2_vertical_spacing);
                }
            }

            canvas.save();
            canvas.translate(0, verticalOffset);
            boolean retVal = super.drawChild(canvas, child, drawingTime);
            canvas.restore();
            return retVal;
        }",0
"protected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,
                                                   byte[] encryptedPreMasterSecret)
    {
        SecureRandom secureRandom = crypto.getSecureRandom();

        /*
         * RFC 5246 7.4.7.1.
         */
        ProtocolVersion clientVersion = cryptoParams.getClientVersion();

        // TODO Provide as configuration option?
        boolean versionNumberCheckDisabled = false;

        /*
         * Generate 48 random bytes we can use as a Pre-Master-Secret, if the
         * PKCS1 padding check should fail.
         */
        byte[] fallback = new byte[48];
        secureRandom.nextBytes(fallback);

        byte[] M = Arrays.clone(fallback);
        try
        {
            Cipher c = crypto.createRSAEncryptionCipher();
            c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);
            byte[] m = c.doFinal(encryptedPreMasterSecret);
            if (m != null && m.length == 48)
            {
                M = m;
            }
        }
        catch (Exception e)
        {
            /*
             * A TLS server MUST NOT generate an alert if processing an
             * RSA-encrypted premaster secret message fails, or the version number is not as
             * expected. Instead, it MUST continue the handshake with a randomly generated
             * premaster secret.
             */
        }

        /*
         * If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST
         * check the version number [..].
         */
        if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))
        {
            /*
             * If the version number is TLS 1.0 or earlier, server
             * implementations SHOULD check the version number, but MAY have a
             * configuration option to disable the check.
             *
             * So there is nothing to do here.
             */
        }
        else
        {
            /*
             * OK, we need to compare the version number in the decrypted Pre-Master-Secret with the
             * clientVersion received during the handshake. If they don't match, we replace the
             * decrypted Pre-Master-Secret with a random one.
             */
            int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))
                | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));
            correct |= correct >> 1;
            correct |= correct >> 2;
            correct |= correct >> 4;
            int mask = ~((correct & 1) - 1);

            /*
             * mask will be all bits set to 0xff if the version number differed.
             */
            for (int i = 0; i < 48; i++)
            {
                M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));
            }
        }
        return crypto.createSecret(M);
    }",1
"@Override
    public Set<Class<?>> list() {
        final ImmutableSet.Builder<Class<?>> classes = ImmutableSet.builder();

        try (DBCursor<ClusterConfig> clusterConfigs = dbCollection.find()) {
            for (ClusterConfig clusterConfig : clusterConfigs) {
                final String type = clusterConfig.type();
                try {
                    final Class<?> cls = chainingClassLoader.loadClassSafely(type);
                    classes.add(cls);
                } catch (ClassNotFoundException e) {
                    LOG.debug(""Couldn't find configuration class \""{}\"""", type, e);
                } catch (UnsafeClassLoadingAttemptException e) {
                    LOG.warn(""Couldn't load class <{}>."", type, e);
                }
            }
        }

        return classes.build();
    }",1
"protected BlockAsyncRendererConfiguration createBlockAsyncRendererConfiguration(List<?> idElements, Block content,
        String source, MacroTransformationContext context)
    {
        BlockAsyncRendererConfiguration configuration = new BlockAsyncRendererConfiguration(idElements, content);

        // Set author
        if (source != null) {
            DocumentReference sourceReference = this.resolver.resolve(source);
            configuration.setSecureReference(sourceReference, this.documentAccessBridge.getCurrentAuthorReference());

            // Invalidate the cache when the document containing the macro call is modified
            configuration.useEntity(sourceReference);
        }

        // Indicate if the result should be inline or not
        configuration.setInline(context.isInline());

        // Indicate the syntax of the content
        configuration.setDefaultSyntax(this.parser.getCurrentSyntax(context));

        // Indicate the target syntax
        configuration.setTargetSyntax(this.renderingContext.getTargetSyntax());

        // Set the transformation id
        configuration.setTransformationId(context.getTransformationContext().getId());

        // Indicate if we are in a restricted mode
        configuration.setResricted(context.getTransformationContext().isRestricted());

        return configuration;
    }",1
"@Transactional(readOnly = false)
	public String startProcess(String procDefKey, String businessTable, String businessId, String title, Map<String, Object> vars) {
		String userId = UserUtils.getUser().getLoginName();//ObjectUtils.toString(UserUtils.getUser().getId())
		
		// 用来设置启动流程的人员ID，引擎会自动把用户ID保存到activiti:initiator中
		identityService.setAuthenticatedUserId(userId);
		
		// 设置流程变量
		if (vars == null){
			vars = Maps.newHashMap();
		}
		
		// 设置流程标题
		if (StringUtils.isNotBlank(title)){
			vars.put(""title"", title);
		}

		// 安全过滤
		Matcher matcher = businessTablePattern.matcher(businessTable);
		if (!matcher.matches()) {
			throw new ServiceException(""非法参数 businessTable"");
		}
		
		// 启动流程
		ProcessInstance procIns = runtimeService.startProcessInstanceByKey(procDefKey, businessTable+"":""+businessId, vars);
		
		// 更新业务表流程实例ID
		Act act = new Act();
		act.setBusinessTable(businessTable);// 业务表名
		act.setBusinessId(businessId);	// 业务表ID
		act.setProcInsId(procIns.getId());
		actDao.updateProcInsIdByBusinessId(act);
		return act.getProcInsId();
	}",1
"public void addViolation(String message) {
        addViolation(message, Collections.emptyMap());
    }",1
"public static void saveConfig(BaseGUI gui) {
		try {
			Path.safeDeleteFile(new File(Path.legacyConfig()), false); // delete legacy cfg file if it exists and replace it with osConform one
			File configfile = new File(Path.osConformConfig());
			Path.safeDeleteFile(configfile, false);
			Path.safeCreateFile(configfile, false);

			Config cfg = Config.getInstance();
			Properties props = new Properties();

			props.setProperty(PROGRAM_VERSION, Program.getInstance().getVersion());
			props.setProperty(DEFAULT_FONTSIZE, Integer.toString(cfg.getDefaultFontsize()));
			props.setProperty(PROPERTIES_PANEL_FONTSIZE, Integer.toString(cfg.getPropertiesPanelFontsize()));
			props.setProperty(DEFAULT_FONTFAMILY, cfg.getDefaultFontFamily());
			props.setProperty(SHOW_STICKINGPOLYGON, Boolean.toString(SharedConfig.getInstance().isShow_stickingpolygon()));
			props.setProperty(SHOW_GRID, Boolean.toString(cfg.isShow_grid()));
			props.setProperty(ENABLE_CUSTOM_ELEMENTS, Boolean.toString(cfg.isEnable_custom_elements()));
			props.setProperty(UI_MANAGER, cfg.getUiManager());
			props.setProperty(PRINT_PADDING, Integer.toString(cfg.getPrintPadding()));
			props.setProperty(PDF_EXPORT_FONT, cfg.getPdfExportFont());
			props.setProperty(PDF_EXPORT_FONT_BOLD, cfg.getPdfExportFontBold());
			props.setProperty(PDF_EXPORT_FONT_ITALIC, cfg.getPdfExportFontItalic());
			props.setProperty(PDF_EXPORT_FONT_BOLDITALIC, cfg.getPdfExportFontBoldItalic());
			props.setProperty(CHECK_FOR_UPDATES, Boolean.toString(cfg.isCheckForUpdates()));
			props.setProperty(SECURE_XML_PROCESSING, Boolean.toString(cfg.isSecureXmlProcessing()));
			props.setProperty(OPEN_FILE_HOME, cfg.getOpenFileHome());
			props.setProperty(SAVE_FILE_HOME, cfg.getSaveFileHome());
			props.setProperty(DEV_MODE, Boolean.toString(SharedConfig.getInstance().isDev_mode()));
			props.setProperty(LAST_USED_PALETTE, cfg.getLastUsedPalette());

			props.setProperty(MAIN_SPLIT_POSITION, Integer.toString(gui.getMainSplitPosition()));
			props.setProperty(RIGHT_SPLIT_POSITION, Integer.toString(gui.getRightSplitPosition()));
			props.setProperty(MAIL_SPLIT_POSITION, Integer.toString(gui.getMailSplitPosition()));
			if (gui.saveWindowSizeInConfig()) {
				// If the window is maximized in any direction this fact is written in the cfg
				Frame topContainer = gui.getMainFrame();
				if ((topContainer.getExtendedState() & Frame.MAXIMIZED_BOTH) == Frame.MAXIMIZED_BOTH) {
					props.setProperty(START_MAXIMIZED, ""true"");
				} // Otherwise the size and the location is written in the cfg
				else {
					props.setProperty(START_MAXIMIZED, ""false"");
					props.setProperty(PROGRAM_SIZE, topContainer.getSize().width + "","" + topContainer.getSize().height);
					props.setProperty(PROGRAM_LOCATION, topContainer.getLocation().x + "","" + topContainer.getLocation().y);
				}
			}
			if (!RecentlyUsedFilesList.getInstance().isEmpty()) {
				StringBuilder sb = new StringBuilder("""");
				for (String recentFile : RecentlyUsedFilesList.getInstance()) {
					sb.append(recentFile).append(""|"");
				}
				sb.setLength(sb.length() - 1);
				props.setProperty(RECENT_FILES, sb.toString());
			}

			/* MAIL */
			ConfigMail cfgMail = ConfigMail.getInstance();
			if (!cfgMail.getMail_smtp().isEmpty()) {
				props.setProperty(MAIL_SMTP, cfgMail.getMail_smtp());
			}
			props.setProperty(MAIL_SMTP_AUTH, Boolean.toString(cfgMail.isMail_smtp_auth()));
			if (!cfgMail.getMail_smtp_user().isEmpty()) {
				props.setProperty(MAIL_SMTP_USER, cfgMail.getMail_smtp_user());
			}
			props.setProperty(MAIL_SMTP_PW_STORE, Boolean.toString(cfgMail.isMail_smtp_pw_store()));
			if (!cfgMail.getMail_smtp_pw().isEmpty()) {
				props.setProperty(MAIL_SMTP_PW, cfgMail.getMail_smtp_pw());
			}
			if (!cfgMail.getMail_from().isEmpty()) {
				props.setProperty(MAIL_FROM, cfgMail.getMail_from());
			}
			if (!cfgMail.getMail_to().isEmpty()) {
				props.setProperty(MAIL_TO, cfgMail.getMail_to());
			}
			if (!cfgMail.getMail_cc().isEmpty()) {
				props.setProperty(MAIL_CC, cfgMail.getMail_cc());
			}
			if (!cfgMail.getMail_bcc().isEmpty()) {
				props.setProperty(MAIL_BCC, cfgMail.getMail_bcc());
			}
			props.setProperty(MAIL_XML, Boolean.toString(cfgMail.isMail_xml()));
			props.setProperty(MAIL_GIF, Boolean.toString(cfgMail.isMail_gif()));
			props.setProperty(MAIL_PDF, Boolean.toString(cfgMail.isMail_pdf()));

			/* Generate Class Element Options */
			ConfigClassGen genCfg = ConfigClassGen.getInstance();
			props.setProperty(GENERATE_CLASS_PACKAGE, Boolean.toString(genCfg.isGenerateClassPackage()));
			props.setProperty(GENERATE_CLASS_FIELDS, genCfg.getGenerateClassFields().toString());
			props.setProperty(GENERATE_CLASS_METHODS, genCfg.getGenerateClassMethods().toString());
			props.setProperty(GENERATE_CLASS_SIGNATURES, genCfg.getGenerateClassSignatures().toString());
			props.setProperty(GENERATE_CLASS_SORTINGS, genCfg.getGenerateClassSortings().toString());

			FileOutputStream outStream = new FileOutputStream(configfile);
			try {
				props.store(outStream, null);
			} finally {
				outStream.close();
			}
		} catch (IOException ex) {
			ex.printStackTrace();
		}
	}",1
"void installStage(String packageName, File stagedDir, String stagedCid,
            IPackageInstallObserver2 observer, PackageInstaller.SessionParams params,
            String installerPackageName, int installerUid, UserHandle user) {
        final VerificationParams verifParams = new VerificationParams(null, params.originatingUri,
                params.referrerUri, installerUid, null);
        verifParams.setInstallerUid(installerUid);

        final OriginInfo origin;
        if (stagedDir != null) {
            origin = OriginInfo.fromStagedFile(stagedDir);
        } else {
            origin = OriginInfo.fromStagedContainer(stagedCid);
        }

        final Message msg = mHandler.obtainMessage(INIT_COPY);
        msg.obj = new InstallParams(origin, null, observer, params.installFlags,
                installerPackageName, params.volumeUuid, verifParams, user, params.abiOverride,
                params.grantedRuntimePermissions);
        mHandler.sendMessage(msg);
    }",0
"private ApplicationBasicInfo getApplicationBasicInfo(String resourceId, String tenantDomain)
            throws IdentityApplicationManagementException {

        ApplicationDAO appDAO = ApplicationMgtSystemConfig.getInstance().getApplicationDAO();
        return appDAO.getApplicationBasicInfoByResourceId(resourceId, tenantDomain);
    }",0
"private void setDataProvider(int nodesPerLevel, int depth) {
        grid.setDataProvider(
                new LazyHierarchicalDataProvider(nodesPerLevel, depth) {
                    @Override
                    protected Stream<HierarchicalTestBean> fetchChildrenFromBackEnd(
                            HierarchicalQuery<HierarchicalTestBean, Void> query) {
                        VaadinRequest currentRequest = VaadinService
                                .getCurrentRequest();
                        if (!currentRequest.equals(lastRequest)) {
                            requestCount++;
                        }
                        lastRequest = currentRequest;
                        requestCountField
                                .setValue(String.valueOf(requestCount));

                        fetchCount++;
                        fetchCountField.setValue(String.valueOf(fetchCount));

                        return super.fetchChildrenFromBackEnd(query);
                    }

                    @Override
                    public Object getId(HierarchicalTestBean item) {
                        return item != null ? item.toString() : ""null"";
                    }
                });
    }",1
"public Form<T> withError(final ValidationError error) {
    if (error == null) {
      throw new NullPointerException(""Can't reject null-values"");
    }
    final List<ValidationError> copiedErrors = new ArrayList<>(this.errors);
    copiedErrors.add(error);
    return new Form<T>(
        this.rootName,
        this.backedType,
        this.rawData,
        this.files,
        copiedErrors,
        this.value,
        this.groups,
        this.messagesApi,
        this.formatters,
        this.validatorFactory,
        this.config,
        this.lang,
        this.directFieldAccess);
  }",0
"public String dialogStart() {

        return dialog(HTML_START, null);
    }",0
"@Override
    public boolean action(XWikiContext context) throws XWikiException
    {
        XWiki xwiki = context.getWiki();
        XWikiRequest request = context.getRequest();
        XWikiResponse response = context.getResponse();

        // Disallow template override with xpage parameter.
        if (!REGISTER.equals(Utils.getPage(context.getRequest(), REGISTER))) {
            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_ACCESS_DENIED,
                String.format(""Template may not be overriden with 'xpage' in [%s] action."", REGISTER));
        }

        String register = request.getParameter(REGISTER);
        if (register != null && register.equals(""1"")) {
            // CSRF prevention
            if (!csrfTokenCheck(context)) {
                return false;
            }
            // Let's verify that the user submitted the right CAPTCHA (if required).
            if (!verifyCaptcha(context, xwiki)) {
                return false;
            }

            int useemail = xwiki.getXWikiPreferenceAsInt(""use_email_verification"", 0, context);
            int result;
            if (useemail == 1) {
                result = xwiki.createUser(true, ""edit"", context);
            } else {
                result = xwiki.createUser(context);
            }
            getCurrentScriptContext().setAttribute(""reg"", Integer.valueOf(result), ScriptContext.ENGINE_SCOPE);

            // Redirect if a redirection parameter is passed.
            String redirect = Utils.getRedirect(request, null);
            if (redirect == null) {
                return true;
            } else {
                sendRedirect(response, redirect);
                return false;
            }
        }

        return true;
    }",1
"@Override
    public boolean matches(ConditionContext context) {
        BeanContext beanContext = context.getBeanContext();
        if (beanContext instanceof ApplicationContext) {
            List<String> paths = ((ApplicationContext) beanContext)
                    .getEnvironment()
                    .getProperty(FileWatchConfiguration.PATHS, ConversionContext.LIST_OF_STRING)
                    .orElse(null);

            if (CollectionUtils.isNotEmpty(paths)) {


                boolean matchedPaths = paths.stream().anyMatch(p -> new File(p).exists());
                if (!matchedPaths) {
                    context.fail(""File watch disabled because no paths matching the watch pattern exist (Paths: "" + paths + "")"");
                }
                return matchedPaths;
            }
        }

        context.fail(""File watch disabled because no watch paths specified"");
        return false;
    }",1
private static native long nativeAssetGetLength(long assetPtr);,0
"public void setLinkName(String linkName) {
        this.linkName = linkName;
    }",1
"public ApiClient setServers(List<ServerConfiguration> servers) {
    this.servers = servers;
    updateBasePath();
    return this;
  }",0
"@Nullable
    static String parseStringAttribute(TypedXmlPullParser parser, String attribute) {
        return parser.getAttributeValue(null, attribute);
    }",0
"private static int checkCallingPermission(String permission) {
        return checkPermission(
                permission, Binder.getCallingPid(), Binder.getCallingUid());
    }",0
"private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,
            String authToken) {
        if (account == null || type == null) {
            return false;
        }
        cancelNotification(getSigninRequiredNotificationId(accounts, account),
                UserHandle.of(accounts.userId));
        synchronized (accounts.dbLock) {
            accounts.accountsDb.beginTransaction();
            boolean updateCache = false;
            try {
                long accountId = accounts.accountsDb.findDeAccountId(account);
                if (accountId < 0) {
                    return false;
                }
                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);
                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {
                    accounts.accountsDb.setTransactionSuccessful();
                    updateCache = true;
                    return true;
                }
                return false;
            } finally {
                accounts.accountsDb.endTransaction();
                if (updateCache) {
                    synchronized (accounts.cacheLock) {
                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);
                    }
                }
            }
        }
    }",0
"protected DataSource createDataSource() throws SQLException {
        DataSource source = null;
        try {
            source = (DataSource) GeoTools.jndiLookup(datasourceName);
        } catch (IllegalArgumentException | NamingException exception) {
            // Fall back on 'return null' below.
        }
        return source;
    }",1
"@Override
    public void afterJFinalStart() {
        FreeMarkerRender.getConfiguration().setClassForTemplateLoading(ZrLogConfig.class, com.zrlog.common.Constants.FTL_VIEW_PATH);
        try {
            BlogFrontendFreeMarkerRender.getConfiguration().setDirectoryForTemplateLoading(new File(PathKit.getWebRootPath()));
            BlogFrontendFreeMarkerRender.init(JFinal.me().getServletContext(), Locale.getDefault(), Const.DEFAULT_FREEMARKER_TEMPLATE_UPDATE_DELAY);
        } catch (IOException e) {
            e.printStackTrace();
        }
        super.afterJFinalStart();
        if (isInstalled()) {
            initDatabaseVersion();
        }
        SYSTEM_PROP.setProperty(""zrlog.runtime.path"", PathKit.getWebRootPath());
        SYSTEM_PROP.setProperty(""server.info"", JFinal.me().getServletContext().getServerInfo());
        JFinal.me().getServletContext().setAttribute(""system"", SYSTEM_PROP);
        blogProperties.put(""version"", BlogBuildInfoUtil.getVersion());
        blogProperties.put(""buildId"", BlogBuildInfoUtil.getBuildId());
        blogProperties.put(""buildTime"", new SimpleDateFormat(""yyyy-MM-dd"").format(BlogBuildInfoUtil.getTime()));
        blogProperties.put(""runMode"", BlogBuildInfoUtil.getRunMode());
        JFinal.me().getServletContext().setAttribute(""zrlog"", blogProperties);
        JFinal.me().getServletContext().setAttribute(""config"", this);
        if (haveSqlUpdated) {
            int updatedVersion = ZrLogUtil.getSqlVersion(getUpgradeSqlBasePath());
            if (updatedVersion > 0) {
                new WebSite().updateByKV(com.zrlog.common.Constants.ZRLOG_SQL_VERSION_KEY, updatedVersion + """");
            }
        }
    }",1
"protected void doGet(HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException
    {

    	UUID errorCode = UUID.randomUUID();
        // Get the exception that occurred, if any
        Throwable t = (Throwable) request
                .getAttribute(""javax.servlet.error.exception"");

        String logInfo = UIUtil.getRequestLogInfo(request);

        // Log the error. Since we don't have a context, we need to
        // build the info ""by hand""
        String logMessage = "":error_code="" + errorCode + "":session_id="" + request.getSession().getId()
                + "":internal_error:"" + logInfo;

        log.warn(logMessage, t);

        // Now we try and mail the designated user, if any
        UIUtil.sendAlert(request, (Exception) t);

        request.setAttribute(""javax.servlet.error.code"", errorCode.toString());
        JSPManager.showJSP(request, response, ""/error/internal.jsp"");
    }",1
"@Override
    protected void shiftLeft(int numDigits) {
        if (!usingBytes && precision + numDigits > 16) {
            switchStorage();
        }
        if (usingBytes) {
            ensureCapacity(precision + numDigits);
            int i = precision + numDigits - 1;
            for (; i >= numDigits; i--) {
                bcdBytes[i] = bcdBytes[i - numDigits];
            }
            for (; i >= 0; i--) {
                bcdBytes[i] = 0;
            }
        } else {
            bcdLong <<= (numDigits * 4);
        }
        scale -= numDigits;
        precision += numDigits;
    }",0
"private void dispose(@Nullable Disposable disposable) {
        if (disposable != null && !disposable.isDisposed()) {
            disposable.dispose();
        } else if (disposable == null) {
            if (signalingDisposable != null && !signalingDisposable.isDisposed()) {
                signalingDisposable.dispose();
                signalingDisposable = null;
            }
        }
    }",0
"@Override
        public Iterable<File> successors(File file) {
          // check isDirectory() just because it may be faster than listFiles() on a non-directory
          if (file.isDirectory()) {
            File[] files = file.listFiles();
            if (files != null) {
              return Collections.unmodifiableList(Arrays.asList(files));
            }
          }

          return ImmutableList.of();
        }",0
"protected void activateJars(final List<JARDesc> jars) {
        PrivilegedAction<Void> activate = new PrivilegedAction<Void>() {

            @SuppressWarnings(""deprecation"")
            @Override
            public Void run() {
                // transfer the Jars
                waitForJars(jars);

                for (JARDesc jar : jars) {
                    available.remove(jar);

                    // add jar
                    File localFile = tracker.getCacheFile(jar.getLocation());
                    try {
                        URL location = jar.getLocation(); // non-cacheable, use source location
                        if (localFile != null) {
                            // TODO: Should be toURI().toURL()
                            location = localFile.toURL(); // cached file
                            // This is really not the best way.. but we need some way for
                            // PluginAppletViewer::getCachedImageRef() to check if the image
                            // is available locally, and it cannot use getResources() because
                            // that prefetches the resource, which confuses MediaTracker.waitForAll()
                            // which does a wait(), waiting for notification (presumably
                            // thrown after a resource is fetched). This bug manifests itself
                            // particularly when using The FileManager applet from Webmin.
                            try (JarFile jarFile = new JarFile(localFile)) {
                                for (JarEntry je : Collections.list(jarFile.entries())) {

                                    // another jar in my jar? it is more likely than you think
                                    if (je.getName().endsWith("".jar"")) {
                                        // We need to extract that jar so that it can be loaded
                                        // (inline loading with ""jar:..!/..."" path will not work
                                        // with standard classloader methods)

                                        String name = je.getName();
                                        if (name.contains("".."")){
                                            name=CacheUtil.hex(name, name);
                                        }
                                        String extractedJarLocation = localFile + "".nested/"" + name;
                                        File parentDir = new File(extractedJarLocation).getParentFile();
                                        if (!parentDir.isDirectory() && !parentDir.mkdirs()) {
                                            throw new RuntimeException(""Unable to extract nested jar."");
                                        }
                                        FileOutputStream extractedJar = new FileOutputStream(extractedJarLocation);
                                        InputStream is = jarFile.getInputStream(je);

                                        byte[] bytes = new byte[1024];
                                        int read = is.read(bytes);
                                        int fileSize = read;
                                        while (read > 0) {
                                            extractedJar.write(bytes, 0, read);
                                            read = is.read(bytes);
                                            fileSize += read;
                                        }

                                        is.close();
                                        extractedJar.close();

                                        // 0 byte file? skip
                                        if (fileSize <= 0) {
                                            continue;
                                        }

                                        tracker.addResource(new File(extractedJarLocation).toURL(), null, null, null);

                                        URL codebase = file.getCodeBase();
                                        if (codebase == null) {
                                            //FIXME: codebase should be the codebase of the Main Jar not
                                            //the location. Although, it still works in the current state.
                                            codebase = file.getResources().getMainJAR().getLocation();
                                        }

                                        final SecurityDesc jarSecurity = securityDelegate.getJarPermissions(codebase);

                                        try {
                                            URL fileURL = new URL(""file://"" + extractedJarLocation);
                                            // there is no remote URL for this, so lets fake one
                                            URL fakeRemote = new URL(jar.getLocation().toString() + ""!"" + je.getName());
                                            CachedJarFileCallback.getInstance().addMapping(fakeRemote, fileURL);
                                            addURL(fakeRemote);

                                            jarLocationSecurityMap.put(fakeRemote, jarSecurity);

                                        } catch (MalformedURLException mfue) {
                                            LOG.error(""Unable to add extracted nested jar to classpath"", mfue);
                                        }
                                    }

                                    jarEntries.add(je.getName());
                                }
                            }
                        }

                        addURL(jar.getLocation());

                        // there is currently no mechanism to cache files per
                        // instance.. so only index cached files
                        if (localFile != null) {
                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), localFile.toURI().toURL());

                            try (JarFile jarFile = new JarFile(localFile.getAbsolutePath())) {
                                Manifest mf = jarFile.getManifest();

                                // Only check classpath if this is the plugin and there is no jnlp_href usage.
                                // Note that this is different from proprietary plugin behaviour.
                                // If jnlp_href is used, the app should be treated similarly to when
                                // it is run from javaws as a webstart.
                                if (file instanceof PluginBridge && !((PluginBridge) file).useJNLPHref()) {
                                    classpaths.addAll(ManifestAttributesReader.getClassPaths(mf, jar.getLocation()));
                                }

                                JarIndexAccess index = JarIndexAccess.getJarIndex(jarFile);
                                if (index != null) {
                                    jarIndexes.add(index);
                                }
                            }
                        } else {
                            CachedJarFileCallback.getInstance().addMapping(jar.getLocation(), jar.getLocation());
                        }

                        LOG.debug(""Activate jar: {}"", location);
                    } catch (Exception ex) {
                        LOG.error(IcedTeaWebConstants.DEFAULT_ERROR_MESSAGE, ex);
                    }

                    // some programs place a native library in any jar
                    nativeLibraryStorage.addSearchJar(jar.getLocation());
                }

                return null;
            }
        };

        AccessController.doPrivileged(activate, acc);
    }",1
"public boolean updateCaCertificate(int networkId, @NonNull X509Certificate caCert,
            @NonNull X509Certificate serverCert, String certHash) {
        WifiConfiguration internalConfig = getInternalConfiguredNetwork(networkId);
        if (internalConfig == null) {
            Log.e(TAG, ""No network for network ID "" + networkId);
            return false;
        }
        if (!internalConfig.isEnterprise()) {
            Log.e(TAG, ""Network "" + networkId + "" is not an Enterprise network"");
            return false;
        }
        if (!internalConfig.enterpriseConfig.isEapMethodServerCertUsed()) {
            Log.e(TAG, ""Network "" + networkId + "" does not need verifying server cert"");
            return false;
        }
        if (null == caCert) {
            Log.e(TAG, ""Root CA cert is null"");
            return false;
        }
        if (null == serverCert) {
            Log.e(TAG, ""Server cert is null"");
            return false;
        }
        CertificateSubjectInfo serverCertInfo = CertificateSubjectInfo.parse(
                serverCert.getSubjectDN().getName());
        if (null == serverCertInfo) {
            Log.e(TAG, ""Invalid Server CA cert subject"");
            return false;
        }

        WifiConfiguration newConfig = new WifiConfiguration(internalConfig);
        try {
            if (newConfig.enterpriseConfig.isTrustOnFirstUseEnabled()) {
                if (TextUtils.isEmpty(certHash)) {
                    newConfig.enterpriseConfig.setCaCertificateForTrustOnFirstUse(caCert);
                } else {
                    newConfig.enterpriseConfig.setServerCertificateHash(certHash);
                }
                newConfig.enterpriseConfig.enableTrustOnFirstUse(false);
            } else {
                // setCaCertificate will mark that this CA certificate should be removed on
                // removing this configuration.
                newConfig.enterpriseConfig.setCaCertificate(caCert);
            }
        } catch (IllegalArgumentException ex) {
            Log.e(TAG, ""Failed to set CA cert: "" + caCert);
            return false;
        }

        // If there is a subject alternative name, it should be matched first.
        String altSubjectNames = getAltSubjectMatchFromAltSubjectName(serverCert);
        if (!TextUtils.isEmpty(altSubjectNames)) {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, ""Set altSubjectMatch to "" + altSubjectNames);
            }
            newConfig.enterpriseConfig.setAltSubjectMatch(altSubjectNames);
        } else {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, ""Set domainSuffixMatch to "" + serverCertInfo.commonName);
            }
            newConfig.enterpriseConfig.setDomainSuffixMatch(serverCertInfo.commonName);
        }
        newConfig.enterpriseConfig.setUserApproveNoCaCert(false);
        // Trigger an update to install CA certificate and the corresponding configuration.
        NetworkUpdateResult result = addOrUpdateNetwork(newConfig, internalConfig.creatorUid);
        if (!result.isSuccess()) {
            Log.e(TAG, ""Failed to install CA cert for network "" + internalConfig.SSID);
            mFrameworkFacade.showToast(mContext, mContext.getResources().getString(
                    R.string.wifi_ca_cert_failed_to_install_ca_cert));
            return false;
        }
        return true;
    }",1
"public int readInt() throws IOException {
        return primitiveTypes.readInt();
    }",0
"@Override public Material toOldMaterial(String name, String folder, String password) {
        TfsMaterial tfsMaterial = new TfsMaterial(new UrlArgument(url), username, domain, password, projectPath);
        tfsMaterial.setFolder(folder);
        setName(name,tfsMaterial);
        return tfsMaterial;
    }",1
"@Override
    public Frame readFrame() throws IOException {
        synchronized (_inputStream) {
            return Frame.readFrom(_inputStream, this.maxInboundMessageBodySize);
        }
    }",1
"protected Node composeSequenceNode(String anchor) {
        SequenceStartEvent startEvent = (SequenceStartEvent) parser.getEvent();
        String tag = startEvent.getTag();
        Tag nodeTag;
        
        boolean resolved = false;
        if (tag == null || tag.equals(""!"")) {
            nodeTag = resolver.resolve(NodeId.sequence, null, startEvent.getImplicit());
            resolved = true;
        } else {
            nodeTag = new Tag(tag);
        }
        final ArrayList<Node> children = new ArrayList<Node>();
        SequenceNode node = new SequenceNode(nodeTag, resolved, children, startEvent.getStartMark(),
                null, startEvent.getFlowStyle());
        if (startEvent.isFlow()) {
            node.setBlockComments(blockCommentsCollector.consume());
        }
        if (anchor != null) {
            node.setAnchor(anchor);
            anchors.put(anchor, node);
        }
        while (!parser.checkEvent(Event.ID.SequenceEnd)) {
            blockCommentsCollector.collectEvents();
            if (parser.checkEvent(Event.ID.SequenceEnd)) {
                break;
            }
            children.add(composeNode(node));
        }
        if (startEvent.isFlow()) {
            node.setInLineComments(inlineCommentsCollector.collectEvents().consume());
        }
        Event endEvent = parser.getEvent();
        node.setEndMark(endEvent.getEndMark());
        inlineCommentsCollector.collectEvents();
        if(!inlineCommentsCollector.isEmpty()) {
            node.setInLineComments(inlineCommentsCollector.consume());
        }
        return node;
    }",0
"private boolean isFinancedDeviceOwner(CallerIdentity caller) {
        synchronized (getLockObject()) {
            return isDeviceOwnerLocked(caller) && getDeviceOwnerTypeLocked(
                    mOwners.getDeviceOwnerPackageName()) == DEVICE_OWNER_TYPE_FINANCED;
        }
    }",0
"@Order(3)
    @Test
    void testActionRights(TestUtils testUtils, TestReference testReference)
    {
        // set some rights before the test
        DocumentReference xwikiPreferences = new DocumentReference(""xwiki"", ""XWiki"", ""XWikiPreferences"");

        testUtils.loginAsSuperAdmin();
        String anotherUserName = ""someOtherUser"";
        testUtils.createPage(xwikiPreferences, """");
        testUtils.addObject(xwikiPreferences, ""XWiki.XWikiGlobalRights"",
            ""levels"", ""edit,script"",
            ""allow"", ""1"",
            ""users"", String.format(""XWiki.%s,XWiki.%s"", USERNAME, anotherUserName));

        testUtils.login(USERNAME, PASSWORD);
        appWithinMinutesHomePage = AppWithinMinutesHomePage.gotoPage();
        try {
            // The application author should be able to edit and delete the application.
            ApplicationsLiveTableElement appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();
            appsLiveTable.filterApplicationName(appName);
            assertTrue(appsLiveTable.canEditApplication(appName));
            assertTrue(appsLiveTable.canDeleteApplication(appName));

            // Logout. Guests shouldn't be able to edit nor delete the application.
            appWithinMinutesHomePage.logout();
            testUtils.recacheSecretToken();
            appWithinMinutesHomePage = new AppWithinMinutesHomePage();
            appsLiveTable = appWithinMinutesHomePage.getAppsLiveTable();
            appsLiveTable.filterApplicationName(appName);
            assertFalse(appsLiveTable.canEditApplication(appName));
            assertFalse(appsLiveTable.canDeleteApplication(appName));

            // Login with a different user. The new user shouldn't be able to delete the application.
            testUtils.createUserAndLogin(anotherUserName, ""somePassword"");
            appsLiveTable = AppWithinMinutesHomePage.gotoPage().getAppsLiveTable();
            appsLiveTable.filterApplicationName(appName);
            assertTrue(appsLiveTable.canEditApplication(appName));
            assertFalse(appsLiveTable.canDeleteApplication(appName));
        } finally {
            testUtils.loginAsSuperAdmin();
            // We don't want to keep the rights
            testUtils.deletePage(xwikiPreferences);
        }
    }",1
"@Override
        public boolean startAsCaller(Activity activity, Bundle options, int userId) {
            final Intent intent = getBaseIntentToSend();
            if (intent == null) {
                return false;
            }
            intent.setComponent(mChooserTarget.getComponentName());
            intent.putExtras(mChooserTarget.getIntentExtras());

            // Important: we will ignore the target security checks in ActivityManager
            // if and only if the ChooserTarget's target package is the same package
            // where we got the ChooserTargetService that provided it. This lets a
            // ChooserTargetService provide a non-exported or permission-guarded target
            // to the chooser for the user to pick.
            //
            // If mSourceInfo is null, we got this ChooserTarget from the caller or elsewhere
            // so we'll obey the caller's normal security checks.
            final boolean ignoreTargetSecurity = mSourceInfo != null
                    && mSourceInfo.getResolvedComponentName().getPackageName()
                    .equals(mChooserTarget.getComponentName().getPackageName());
            activity.startActivityAsCaller(intent, options, ignoreTargetSecurity, userId);
            return true;
        }",1
"protected void setSignalStrengthDefaultValues() {
        mSignalStrength = new SignalStrength( false);
    }",0
"private List<OraclePackage> getAllRealOraclePackage(OBridgeConfiguration c) {
        String query = ""select object_name from user_objects where object_type = 'PACKAGE' and object_name like ?"";
        return jdbcTemplate.query(query, (resultSet, i) -> {
            OraclePackage p = new OraclePackage();
            p.setName(resultSet.getString(""object_name""));
            p.setProcedureList(getAllProcedure(resultSet.getString(""object_name""), """"));
            return p;
        }, c.getPackagesLike());
    }",1
"public static String errorPage(int code, String message) {
        return Holder.INSTANCE.replaceAll(buildRegex(""status_code""), valueOf(code))
                .replaceAll(buildRegex(""error_message""), StringEscapeUtils.escapeHtml4(message));
    }",1
"public String buildQuery(
            String[] projectionIn, String selection, String groupBy,
            String having, String sortOrder, String limit) {
        String[] projection = computeProjection(projectionIn);
        String where = computeWhere(selection);

        return buildQueryString(
                mDistinct, mTables, projection, where,
                groupBy, having, sortOrder, limit);
    }",1
"@Override
  public int read() throws IOException {
    int readLen = read(oneByteBuffer);

    if (readLen == -1) {
      return -1;
    }

    return oneByteBuffer[0];
  }",0
"@Deprecated
    public void setIntValue(String className, String fieldName, int value)
    {
        setIntValue(getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),
            fieldName, value);
    }",0
"@Override
    public String render(XWikiContext context) throws XWikiException
    {
        String msg = (String) context.get(""message"");
        if (StringUtils.isNotBlank(msg)) {
            context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);
        }
        return LOGIN;
    }",1
"public static boolean jsFunction_addSubscriber(Context cx, Scriptable thisObj, Object[] args, Function funObj)
            throws ScriptException, APIManagementException{

        if (args != null && isStringArray(args)) {
            if (args.length < 2) {
                handleException(
                        ""Expected 2 arguments for adding a subscriber (username, groupId), but found "" + args.length);
            }
            String username = (String) args[0];
            String groupId = (String) args[1];
            APIConsumer apiConsumer = getAPIConsumer(thisObj);
            try {
                apiConsumer.addSubscriber(username, groupId);
                return true;
            } catch (APIManagementException e) {
                handleException(""Error while adding the subscriber "" + username, e);
                return false;
            }
        }
        return false;
    }",0
"private String getRedirectParameters(String parent, String title, String template, ActionOnCreate actionOnCreate)
    {
        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {
            // We don't need to pass any parameters because the document is saved before the redirect using the
            // parameter values.
            return null;
        }

        String redirectParams = ""template="" + Util.encodeURI(template, null);
        if (parent != null) {
            redirectParams += ""&parent="" + Util.encodeURI(parent, null);
        }
        if (title != null) {
            redirectParams += ""&title="" + Util.encodeURI(title, null);
        }
        // Both the save and the edit action might require a CSRF token
        redirectParams += ""&form_token="" + Util.encodeURI(this.csrf.getToken(), null);

        return redirectParams;
    }",1
"public List<String> getConfiguredLocales() {
        List<String> tmp = new LinkedList<String>();
        for (Iterator<String> iter = this.supportedLocales.keySet().iterator(); iter
                .hasNext();) {
            String key = iter.next();
            LocaleInfo li = this.supportedLocales.get(key);
            if (!li.isAlias()) {
                tmp.add(key);
            }
        }
        Collections.sort(tmp);
        return Collections.unmodifiableList(tmp);
    }",0
"public HttpMultiMap<String> query() {
		return query;
	}",0
"OortComet createOortComet(String cometURL) {
        return _membership.createOortComet(cometURL);
    }",0
"@Override
	protected void onStart() {
		super.onStart();
		if (!xmppConnectionServiceBound) {
			if (this.mSkipBackgroundBinding) {
				Log.d(Config.LOGTAG,""skipping background binding"");
			} else {
				connectToBackend();
			}
		} else {
			this.registerListeners();
			this.onBackendConnected();
		}
	}",0
"@Override
    public void setLockTaskPackages(ComponentName who, String[] packages)
            throws SecurityException {
        Objects.requireNonNull(who, ""ComponentName is null"");
        Objects.requireNonNull(packages, ""packages is null"");
        for (String pkg : packages) {
            enforceMaxPackageNameLength(pkg);
        }

        final CallerIdentity caller = getCallerIdentity(who);

        synchronized (getLockObject()) {
            enforceCanCallLockTaskLocked(caller);
            checkCanExecuteOrThrowUnsafe(DevicePolicyManager.OPERATION_SET_LOCK_TASK_PACKAGES);
            final int userHandle = caller.getUserId();
            setLockTaskPackagesLocked(userHandle, new ArrayList<>(Arrays.asList(packages)));
        }
    }",1
"@SuppressLint(""InflateParams"")
	protected void showCreateContactDialog(final String prefilledJid, final Invite invite) {
		FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
		Fragment prev = getSupportFragmentManager().findFragmentByTag(FRAGMENT_TAG_DIALOG);
		if (prev != null) {
			ft.remove(prev);
		}
		ft.addToBackStack(null);
		EnterJidDialog dialog = EnterJidDialog.newInstance(
				mActivatedAccounts,
				getString(R.string.dialog_title_create_contact),
				getString(R.string.create),
				prefilledJid,
				null,
				invite == null || !invite.hasFingerprints()
		);

		dialog.setOnEnterJidDialogPositiveListener((accountJid, contactJid) -> {
			if (!xmppConnectionServiceBound) {
				return false;
			}

			final Account account = xmppConnectionService.findAccountByJid(accountJid);
			if (account == null) {
				return true;
			}

			final Contact contact = account.getRoster().getContact(contactJid);
			if (invite != null && invite.getName() != null) {
				contact.setServerName(invite.getName());
			}
			if (contact.isSelf()) {
				switchToConversation(contact);
				return true;
			} else if (contact.showInRoster()) {
				throw new EnterJidDialog.JidError(getString(R.string.contact_already_exists));
			} else {
				xmppConnectionService.createContact(contact, true);
				if (invite != null && invite.hasFingerprints()) {
					xmppConnectionService.verifyFingerprints(contact, invite.getFingerprints());
				}
				switchToConversationDoNotAppend(contact, invite == null ? null : invite.getBody());
				return true;
			}
		});
		dialog.show(ft, FRAGMENT_TAG_DIALOG);
	}",1
"private BigInteger validate(BigInteger y, DHParameters dhParams)
    {
        if (y == null)
        {
            throw new NullPointerException(""y value cannot be null"");
        }

        if (dhParams.getQ() != null)
        {
            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))
            {
                return y;
            }

            throw new IllegalArgumentException(""Y value does not appear to be in correct group"");
        }
        else
        {
            // TLS check
            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)
            {
                throw new IllegalArgumentException(""invalid DH public key"");
            }

            return y;         // we can't validate without Q.
        }
    }",1
"@Override
    protected ObjectStreamClass readClassDescriptor()
            throws IOException, ClassNotFoundException {
        int type = read();
        if (type < 0) {
            throw new EOFException();
        }
        switch (type) {
            case ThrowableObjectOutputStream.TYPE_EXCEPTION:
                return ObjectStreamClass.lookup(Exception.class);
            case ThrowableObjectOutputStream.TYPE_STACKTRACEELEMENT:
                return ObjectStreamClass.lookup(StackTraceElement.class);
            case ThrowableObjectOutputStream.TYPE_FAT_DESCRIPTOR:
                return verify(super.readClassDescriptor());
            case ThrowableObjectOutputStream.TYPE_THIN_DESCRIPTOR:
                String className = readUTF();
                Class<?> clazz = loadClass(className);
                return verify(ObjectStreamClass.lookup(clazz));
            default:
                throw new StreamCorruptedException(
                        ""Unexpected class descriptor type: "" + type);
        }
    }",1
"public static String getDatabaseUrl(DatabaseConfiguration dbConfig) {
        try {
            URI uri = new URI(""jdbc:"" + dbConfig.getDatabaseType().toLowerCase(), dbConfig.getDatabaseName(), null);
            return uri.toASCIIString();
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException(e);
        }
    }",1
"public Object getObject(ObjectReference objectReference)
    {
        try {
            BaseObject obj = this.getDoc().getXObject(objectReference);
            return obj == null ? null : newObjectApi(obj, getXWikiContext());
        } catch (Exception e) {
            return null;
        }
    }",0
boolean shouldUseHuffman(HttpString header);,0
"protected EvaluationContext createEvaluationContext(InstanceEvent event, Instance instance) {
		Map<String, Object> root = new HashMap<>();
		root.put(""event"", event);
		root.put(""instance"", instance);
		root.put(""lastStatus"", getLastStatus(event.getInstance()));
		return SimpleEvaluationContext
				.forPropertyAccessors(DataBindingPropertyAccessor.forReadOnlyAccess(), new MapAccessor())
				.withRootObject(root).build();
	}",1
"protected Client buildHttpClient() {
    // use the default client config if not yet initialized
    if (clientConfig == null) {
        clientConfig = getDefaultClientConfig();
    }

    ClientBuilder clientBuilder = ClientBuilder.newBuilder();
    customizeClientBuilder(clientBuilder);
    clientBuilder = clientBuilder.withConfig(clientConfig);
    return clientBuilder.build();
  }",0
"@Test
    public void testExtractNanosecondDecimal04()
    {
        BigDecimal value = new BigDecimal(""19827342231.192837465"");
        checkExtractNanos(19827342231L, 192837465, value);
    }",1
"public FormValidation doCheckDisplayName(@QueryParameter String displayName, 
            @QueryParameter String jobName) {
        displayName = displayName.trim();
        
        if(LOGGER.isLoggable(Level.FINE)) {
            LOGGER.log(Level.FINE, ""Current job name is "" + jobName);
        }
        
        if(!isNameUnique(displayName, jobName)) {
            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));
        }
        else if(!isDisplayNameUnique(displayName, jobName)){
            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));
        }
        else {
            return FormValidation.ok();
        }
    }",0
"@Override
    public void getMyMemoryState(ActivityManager.RunningAppProcessInfo outInfo) {
        enforceNotIsolatedCaller(""getMyMemoryState"");
        synchronized (this) {
            ProcessRecord proc;
            synchronized (mPidsSelfLocked) {
                proc = mPidsSelfLocked.get(Binder.getCallingPid());
            }
            fillInProcMemInfo(proc, outInfo);
        }
    }",0
"private void splitHeader(AppendableCharSequence sb) {
        final int length = sb.length();
        int nameStart;
        int nameEnd;
        int colonEnd;
        int valueStart;
        int valueEnd;

        nameStart = findNonWhitespace(sb, 0);
        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {
            char ch = sb.charAtUnsafe(nameEnd);
            // https://tools.ietf.org/html/rfc7230#section-3.2.4
            //
            // No whitespace is allowed between the header field-name and colon. In
            // the past, differences in the handling of such whitespace have led to
            // security vulnerabilities in request routing and response handling. A
            // server MUST reject any received request message that contains
            // whitespace between a header field-name and colon with a response code
            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a
            // response message before forwarding the message downstream.
            if (ch == ':' ||
                    // In case of decoding a request we will just continue processing and header validation
                    // is done in the DefaultHttpHeaders implementation.
                    //
                    // In the case of decoding a response we will ""skip"" the whitespace.
                    (!isDecodingRequest() && isOWS(ch))) {
                break;
            }
        }

        if (nameEnd == length) {
            // There was no colon present at all.
            throw new IllegalArgumentException(""No colon found"");
        }

        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {
            if (sb.charAtUnsafe(colonEnd) == ':') {
                colonEnd ++;
                break;
            }
        }

        name = sb.subStringUnsafe(nameStart, nameEnd);
        valueStart = findNonWhitespace(sb, colonEnd);
        if (valueStart == length) {
            value = EMPTY_VALUE;
        } else {
            valueEnd = findEndOfString(sb);
            value = sb.subStringUnsafe(valueStart, valueEnd);
        }
    }",1
"public boolean sendPendingBroadcastsLocked(ProcessRecord app) {
        boolean didSomething = false;
        final BroadcastRecord br = mPendingBroadcast;
        if (br != null && br.curApp.pid == app.pid) {
            if (br.curApp != app) {
                Slog.e(TAG, ""App mismatch when sending pending broadcast to ""
                        + app.processName + "", intended target is "" + br.curApp.processName);
                return false;
            }
            try {
                mPendingBroadcast = null;
                processCurBroadcastLocked(br, app);
                didSomething = true;
            } catch (Exception e) {
                Slog.w(TAG, ""Exception in new application when starting receiver ""
                        + br.curComponent.flattenToShortString(), e);
                logBroadcastReceiverDiscardLocked(br);
                finishReceiverLocked(br, br.resultCode, br.resultData,
                        br.resultExtras, br.resultAbort, false);
                scheduleBroadcastsLocked();
                // We need to reset the state if we failed to start the receiver.
                br.state = BroadcastRecord.IDLE;
                throw new RuntimeException(e.getMessage());
            }
        }
        return didSomething;
    }",1
"void addRenderer(Renderer<?> renderer) {
        addExtension(renderer);
    }",0
"public void addContainerStructures(List<ContainerStructure> containerStructures, String containerIdentifier, String containerInode){
        cache.put(containerStructureGroup + containerIdentifier + containerInode, containerStructures, containerStructureGroup);
	}",0
"private void displayVerificationWarningDialog(final Contact contact, final Invite invite) {
		AlertDialog.Builder builder = new AlertDialog.Builder(this);
		builder.setTitle(R.string.verify_omemo_keys);
		View view = getLayoutInflater().inflate(R.layout.dialog_verify_fingerprints, null);
		final CheckBox isTrustedSource = view.findViewById(R.id.trusted_source);
		TextView warning = view.findViewById(R.id.warning);
		warning.setText(JidDialog.style(this, R.string.verifying_omemo_keys_trusted_source, contact.getJid().asBareJid().toEscapedString(), contact.getDisplayName()));
		builder.setView(view);
		builder.setPositiveButton(R.string.confirm, (dialog, which) -> {
			if (isTrustedSource.isChecked() && invite.hasFingerprints()) {
				xmppConnectionService.verifyFingerprints(contact, invite.getFingerprints());
			}
			switchToConversationDoNotAppend(contact, invite.getBody());
		});
		builder.setNegativeButton(R.string.cancel, (dialog, which) -> StartConversationActivity.this.finish());
		AlertDialog dialog = builder.create();
		dialog.setCanceledOnTouchOutside(false);
		dialog.setOnCancelListener(dialog1 -> StartConversationActivity.this.finish());
		dialog.show();
	}",1
"public void put(Env env, String path, Object request, Object... urlVariables) throws RestClientException {
    execute(HttpMethod.PUT, env, path, request, null, urlVariables);
  }",0
"@Override
    public void addItem(Context context, Collection collection, Item item) throws SQLException, AuthorizeException {
        // Check authorisation
        authorizeService.authorizeAction(context, collection, Constants.ADD);

        log.info(LogHelper.getHeader(context, ""add_item"", ""collection_id=""
            + collection.getID() + "",item_id="" + item.getID()));

        // Create mapping
        // We do NOT add the item to the collection template since we would have to load in all our items
        // Instead we add the collection to an item which works in the same way.
        if (!item.getCollections().contains(collection)) {
            item.addCollection(collection);
        }

        context.addEvent(new Event(Event.ADD, Constants.COLLECTION, collection.getID(),
                                   Constants.ITEM, item.getID(), item.getHandle(),
                                   getIdentifiers(context, collection)));
    }",0
"@RequestMapping(value = ""/recoverPassword"", method = RequestMethod.GET)
  public String recoverPassword(HttpServletRequest request)
  {
    // Get the session, creating it if necessary, to make sure that the session
    // cookie gets set on the browser.  If the user goes to the ""recover"" page
    // and doesn't have a session cookie, CSRF validation will fail because the
    // token that is posted in the recovery form cannot be correlated with the
    // token in the session. Also, clean up the session if things were put into
    // it by a failed recovery attempt.
    HttpSession session = request.getSession(true);
    session.removeAttribute(""recoveryDN"");
    session.removeAttribute(""useRecaptcha"");
    return ""recover-password"";
  }",0
"private void setAvailableFileFilters(boolean ownXmlFormat, JFileChooser fileChooser) {
		if (ownXmlFormat) {
			fileChooser.resetChoosableFileFilters();
			fileChooser.addChoosableFileFilter(filterxml);
		}
		else {
			fileChooser.resetChoosableFileFilters();
			fileChooser.addChoosableFileFilter(filterbmp);
			fileChooser.addChoosableFileFilter(filtereps);
			fileChooser.addChoosableFileFilter(filtergif);
			fileChooser.addChoosableFileFilter(filterjpg);
			fileChooser.addChoosableFileFilter(filterpdf);
			fileChooser.addChoosableFileFilter(filterpng);
			fileChooser.addChoosableFileFilter(filtersvg);
		}
	}",0
"public void enforceCallFromPackage(String packageName) {
            mAppOpsManager.checkPackage(Binder.getCallingUid(), packageName);
        }",0
"protected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {
    InputStream in = null;
    HttpResponse response = null;
    CloseableHttpClient externalHttpClient = null;
    try {
      if (uri.toString().startsWith(""http"")) {
        HttpGet get = new HttpGet(uri);
        var clusterUrls = securityService.getOrganization().getServers().keySet();

        if (uri.toString().matches(downloadSource)) {
          //NB: We're creating a new client here with *different* auth than the system auth creds
          externalHttpClient = getAuthedHttpClient();
          response = externalHttpClient.execute(get);
        } else if (clusterUrls.contains(uri.getScheme() + ""://"" + uri.getHost())) {
          // Only using the system-level httpclient and digest credentials against our own servers
          response = httpClient.execute(get);
        } else {
          //NB: No auth here at all
          externalHttpClient = getNoAuthHttpClient();
          response = externalHttpClient.execute(get);
        }

        if (null == response) {
          // If you get here then chances are you're using a mock httpClient which does not have appropriate
          // mocking to respond to the URL you are feeding it.  Try adding that URL to the mock and see if that works.
          throw new IOException(""Null response object from the http client, refer to code for explanation"");
        }

        int httpStatusCode = response.getStatusLine().getStatusCode();
        if (httpStatusCode != 200) {
          throw new IOException(uri + "" returns http "" + httpStatusCode);
        }
        in = response.getEntity().getContent();
        //If it does not start with file, or we're in test mode (ie, to allow arbitrary file:// access)
      } else if (!uri.toString().startsWith(""file"") || testMode) {
        in = uri.toURL().openStream();
      } else {
        throw new IOException(""Refusing to fetch files from the local filesystem"");
      }
      String fileName = FilenameUtils.getName(uri.getPath());
      if (isBlank(FilenameUtils.getExtension(fileName)))
        fileName = getContentDispositionFileName(response);

      if (isBlank(FilenameUtils.getExtension(fileName)))
        throw new IOException(""No filename extension found: "" + fileName);
      return addContentToRepo(mp, elementId, fileName, in);
    } finally {
      if (in != null) {
        in.close();
      }
      if (externalHttpClient != null) {
        externalHttpClient.close();
      }
      httpClient.close(response);
    }
  }",1
"private SingleButtonPanel addNewAjaxActionButton(final AjaxCallback ajaxCallback, final String label, final String... classnames)
  {
    final AjaxButton button = new AjaxButton(""button"", form) {
      private static final long serialVersionUID = -5306532706450731336L;

      @Override
      protected void onSubmit(final AjaxRequestTarget target, final Form< ? > form)
      {
        csrfTokenHandler.onSubmit();
        ajaxCallback.callback(target);
      }

      @Override
      protected void onError(final AjaxRequestTarget target, final Form< ? > form)
      {
        if (ajaxCallback instanceof AjaxFormSubmitCallback) {
          ((AjaxFormSubmitCallback) ajaxCallback).onError(target, form);
        }
      }
    };
    final SingleButtonPanel buttonPanel = new SingleButtonPanel(this.actionButtons.newChildId(), button, label, classnames);
    buttonPanel.add(button);
    return buttonPanel;
  }",1
"@Override
    public String convert(String url) throws DiffException
    {
        if (url.startsWith(""data:"") || !this.configuration.isEnabled()) {
            // Already data URI.
            return url;
        }

        // Convert URL to absolute URL to avoid issues with relative URLs that might reference different images
        // in different subwikis.
        URL absoluteURL = getAbsoluteURL(url, this.xcontextProvider.get());

        String cacheKey = getCacheKey(absoluteURL);

        try {
            String dataURI = this.cache.get(cacheKey);

            if (dataURI == null) {
                DiffException failure = this.failureCache.get(cacheKey);

                if (failure != null) {
                    throw failure;
                }

                dataURI = convert(absoluteURL);
                this.cache.set(cacheKey, dataURI);
            }

            return dataURI;
        } catch (IOException | URISyntaxException e) {
            DiffException diffException = new DiffException(""Failed to convert ["" + url + ""] to data URI."", e);
            this.failureCache.set(cacheKey, diffException);
            throw diffException;
        }
    }",1
"public void activityIdle(IBinder token, Configuration config,
            boolean stopProfiling) throws RemoteException;",0
"private File getCustomLogoFile() {
		return new File(Bootstrap.getSiteDir(), ""assets/logo.png"");
	}",1
"@Transactional
    public void update(DatabaseTypeUpdateRequest request) {
        databaseTypeDao.selectOptionalById(request.getId()).ifPresent(data -> {
            if (DatabaseTypes.has(data.getDatabaseType())) {
                throw DomainErrors.MUST_NOT_MODIFY_SYSTEM_DEFAULT_DATABASE_TYPE.exception();
            }
            driverResources.validateJar(request.getJdbcDriverFileUrl(), request.getJdbcDriverClassName());
            DatabaseTypePojo pojo = databaseTypePojoConverter.of(request);
            try {
                databaseTypeDao.updateById(pojo);
            } catch (DuplicateKeyException e) {
                throw DomainErrors.DATABASE_TYPE_NAME_DUPLICATE.exception();
            }

            // 名称修改，下载地址修改需要删除原有的 driver
            if (!Objects.equals(request.getDatabaseType(), data.getDatabaseType())
                    || !Objects.equals(request.getJdbcDriverFileUrl(), data.getJdbcDriverFileUrl())) {
                driverResources.deleteByDatabaseType(data.getDatabaseType());
            }
        });

    }",1
"protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {


        String username = request.getParameter(""username""); //Gets all the parameters
        String password = request.getParameter(""password"");
        Properties prop = System.getProperties();

        try {

            prop.put(""mail.user"", username);
            prop.put(""mail.password"", password);
            prop.put(""mail.smtp.auth"", ""true"");
            prop.put(""mail.smtp.starttls.enable"", ""true"");
            prop.put(""mail.smtp.host"", ""smtp.gmail.com"");
            prop.put(""mail.smtp.port"", ""587"");
            prop.put(""mail.store.protocol"", ""imaps"");

            Session session = Session.getDefaultInstance(prop);
            Store store = session.getStore(""imaps"");
            store.connect(""imap.googlemail.com"", username, password);

            request.getSession().setAttribute(""session"", session);

            RequestDispatcher dispatcher = request.getRequestDispatcher(""email.html"");
            dispatcher.forward(request, response);

        } catch (MessagingException e) {
            RequestDispatcher dispatcher = request.getRequestDispatcher(""Error""); //New Request Dispatcher
            request.setAttribute(""error"", e.getMessage());
            request.setAttribute(""previous"", ""index.html"");
            dispatcher.forward(request, response);
        }
    }",1
"@Override
        public void accept(@NotNull DockerfileBuilder builder) {
            builder.from(""alpine:3.19.0"");
            builder.run(""apk add --no-cache openssh"");
            builder.expose(22);
            builder.copy(""entrypoint.sh"", ""/entrypoint.sh"");

            builder.add(""authorized_keys"", ""/home/sshj/.ssh/authorized_keys"");
            builder.copy(""test-container/trusted_ca_keys"", ""/etc/ssh/trusted_ca_keys"");

            for (String hostKey : hostKeys) {
                builder.copy(hostKey, ""/etc/ssh/"" + Paths.get(hostKey).getFileName());
                builder.copy(hostKey + "".pub"", ""/etc/ssh/"" + Paths.get(hostKey).getFileName() + "".pub"");
            }

            for (String certificate : certificates) {
                builder.copy(certificate, ""/etc/ssh/"" + Paths.get(certificate).getFileName());
            }


            builder.run(""apk add --no-cache tini""
                    + "" && echo \""root:smile\"" | chpasswd""
                    + "" && adduser -D -s /bin/ash sshj""
                    + "" && passwd -u sshj""
                    + "" && echo \""sshj:ultrapassword\"" | chpasswd""
                    + "" && chmod 600 /home/sshj/.ssh/authorized_keys""
                    + "" && chmod 600 /etc/ssh/ssh_host_*_key""
                    + "" && chmod 644 /etc/ssh/*.pub""
                    + "" && chmod 755 /entrypoint.sh""
                    + "" && chown -R sshj:sshj /home/sshj"");
            builder.entryPoint(""/sbin/tini"", ""/entrypoint.sh"", ""-o"", ""LogLevel=DEBUG2"");

            builder.add(""sshd_config"", ""/etc/ssh/sshd_config"");
        }",1
"public String ParamAsRealPath(String key)
    {
        String param = getConfiguration().getProperty(key);
        try {
            return getRealPath(param);
        } catch (Exception e) {
            return param;
        }
    }",0
"public static HgMaterial hgMaterial() {
        return new HgMaterial(""hg-url"", null);
    }",0
"public static PSystemVersion createShowAuthors2(UmlSource source) {
		// Duplicate in OptionPrint
		final List<String> strings = getAuthorsStrings(true);
		return new PSystemVersion(source, true, strings);
	}",0
"private boolean makeAppCrashingLocked(ProcessRecord app,
            String shortMsg, String longMsg, String stackTrace) {
        app.crashing = true;
        app.crashingReport = generateProcessError(app,
                ActivityManager.ProcessErrorStateInfo.CRASHED, null, shortMsg, longMsg, stackTrace);
        startAppProblemLocked(app);
        app.stopFreezingAllLocked();
        return handleAppCrashLocked(app, ""force-crash"" /*reason*/, shortMsg, longMsg, stackTrace);
    }",0
"@Override
    public Duration deserialize(JsonParser parser, DeserializationContext context) throws IOException
    {
        switch (parser.getCurrentTokenId())
        {
            case JsonTokenId.ID_NUMBER_FLOAT:
                BigDecimal value = parser.getDecimalValue();
                return DecimalUtils.extractSecondsAndNanos(value, Duration::ofSeconds);

            case JsonTokenId.ID_NUMBER_INT:
                if(context.isEnabled(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)) {
                    return Duration.ofSeconds(parser.getLongValue());
                }
                return Duration.ofMillis(parser.getLongValue());

            case JsonTokenId.ID_STRING:
                String string = parser.getText().trim();
                if (string.length() == 0) {
                    return null;
                }
                try {
                    return Duration.parse(string);
                } catch (DateTimeException e) {
                    return _handleDateTimeException(context, e, string);
                }
            case JsonTokenId.ID_EMBEDDED_OBJECT:
                // 20-Apr-2016, tatu: Related to [databind#1208], can try supporting embedded
                //    values quite easily
                return (Duration) parser.getEmbeddedObject();
                
            case JsonTokenId.ID_START_ARRAY:
            	return _deserializeFromArray(parser, context);
        }
        return _handleUnexpectedToken(context, parser, JsonToken.VALUE_STRING,
                JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_FLOAT);
    }",1
"private void startFreezingDisplayLocked(boolean inTransaction, int exitAnim, int enterAnim) {
        if (mDisplayFrozen) {
            return;
        }

        if (!mDisplayReady || !mPolicy.isScreenOn()) {
            // No need to freeze the screen before the system is ready or if
            // the screen is off.
            return;
        }

        mScreenFrozenLock.acquire();

        mDisplayFrozen = true;
        mDisplayFreezeTime = SystemClock.elapsedRealtime();
        mLastFinishedFreezeSource = null;

        mInputMonitor.freezeInputDispatchingLw();

        // Clear the last input window -- that is just used for
        // clean transitions between IMEs, and if we are freezing
        // the screen then the whole world is changing behind the scenes.
        mPolicy.setLastInputMethodWindowLw(null, null);

        if (mAppTransition.isTransitionSet()) {
            mAppTransition.freeze();
        }

        if (PROFILE_ORIENTATION) {
            File file = new File(""/data/system/frozen"");
            Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);
        }

        if (CUSTOM_SCREEN_ROTATION) {
            mExitAnimId = exitAnim;
            mEnterAnimId = enterAnim;
            final DisplayContent displayContent = getDefaultDisplayContentLocked();
            final int displayId = displayContent.getDisplayId();
            ScreenRotationAnimation screenRotationAnimation =
                    mAnimator.getScreenRotationAnimationLocked(displayId);
            if (screenRotationAnimation != null) {
                screenRotationAnimation.kill();
            }

            // Check whether the current screen contains any secure content.
            boolean isSecure = false;
            final WindowList windows = getDefaultWindowListLocked();
            final int N = windows.size();
            for (int i = 0; i < N; i++) {
                WindowState ws = windows.get(i);
                if (ws.isOnScreen() && (ws.mAttrs.flags & FLAG_SECURE) != 0) {
                    isSecure = true;
                    break;
                }
            }

            // TODO(multidisplay): rotation on main screen only.
            displayContent.updateDisplayInfo();
            screenRotationAnimation = new ScreenRotationAnimation(mContext, displayContent,
                    mFxSession, inTransaction, mPolicy.isDefaultOrientationForced(), isSecure);
            mAnimator.setScreenRotationAnimationLocked(displayId, screenRotationAnimation);
        }
    }",0
"public void setAllowMultiple(boolean allowMultiple) {
		this.allowMultiple = allowMultiple;
	}",0
"@Test(timeout = 100)
    public void testDeserializationAsFloatEdgeCase09() throws Exception
    {
        String input = ""-1e10000000"";
        Instant value = MAPPER.readValue(input, Instant.class);
        assertEquals(0, value.getEpochSecond());
    }",1
"protected FhirContext newContext(FhirVersionEnum version) {
		FhirContext retVal;
		retVal = new FhirContext(version);
		return retVal;
	}",0
"private LikeCondition createLike(Type type, String toMatch) {
		if (notLike) {
			return new NotLikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));
		} else {
			return new LikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));
		}
	}",1
"public static GitMaterial gitMaterial(String url) {
        return gitMaterial(url, null, null);
    }",0
"public void editarResponsavel(Responsavel responsavel) throws Exception{
		ResultSet result = this.bancoConec.execConsulta(""Select * from ACI_Responsavel where Email='""
				+responsavel.getEmail()+""'"");
		if(!result.first()){
			throw new Exception(""Responsavel com esse email já inexistente"");
		}
		
		result.close();
		
		String comSql = ""update ACI_Responsavel set Nome='""+responsavel.getNome()+
				""', Telefone='"" + responsavel.getTelefone() + ""', Endereco='"" + responsavel.getEndereco()
				+ ""' where Email='""+ responsavel.getEmail() + ""'"";
		this.bancoConec.execComando(comSql);
	}",0
"@Override
    public Collection<LBMember> listMembersByPool(String poolId) {
        Collection<LBMember> result = new HashSet<LBMember>();
        
        if(pools.containsKey(poolId)) {
            ArrayList<String> memberIds = pools.get(poolId).members;
            for (int i = 0; i<memberIds.size(); i++)
                result.add(members.get(memberIds.get(i)));
        }
        return result;
    }",0
"private String getPath(HttpServletRequest request) {
        try {
            return new URI(request.getRequestURI()).getPath();
        } catch (URISyntaxException e) {
            LOGGER.error(""parse request to path error"", e);
            throw new NacosRuntimeException(NacosException.NOT_FOUND, ""Invalid URI"");
        }
    }",1
"private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {
        String url = httpServletRequest.getRequestURI();
        String urlStart = ""/navigate/directions/v5/gh/"" + profile + ""/"";
        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(""Incorrect URL "" + url);
        url = url.substring(urlStart.length());
        String[] pointStrings = url.split("";"");
        List<GHPoint> points = new ArrayList<>(pointStrings.length);
        for (int i = 0; i < pointStrings.length; i++) {
            points.add(GHPoint.fromStringLonLat(pointStrings[i]));
        }

        return points;
    }",1
"@Override
    public Object readObject() throws JMSException {
        return this.readPrimitiveType(Object.class);
    }",0
"protected Schema getEmbeddedLwM2mSchema() throws SAXException {
        InputStream inputStream = DDFFileValidator.class.getResourceAsStream(LWM2M_V1_SCHEMA_PATH);
        Source source = new StreamSource(inputStream);
        SchemaFactory schemaFactory = createSchemaFactory();
        return schemaFactory.newSchema(source);
    }",1
"@Post(""/projects/{projectName}/repos/{repoName}/contents"")
    @RequiresWritePermission
    public CompletableFuture<PushResultDto> push(
            @Param @Default(""-1"") String revision,
            Repository repository,
            Author author,
            CommitMessageDto commitMessage,
            @RequestConverter(ChangesRequestConverter.class) Iterable<Change<?>> changes) {
        checkMirrorLocalRepo(repository, changes);

        final long commitTimeMillis = System.currentTimeMillis();
        return push(commitTimeMillis, author, repository, new Revision(revision), commitMessage, changes)
                .toCompletableFuture()
                .thenApply(rrev -> convert(rrev, commitTimeMillis));
    }",1
"@Override
	public boolean hasKey() {
		return haskey;
	}",0
"@Override
    public void setLockPattern(String pattern, String savedCredential, int userId)
            throws RemoteException {
        checkWritePermission(userId);
        byte[] currentHandle = getCurrentHandle(userId);

        if (pattern == null) {
            getGateKeeperService().clearSecureUserId(userId);
            mStorage.writePatternHash(null, userId);
            setKeystorePassword(null, userId);
            return;
        }

        if (currentHandle == null) {
            if (savedCredential != null) {
                Slog.w(TAG, ""Saved credential provided, but none stored"");
            }
            savedCredential = null;
        }

        byte[] enrolledHandle = enrollCredential(currentHandle, savedCredential, pattern, userId);
        if (enrolledHandle != null) {
            mStorage.writePatternHash(enrolledHandle, userId);
        } else {
            Slog.e(TAG, ""Failed to enroll pattern"");
        }
    }",1
"@RequestMapping(""/"")
    @ResponseBody
    public String list(Model model, // TODO model should no longer be injected
                       @RequestParam(required = false, defaultValue = ""FILENAME"") SortBy sortBy,
                       @RequestParam(required = false, defaultValue = ""false"") boolean desc,
                       @RequestParam(required = false) String base) throws IOException, TemplateException {
        Path currentFolder = loggingPath(base);
        securityCheck(currentFolder, null);


        List<FileEntry> files = getFileProvider(currentFolder).getFileEntries(currentFolder);
        List<FileEntry> sortedFiles = sortFiles(files, sortBy, desc);

        model.addAttribute(""sortBy"", sortBy);
        model.addAttribute(""desc"", desc);
        model.addAttribute(""files"", sortedFiles);
        model.addAttribute(""currentFolder"", currentFolder.toAbsolutePath().toString());
        model.addAttribute(""base"", base != null ? URLEncoder.encode(base, ""UTF-8"") : """");
        model.addAttribute(""parent"", getParent(currentFolder));
        model.addAttribute(""stylesheets"", stylesheets);

        return FreeMarkerTemplateUtils.processTemplateIntoString(freemarkerConfig.getTemplate(""logview.ftl""), model);
    }",1
"private void setPropertyIfNotNull(org.neo4j.graphdb.Node root, String propertyKey, Object value) {
        if (value!=null) {
            root.setProperty(propertyKey, value);
        }
    }",0
"public void setSubscriptionType(String subscriptionType) {
        mSubscriptionType = subscriptionType;
    }",0
"@Override
    @SuppressWarnings(""FinalizeDeclaration"")
    protected void finalize() throws Throwable {
        super.finalize();
        // Call shutdown as the user may have created the OpenSslEngine and not used it at all.
        shutdown();
    }",0
"public void onHostEmulationData(byte[] data) {
        Log.d(TAG, ""notifyHostEmulationData"");
        String selectAid = findSelectAid(data);
        ComponentName resolvedService = null;
        ApduServiceInfo resolvedServiceInfo = null;
        AidResolveInfo resolveInfo = null;
        synchronized (mLock) {
            if (mState == STATE_IDLE) {
                Log.e(TAG, ""Got data in idle state."");
                return;
            } else if (mState == STATE_W4_DEACTIVATE) {
                Log.e(TAG, ""Dropping APDU in STATE_W4_DECTIVATE"");
                return;
            }
            if (selectAid != null) {
                if (selectAid.equals(ANDROID_HCE_AID)) {
                    NfcService.getInstance().sendData(ANDROID_HCE_RESPONSE);
                    return;
                }
                resolveInfo = mAidCache.resolveAid(selectAid);
                if (resolveInfo == null || resolveInfo.services.size() == 0) {
                    // Tell the remote we don't handle this AID
                    NfcService.getInstance().sendData(AID_NOT_FOUND);
                    return;
                }
                mLastSelectedAid = selectAid;
                if (resolveInfo.defaultService != null) {
                    // Resolve to default
                    // Check if resolvedService requires unlock
                    ApduServiceInfo defaultServiceInfo = resolveInfo.defaultService;
                    if ((defaultServiceInfo.requiresUnlock()
                            || NfcService.getInstance().isSecureNfcEnabled())
                          && mKeyguard.isKeyguardLocked()) {
                        NfcService.getInstance().sendRequireUnlockIntent();
                        NfcService.getInstance().sendData(AID_NOT_FOUND);
                        if (DBG) Log.d(TAG, ""requiresUnlock()! show toast"");
                        launchTapAgain(resolveInfo.defaultService, resolveInfo.category);
                        return;
                    }
                    if (defaultServiceInfo.requiresScreenOn() && !mPowerManager.isScreenOn()) {
                        NfcService.getInstance().sendRequireUnlockIntent();
                        NfcService.getInstance().sendData(AID_NOT_FOUND);
                        if (DBG) Log.d(TAG, ""requiresScreenOn()!"");
                        return;
                    }
                    // In no circumstance should this be an OffHostService -
                    // we should never get this AID on the host in the first place
                    if (!defaultServiceInfo.isOnHost()) {
                        Log.e(TAG, ""AID that was meant to go off-host was routed to host."" +
                                "" Check routing table configuration."");
                        NfcService.getInstance().sendData(AID_NOT_FOUND);
                        return;
                    }
                    resolvedService = defaultServiceInfo.getComponent();
                    resolvedServiceInfo = defaultServiceInfo;
                } else if (mActiveServiceName != null) {
                    for (ApduServiceInfo serviceInfo : resolveInfo.services) {
                        if (mActiveServiceName.equals(serviceInfo.getComponent())) {
                            resolvedService = mActiveServiceName;
                            resolvedServiceInfo = serviceInfo;
                            break;
                        }
                    }
                }
                if (resolvedService == null) {
                    // We have no default, and either one or more services.
                    // Ask the user to confirm.
                    // Just ignore all future APDUs until we resolve to only one
                    mState = STATE_W4_DEACTIVATE;
                    launchResolver((ArrayList<ApduServiceInfo>)resolveInfo.services, null,
                            resolveInfo.category);
                    return;
                }
            }
            switch (mState) {
                case STATE_W4_SELECT:
                    if (selectAid != null) {
                        UserHandle user =
                                UserHandle.getUserHandleForUid(resolvedServiceInfo.getUid());
                        Messenger existingService =
                                bindServiceIfNeededLocked(user.getIdentifier(), resolvedService);
                        if (existingService != null) {
                            Log.d(TAG, ""Binding to existing service"");
                            mState = STATE_XFER;
                            sendDataToServiceLocked(existingService, data);
                        } else {
                            // Waiting for service to be bound
                            Log.d(TAG, ""Waiting for new service."");
                            // Queue SELECT APDU to be used
                            mSelectApdu = data;
                            mState = STATE_W4_SERVICE;
                        }
                        if (CardEmulation.CATEGORY_PAYMENT.equals(resolveInfo.category)) {
                            NfcStatsLog.write(NfcStatsLog.NFC_CARDEMULATION_OCCURRED,
                                    NfcStatsLog.NFC_CARDEMULATION_OCCURRED__CATEGORY__HCE_PAYMENT,
                                    ""HCE"");
                        } else {
                            NfcStatsLog.write(NfcStatsLog.NFC_CARDEMULATION_OCCURRED,
                                    NfcStatsLog.NFC_CARDEMULATION_OCCURRED__CATEGORY__HCE_OTHER,
                                    ""HCE"");
                        }
                    } else {
                        Log.d(TAG, ""Dropping non-select APDU in STATE_W4_SELECT"");
                        NfcService.getInstance().sendData(UNKNOWN_ERROR);
                    }
                    break;
                case STATE_W4_SERVICE:
                    Log.d(TAG, ""Unexpected APDU in STATE_W4_SERVICE"");
                    break;
                case STATE_XFER:
                    if (selectAid != null) {
                        UserHandle user =
                                UserHandle.getUserHandleForUid(resolvedServiceInfo.getUid());
                        Messenger existingService =
                                bindServiceIfNeededLocked(user.getIdentifier(), resolvedService);
                        if (existingService != null) {
                            sendDataToServiceLocked(existingService, data);
                            mState = STATE_XFER;
                        } else {
                            // Waiting for service to be bound
                            mSelectApdu = data;
                            mState = STATE_W4_SERVICE;
                        }
                    } else if (mActiveService != null) {
                        // Regular APDU data
                        sendDataToServiceLocked(mActiveService, data);
                    } else {
                        // No SELECT AID and no active service.
                        Log.d(TAG, ""Service no longer bound, dropping APDU"");
                    }
                    break;
            }
        }
    }",1
"private static void writeBaloFile(HttpsURLConnection conn, Path baloPath, String fullModuleName,
            long resContentLength) {
        try (InputStream inputStream = conn.getInputStream();
                FileOutputStream outputStream = new FileOutputStream(baloPath.toString())) {
            writeAndHandleProgress(inputStream, outputStream, resContentLength / 1024, fullModuleName);
        } catch (IOException e) {
            createError(""error occurred copying the balo file: "" + e.getMessage());
        }
    }",1
"private void cancelAuthentication(CryptoObject cryptoObject) {
        if (mService != null) try {
            mService.cancelAuthentication(mToken, mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }",0
"public static Rectangle getNormalizedRectangle(PdfArray box) {
		if( box== null )
			return null;
        float llx = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(0))).floatValue();
        float lly = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(1))).floatValue();
        float urx = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(2))).floatValue();
        float ury = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(3))).floatValue();
        return new Rectangle(Math.min(llx, urx), Math.min(lly, ury),
        Math.max(llx, urx), Math.max(lly, ury));
    }",0
"public boolean isResourceProviderInDevelopmentMode(String providerName) {
		return resourceProvidersInDevelopmentMode.contains(providerName);
	}",1
"private IdProviders getSortedIdProviders()
    {
        IdProviders idProviders = securityService.get().getIdProviders();
        return IdProviders.from(
            idProviders.stream().sorted( Comparator.comparing( u -> u.getKey().toString() ) ).collect( Collectors.toList() ) );
    }",1
"@SuppressWarnings(""unchecked"")
    private Map < String, Property<?>> parseProperties(List<Map<String, Object>> properties) {
        Map < String, Property<?>> result = new HashMap<>();
        if (null != properties) {
            properties.forEach(property -> {
                // Initiate with name and value
                String name     = (String) property.get(PROPERTY_PARAMNAME);
                if (null == name) { 
                    throw new IllegalArgumentException(""Invalid YAML File: 'name' is expected for properties"");
                }
                
                Object objValue = property.get(PROPERTY_PARAMVALUE);
                if (null == objValue) {
                    throw new IllegalArgumentException(""Invalid YAML File: 'value' is expected for properties"");
                }
                // Convert as a String
                String strValue = String.valueOf(objValue);
                if (objValue instanceof Date) {
                    strValue = SIMPLE_DATE_FORMAT.format((Date) objValue);
                }
                
                Property<?> ap = new PropertyString(name, strValue);
                String optionalType = (String) property.get(PROPERTY_PARAMTYPE);
                // If specific type defined ?
                if (null != optionalType) {
                    // Substitution if relevant (e.g. 'int' -> 'org.ff4j.property.PropertyInt')
                    optionalType = MappingUtil.mapPropertyType(optionalType);
                    try {
                        // Constructor (String, String) is mandatory in Property interface
                        Class<?> typeClass = Class.forName(optionalType);
                        if (!Property.class.isAssignableFrom(typeClass)) {
                            throw new IllegalArgumentException(""Cannot create property <"" + name + ""> invalid type <"" + optionalType + "">"");
                        }
                        Constructor<?> constr = typeClass.getConstructor(String.class, String.class);
                        ap = (Property<?>) constr.newInstance(name, strValue);
                    } catch (Exception e) {
                        throw new IllegalArgumentException(""Cannot instantiate '"" + optionalType + ""' check default constructor"", e);
                    }
                }
                // Description
                String description = (String) property.get(PROPERTY_PARAMDESCRIPTION);
                if (null != description) {
                    ap.setDescription(description);
                } 
                // Fixed Values
                List<Object> fixedValues = (List<Object>) property.get(PROPERTY_PARAMFIXED_VALUES);
                if (null != fixedValues && fixedValues.size() > 0) {
                    fixedValues.stream().map(Object::toString).forEach(ap::add2FixedValueFromString);
                }
                // Check fixed value
                if (ap.getFixedValues() != null &&  
                   !ap.getFixedValues().isEmpty() && 
                   !ap.getFixedValues().contains(ap.getValue())) {
                    throw new IllegalArgumentException(""Cannot create property <"" + ap.getName() + 
                            ""> invalid value <"" + ap.getValue() + 
                            ""> expected one of "" + ap.getFixedValues());
                }
                result.put(ap.getName(), ap);
            });
        }
        return result;
    }",1
"private final boolean cleanUpApplicationRecordLocked(ProcessRecord app,
            boolean restarting, boolean allowRestart, int index, boolean replacingPid) {
        Slog.d(TAG, ""cleanUpApplicationRecord -- "" + app.pid);
        if (index >= 0) {
            removeLruProcessLocked(app);
            ProcessList.remove(app.pid);
        }

        mProcessesToGc.remove(app);
        mPendingPssProcesses.remove(app);

        // Dismiss any open dialogs.
        if (app.crashDialog != null && !app.forceCrashReport) {
            app.crashDialog.dismiss();
            app.crashDialog = null;
        }
        if (app.anrDialog != null) {
            app.anrDialog.dismiss();
            app.anrDialog = null;
        }
        if (app.waitDialog != null) {
            app.waitDialog.dismiss();
            app.waitDialog = null;
        }

        app.crashing = false;
        app.notResponding = false;

        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        app.makeInactive(mProcessStats);
        app.waitingToKill = null;
        app.forcingToForeground = null;
        updateProcessForegroundLocked(app, false, false);
        app.foregroundActivities = false;
        app.hasShownUi = false;
        app.treatLikeActivity = false;
        app.hasAboveClient = false;
        app.hasClientActivities = false;

        mServices.killServicesLocked(app, allowRestart);

        boolean restart = false;

        // Remove published content providers.
        for (int i = app.pubProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = app.pubProviders.valueAt(i);
            final boolean always = app.bad || !allowRestart;
            boolean inLaunching = removeDyingProviderLocked(app, cpr, always);
            if ((inLaunching || always) && cpr.hasConnectionOrHandle()) {
                // We left the provider in the launching list, need to
                // restart it.
                restart = true;
            }

            cpr.provider = null;
            cpr.proc = null;
        }
        app.pubProviders.clear();

        // Take care of any launching providers waiting for this process.
        if (cleanupAppInLaunchingProvidersLocked(app, false)) {
            restart = true;
        }

        // Unregister from connected content providers.
        if (!app.conProviders.isEmpty()) {
            for (int i = app.conProviders.size() - 1; i >= 0; i--) {
                ContentProviderConnection conn = app.conProviders.get(i);
                conn.provider.connections.remove(conn);
                stopAssociationLocked(app.uid, app.processName, conn.provider.uid,
                        conn.provider.name);
            }
            app.conProviders.clear();
        }

        // At this point there may be remaining entries in mLaunchingProviders
        // where we were the only one waiting, so they are no longer of use.
        // Look for these and clean up if found.
        // XXX Commented out for now.  Trying to figure out a way to reproduce
        // the actual situation to identify what is actually going on.
        if (false) {
            for (int i = mLaunchingProviders.size() - 1; i >= 0; i--) {
                ContentProviderRecord cpr = mLaunchingProviders.get(i);
                if (cpr.connections.size() <= 0 && !cpr.hasExternalProcessHandles()) {
                    synchronized (cpr) {
                        cpr.launchingApp = null;
                        cpr.notifyAll();
                    }
                }
            }
        }

        skipCurrentReceiverLocked(app);

        // Unregister any receivers.
        for (int i = app.receivers.size() - 1; i >= 0; i--) {
            removeReceiverLocked(app.receivers.valueAt(i));
        }
        app.receivers.clear();

        // If the app is undergoing backup, tell the backup manager about it
        if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
            if (DEBUG_BACKUP || DEBUG_CLEANUP) Slog.d(TAG_CLEANUP, ""App ""
                    + mBackupTarget.appInfo + "" died during backup"");
            try {
                IBackupManager bm = IBackupManager.Stub.asInterface(
                        ServiceManager.getService(Context.BACKUP_SERVICE));
                bm.agentDisconnected(app.info.packageName);
            } catch (RemoteException e) {
                // can't happen; backup manager is local
            }
        }

        for (int i = mPendingProcessChanges.size() - 1; i >= 0; i--) {
            ProcessChangeItem item = mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                mPendingProcessChanges.remove(i);
                mAvailProcessChanges.add(item);
            }
        }
        mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED_UI_MSG, app.pid, app.info.uid,
                null).sendToTarget();

        // If the caller is restarting this app, then leave it in its
        // current lists and let the caller take care of it.
        if (restarting) {
            return false;
        }

        if (!app.persistent || app.isolated) {
            if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,
                    ""Removing non-persistent process during cleanup: "" + app);
            if (!replacingPid) {
                removeProcessNameLocked(app.processName, app.uid);
            }
            if (mHeavyWeightProcess == app) {
                mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,
                        mHeavyWeightProcess.userId, 0));
                mHeavyWeightProcess = null;
            }
        } else if (!app.removed) {
            // This app is persistent, so we need to keep its record around.
            // If it is not already on the pending app list, add it there
            // and start a new process for it.
            if (mPersistentStartingProcesses.indexOf(app) < 0) {
                mPersistentStartingProcesses.add(app);
                restart = true;
            }
        }
        if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app)) Slog.v(
                TAG_CLEANUP, ""Clean-up removing on hold: "" + app);
        mProcessesOnHold.remove(app);

        if (app == mHomeProcess) {
            mHomeProcess = null;
        }
        if (app == mPreviousProcess) {
            mPreviousProcess = null;
        }

        if (restart && !app.isolated) {
            // We have components that still need to be running in the
            // process, so re-launch it.
            if (index < 0) {
                ProcessList.remove(app.pid);
            }
            addProcessNameLocked(app);
            startProcessLocked(app, ""restart"", app.processName);
            return true;
        } else if (app.pid > 0 && app.pid != MY_PID) {
            // Goodbye!
            boolean removed;
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.remove(app.pid);
                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
            }
            mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
            if (app.isolated) {
                mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
            }
            app.setPid(0);
        }
        return false;
    }",1
"protected final void _decodeNonStringName(int ch) throws IOException
    {
        final int type = ((ch >> 5) & 0x7);
        String name;
        if (type == CBORConstants.MAJOR_TYPE_INT_POS) {
            name = _numberToName(ch, false);
        } else if (type == CBORConstants.MAJOR_TYPE_INT_NEG) {
            name = _numberToName(ch, true);
        } else if (type == CBORConstants.MAJOR_TYPE_BYTES) {
            // 08-Sep-2014, tatu: As per [Issue#5], there are codecs
            //   (f.ex. Perl module ""CBOR::XS"") that use Binary data...
            final int blen = _decodeExplicitLength(ch & 0x1F);
            byte[] b = _finishBytes(blen);
            // TODO: Optimize, if this becomes commonly used & bottleneck; we have
            //  more optimized UTF-8 codecs available.
            name = new String(b, UTF8);
        } else {
            if ((ch & 0xFF) == CBORConstants.INT_BREAK) {
                _reportUnexpectedBreak();
            }
            throw _constructError(""Unsupported major type (""+type+"") for CBOR Objects, not (yet?) supported, only Strings"");
        }
        _parsingContext.setCurrentName(name);
    }",1
"public final void addActivity(PackageParser.Activity a, String type) {
            final boolean systemApp = a.info.applicationInfo.isSystemApp();
            mActivities.put(a.getComponentName(), a);
            if (DEBUG_SHOW_INFO)
                Log.v(
                TAG, ""  "" + type + "" "" +
                (a.info.nonLocalizedLabel != null ? a.info.nonLocalizedLabel : a.info.name) + "":"");
            if (DEBUG_SHOW_INFO)
                Log.v(TAG, ""    Class="" + a.info.name);
            final int NI = a.intents.size();
            for (int j=0; j<NI; j++) {
                PackageParser.ActivityIntentInfo intent = a.intents.get(j);
                if (""activity"".equals(type)) {
                    final PackageSetting ps =
                            mSettings.getDisabledSystemPkgLPr(intent.activity.info.packageName);
                    final List<PackageParser.Activity> systemActivities =
                            ps != null && ps.pkg != null ? ps.pkg.activities : null;
                    adjustPriority(systemActivities, intent);
                }
                if (DEBUG_SHOW_INFO) {
                    Log.v(TAG, ""    IntentFilter:"");
                    intent.dump(new LogPrinter(Log.VERBOSE, TAG), ""      "");
                }
                if (!intent.debugCheck()) {
                    Log.w(TAG, ""==> For Activity "" + a.info.name);
                }
                addFilter(intent);
            }
        }",1
"public int dumpToFiles(final String basepath) throws IOException {
    int npoints = 0;
    final int nseries = datapoints.size();
    final String datafiles[] = nseries > 0 ? new String[nseries] : null;
    FileSystem.checkDirectory(new File(basepath).getParent(),
        Const.MUST_BE_WRITEABLE, Const.CREATE_IF_NEEDED);
    for (int i = 0; i < nseries; i++) {
      datafiles[i] = basepath + ""_"" + i + "".dat"";
      final PrintWriter datafile = new PrintWriter(datafiles[i]);
      try {
        for (final DataPoint d : datapoints.get(i)) {
          final long ts = d.timestamp() / 1000;          
          if (d.isInteger()) {
            datafile.print(ts + utc_offset);
            datafile.print(' ');
            datafile.print(d.longValue());
          } else {
            final double value = d.doubleValue();

            if (Double.isInfinite(value)) {
              // Infinity is invalid.
              throw new IllegalStateException(""Infinity found in""
                  + "" datapoints #"" + i + "": "" + value + "" d="" + d);
            } else if (Double.isNaN(value)) {
              // NaNs should be skipped.
              continue;
            }

            datafile.print(ts + utc_offset);
            datafile.print(' ');
            datafile.print(value);
          }
          
          datafile.print('\n');
          
          if (ts >= (start_time & UNSIGNED) && ts <= (end_time & UNSIGNED)) {
            npoints++;
          }
        }
      } finally {
        datafile.close();
      }
    }

    if (npoints == 0) {
      // Gnuplot doesn't like empty graphs when xrange and yrange aren't
      // entirely defined, because it can't decide on good ranges with no
      // data.  We always set the xrange, but the yrange is supplied by the
      // user.  Let's make sure it defines a min and a max.
      params.put(""yrange"", ""[0:10]"");  // Doesn't matter what values we use.
    }
    writeGnuplotScript(basepath, datafiles);
    return npoints;
  }",0
"public static Iterable<Node> asElementIterable(NodeList list) {
        return new IterableNodeList(list, Node.ELEMENT_NODE);
    }",0
"public void notifyWarnings(Warnings warnings) {
        style.addWarnings(warnings);
    }",0
"private Map<String, String> cleanAttributes(String elementName, Map<String, String> attributes)
    {
        Map<String, String> cleanAttributes;

        if (this.htmlElementSanitizer == null || attributes == null) {
            cleanAttributes = attributes;
        } else {
            cleanAttributes = new LinkedHashMap<>();
            for (Map.Entry<String, String> e : attributes.entrySet()) {
                if (this.htmlElementSanitizer.isAttributeAllowed(elementName, e.getKey(), e.getValue())) {
                    cleanAttributes.put(e.getKey(), e.getValue());
                } else {
                    // Keep but clean invalid attributes with a prefix (removed during parsing) to avoid loosing them
                    // through WYSIWYG editing.
                    String translatedName =
                        TRANSLATED_ATTRIBUTE_PREFIX + removeInvalidDataAttributeCharacters(e.getKey());
                    if (this.htmlElementSanitizer.isAttributeAllowed(elementName, translatedName, e.getValue())) {
                        cleanAttributes.put(translatedName, e.getValue());
                    }
                }
            }
        }

        return cleanAttributes;
    }",1
"public boolean getAdaptiveFetch() throws SQLException {
    checkClosed();
    return adaptiveFetch;
  }",0
"@UnsupportedAppUsage
    @Nullable String getResourceName(@AnyRes int resId) {
        synchronized (this) {
            ensureValidLocked();
            return nativeGetResourceName(mObject, resId);
        }
    }",0
"public void setSecurityService(SecurityService securityService) {
    this.securityService = securityService;
  }",0
"final void rebuildAppWindowListLocked() {
        rebuildAppWindowListLocked(getDefaultDisplayContentLocked());
    }",0
"@Override
    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {
        UserInfo user = getUserManager().getUserInfo(userId);
        if (user == null) {
            Log.w(TAG, ""onServiceChanged: ignore removed user "" + userId);
            return;
        }
        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);
    }",0
"@Override
    public void onReceive(Context context, Intent intent) {
        PendingIntent pendingIntent =
                intent.getParcelableExtra(EXTRA_ACTION_INTENT, PendingIntent.class);
        Intent fillIn = intent.getParcelableExtra(EXTRA_ACTION_INTENT_FILLIN, Intent.class);
        String actionType = intent.getStringExtra(EXTRA_ACTION_TYPE);
        if (DEBUG_ACTIONS) {
            Log.d(TAG, ""Executing smart action ["" + actionType + ""]:"" + pendingIntent.getIntent());
        }
        ActivityOptions opts = ActivityOptions.makeBasic();

        try {
            pendingIntent.send(context, 0, fillIn, null, null, null, opts.toBundle());
        } catch (PendingIntent.CanceledException e) {
            Log.e(TAG, ""Pending intent canceled"", e);
        }

        mScreenshotSmartActions.notifyScreenshotAction(
                context, intent.getStringExtra(EXTRA_ID), actionType, true,
                pendingIntent.getIntent());
    }",1
"private String[] getParts(String encodedJWT) {
    String[] parts = encodedJWT.split(""\\."");
    // Secured JWT XXXXX.YYYYY.ZZZZZ, Unsecured JWT XXXXX.YYYYY.
    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith("".""))) {
      return parts;
    }

    throw new InvalidJWTException(""The encoded JWT is not properly formatted. Expected a three part dot separated string."");
  }",0
"CharSequence getDescription(Context context) {
        // TODO: create more descriptive string
        StringBuilder sb = new StringBuilder();
        String newline = ""<br>"";
        if (mUserKey != null) {
            sb.append(context.getString(R.string.one_userkey)).append(newline);
        }
        if (mUserCert != null) {
            sb.append(context.getString(R.string.one_usercrt)).append(newline);
        }
        int n = mCaCerts.size();
        if (n > 0) {
            if (n == 1) {
                sb.append(context.getString(R.string.one_cacrt));
            } else {
                sb.append(context.getString(R.string.n_cacrts, n));
            }
        }
        return Html.fromHtml(sb.toString());
    }",0
"final void addObject(CharSequence name, Object... values) {
        final AsciiString normalizedName = HttpHeaderNames.of(name);
        requireNonNull(values, ""values"");
        for (Object v : values) {
            requireNonNullElement(values, v);
            addObject(normalizedName, v);
        }
    }",1
"private Pair<AuthorityInfo, SyncStatusInfo> createCopyPairOfAuthorityWithSyncStatusLocked(
            AuthorityInfo authorityInfo) {
        SyncStatusInfo syncStatusInfo = getOrCreateSyncStatusLocked(authorityInfo.ident);
        return Pair.create(new AuthorityInfo(authorityInfo), new SyncStatusInfo(syncStatusInfo));
    }",0
"@Override public String toString() {
                return ""JENKINS-14814"";
            }",0
"@Override
        public void setStatusHints(String callId, StatusHints statusHints,
                Session.Info sessionInfo) {
            Log.startSession(sessionInfo, ""CSW.sSH"", mPackageAbbreviation);
            UserHandle callingUserHandle = Binder.getCallingUserHandle();
            long token = Binder.clearCallingIdentity();
            try {
                synchronized (mLock) {
                    logIncoming(""setStatusHints %s %s"", callId, statusHints);
                    // Check status hints image for cross user access
                    if (statusHints != null) {
                        Icon icon = statusHints.getIcon();
                        statusHints.setIcon(StatusHints.validateAccountIconUserBoundary(
                                icon, callingUserHandle));
                    }
                    Call call = mCallIdMapper.getCall(callId);
                    if (call != null) {
                        call.setStatusHints(statusHints);
                    }
                }
            } catch (Throwable t) {
                Log.e(ConnectionServiceWrapper.this, t, """");
                throw t;
            } finally {
                Binder.restoreCallingIdentity(token);
                Log.endSession();
            }
        }",1
"public static String getGeoToolsJarInfo() {
        final StringBuilder sb = new StringBuilder();
        final String newline = String.format(""%n"");
        final String indent = ""    "";

        sb.append(""GeoTools jars on classpath:"");
        for (String jarName : getGeoToolsJars()) {
            sb.append(newline).append(indent).append(jarName);
        }

        return sb.toString();
    }",0
"public boolean profileControl(String process, int userId, boolean start,
            ProfilerInfo profilerInfo, int profileType) throws RemoteException;",0
"private static void allowPatch(HttpURLConnection connection) {
        if(enabledPatch) {
            return;
        }
        if(patchFailed) {
            connection.setRequestProperty(""X-HTTP-Method-Override"", ""PATCH"");
            return;
        }
        try {
            Field methodsField = HttpURLConnection.class.getDeclaredField(""methods"");

            Field modifiersField = Field.class.getDeclaredField(""modifiers"");
            modifiersField.setAccessible(true);
            modifiersField.setInt(methodsField, methodsField.getModifiers() & ~Modifier.FINAL);

            methodsField.setAccessible(true);

            String[] oldMethods = (String[]) methodsField.get(null);
            Set<String> methodsSet = new LinkedHashSet<String>(Arrays.asList(oldMethods));
            methodsSet.addAll(Arrays.asList(""PATCH""));
            String[] newMethods = methodsSet.toArray(new String[0]);

            methodsField.set(null/*static field*/, newMethods);
            enabledPatch = true;
        } catch (NoSuchFieldException e) {
            patchFailed = true;
            connection.setRequestProperty(""X-HTTP-Method-Override"", ""PATCH"");
        } catch(IllegalAccessException ee) {
            patchFailed = true;
            connection.setRequestProperty(""X-HTTP-Method-Override"", ""PATCH"");
        }
    }",0
"@Override
	public List<KBTemplate> findByGroupId(long groupId, int start, int end,
		OrderByComparator<KBTemplate> orderByComparator) {
		return findByGroupId(groupId, start, end, orderByComparator, true);
	}",0
"@Override
    protected void clearListener() {
        final Class bgListenerClass = getBackgroundLocationListener();
        Thread t = new Thread(new Runnable() {

            @Override
            public void run() {
                //mGoogleApiClient must be connected
                while (!getmGoogleApiClient().isConnected()) {
                    try {
                        Thread.sleep(300);
                    } catch (Exception ex) {
                    }
                }
                Handler mHandler = new Handler(Looper.getMainLooper());
                mHandler.post(new Runnable() {

                    public void run() {
                        if (inMemoryBackgroundLocationListener != null) {
                            Context context = AndroidNativeUtil.getContext();
                            Intent intent = new Intent(context, BackgroundLocationHandler.class);
                            if (bgListenerClass != null) {
                                intent.putExtra(""backgroundClass"", bgListenerClass.getName());
                            }
                            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,
                                    intent);

                            //LocationServices.FusedLocationApi.removeLocationUpdates(getmGoogleApiClient(), pendingIntent);
                            removeLocationUpdates(context, pendingIntent);
                            inMemoryBackgroundLocationListener = null;
                        } else {
                            //LocationServices.FusedLocationApi.removeLocationUpdates(getmGoogleApiClient(), AndroidLocationPlayServiceManager.this);
                            removeLocationUpdates(AndroidNativeUtil.getContext(), AndroidLocationPlayServiceManager.this);
                        }
                    }
                });
            }
        });
        t.setUncaughtExceptionHandler(AndroidImplementation.exceptionHandler);
        t.start();
    }",1
"public void onRoleChanged() {
        ClientRole role = mClientModeManager.getRole();
        if (role == ROLE_CLIENT_PRIMARY) {
            applyCachedPacketFilter();
            if (mScreenOn) {
                // Start RSSI polling for the new primary network to enable scoring.
                enableRssiPolling(true);
            }
        } else {
            if (mScreenOn && !isSecondaryInternet()) {
                // Stop RSSI polling (if enabled) for the secondary network.
                enableRssiPolling(false);
            }
        }
        WifiConfiguration connectedNetwork = getConnectedWifiConfiguration();
        if (connectedNetwork != null) {
            updateWifiInfoWhenConnected(connectedNetwork);
            // Update capabilities after a role change.
            updateCapabilities(connectedNetwork);
        }
        mWifiScoreReport.onRoleChanged(role);
    }",0
"@RequestMapping(value = { ""/read"" })
	public String actionRead(HttpServletRequest theServletRequest, HomeRequest theRequest, BindingResult theBindingResult, ModelMap theModel) {
		addCommonParams(theServletRequest, theRequest, theModel);

		CaptureInterceptor interceptor = new CaptureInterceptor();
		GenericClient client = theRequest.newClient(theServletRequest, getContext(theRequest), myConfig, interceptor);

		RuntimeResourceDefinition def;
		try {
			def = getResourceType(theRequest, theServletRequest);
		} catch (ServletException e) {
			populateModelForResource(theServletRequest, theRequest, theModel);
			theModel.put(""errorMsg"", toDisplayError(e.toString(), e));
			return ""resource"";
		}
		String id = sanitizeUrlPart(defaultString(theServletRequest.getParameter(""id"")));
		if (StringUtils.isBlank(id)) {
			populateModelForResource(theServletRequest, theRequest, theModel);
			theModel.put(""errorMsg"", toDisplayError(""No ID specified"", null));
			return ""resource"";
		}
		ResultType returnsResource = ResultType.RESOURCE;

		String versionId = sanitizeUrlPart(defaultString(theServletRequest.getParameter(""vid"")));
		String outcomeDescription;
		if (StringUtils.isBlank(versionId)) {
			versionId = null;
			outcomeDescription = ""Read Resource"";
		} else {
			outcomeDescription = ""VRead Resource"";
		}

		long start = System.currentTimeMillis();
		try {
			IdDt resid = new IdDt(def.getName(), id, versionId);
			ourLog.info(logPrefix(theModel) + ""Reading resource: {}"", resid);
			if (resid.hasVersionIdPart()) {
				client.vread(def.getImplementingClass(), resid);
			} else {
				client.read(def.getImplementingClass(), resid);
			}
		} catch (Exception e) {
			returnsResource = handleClientException(client, e, theModel);
		}
		long delay = System.currentTimeMillis() - start;

		processAndAddLastClientInvocation(client, returnsResource, theModel, delay, outcomeDescription, interceptor, theRequest);

		return ""result"";
	}",1
"@Override
  public String getDestination(String function, JobDomainPeasSessionController jobDomainSC,
      HttpRequest request) {
    String destination = """";


    try {
      if (!jobDomainSC.isAccessGranted()) {
        throw new JobDomainPeasException(""Bad right for user {0}"", jobDomainSC.getUserId());
      }
      // 1) Performs the action
      // ----------------------
      if (function.startsWith(""selectUserOrGroup"")) {
        String id;

        function = DOMAIN_CONTENT_FCT;
        id = jobDomainSC.getSelectedUserId();
        if (id != null) {
          jobDomainSC.setTargetUser(id);
          function = USER_CONTENT_FCT;
        } else {
          id = jobDomainSC.getSelectedGroupId();
          if (id != null) {
            jobDomainSC.goIntoGroup(id);
            function = GROUP_CONTENT_FCT;
          }
        }
      }

      if (""blankUsers"".equals(function)) {
        final List<String> userIds = new ArrayList<>();
        request.mergeSelectedItemsInto(userIds);
        if (!userIds.isEmpty()) {
          jobDomainSC.blankDeletedUsers(userIds);
        }
        function = DOMAIN_CONTENT_FCT;
      }

      if (function.startsWith(""Main"")) {
        jobDomainSC.returnIntoGroup(null);
        jobDomainSC.setDefaultTargetDomain();
        destination = ""jobDomain.jsp"";
      } else if (""PreviousUser"".equals(function)) {
        UserDetail user = jobDomainSC.getPrevious();
        jobDomainSC.setTargetUser(user.getId());
        destination = USER_CONTENT_DEST;
      } else if (""NextUser"".equals(function)) {
        UserDetail user = jobDomainSC.getNext();
        jobDomainSC.setTargetUser(user.getId());
        destination = USER_CONTENT_DEST;
      } else if (""restoreUsers"".equals(function)) {
        final List<String> userIds = new ArrayList<>();
        request.mergeSelectedItemsInto(userIds);
        for (final String u : userIds) {
          jobDomainSC.restoreUser(u);
        }
        destination = getDestination(DISPLAY_REMOVED_USERS_DEST, jobDomainSC, request);
      } else if (""deleteUsers"".equals(function)) {
        final List<String> userIds = new ArrayList<>();
        request.mergeSelectedItemsInto(userIds);
        for (final String u : userIds) {
          jobDomainSC.deleteUser(u);
        }
        destination = getDestination(DISPLAY_REMOVED_USERS_DEST, jobDomainSC, request);
      } else if (""restoreGroups"".equals(function)) {
        final List<String> groupIds = new ArrayList<>();
        request.mergeSelectedItemsInto(groupIds);
        boolean refreshDomainNav = false;
        for (final String group : groupIds) {
          refreshDomainNav |= jobDomainSC.restoreGroup(group);
        }
        if (refreshDomainNav) {
          reloadDomainNavigation(request);
        }
        destination = getDestination(DISPLAY_REMOVED_GROUPS_DEST, jobDomainSC, request);
      } else if (""deleteGroups"".equals(function)) {
        final List<String> groupIds = new ArrayList<>();
        request.mergeSelectedItemsInto(groupIds);
        for (final String group : groupIds) {
          jobDomainSC.deleteGroup(group);
        }
        destination = getDestination(DISPLAY_REMOVED_GROUPS_DEST, jobDomainSC, request);
      } else if (function.startsWith(""user"")) {
        // USER Actions --------------------------------------------
        String userId = request.getParameter(""Iduser"");
        if (function.startsWith(USER_CONTENT_FCT)) {
          if (isDefined(userId)) {
            jobDomainSC.setTargetUser(userId);
          }
        } else if (""userGetP12"".equals(function)) {
          jobDomainSC.getP12(userId);
        } else if (function.startsWith(""userCreate"")) {
          UserRequestData userRequestData =
              RequestParameterDecoder.decode(request, UserRequestData.class);

          // process extra properties
          HashMap<String, String> properties = getExtraPropertyValues(request);

          jobDomainSC.createUser(userRequestData, properties, request);

        } else if (function.startsWith(""usersCsvImport"")) {
          List<FileItem> fileItems = request.getFileItems();
          UserRequestData userRequestData =
              RequestParameterDecoder.decode(request, UserRequestData.class);

          FileItem fileItem = FileUploadUtil.getFile(fileItems, ""file_upload"");

          if (fileItem != null) {
            jobDomainSC.importCsvUsers(fileItem, userRequestData, request);
          }

          destination = DOMAIN_CONTENT_DEST;
        } else if (function.startsWith(""userUpdate"")) {
          UserRequestData userRequestData =
              RequestParameterDecoder.decode(request, UserRequestData.class);

          // process extra properties
          HashMap<String, String> properties = getExtraPropertyValues(request);

          jobDomainSC.modifyUser(userRequestData, properties, request);
        } else if (function.startsWith(""userBlock"")) {
          jobDomainSC.blockUser(userId);
        } else if (function.startsWith(""userUnblock"")) {
          jobDomainSC.unblockUser(userId);
        } else if (function.startsWith(""userDeactivate"")) {
          jobDomainSC.deactivateUser(userId);
        } else if (function.startsWith(""userActivate"")) {
          jobDomainSC.activateUser(userId);
        } else if (function.startsWith(""userDelete"")) {
          jobDomainSC.deleteUser(userId);
        } else if (function.startsWith(""userRemove"")) {
          jobDomainSC.removeUser(userId);
        } else if (function.startsWith(""userAvatarDelete"")) {
          jobDomainSC.deleteUserAvatar(userId);
        } else if (""userViewRights"".equals(function)) {
          request.setAttribute(""UserProfiles"", jobDomainSC.getCurrentProfiles());
        } else if (function.startsWith(""userMS"")) {
          UserRequestData userRequestData =
              RequestParameterDecoder.decode(request, UserRequestData.class);

          // process extra properties
          HashMap<String, String> properties = getExtraPropertyValues(request);

          jobDomainSC.modifySynchronizedUser(userRequestData, properties, request);
        } else if (function.startsWith(""userSearchToImport"")) {
          Map<String, String> query;
          List<UserDetail> users;
          jobDomainSC.clearListSelectedUsers();
          jobDomainSC.setIndexOfFirstItemToDisplay(""0"");

          String fromArray = request.getParameter(""FromArray"");
          if (isDefined(fromArray)) {
            query = jobDomainSC.getQueryToImport();
            users = jobDomainSC.getUsersToImport();
          } else {
            query = new Hashtable<>();
            Enumeration<String> parameters = request.getParameterNames();
            String paramName;
            String paramValue;
            while (parameters.hasMoreElements()) {
              paramName = parameters.nextElement();
              if (!paramName.startsWith(""Pagination"") && !paramName.equals(SESSION_TOKEN_KEY)) {
                paramValue = request.getParameter(paramName);
                if (isDefined(paramValue)) {
                  query.put(paramName, paramValue);
                }
              }
            }

            users = jobDomainSC.searchUsers(query);
          }

          request.setAttribute(""Query"", query);
          request.setAttribute(USERS_ATTR, users);

          destination = getDestination(DISPLAY_USER_IMPORT_FCT, jobDomainSC, request);
        } else if (""userImport"".equals(function)) {
          String[] specificIds = request.getParameterValues(""specificIds"");
          // Massive users import
          if (specificIds != null) {
            processSelection(request, jobDomainSC);
            specificIds = new String[jobDomainSC.getListSelectedUsers().size()];
            jobDomainSC.getListSelectedUsers().toArray(specificIds);
            jobDomainSC.importUsers(specificIds);
          } else {
            // Unitary user Import
            String specificId = request.getParameter(""specificIds"");
            if (isDefined(specificId)) {
              jobDomainSC.importUser(specificId);
            }
          }
        } else if (""userImportAll"".equals(function)) {
          Iterator<UserDetail> usersIt = jobDomainSC.getUsersToImport().iterator();
          ArrayList<String> listSelectedUsersIds = new ArrayList<>();
          while (usersIt.hasNext()) {
            listSelectedUsersIds.add(usersIt.next().getSpecificId());
          }
          jobDomainSC.setListSelectedUsers(listSelectedUsersIds);
          String[] specificIds = new String[jobDomainSC.getListSelectedUsers().size()];
          jobDomainSC.getListSelectedUsers().toArray(specificIds);
          jobDomainSC.importUsers(specificIds);
        } else if (""userView"".equals(function)) {
          String specificId = request.getParameter(""specificId"");

          UserFull user = jobDomainSC.getUser(specificId);

          request.setAttribute(""UserFull"", user);

          destination = ""userView.jsp"";
        } else if (function.startsWith(""userSynchro"")) {
          jobDomainSC.synchroUser(userId);
        } else if (function.startsWith(""userUnSynchro"")) {
          jobDomainSC.unsynchroUser(userId);
        } else if (""userOpen"".equals(function)) {
          userId = request.getParameter(""userId"");

          UserDetail user = UserDetail.getById(userId);
          String domainId = user.getDomainId();
          if (domainId == null) {
            domainId = Domain.MIXED_DOMAIN_ID;
          }

          // not refresh the domain
          jobDomainSC.setRefreshDomain(false);

          // domaine
          jobDomainSC.setTargetDomain(domainId);

          // réinitialise les groupes
          jobDomainSC.returnIntoGroup(null);

          // groupe d'appartenance
          AdminController adminController = ServiceProvider.getService(AdminController.class);
          List<GroupDetail> groups = adminController.getDirectGroupsOfUser(userId);
          for (final Group group : groups) {
            String groupDomainId = group.getDomainId();
            if (groupDomainId == null) {
              groupDomainId = ""-1"";
            }
            if (!""-1"".equals(groupDomainId)) {
              jobDomainSC.goIntoGroup(group.getId());
              break;
            }
          }

          // user
          jobDomainSC.setTargetUser(userId);
        }
        if (destination.length() <= 0) {
          if (jobDomainSC.getTargetUserDetail() != null) {
            destination = USER_CONTENT_DEST;
          } else {
            destination = getDestination(GROUP_CONTENT_FCT, jobDomainSC, request);
          }
        }
      } else if (function.startsWith(""group"")) {
        // GROUP Actions --------------------------------------------
        boolean bHaveToRefreshDomain = false;

        jobDomainSC.setTargetUser(null);

        // Browse functions
        // ----------------
        if (function.startsWith(GROUP_CONTENT_FCT)) {
          String groupId = request.getParameter(IDGROUP_PARAM);
          if (isDefined(groupId)) {
            jobDomainSC.goIntoGroup(groupId);
          }
        } else if (function.startsWith(""groupExport.txt"")) {
          String groupId = request.getParameter(IDGROUP_PARAM);
          if (isDefined(groupId)) {
            jobDomainSC.goIntoGroup(request.getParameter(IDGROUP_PARAM));
            destination = ""exportgroup.jsp"";
          }
        } else if (function.startsWith(""groupReturn"")) {
          jobDomainSC.returnIntoGroup(request.getParameter(IDGROUP_PARAM));
        } else if (function.startsWith(""groupSet"")) {
          jobDomainSC.returnIntoGroup(null);
          jobDomainSC.goIntoGroup(request.getParameter(IDGROUP_PARAM));
        } else if (function.startsWith(""groupCreate"")) {
          bHaveToRefreshDomain = jobDomainSC.createGroup(request.getParameter(""Idparent""),
              WebEncodeHelper.htmlStringToJavaString(request.getParameter(GROUP_NAME_PARAM)),
              WebEncodeHelper.htmlStringToJavaString(request.getParameter(""groupDescription"")),
              request.getParameter(""groupRule""));
        } else if (function.startsWith(""groupUpdate"")) {
          bHaveToRefreshDomain = jobDomainSC.modifyGroup(request.getParameter(IDGROUP_PARAM),
              WebEncodeHelper.htmlStringToJavaString(request.getParameter(GROUP_NAME_PARAM)),
              WebEncodeHelper.htmlStringToJavaString(request.getParameter(""groupDescription"")),
              request.getParameter(""groupRule""));
        } else if (function.startsWith(""groupAddRemoveUsers"")) {
          bHaveToRefreshDomain = jobDomainSC
              .updateGroupSubUsers(jobDomainSC.getTargetGroup().getId(), jobDomainSC.getSelectedUsersIds());
        } else if (function.startsWith(""groupRemove"")) {
          bHaveToRefreshDomain = jobDomainSC.removeGroup(request.getParameter(IDGROUP_PARAM));
        } else if (function.startsWith(""groupDelete"")) {
          bHaveToRefreshDomain = jobDomainSC.deleteGroup(request.getParameter(IDGROUP_PARAM));
        } else if (function.startsWith(""groupSynchro"")) {
          final Optional<Group> synchronizedGroup = jobDomainSC.synchroGroup(request.getParameter(IDGROUP_PARAM));
          if (synchronizedGroup.isPresent()) {
            final Group group = synchronizedGroup.get();
            if (group.isRemovedState()) {
              reloadDomainNavigation(request);
            } else {
              bHaveToRefreshDomain = true;
            }
          }
        } else if (function.startsWith(""groupUnSynchro"")) {
          bHaveToRefreshDomain = jobDomainSC.unsynchroGroup(request.getParameter(IDGROUP_PARAM));
        } else if (function.startsWith(""groupImport"")) {
          bHaveToRefreshDomain = jobDomainSC.importGroup(WebEncodeHelper.htmlStringToJavaString(request.getParameter(
              GROUP_NAME_PARAM)));
        } else if (""groupManagersView"".equals(function)) {
          List<List> groupManagers = jobDomainSC.getGroupManagers();

          request.setAttribute(USERS_ATTR, groupManagers.get(0));
          request.setAttribute(""Groups"", groupManagers.get(1));

          destination = ""groupManagers.jsp"";
        } else if (""groupManagersChoose"".equals(function)) {
          List<String> userIds = (List<String>) StringUtil
              .splitString(request.getParameter(""UserPanelCurrentUserIds""), ',');
          List<String> groupIds = (List<String>) StringUtil
              .splitString(request.getParameter(""UserPanelCurrentGroupIds""), ',');
          jobDomainSC.initUserPanelForGroupManagers(userIds, groupIds);
          destination = Selection.getSelectionURL();
        } else if (""groupManagersUpdate"".equals(function)) {
          List<String> userIds = (List<String>) StringUtil
              .splitString(request.getParameter(""roleItems"" + ""UserPanelCurrentUserIds""), ',');
          List<String> groupIds = (List<String>) StringUtil
              .splitString(request.getParameter(""roleItems"" + ""UserPanelCurrentGroupIds""), ',');
          jobDomainSC.updateGroupProfile(userIds, groupIds);

          destination = getDestination(""groupManagersView"", jobDomainSC, request);
        } else if (""groupOpen"".equals(function)) {
          String groupId = request.getParameter(""groupId"");

          if (jobDomainSC.isAccessGranted() || jobDomainSC.isGroupManagerOnGroup(groupId)) {
            OrganizationController orgaController = jobDomainSC.getOrganisationController();
            Group group = orgaController.getGroup(groupId);
            String domainId = group.getDomainId();
            if (domainId == null) {
              domainId = ""-1"";
            }

            // not refresh the domain
            jobDomainSC.setRefreshDomain(false);

            // domaine
            jobDomainSC.setTargetDomain(domainId);
            jobDomainSC.returnIntoGroup(null);

            // groupe(s) père(s)
            List<String> groupList = orgaController.getPathToGroup(groupId);
            for (String elementGroupId : groupList) {
              jobDomainSC.goIntoGroup(elementGroupId);
            }

            // groupe
            jobDomainSC.goIntoGroup(groupId);

            destination = GROUP_CONTENT_DEST;
          } else {
            destination = ""/admin/jsp/accessForbidden.jsp"";
          }
        } else if (""groupViewRights"".equals(function)) {
          request.setAttribute(""GroupProfiles"", jobDomainSC.getCurrentProfiles());
        }

        if (destination.length() <= 0) {
          if (jobDomainSC.getTargetGroup() != null) {
            if (bHaveToRefreshDomain) {
              reloadDomainNavigation(request);
            }
            destination = GROUP_CONTENT_DEST;
          } else if (bHaveToRefreshDomain) {
            destination = getDestination(""domainRefresh"", jobDomainSC, request);
          } else {
            destination = getDestination(DOMAIN_CONTENT_FCT, jobDomainSC, request);
          }
        }
        // DOMAIN Actions --------------------------------------------
      } else if (function.startsWith(DOMAIN_ATTR)) {
        jobDomainSC.setTargetUser(null);
        if (function.startsWith(""domainModifyUserFilter"")) {
          destination = handleUserFilterModification(jobDomainSC, request);
        } else if (function.startsWith(""domainGoTo"")) {
          jobDomainSC.setTargetDomain(request.getParameter(IDDOMAIN_PARAM));
          jobDomainSC.returnIntoGroup(null);
          jobDomainSC.setRefreshDomain(true);
          return emptyJsonResponse();
        } else if (function.startsWith(""domainNavigation"")) {
          jobDomainSC.setTargetDomain(request.getParameter(IDDOMAIN_PARAM));
          jobDomainSC.returnIntoGroup(null);
          jobDomainSC.setRefreshDomain(true);
          destination = DOMAIN_NAVIGATION_DEST;
        } else if (function.startsWith(""domainRefreshCurrentLevel"")) {
          request.setAttribute(""domainRefreshCurrentLevel"", true);
          destination = DOMAIN_NAVIGATION_DEST;
        } else {
          if (function.startsWith(DOMAIN_CONTENT_FCT)) {
            jobDomainSC.returnIntoGroup(null);
          } else if (function.startsWith(DOMAIN_CREATE_FCT)
                    || function.startsWith(DOMAIN_SCIM_CREATE_FCT)
                    || function.startsWith(DOMAIN_GOOGLE_CREATE_FCT)) {
            final DomainType domainType;
            if (function.startsWith(DOMAIN_CREATE_FCT)) {
              domainType = DomainType.LDAP;
            } else if (function.startsWith(DOMAIN_SCIM_CREATE_FCT)) {
              domainType = DomainType.SCIM;
            } else {
              domainType = DomainType.GOOGLE;
            }
            String newDomainId = jobDomainSC.createDomain(request2Domain(request), domainType);
            request.setAttribute(IDDOMAIN_PARAM, newDomainId);
            destination = GO_BACK_DEST;
          } else if (function.startsWith(DOMAIN_SQL_CREATE_FCT)) {
            String newDomainId = jobDomainSC.createSQLDomain(WebEncodeHelper.htmlStringToJavaString(request.getParameter(DOMAIN_NAME_PARAM)),
                WebEncodeHelper.htmlStringToJavaString(request.getParameter(DOMAIN_DESCRIPTION_PARAM)),
                WebEncodeHelper.htmlStringToJavaString(request.getParameter(SILVERPEAS_SERVER_URL_PARAM)),request.getParameter(USER_DOMAIN_QUOTA_MAX_COUNT_PARAM));
            request.setAttribute(IDDOMAIN_PARAM, newDomainId);
            destination = GO_BACK_DEST;
          } else if (function.startsWith(""domainModify"")) {
            String modifiedDomainId = jobDomainSC.modifyDomain(request2Domain(request),
                    request.getParameter(USER_DOMAIN_QUOTA_MAX_COUNT_PARAM));
            request.setAttribute(IDDOMAIN_PARAM, modifiedDomainId);
            destination = GO_BACK_DEST;
          } else if (function.startsWith(""domainSQLModify"")) {
            String modifiedDomainId = jobDomainSC.modifySQLDomain(WebEncodeHelper.
                    htmlStringToJavaString(request.getParameter(DOMAIN_NAME_PARAM)), WebEncodeHelper.htmlStringToJavaString(request.getParameter(
                DOMAIN_DESCRIPTION_PARAM)),
                WebEncodeHelper.htmlStringToJavaString(request.getParameter(
                    SILVERPEAS_SERVER_URL_PARAM)),
                request.getParameter(USER_DOMAIN_QUOTA_MAX_COUNT_PARAM));
            request.setAttribute(IDDOMAIN_PARAM, modifiedDomainId);
            destination = GO_BACK_DEST;
          } else if (function.startsWith(DOMAIN_DELETE_FCT)) {
            jobDomainSC.deleteDomain(DomainType.LDAP);
            destination = GO_BACK_DEST;
          } else if (function.startsWith(DOMAIN_SCIM_DELETE_FCT)) {
            jobDomainSC.deleteDomain(DomainType.SCIM);
            destination = GO_BACK_DEST;
          } else if (function.startsWith(DOMAIN_GOOGLE_DELETE_FCT)) {
            jobDomainSC.deleteDomain(DomainType.GOOGLE);
            destination = GO_BACK_DEST;
          } else if (function.startsWith(DOMAIN_SQL_DELETE_FCT)) {
            jobDomainSC.deleteSQLDomain();
            destination = GO_BACK_DEST;
          } else if (function.startsWith(""domainPingSynchro"")) {
            if (jobDomainSC.isEnCours()) {
              destination = DOMAIN_SYNCHRO_PING_DEST;
            } else {
              String strSynchroReport = jobDomainSC.getSynchroReport();

              jobDomainSC.refresh();

              request.setAttribute(""SynchroDomainReport"", strSynchroReport);
              destination = ""domainSynchroReport.jsp"";
            }
          } else if (function.startsWith(""domainSynchro"")) {
            jobDomainSC.synchroDomain(Level.valueOf(request.getParameter(""IdTraceLevel"")));
            destination = DOMAIN_SYNCHRO_PING_DEST;
          } else if (function.startsWith(""domainSQLSynchro"")) {
            jobDomainSC.synchroSQLDomain();
            destination = DOMAIN_SYNCHRO_PING_DEST;
          } else if (function.startsWith(""domainRefresh"")) {
            request.setAttribute(IDDOMAIN_PARAM, jobDomainSC.getTargetDomain().getId());
            destination = GO_BACK_DEST;
          }

          if (destination.length() <= 0) {
            if (jobDomainSC.getTargetDomain() != null) {
              destination = DOMAIN_CONTENT_DEST;
            } else {
              destination = getDestination(""welcome"", jobDomainSC, request);
            }
          }
        }
      } else if (function.startsWith(""display"")) {
        if (function.startsWith(""displayGroupCreate"")) {
          GroupDetail newGroup = new GroupDetail();

          newGroup.setSuperGroupId(request.getParameter(IDGROUP_PARAM));
          request.setAttribute(GROUP_OBJECT_ATTR, newGroup);
          request.setAttribute(ACTION_ATTR, ""groupCreate"");
          request.setAttribute(GROUPS_PATH_ATTR, jobDomainSC
              .getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
                  jobDomainSC.getString(""JDP.groupAdd"") + ""...""));
          destination = ""groupCreate.jsp"";
        } else if (function.startsWith(""displayGroupUpdate"")) {
          request.setAttribute(GROUP_OBJECT_ATTR, jobDomainSC.getTargetGroup());
          request.setAttribute(ACTION_ATTR, ""groupUpdate"");
          request.setAttribute(GROUPS_PATH_ATTR, jobDomainSC
              .getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
                  jobDomainSC.getString(""JDP.groupUpdate"") + ""...""));
          destination = ""groupCreate.jsp"";
        } else if (function.startsWith(""displayGroupImport"")) {
          request.setAttribute(GROUPS_PATH_ATTR, jobDomainSC
              .getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
                  jobDomainSC.getString(""JDP.groupImport"") + ""...""));
          destination = ""groupImport.jsp"";
        } else if (function.startsWith(""displaySelectUserOrGroup"")) {
          destination = jobDomainSC.initSelectionPeasForOneGroupOrUser((String) request.
              getAttribute(MY_COMPONENT_URL_ATTR));
        } else if (function.startsWith(""displayAddRemoveUsers"")) {
          destination = jobDomainSC
              .initSelectionPeasForGroups((String) request.getAttribute(MY_COMPONENT_URL_ATTR));
        } else if (function.startsWith(""displayUserCreate"")) {
          DomainDriverManager domainDriverManager =
              DomainDriverManagerProvider.getCurrentDomainDriverManager();
          DomainDriver domainDriver =
              domainDriverManager.getDomainDriver(jobDomainSC.getTargetDomain().getId());
          UserFull newUser = new UserFull(domainDriver);
          newUser.setPasswordAvailable(true);

          request.setAttribute(USER_OBJECT_ATTR, newUser);
          request.setAttribute(ACTION_ATTR, ""userCreate"");
          request.setAttribute(GROUPS_PATH_ATTR,
              jobDomainSC.getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
              jobDomainSC.getString(""JDP.userAdd"") + ""...""));
          request.setAttribute(MIN_LENGTH_LOGIN_ATTR, jobDomainSC.getMinLengthLogin());
          request.setAttribute(CURRENT_USER_ATTR, jobDomainSC.getUserDetail());
          // if community management is activated, add groups on this user is manager
          if (JobDomainSettings.m_UseCommunityManagement) {
            request.setAttribute(""GroupsManagedByCurrentUser"", jobDomainSC.getUserManageableGroups());
          }

          destination = USER_CREATE_DEST;
        } else if (function.startsWith(""displayUsersCsvImport"")) {
          request.setAttribute(GROUPS_PATH_ATTR, jobDomainSC
              .getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
                  jobDomainSC.getString(""JDP.csvImport"") + ""...""));
          request.setAttribute(""FieldLabelsToImport"", jobDomainSC.getFieldLabelsOfCSVToImport());
          destination = ""usersCsvImport.jsp"";
        } else if (function.startsWith(""displayUserUpdate"")) {
          request.setAttribute(USER_OBJECT_ATTR, jobDomainSC.getTargetUserFull());
          request.setAttribute(ACTION_ATTR, ""userUpdate"");
          request.setAttribute(GROUPS_PATH_ATTR, jobDomainSC
              .getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
                  jobDomainSC.getString(""JDP.userUpdate"") + ""...""));
          request.setAttribute(MIN_LENGTH_LOGIN_ATTR, jobDomainSC.getMinLengthLogin());
          request.setAttribute(CURRENT_USER_ATTR, jobDomainSC.getUserDetail());

          destination = USER_CREATE_DEST;
        } else if (function.startsWith(""displayUserMS"")) {
          request.setAttribute(USER_OBJECT_ATTR, jobDomainSC.getTargetUserFull());
          request.setAttribute(ACTION_ATTR, ""userMS"");
          request.setAttribute(GROUPS_PATH_ATTR, jobDomainSC
              .getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
                  jobDomainSC.getString(""JDP.userUpdate"") + ""...""));
          request.setAttribute(MIN_LENGTH_LOGIN_ATTR, jobDomainSC.getMinLengthLogin());
          request.setAttribute(CURRENT_USER_ATTR, jobDomainSC.getUserDetail());

          destination = USER_CREATE_DEST;
        } else if (function.startsWith(DISPLAY_USER_IMPORT_FCT)) {
          request.setAttribute(""SelectedIds"", jobDomainSC.getListSelectedUsers());
          request.setAttribute(""FirstUserIndex"", jobDomainSC.
              getIndexOfFirstItemToDisplay());
          request.setAttribute(GROUPS_PATH_ATTR, jobDomainSC
              .getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR),
                  jobDomainSC.getString(""JDP.userImport"") + ""...""));
          request.setAttribute(""properties"", jobDomainSC.getPropertiesToImport());
          destination = ""userImport.jsp"";
        } else if (function.startsWith(""displayDomainCreate"")) {
          Domain theNewDomain = new Domain();
          theNewDomain.setDriverClassName(""org.silverpeas.core.admin.domain.driver.ldapdriver.LDAPDriver"");
          theNewDomain.setPropFileName(""org.silverpeas.domains.domain"");
          theNewDomain.setAuthenticationServer(""autDomain"");
          theNewDomain.setSilverpeasServerURL(URLUtil.getAbsoluteApplicationURL());
          request.setAttribute(DOMAIN_OBJECT_ATTR, theNewDomain);
          request.setAttribute(ACTION_ATTR, DOMAIN_CREATE_FCT);
          destination = DOMAIN_CREATE_DEST;
        } else if (function.startsWith(""displayDomainSCIMCreate"")) {
          Domain theNewDomain = new Domain();
          theNewDomain.setDriverClassName(""org.silverpeas.core.admin.domain.driver.scimdriver.SCIMDriver"");
          theNewDomain.setPropFileName(""org.silverpeas.domains.domainSCIM"");
          theNewDomain.setAuthenticationServer(""autDomainSCIM"");
          theNewDomain.setSilverpeasServerURL(URLUtil.getAbsoluteApplicationURL());
          request.setAttribute(DOMAIN_OBJECT_ATTR, theNewDomain);
          request.setAttribute(ACTION_ATTR, DOMAIN_SCIM_CREATE_FCT);
          destination = DOMAIN_CREATE_DEST;
        } else if (function.startsWith(""displayDomainGoogleCreate"")) {
          Domain theNewDomain = new Domain();
          theNewDomain.setDriverClassName(""org.silverpeas.core.admin.domain.driver.googledriver.GoogleDriver"");
          theNewDomain.setPropFileName(""org.silverpeas.domains.domainGoogle"");
          theNewDomain.setAuthenticationServer(""autDomainGoogle"");
          theNewDomain.setSilverpeasServerURL(URLUtil.getAbsoluteApplicationURL());
          request.setAttribute(DOMAIN_OBJECT_ATTR, theNewDomain);
          request.setAttribute(ACTION_ATTR, DOMAIN_GOOGLE_CREATE_FCT);
          destination = DOMAIN_CREATE_DEST;
        } else if (function.startsWith(""displayDomainSQLCreate"")) {
          Domain theNewDomain = new Domain();
          theNewDomain.setSilverpeasServerURL(URLUtil.getAbsoluteApplicationURL());
          request.setAttribute(DOMAIN_OBJECT_ATTR, theNewDomain);
          request.setAttribute(ACTION_ATTR, DOMAIN_SQL_CREATE_FCT);
          destination = ""domainSQLCreate.jsp"";
        } else if (function.startsWith(""displayDomainModify"")) {
          request.setAttribute(ACTION_ATTR, ""domainModify"");
          destination = DOMAIN_CREATE_DEST;
        } else if (function.startsWith(""displayDomainSQLModify"")) {
          request.setAttribute(ACTION_ATTR, ""domainSQLModify"");
          destination = ""domainSQLCreate.jsp"";
        } else if (function.startsWith(""displayDomainSynchro"")) {
          destination = ""domainSynchro.jsp"";
        } else if (function.startsWith(""displayDynamicSynchroReport"")) {
          SynchroDomainReport.setReportLevel(Level.valueOf(request.getParameter(""IdTraceLevel"")));
          destination = ""dynamicSynchroReport.jsp"";
        } else if (function.startsWith(DISPLAY_REMOVED_USERS_DEST)) {
          final SilverpeasList<UserDetail> removedUsers = SilverpeasList.wrap(jobDomainSC.getRemovedUsers());
          request.setAttribute(""removedUsers"", convertRemovedUserList(removedUsers, emptySet()));
          request.setAttribute(DOMAIN_ATTR, jobDomainSC.getTargetDomain());
          request.setAttribute(THE_USER_ATTR, jobDomainSC.getUserDetail());
          destination = ""removedUsers.jsp"";
        } else if (function.startsWith(""displayDeletedUsers"")) {
          final List<UserDetail> deletedUsers = jobDomainSC.getDeletedUsers();
          request.setAttribute(""deletedUsers"", deletedUsers);
          request.setAttribute(DOMAIN_ATTR, jobDomainSC.getTargetDomain());
          request.setAttribute(THE_USER_ATTR, jobDomainSC.getUserDetail());
          destination = ""deletedUsers.jsp"";
        } else if (function.startsWith(DISPLAY_REMOVED_GROUPS_DEST)) {
          final List<GroupDetail> allRemovedGroups = jobDomainSC.getRemovedGroups();
          final SilverpeasList<GroupDetail> removedGroups = SilverpeasList.wrap(allRemovedGroups);
          request.setAttribute(""removedGroups"", convertRemovedGroupList(removedGroups, emptySet()));
          request.setAttribute(DOMAIN_ATTR, jobDomainSC.getTargetDomain());
          request.setAttribute(THE_USER_ATTR, jobDomainSC.getUserDetail());
          destination = ""removedGroups.jsp"";
        }
      } else if (function.startsWith(""welcome"")) {
        jobDomainSC.returnIntoGroup(null);
        request.setAttribute(""DisplayOperations"", jobDomainSC.getUserDetail().isAccessAdmin());

        SettingBundle rs = getSettingBundle(""org.silverpeas.jobDomainPeas.settings.jobDomainPeasSettings"");
        Properties configuration = new Properties();
        configuration
            .setProperty(SilverpeasTemplate.TEMPLATE_ROOT_DIR, rs.getString(""templatePath""));
        configuration.setProperty(SilverpeasTemplate.TEMPLATE_CUSTOM_DIR, rs.getString(""customersTemplatePath""));
        SilverpeasTemplate template = SilverpeasTemplateFactory.createSilverpeasTemplate(configuration);

        // setting domains to welcome template
        List<Domain> allDomains = jobDomainSC.getAllDomains();
        // do not return mixed domain
        String[] domainsByList = new String[allDomains.size() - 1];
        for (int n = 1; n < allDomains.size(); n++) {
          domainsByList[n - 1] = allDomains.get(n).getName();
        }
        template.setAttribute(""listDomains"", domainsByList);
        request.setAttribute(""Content"",
            template.applyFileTemplate(""register_"" + jobDomainSC.getLanguage()));

        destination = ""welcome.jsp"";
      } else if (""Pagination"".equals(function)) {
        processSelection(request, jobDomainSC);

        // traitement de la pagination : passage des parametres
        String index = request.getParameter(""Pagination_Index"");

        if (index != null && index.length() > 0) {
          jobDomainSC.setIndexOfFirstItemToDisplay(index);
        }
        // retour a l'album courant
        request.setAttribute(""Query"", jobDomainSC.getQueryToImport());
        request.setAttribute(USERS_ATTR, jobDomainSC.getUsersToImport());
        destination = getDestination(DISPLAY_USER_IMPORT_FCT, jobDomainSC, request);
      } else if (""SelectRightsUserOrGroup"".equals(function)) {
        destination = jobDomainSC.initSelectionRightsUserOrGroup();
      } else if (""AssignSameRights"".equals(function)) {
        if (!jobDomainSC.isRightCopyReplaceEnabled()) {
          throwHttpForbiddenError();
        }
        //1 = replace rights | 2 = add rights
        String choiceAssignRights = request.getParameter(""choiceAssignRights"");
        String sourceRightsId = request.getParameter(""sourceRightsId"");
        //Set | Element
        String sourceRightsType = request.getParameter(""sourceRightsType"");
        //true | false
        boolean nodeAssignRights = request.getParameterAsBoolean(""nodeAssignRights"");

        jobDomainSC
              .assignRights(choiceAssignRights, sourceRightsId, sourceRightsType, nodeAssignRights);

        if (jobDomainSC.getTargetUserDetail() != null) {
          destination = USER_CONTENT_DEST;
        } else {
          destination = GROUP_CONTENT_DEST;
        }
      } else {
        destination = function;
      }

      // 2) Prepare the pages
      // --------------------
      if (jobDomainSC.getTargetDomain() != null) {
        request.setAttribute(DOMAIN_OBJECT_ATTR, jobDomainSC.getTargetDomain());
      }
      if (DOMAIN_CONTENT_DEST.equals(destination)) {
        jobDomainSC.refresh();
        long domainRight = jobDomainSC.getDomainActions();
        request.setAttribute(THE_USER_ATTR, jobDomainSC.getUserDetail());
        request.setAttribute(""subGroups"", jobDomainSC.getSubGroups(false));
        request.setAttribute(""subUsers"", jobDomainSC.getSubUsers(false));
        setRightManagementAttributes(request, domainRight);

        request.setAttribute(IS_ONLY_GROUP_MANAGER_ATTR, jobDomainSC.isOnlyGroupManager());
        request.setAttribute(IS_ONLY_SPACE_MANAGER_ATTR, jobDomainSC.isOnlySpaceManager());
        request.setAttribute(""isUserAddingAllowedForGroupManager"", jobDomainSC.
            isUserAddingAllowedForGroupManager());
      } else if (GROUP_CONTENT_DEST.equals(destination) || ""exportgroup.jsp"".equals(destination)) {
        long domainRight = jobDomainSC.getDomainActions();

        request.setAttribute(GROUP_OBJECT_ATTR, jobDomainSC.getTargetGroup());
        request.setAttribute(GROUPS_PATH_ATTR,
            jobDomainSC.getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR), null));
        request.setAttribute(""subGroups"", jobDomainSC.getSubGroups(true));
        request.setAttribute(""subUsers"", jobDomainSC.getSubUsers(true));
        setRightManagementAttributes(request, domainRight);

        request
            .setAttribute(""isGroupManagerOnThisGroup"", jobDomainSC.isGroupManagerOnCurrentGroup());
        request.setAttribute(""isGroupManagerDirectlyOnThisGroup"", jobDomainSC.
            isGroupManagerDirectlyOnCurrentGroup());
        request.setAttribute(IS_ONLY_GROUP_MANAGER_ATTR, jobDomainSC.isOnlyGroupManager());
        request.setAttribute(IS_ONLY_SPACE_MANAGER_ATTR, jobDomainSC.isOnlySpaceManager());

        request.setAttribute(""ManageableSpaces"", jobDomainSC.getManageablesSpaces());
        request.setAttribute(""IsRightCopyReplaceEnabled"",
            jobDomainSC.isRightCopyReplaceEnabled());
      } else if (USER_CONTENT_DEST.equals(destination)) {
        request.setAttribute(GROUPS_PATH_ATTR,
            jobDomainSC.getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR), null));

        if (jobDomainSC.getTargetDomain() != null) {
          long domainRight = jobDomainSC.getDomainActions();
          setRightManagementAttributes(request, domainRight);
          request.setAttribute(""isX509Enabled"", (domainRight & ACTION_X509_USER) != 0);
          request.setAttribute(IS_ONLY_GROUP_MANAGER_ATTR, jobDomainSC.isOnlyGroupManager());
          request.setAttribute(""userManageableByGroupManager"", jobDomainSC.
              isUserInAtLeastOneGroupManageableByCurrentUser());
          request.setAttribute(IS_ONLY_SPACE_MANAGER_ATTR, jobDomainSC.isOnlySpaceManager());
        }
        try {
          request.setAttribute(USER_OBJECT_ATTR, jobDomainSC.getTargetUserFull());
        } catch (JobDomainPeasException e) {
          request.setAttribute(USER_OBJECT_ATTR, jobDomainSC.getTargetUserDetail());
        }
        request.setAttribute(""Index"", jobDomainSC.getIndex());
        request.setAttribute(""UserGroups"", jobDomainSC.getCurrentUserGroups());
        request.setAttribute(""UserManageableSpaces"", jobDomainSC.getManageablesSpaces());
        request.setAttribute(""UserManageableGroups"", jobDomainSC.getManageablesGroups());
        request.setAttribute(""IsRightCopyReplaceEnabled"",
            jobDomainSC.isRightCopyReplaceEnabled());

      } else if (DOMAIN_NAVIGATION_DEST.equals(destination)) {
        List<Domain> domains = jobDomainSC.getAllDomains();
        if (domains.size() == 1) {
          jobDomainSC.setTargetDomain(domains.get(0).getId());
        }
        request.setAttribute(""allDomains"", domains);
        request.setAttribute(""allRootGroups"", jobDomainSC.getAllRootGroups());
        request.setAttribute(""CurrentDomain"", jobDomainSC.getTargetDomain());
      } else if (""groupManagers.jsp"".equals(destination)) {
        request.setAttribute(GROUP_OBJECT_ATTR, jobDomainSC.getTargetGroup());
        request.setAttribute(GROUPS_PATH_ATTR,
            jobDomainSC.getPath((String) request.getAttribute(MY_COMPONENT_URL_ATTR), null));
      }
      // 3) Concat the path
      // ------------------
      if (!destination.startsWith(""/"")) {
        destination = ""/jobDomainPeas/jsp/"" + destination;
      }
    } catch (Exception e) {
      request.setAttribute(""javax.servlet.jsp.jspException"", e);
      destination = ""/admin/jsp/errorpageMain.jsp"";
    }


    return destination;
  }",1
"public static boolean sanitizeUrl(String url)
	{
		if (url != null)
		{
			try
			{
				URL parsedUrl = new URL(url);
				String protocol = parsedUrl.getProtocol();
				String host = parsedUrl.getHost();
				InetAddress address = InetAddress.getByName(host);
				String hostAddress = address.getHostAddress();
				host = host.toLowerCase();
				
				return (protocol.equals(""http"") || protocol.equals(""https""))
						&& !address.isAnyLocalAddress()
						&& !address.isLoopbackAddress()
						&& !address.isLinkLocalAddress()
						&& allowedPorts.contains(parsedUrl.getPort())
						&& !host.endsWith("".internal"") // Redundant
						&& !host.endsWith("".local"") // Redundant
						&& !host.contains(""localhost"") // Redundant
						&& !hostAddress.startsWith(""0."") // 0.0.0.0/8 
						&& !hostAddress.startsWith(""10."") // 10.0.0.0/8
						&& !hostAddress.startsWith(""127."") // 127.0.0.0/8
						&& !hostAddress.startsWith(""169.254."") // 169.254.0.0/16
						&& !hostAddress.startsWith(""172.16."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.17."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.18."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.19."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.20."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.21."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.22."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.23."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.24."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.25."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.26."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.27."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.28."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.29."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.30."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""172.31."") // 172.16.0.0/12
						&& !hostAddress.startsWith(""192.0.0."") // 192.0.0.0/24
						&& !hostAddress.startsWith(""192.168."") // 192.168.0.0/16
						&& !hostAddress.startsWith(""198.18."") // 198.18.0.0/15
						&& !hostAddress.startsWith(""198.19."") // 198.18.0.0/15
						&& !hostAddress.startsWith(""fc00::"") // fc00::/7 https://stackoverflow.com/questions/53764109/is-there-a-java-api-that-will-identify-the-ipv6-address-fd00-as-local-private
						&& !hostAddress.startsWith(""fd00::"") // fd00::/8
						&& !host.endsWith("".arpa""); // reverse domain (needed?)
			}
			catch (MalformedURLException e)
			{
				return false;
			}
			catch (UnknownHostException e)
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}",1
"public List<Cliente> buscarClienteEmail(String email) throws SQLException, ClassNotFoundException {
        Connection con = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            con = ConnectionFactory.getConnection();
            email = ""%""+email+""%"";
            stmt = con.prepareStatement(stmtBuscarEmailCliente);
            stmt.setString(1,email);
            rs = stmt.executeQuery();
            return montaListaClientes(rs);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                rs.close();
            } catch (Exception ex) {
                System.out.println(""Erro ao fechar result set.Erro: "" + ex.getMessage());
            }
            try {
                stmt.close();
            } catch (SQLException ex) {
                System.out.println(""Erro ao fechar statement. Ex = "" + ex.getMessage());
            }
            try {
                con.close();
            } catch (SQLException ex) {
                System.out.println(""Erro ao fechar a conexao. Ex = "" + ex.getMessage());
            }
        }
    }",1
"private void tieProfileLockToParent(int userId, String password) {
        if (DEBUG) Slog.v(TAG, ""tieProfileLockToParent for user: "" + userId);
        byte[] randomLockSeed = password.getBytes(StandardCharsets.UTF_8);
        byte[] encryptionResult;
        byte[] iv;
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES);
            keyGenerator.init(new SecureRandom());
            SecretKey secretKey = keyGenerator.generateKey();

            java.security.KeyStore keyStore = java.security.KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);
            keyStore.setEntry(
                    LockPatternUtils.PROFILE_KEY_NAME_ENCRYPT + userId,
                    new java.security.KeyStore.SecretKeyEntry(secretKey),
                    new KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT)
                            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                            .build());
            keyStore.setEntry(
                    LockPatternUtils.PROFILE_KEY_NAME_DECRYPT + userId,
                    new java.security.KeyStore.SecretKeyEntry(secretKey),
                    new KeyProtection.Builder(KeyProperties.PURPOSE_DECRYPT)
                            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                            .setUserAuthenticationRequired(true)
                            .setUserAuthenticationValidityDurationSeconds(30)
                            .build());

            // Key imported, obtain a reference to it.
            SecretKey keyStoreEncryptionKey = (SecretKey) keyStore.getKey(
                    LockPatternUtils.PROFILE_KEY_NAME_ENCRYPT + userId, null);
            // The original key can now be discarded.

            Cipher cipher = Cipher.getInstance(
                    KeyProperties.KEY_ALGORITHM_AES + ""/"" + KeyProperties.BLOCK_MODE_GCM + ""/""
                            + KeyProperties.ENCRYPTION_PADDING_NONE);
            cipher.init(Cipher.ENCRYPT_MODE, keyStoreEncryptionKey);
            encryptionResult = cipher.doFinal(randomLockSeed);
            iv = cipher.getIV();
        } catch (CertificateException | UnrecoverableKeyException
                | IOException | BadPaddingException | IllegalBlockSizeException | KeyStoreException
                | NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException e) {
            throw new RuntimeException(""Failed to encrypt key"", e);
        }
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try {
            if (iv.length != PROFILE_KEY_IV_SIZE) {
                throw new RuntimeException(""Invalid iv length: "" + iv.length);
            }
            outputStream.write(iv);
            outputStream.write(encryptionResult);
        } catch (IOException e) {
            throw new RuntimeException(""Failed to concatenate byte arrays"", e);
        }
        mStorage.writeChildProfileLock(userId, outputStream.toByteArray());
    }",0
"public static String convertToWindowsPath(String pathString) {
		String pathSlash = getFilePathSlash(pathString);
		if (pathString.startsWith(pathSlash)) {
			if (pathString.length() > 3) {
				char letter = pathString.charAt(1);
				char colon = pathString.charAt(2);
				if (Character.isLetter(letter) && ':' == colon) {
					pathString = pathString.substring(1);
				}
			}
		}
		return pathString.replace(""/"", ""\\"");
	}",1
"private MacAddress setRandomizedMacToPersistentMac(WifiConfiguration config) {
        MacAddress persistentMac = getPersistentMacAddress(config);
        if (persistentMac == null || persistentMac.equals(config.getRandomizedMacAddress())) {
            return persistentMac;
        }
        WifiConfiguration internalConfig = getInternalConfiguredNetwork(config.networkId);
        setRandomizedMacAddress(internalConfig, persistentMac);
        return persistentMac;
    }",0
"public <T> List<T> search(String sql, Object[][] whereParams, XWikiContext context) throws XWikiException
    {
        return getStore().search(sql, 0, 0, whereParams, context);
    }",0
"@Deprecated
    public String[] getIndexableNames() {
        return indexableNames;
    }",1
"private void generateValuesFile(ResValuesFile valuesFile, Directory out,
                                    ExtXmlSerializer serial) throws AndrolibException {
        try {
            OutputStream outStream = out.getFileOutput(valuesFile.getPath());
            serial.setOutput((outStream), null);
            serial.startDocument(null, null);
            serial.startTag(null, ""resources"");

            for (ResResource res : valuesFile.listResources()) {
                if (valuesFile.isSynthesized(res)) {
                    continue;
                }
                ((ResValuesXmlSerializable) res.getValue()).serializeToResValuesXml(serial, res);
            }

            serial.endTag(null, ""resources"");
            serial.newLine();
            serial.endDocument();
            serial.flush();
            outStream.close();
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException(""Could not generate: "" + valuesFile.getPath(), ex);
        }
    }",0
"public Form<T> bind(
      Lang lang, TypedMap attrs, JsonNode data, long maxChars, String... allowedFields) {
    return bind(
        lang,
        attrs,
        play.libs.Scala.asJava(
            play.api.data.FormUtils.fromJson(
                play.api.libs.json.Json.parse(play.libs.Json.stringify(data)),
                maxChars,
                maxJsonDepth())),
        allowedFields);
  }",1
"@SuppressWarnings(""unchecked"")
	private String displayCategory(final String friendlyUrl, final String ref, Model model, HttpServletRequest request, HttpServletResponse response, Locale locale) throws Exception {

		MerchantStore store = (MerchantStore)request.getAttribute(Constants.MERCHANT_STORE);
		
		//set ref as request attribute
		String encoded = HtmlUtils.htmlEscape(ref);
		if(!encoded.equals(ref)) {//possible xss
			throw new Exception(""Wrong input"");
		}
		request.setAttribute(""ref"", encoded);

		//get category
		Category category = categoryService.getBySeUrl(store, friendlyUrl);
		
		Language language = (Language)request.getAttribute(""LANGUAGE"");
		
		if(category==null) {
			LOGGER.error(""No category found for friendlyUrl "" + friendlyUrl);
			//redirect on page not found
			return PageBuilderUtils.build404(store);
			
		}
		
		if(!category.isVisible()) {
			return PageBuilderUtils.buildHomePage(store);
		}
		
		ReadableCategoryPopulator populator = new ReadableCategoryPopulator();
		ReadableCategory categoryProxy = populator.populate(category, new ReadableCategory(), store, language);

		Breadcrumb breadCrumb = breadcrumbsUtils.buildCategoryBreadcrumb(categoryProxy, store, language, request.getContextPath());
		request.getSession().setAttribute(Constants.BREADCRUMB, breadCrumb);
		request.setAttribute(Constants.BREADCRUMB, breadCrumb);
		
		
		//meta information
		PageInformation pageInformation = new PageInformation();
		pageInformation.setPageDescription(categoryProxy.getDescription().getMetaDescription());
		pageInformation.setPageKeywords(categoryProxy.getDescription().getKeyWords());
		pageInformation.setPageTitle(categoryProxy.getDescription().getTitle());
		pageInformation.setPageUrl(categoryProxy.getDescription().getFriendlyUrl());
		
		//** retrieves category id drill down**//
		String lineage = new StringBuilder().append(category.getLineage()).append(Constants.CATEGORY_LINEAGE_DELIMITER).toString();

		
		
		request.setAttribute(Constants.REQUEST_PAGE_INFORMATION, pageInformation);
		
		List<Category> categs = categoryService.getListByLineage(store, lineage);
		categs.add(category);


		StringBuilder subCategoriesCacheKey = new StringBuilder();
		subCategoriesCacheKey
		.append(store.getId())
		.append(""_"")
		.append(category.getId())
		.append(""_"")
		.append(Constants.SUBCATEGORIES_CACHE_KEY)
		.append(""-"")
		.append(language.getCode());
		
		StringBuilder subCategoriesMissed = new StringBuilder();
		subCategoriesMissed
		.append(subCategoriesCacheKey.toString())
		.append(Constants.MISSED_CACHE_KEY);
		
		List<BigDecimal> prices = new ArrayList<BigDecimal>();
		List<ReadableCategory> subCategories = null;
		Map<Long,Long> countProductsByCategories = null;

		if(store.isUseCache()) {

			//get from the cache
			subCategories = (List<ReadableCategory>) cache.getFromCache(subCategoriesCacheKey.toString());
			if(subCategories==null) {
				//get from missed cache
				//Boolean missedContent = (Boolean)cache.getFromCache(subCategoriesMissed.toString());

				//if(missedContent==null) {
				    countProductsByCategories = getProductsByCategory(store, categs);
					subCategories = getSubCategories(store,category,countProductsByCategories,language,locale);
					
					if(subCategories!=null) {
						cache.putInCache(subCategories, subCategoriesCacheKey.toString());
					} else {
						//cache.putInCache(new Boolean(true), subCategoriesCacheKey.toString());
					}
				//}
			}
		} else {
			countProductsByCategories = getProductsByCategory(store, categs);
			subCategories = getSubCategories(store,category,countProductsByCategories,language,locale);
		}

		//Parent category
		ReadableCategory parentProxy  = null;

		if(category.getParent()!=null) {
			Category parent = categoryService.getById(category.getParent().getId(), store.getId());
			parentProxy = populator.populate(parent, new ReadableCategory(), store, language);
		}
		
		
		//** List of manufacturers **//
		List<ReadableManufacturer> manufacturerList = getManufacturersByProductAndCategory(store,category,categs,language);

		model.addAttribute(""manufacturers"", manufacturerList);
		model.addAttribute(""parent"", parentProxy);
		model.addAttribute(""category"", categoryProxy);
		model.addAttribute(""subCategories"", subCategories);
		
		if(parentProxy!=null) {
			request.setAttribute(Constants.LINK_CODE, parentProxy.getDescription().getFriendlyUrl());
		}
		
		
		/** template **/
		StringBuilder template = new StringBuilder().append(ControllerConstants.Tiles.Category.category).append(""."").append(store.getStoreTemplate());

		return template.toString();
	}",1
"@Override
    public T setObject(K name, Iterable<?> values) {
        validateName(nameValidator, false, name);

        int h = hashingStrategy.hashCode(name);
        int i = index(h);

        remove0(h, i, name);
        for (Object v: values) {
            if (v == null) {
                break;
            }
            V converted = fromObject(name, v);
            validateValue(valueValidator, name, converted);
            add0(h, i, name, converted);
        }

        return thisT();
    }",1
"@Override
  public synchronized <T extends Source> T getSource(Class<T> sourceClass) throws SQLException {
    checkFreed();
    ensureInitialized();

    if (data == null) {
      return null;
    }

    try {
      if (sourceClass == null || DOMSource.class.equals(sourceClass)) {
        DocumentBuilder builder = getXmlFactoryFactory().newDocumentBuilder();
        InputSource input = new InputSource(new StringReader(data));
        return (T) new DOMSource(builder.parse(input));
      } else if (SAXSource.class.equals(sourceClass)) {
        XMLReader reader = getXmlFactoryFactory().createXMLReader();
        InputSource is = new InputSource(new StringReader(data));
        return (T) new SAXSource(reader, is);
      } else if (StreamSource.class.equals(sourceClass)) {
        return (T) new StreamSource(new StringReader(data));
      } else if (StAXSource.class.equals(sourceClass)) {
        XMLInputFactory xif = getXmlFactoryFactory().newXMLInputFactory();
        XMLStreamReader xsr = xif.createXMLStreamReader(new StringReader(data));
        return (T) new StAXSource(xsr);
      }
    } catch (Exception e) {
      throw new PSQLException(GT.tr(""Unable to decode xml data.""), PSQLState.DATA_ERROR, e);
    }

    throw new PSQLException(GT.tr(""Unknown XML Source class: {0}"", sourceClass),
        PSQLState.INVALID_PARAMETER_TYPE);
  }",1
"@Override
    public T setObject(K name, Object... values) {
        validateName(nameValidator, false, name);

        int h = hashingStrategy.hashCode(name);
        int i = index(h);

        remove0(h, i, name);
        for (Object v: values) {
            if (v == null) {
                break;
            }
            V converted = fromObject(name, v);
            validateValue(valueValidator, name, converted);
            add0(h, i, name, converted);
        }

        return thisT();
    }",1
"public static boolean isDockerInstalled(Path dockerExecutable) {
    return Files.exists(dockerExecutable);
  }",1
"@Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (msg instanceof HttpRequest) {
            HttpRequest req = (HttpRequest) msg;
            List<String> lengthHeaders = req.headers().getAll(HttpHeaderNames.CONTENT_LENGTH);
            if (lengthHeaders.size() > 1) {
                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));
                return;
            } else if (lengthHeaders.size() == 1) {
                expectedContentLength = Long.parseLong(lengthHeaders.get(0));
                if (expectedContentLength < 0) {
                    // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.
                    ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));
                    return;
                }
            }
            if (hasContentLength() && HttpUtil.isTransferEncodingChunked(req)) {
                // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.
                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));
                return;
            }
        }
        if (msg instanceof HttpContent) {
            ByteBuf content = ((HttpContent) msg).content();
            incrementSeenContent(content.readableBytes());
            if (hasContentLength() && seenContentLength > expectedContentLength) {
                // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.
                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));
                return;
            }
        }
        if (msg instanceof LastHttpContent) {
            if (hasContentLength() && seenContentLength != expectedContentLength) {
                // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.
                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));
                return;
            }
        }
        super.channelRead(ctx, msg);
    }",1
"public void bind(int index, float value) {
            mPreparedStatement.bindDouble(index, value);
        }",0
"@HotPath(caller = HotPath.OOM_ADJUSTMENT)
        @Override
        public void onUidInactive(int uid) {
            mActiveUids.onUidInactive(uid);
        }",0
"protected String determineLoginType(boolean isSecure) {
        String result = JBossSAMLURIConstants.AC_PASSWORD.get();
        LoginConfig loginConfig = getContext().getLoginConfig();
        if (loginConfig != null) {
            String auth = loginConfig.getAuthMethod();
            if (StringUtil.isNotNull(auth)) {
                if (""CLIENT-CERT"".equals(auth)) {
                    result = JBossSAMLURIConstants.AC_TLS_CLIENT.get();
                } else if (isSecure) {
                    result = JBossSAMLURIConstants.AC_PASSWORD_PROTECTED_TRANSPORT.get();
                }
            }
        }
        return result;
    }",0
"private ApplicationCreatePage goToAppCreatePage(TestUtils testUtils, TestReference testReference)
    {
        // Login and go to the App Within Minutes home page.
        testUtils.login(USER_NAME, PASSWORD);
        // Make sure the application location exists so that we can select it with the location picker.
        testUtils.createPage(Arrays.asList(getClass().getSimpleName(), testReference.getLastSpaceReference().getName()),
            ""WebHome"", null, null);
        AppWithinMinutesHomePage appWithinMinutesHomePage = AppWithinMinutesHomePage.gotoPage();

        // Click the Create Application button.
        return appWithinMinutesHomePage.clickCreateApplication();
    }",1
"@Override
        public boolean equals(Object o) {
            return o instanceof RemoteCause && Arrays.equals(new Object[] {addr, note},
                    new Object[] {((RemoteCause)o).addr, ((RemoteCause)o).note});
        }",0
"public static String verifyRedirectUri(KeycloakSession session, String rootUrl, String redirectUri, Set<String> validRedirects, boolean requireRedirectUri) {
        KeycloakUriInfo uriInfo = session.getContext().getUri();
        RealmModel realm = session.getContext().getRealm();

        if (redirectUri == null) {
            if (!requireRedirectUri) {
                redirectUri = getSingleValidRedirectUri(validRedirects);
            }

            if (redirectUri == null) {
                logger.debug(""No Redirect URI parameter specified"");
                return null;
            }
        } else if (validRedirects.isEmpty()) {
            logger.debug(""No Redirect URIs supplied"");
            redirectUri = null;
        } else {
            // Make the validations against fully decoded and normalized redirect-url. This also allows wildcards (case when client configured ""Valid redirect-urls"" contain wildcards)
            String decodedRedirectUri = decodeRedirectUri(redirectUri);
            URI decodedRedirect = toUri(decodedRedirectUri);
            decodedRedirectUri = getNormalizedRedirectUri(decodedRedirect);
            if (decodedRedirectUri == null) return null;

            String r = decodedRedirectUri;
            Set<String> resolveValidRedirects = resolveValidRedirects(session, rootUrl, validRedirects);

            String valid = matchesRedirects(resolveValidRedirects, r, true);

            if (valid == null && (r.startsWith(Constants.INSTALLED_APP_URL) || r.startsWith(Constants.INSTALLED_APP_LOOPBACK)) && r.indexOf(':', Constants.INSTALLED_APP_URL.length()) >= 0) {
                int i = r.indexOf(':', Constants.INSTALLED_APP_URL.length());

                StringBuilder sb = new StringBuilder();
                sb.append(r.substring(0, i));

                i = r.indexOf('/', i);
                if (i >= 0) {
                    sb.append(r.substring(i));
                }

                r = sb.toString();

                valid = matchesRedirects(resolveValidRedirects, r, true);
            }

            // Return the original redirectUri, which can be partially encoded - for example http://localhost:8280/foo/bar%20bar%2092%2F72/3 . Just make sure it is normalized
            URI redirect = toUri(redirectUri);
            redirectUri = getNormalizedRedirectUri(redirect);

            // We try to check validity also for original (encoded) redirectUrl, but just in case it exactly matches some ""Valid Redirect URL"" specified for client (not wildcards allowed)
            if (valid == null) {
                valid = matchesRedirects(resolveValidRedirects, redirectUri, false);
            }

            if (valid != null && redirectUri.startsWith(""/"")) {
                redirectUri = relativeToAbsoluteURI(session, rootUrl, redirectUri);
            }

            String scheme = decodedRedirect.getScheme();
            if (valid != null && scheme != null) {
                // check the scheme is valid, it should be http(s) or explicitly allowed by the validation
                if (!valid.startsWith(scheme + "":"") && !""http"".equalsIgnoreCase(scheme) && !""https"".equalsIgnoreCase(scheme)) {
                    logger.debugf(""Invalid URI because scheme is not allowed: %s"", redirectUri);
                    valid = null;
                }
            }

            redirectUri = valid != null ? redirectUri : null;
        }

        if (Constants.INSTALLED_APP_URN.equals(redirectUri)) {
            return Urls.realmInstalledAppUrnCallback(uriInfo.getBaseUri(), realm.getName()).toString();
        } else {
            return redirectUri;
        }
    }",1
"public void saveANRStateLocked(AppWindowToken appWindowToken, WindowState windowState,
            String reason) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new FastPrintWriter(sw, false, 1024);
        pw.println(""  ANR time: "" + DateFormat.getInstance().format(new Date()));
        if (appWindowToken != null) {
            pw.println(""  Application at fault: "" + appWindowToken.stringName);
        }
        if (windowState != null) {
            pw.println(""  Window at fault: "" + windowState.mAttrs.getTitle());
        }
        if (reason != null) {
            pw.println(""  Reason: "" + reason);
        }
        pw.println();
        dumpWindowsNoHeaderLocked(pw, true, null);
        pw.println();
        pw.println(""Last ANR continued"");
        dumpDisplayContentsLocked(pw, true);
        pw.close();
        mLastANRState = sw.toString();

        mH.removeMessages(H.RESET_ANR_MESSAGE);
        mH.sendEmptyMessageDelayed(H.RESET_ANR_MESSAGE, LAST_ANR_LIFETIME_DURATION_MSECS);
    }",0
"void updateLetterboxSurface(WindowState winHint) {
        mLetterboxUiController.updateLetterboxSurface(winHint);
    }",0
"@Override
	public final void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
	        throws IOException, ServletException {
		if (skipFilter((HttpServletRequest) request)) {
			chain.doFilter(request, response);
		} else {
			
			HttpServletRequest httpRequest = (HttpServletRequest) request;
			HttpServletResponse httpResponse = (HttpServletResponse) response;
			
			String servletPath = httpRequest.getServletPath();
			// for all /images and /initfilter/scripts files, write the path
			// (the ""/initfilter"" part is needed so that the openmrs_static_context-servlet.xml file doesn't
			//  get instantiated early, before the locale messages are all set up)
			if (servletPath.startsWith(""/images"") || servletPath.startsWith(""/initfilter/scripts"")) {
				// strip out the /initfilter part
				servletPath = servletPath.replaceFirst(""/initfilter"", ""/WEB-INF/view"");
				// writes the actual image file path to the response
				Path filePath = Paths.get(filterConfig.getServletContext().getRealPath(servletPath)).normalize();
				Path fullFilePath = filePath;
				if (httpRequest.getPathInfo() != null) {
					fullFilePath = fullFilePath.resolve(httpRequest.getPathInfo());
					if (!(fullFilePath.normalize().startsWith(filePath))) {
						log.warn(""Detected attempted directory traversal in request for {}"", httpRequest.getPathInfo());
						return;
					}
				}
				
				try (InputStream imageFileInputStream = new FileInputStream(fullFilePath.normalize().toFile())) {
					OpenmrsUtil.copyFile(imageFileInputStream, httpResponse.getOutputStream());
				}
				catch (FileNotFoundException e) {
					log.error(""Unable to find file: {}"", filePath, e);
				}
				catch (IOException e) {
					log.warn(""An error occurred while handling file {}"", filePath, e);
				}
			} else if (servletPath.startsWith(""/scripts"")) {
				log.error(
				    ""Calling /scripts during the initializationfilter pages will cause the openmrs_static_context-servlet.xml to initialize too early and cause errors after startup.  Use '/initfilter""
				            + servletPath + ""' instead."");
			}
			// for anything but /initialsetup
			else if (!httpRequest.getServletPath().equals(""/"" + WebConstants.SETUP_PAGE_URL)
			        && !httpRequest.getServletPath().equals(""/"" + AUTO_RUN_OPENMRS)) {
				// send the user to the setup page
				httpResponse.sendRedirect(""/"" + WebConstants.WEBAPP_NAME + ""/"" + WebConstants.SETUP_PAGE_URL);
			} else {
				
				if (""GET"".equals(httpRequest.getMethod())) {
					doGet(httpRequest, httpResponse);
				} else if (""POST"".equals(httpRequest.getMethod())) {
					// only clear errors before POSTS so that redirects can show errors too.
					errors.clear();
					msgs.clear();
					doPost(httpRequest, httpResponse);
				}
			}
			// Don't continue down the filter chain otherwise Spring complains
			// that it hasn't been set up yet.
			// The jsp and servlet filter are also on this chain, so writing to
			// the response directly here is the only option
		}
	}",1
"@Override
    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)
        throws XWikiException
    {
        return search(sql, nb, start, whereParams, null, context);
    }",0
"@Override
    public void closeInbound() {
        debug(""JSSEngine: closeInbound()"");

        if (!is_inbound_closed && ssl_fd != null && !closed_fd) {
            // Send PR_SHUTDOWN_RCV only once. Additionally, this call
            // crashes when ssl_fd == NULL or when the socket is already
            // closed.
            PR.Shutdown(ssl_fd, PR.SHUTDOWN_RCV);
        }

        is_inbound_closed = true;
    }",0
"private Object readNewObject(boolean unshared)
            throws OptionalDataException, ClassNotFoundException, IOException {
        ObjectStreamClass classDesc = readClassDesc();

        if (classDesc == null) {
            throw missingClassDescriptor();
        }

        Class<?> objectClass = classDesc.checkAndGetTcObjectClass();

        int newHandle = nextHandle();
        Object result;
        Object registeredResult = null;
        if (objectClass != null) {
            // Now we know which class to instantiate and which constructor to
            // run. We are allowed to run the constructor.
            result = classDesc.newInstance(objectClass);
            registerObjectRead(result, newHandle, unshared);
            registeredResult = result;
        } else {
            result = null;
        }

        try {
            // This is how we know what to do in defaultReadObject. And it is
            // also used by defaultReadObject to check if it was called from an
            // invalid place. It also allows readExternal to call
            // defaultReadObject and have it work.
            currentObject = result;
            currentClass = classDesc;

            // If Externalizable, just let the object read itself
            // Note that this value comes from the Stream, and in fact it could be
            // that the classes have been changed so that the info below now
            // conflicts with the newer class
            boolean wasExternalizable = (classDesc.getFlags() & SC_EXTERNALIZABLE) != 0;
            if (wasExternalizable) {
                boolean blockData = (classDesc.getFlags() & SC_BLOCK_DATA) != 0;
                if (!blockData) {
                    primitiveData = input;
                }
                if (mustResolve) {
                    Externalizable extern = (Externalizable) result;
                    extern.readExternal(this);
                }
                if (blockData) {
                    // Similar to readHierarchy. Anything not read by
                    // readExternal has to be consumed here
                    discardData();
                } else {
                    primitiveData = emptyStream;
                }
            } else {
                // If we got here, it is Serializable but not Externalizable.
                // Walk the hierarchy reading each class' slots
                readHierarchy(result, classDesc);
            }
        } finally {
            // Cleanup, needs to run always so that we can later detect invalid
            // calls to defaultReadObject
            currentObject = null;
            currentClass = null;
        }

        if (objectClass != null) {

            if (classDesc.hasMethodReadResolve()){
                Method methodReadResolve = classDesc.getMethodReadResolve();
                try {
                    result = methodReadResolve.invoke(result, (Object[]) null);
                } catch (IllegalAccessException ignored) {
                } catch (InvocationTargetException ite) {
                    Throwable target = ite.getTargetException();
                    if (target instanceof ObjectStreamException) {
                        throw (ObjectStreamException) target;
                    } else if (target instanceof Error) {
                        throw (Error) target;
                    } else {
                        throw (RuntimeException) target;
                    }
                }

            }
        }
        // We get here either if class-based replacement was not needed or if it
        // was needed but produced the same object or if it could not be
        // computed.

        // The object to return is the one we instantiated or a replacement for
        // it
        if (result != null && enableResolve) {
            result = resolveObject(result);
        }
        if (registeredResult != result) {
            registerObjectRead(result, newHandle, unshared);
        }
        return result;
    }",1
"public void test_exception() throws Exception {
		RuntimeException ex = new RuntimeException(""e1"");
		String text = JSON.toJSONString(ex);
		System.out.println(text);


		Object obj = JSON.parse(text);
		assertTrue(obj instanceof Map);

		RuntimeException ex2 = (RuntimeException) JSON.parseObject(text, Throwable.class);
	}",1
"private SettingsState getGlobalSettingsLocked() {
                return getSettingsLocked(SETTINGS_TYPE_GLOBAL, UserHandle.USER_SYSTEM);
            }",0
"public static String getFileExtension(String fullName) {
    checkNotNull(fullName);
    String fileName = new File(fullName).getName();
    int dotIndex = fileName.lastIndexOf('.');
    return (dotIndex == -1) ? """" : fileName.substring(dotIndex + 1);
  }",0
"@Override
  public void validate(final OidcCredentials credentials, final WebContext context) {
    final AuthorizationCode code = credentials.getCode();
    // if we have a code
    if (code != null) {
      try {
        final String computedCallbackUrl = client.computeFinalCallbackUrl(context);
        CodeVerifier verifier = (CodeVerifier) configuration.getValueRetriever()
                .retrieve(client.getCodeVerifierSessionAttributeName(), client, context).orElse(null);
        // Token request
        final TokenRequest request = createTokenRequest(new AuthorizationCodeGrant(code, new URI(computedCallbackUrl), verifier));
        HTTPRequest tokenHttpRequest = request.toHTTPRequest();
        tokenHttpRequest.setConnectTimeout(configuration.getConnectTimeout());
        tokenHttpRequest.setReadTimeout(configuration.getReadTimeout());

        final HTTPResponse httpResponse = tokenHttpRequest.send();
        logger.debug(""Token response: status={}, content={}"", httpResponse.getStatusCode(),
            httpResponse.getContent());

        final TokenResponse response = OIDCTokenResponseParser.parse(httpResponse);
        if (response instanceof TokenErrorResponse) {
          throw new TechnicalException(""Bad token response, error="" + ((TokenErrorResponse) response).getErrorObject());
        }
        logger.debug(""Token response successful"");
        final OIDCTokenResponse tokenSuccessResponse = (OIDCTokenResponse) response;

        // save tokens in credentials
        final OIDCTokens oidcTokens = tokenSuccessResponse.getOIDCTokens();
        credentials.setAccessToken(oidcTokens.getAccessToken());
        credentials.setRefreshToken(oidcTokens.getRefreshToken());
        credentials.setIdToken(oidcTokens.getIDToken());

      } catch (final URISyntaxException | IOException | ParseException e) {
        throw new TechnicalException(e);
      }
    }
  }",1
"private void configureUpdateCredentialsNotification(Account account) {
        // let the user update credentials with one click
        Intent updateAccountCredentials = new Intent(this, AuthenticatorActivity.class);
        updateAccountCredentials.putExtra(AuthenticatorActivity.EXTRA_ACCOUNT, account);
        updateAccountCredentials.putExtra(
                AuthenticatorActivity.EXTRA_ACTION,
                AuthenticatorActivity.ACTION_UPDATE_EXPIRED_TOKEN
        );
        updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        updateAccountCredentials.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        updateAccountCredentials.addFlags(Intent.FLAG_FROM_BACKGROUND);
        mNotificationBuilder.setContentIntent(
            PendingIntent.getActivity(this,
                                      (int) System.currentTimeMillis(),
                                      updateAccountCredentials,
                                      PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE)
                                             );
    }",1
"private void copyJarEntryTrimmingBasePath(JarFile jarFile,
            ZipEntry jarEntry, String basePath, File outputDirectory) {
        String fullPath = jarEntry.getName();
        String relativePath = fullPath
                .substring(fullPath.toLowerCase(Locale.ENGLISH)
                        .indexOf(basePath.toLowerCase(Locale.ENGLISH))
                        + basePath.length());
        File target = new File(outputDirectory, relativePath);
        try {
            if (target.exists()) {
                if (!hasSameContent(jarFile.getInputStream(jarEntry), target)) {
                    FileUtils.copyInputStreamToFile(
                            jarFile.getInputStream(jarEntry), target);
                }
            } else {
                FileUtils.copyInputStreamToFile(
                        jarFile.getInputStream(jarEntry), target);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(String.format(
                    ""Failed to extract jar entry '%s' from jarFile '%s'"",
                    jarEntry, outputDirectory), e);
        }
    }",1
"void grantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri,
            final int modeFlags, UriPermissionOwner owner, int targetUserId) {
        if (targetPkg == null) {
            throw new NullPointerException(""targetPkg"");
        }
        int targetUid;
        final IPackageManager pm = AppGlobals.getPackageManager();
        try {
            targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING, targetUserId);
        } catch (RemoteException ex) {
            return;
        }

        targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, modeFlags,
                targetUid);
        if (targetUid < 0) {
            return;
        }

        grantUriPermissionUncheckedLocked(targetUid, targetPkg, grantUri, modeFlags,
                owner);
    }",0
"public static void load(String originalName, ClassLoader loader) {
        // Adjust expected name to support shading of native libraries.
        String packagePrefix = calculatePackagePrefix().replace('.', '_');
        String name = packagePrefix + originalName;
        List<Throwable> suppressed = new ArrayList<Throwable>();
        try {
            // first try to load from java.library.path
            loadLibrary(loader, name, false);
            return;
        } catch (Throwable ex) {
            suppressed.add(ex);
        }

        String libname = System.mapLibraryName(name);
        String path = NATIVE_RESOURCE_HOME + libname;

        InputStream in = null;
        OutputStream out = null;
        File tmpFile = null;
        URL url;
        if (loader == null) {
            url = ClassLoader.getSystemResource(path);
        } else {
            url = loader.getResource(path);
        }
        try {
            if (url == null) {
                if (PlatformDependent.isOsx()) {
                    String fileName = path.endsWith("".jnilib"") ? NATIVE_RESOURCE_HOME + ""lib"" + name + "".dynlib"" :
                            NATIVE_RESOURCE_HOME + ""lib"" + name + "".jnilib"";
                    if (loader == null) {
                        url = ClassLoader.getSystemResource(fileName);
                    } else {
                        url = loader.getResource(fileName);
                    }
                    if (url == null) {
                        FileNotFoundException fnf = new FileNotFoundException(fileName);
                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);
                        throw fnf;
                    }
                } else {
                    FileNotFoundException fnf = new FileNotFoundException(path);
                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);
                    throw fnf;
                }
            }

            int index = libname.lastIndexOf('.');
            String prefix = libname.substring(0, index);
            String suffix = libname.substring(index);

            tmpFile = PlatformDependent.createTempFile(prefix, suffix, WORKDIR);
            in = url.openStream();
            out = new FileOutputStream(tmpFile);

            if (shouldShadedLibraryIdBePatched(packagePrefix)) {
                patchShadedLibraryId(in, out, originalName, name);
            } else {
                byte[] buffer = new byte[8192];
                int length;
                while ((length = in.read(buffer)) > 0) {
                    out.write(buffer, 0, length);
                }
            }

            out.flush();

            // Close the output stream before loading the unpacked library,
            // because otherwise Windows will refuse to load it when it's in use by other process.
            closeQuietly(out);
            out = null;
            loadLibrary(loader, tmpFile.getPath(), true);
        } catch (UnsatisfiedLinkError e) {
            try {
                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&
                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {
                    // Pass ""io.netty.native.workdir"" as an argument to allow shading tools to see
                    // the string. Since this is printed out to users to tell them what to do next,
                    // we want the value to be correct even when shading.
                    logger.info(""{} exists but cannot be executed even when execute permissions set; "" +
                                ""check volume for \""noexec\"" flag; use -D{}=[path] "" +
                                ""to set native working directory separately."",
                                tmpFile.getPath(), ""io.netty.native.workdir"");
                }
            } catch (Throwable t) {
                suppressed.add(t);
                logger.debug(""Error checking if {} is on a file store mounted with noexec"", tmpFile, t);
            }
            // Re-throw to fail the load
            ThrowableUtil.addSuppressedAndClear(e, suppressed);
            throw e;
        } catch (Exception e) {
            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(""could not load a native library: "" + name);
            ule.initCause(e);
            ThrowableUtil.addSuppressedAndClear(ule, suppressed);
            throw ule;
        } finally {
            closeQuietly(in);
            closeQuietly(out);
            // After we load the library it is safe to delete the file.
            // We delete the file immediately to free up resources as soon as possible,
            // and if this fails fallback to deleting on JVM exit.
            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {
                tmpFile.deleteOnExit();
            }
        }
    }",1
"@JRubyMethod(name = ""io"", meta = true)
  public static IRubyObject
  parse_io(ThreadContext context,
           IRubyObject klass,
           IRubyObject data,
           IRubyObject encoding)
  {
    if (!(encoding instanceof RubyFixnum)) {
      throw context.getRuntime().newTypeError(""encoding must be kind_of String"");
    }

    Html4SaxParserContext ctx = Html4SaxParserContext.newInstance(context.runtime, (RubyClass) klass);
    ctx.setIOInputSource(context, data, context.nil);
    String javaEncoding = findEncodingName(context, encoding);
    if (javaEncoding != null) {
      ctx.getInputSource().setEncoding(javaEncoding);
    }
    return ctx;
  }",1
"@Override
        public final int read() throws IOException {
            ensureOpen();
            return nativeAssetReadChar(mAssetNativePtr);
        }",0
"@Unstable
    public String getRenderedContent(String text, Syntax sourceSyntaxId, boolean restrictedTransformationContext,
        XWikiDocument sDocument, boolean isolated, XWikiContext context)
    {
        return getRenderedContent(text, sourceSyntaxId, getOutputSyntax(), restrictedTransformationContext, sDocument,
            isolated, context);
    }",0
"@NonNull
            public BubbleMetadata.Builder setSuppressNotification(boolean shouldSuppressNotif) {
                setFlag(FLAG_SUPPRESS_NOTIFICATION, shouldSuppressNotif);
                return this;
            }",0
"public static boolean isCsrfTokenValid(VaadinSession session,
            String requestToken) {

        if (session.getService().getDeploymentConfiguration()
                .isXsrfProtectionEnabled()) {
            String sessionToken = session.getCsrfToken();

            if (sessionToken == null || !MessageDigest.isEqual(
                    sessionToken.getBytes(StandardCharsets.UTF_8),
                    requestToken.getBytes(StandardCharsets.UTF_8))) {
                return false;
            }
        }
        return true;
    }",1
"@Override
        public boolean isActiveSupervisionApp(int uid) {
            if (!isProfileOwner(new CallerIdentity(uid, null, null))) {
                return false;
            }
            synchronized (getLockObject()) {
                final ActiveAdmin admin = getProfileOwnerAdminLocked(UserHandle.getUserId(uid));
                if (admin == null) {
                    return false;
                }

                return isSupervisionComponentLocked(admin.info.getComponent());
            }
        }",0
"private boolean updateSubmoduleWithDepth(int depth) {
        List<String> updateArgs = new ArrayList<>(asList(""submodule"", ""update""));
        updateArgs.add(""--depth="" + depth);
        CommandLine commandLine = gitWd().withArgs(updateArgs);
        try {
            runOrBomb(commandLine);
        } catch (Exception e) {
            LOG.warn(e.getMessage(), e);
            return false;
        }
        return true;
    }",0
"@Override
    public void displayPreference(PreferenceScreen screen) {
        super.displayPreference(screen);

        MainSwitchPreference pref = screen.findPreference(getPreferenceKey());
        pref.addOnSwitchChangeListener(this);
        pref.updateStatus(isChecked());
    }",0
"@Override
    public InputStream export(FF4jConfiguration ff4jConfig) {
        Util.assertNotNull(ff4jConfig);
        StringBuilder output =  new StringBuilder();
        addProperty(output, FF4J_TAG + ""."" + GLOBAL_AUDIT_TAG, ff4jConfig.isAudit());
        addProperty(output, FF4J_TAG + ""."" + GLOBAL_AUTOCREATE, ff4jConfig.isAutoCreate());
            
        // Features
        if (null != ff4jConfig.getFeatures()) {
            int idxFeature = 0;
            for (Feature f : ff4jConfig.getFeatures().values()) {
                // ff4j.features.x.
                String prefixKey = FF4J_TAG + ""."" + FEATURES_TAG + ""."" + idxFeature + ""."";
                addProperty(output, prefixKey + FEATURE_ATT_UID, f.getUid());
                addProperty(output, prefixKey + FEATURE_ATT_ENABLE, f.isEnable());
                if (null != f.getDescription()) {
                    addProperty(output, prefixKey + FEATURE_ATT_DESC, f.getDescription());
                }
                if (null != f.getGroup()) {
                    addProperty(output, prefixKey + FEATURE_ATT_GROUP, f.getGroup());
                }
                if (!f.getPermissions().isEmpty()) {
                    addProperty(output, prefixKey + FEATURE_ATT_PERMISSIONS, String.join("","", f.getPermissions()));
                }
                if (null != f.getFlippingStrategy()) {
                    String flipKey = prefixKey + TOGGLE_STRATEGY_TAG + ""."";
                    addProperty(output, flipKey + TOGGLE_STRATEGY_ATTCLASS, 
                            String.join("","", f.getFlippingStrategy().getClass().getName()));
                    int idxParam = 0;
                    for (Map.Entry<String, String> entry : f.getFlippingStrategy().getInitParams().entrySet()) {
                        addProperty(output, flipKey + TOGGLE_STRATEGY_PARAMTAG + ""."" + idxParam + ""."" + TOGGLE_STRATEGY_PARAMNAME, entry.getKey());
                        addProperty(output, flipKey + TOGGLE_STRATEGY_PARAMTAG + ""."" + idxParam + ""."" + TOGGLE_STRATEGY_PARAMVALUE, entry.getValue());
                        idxParam++;
                    }
                }
                if (!f.getCustomProperties().isEmpty()) {
                    int idxProps = 0;
                    for (Property<?> p : f.getCustomProperties().values()) {
                        String propKey = prefixKey + FEATURE_ATT_PROPERTIES + ""."" + idxProps + ""."";
                        exportProperty(output, propKey, p);
                        idxProps++;
                    }
                }
                idxFeature++;
            }
        }
        
        // Properties
        if (null != ff4jConfig.getProperties() && !ff4jConfig.getProperties().isEmpty()) {
            int idxProps = 0;
            for (Property<?> p : ff4jConfig.getProperties().values()) {
                String propKey = FF4J_TAG + ""."" + PROPERTIES_TAG + ""."" + idxProps + ""."";
                exportProperty(output, propKey, p);
                idxProps++;
            }
        }
        System.out.println(output.toString());
        return new ByteArrayInputStream(output.toString().getBytes(StandardCharsets.UTF_8));
    }",0
"public static TfsMaterial tfsMaterial(String url) {
        return new TfsMaterial(new UrlArgument(url), ""username"", ""domain"", ""password"", ""project-path"");
    }",1
"private JSON buildResultSearch(Entity searchEntity, String quickFields, String q, String appendWhere, int maxResults) {
        String searchWhere = ""(1=1)"";

        if (StringUtils.isNotBlank(q)) {
            // 查询字段
            Set<String> searchFields = ParseHelper.buildQuickFields(searchEntity, quickFields);
            if (searchFields.isEmpty()) {
                return JSONUtils.EMPTY_ARRAY;
            }

            String like = "" like '%"" + CommonsUtils.escapeSql(q) + ""%'"";
            searchWhere = StringUtils.join(searchFields.iterator(), like + "" or "") + like;
        }

        if (appendWhere != null) {
            searchWhere = String.format(""(%s) and (%s)"", appendWhere, searchWhere);
        } else {
            searchWhere = String.format(""(%s)"", searchWhere);
        }

        List<Object> result = resultSearch(searchWhere, searchEntity, maxResults);
        return (JSON) JSON.toJSON(result);
    }",1
"private boolean isStackFrameNotWhitelisted(StackTraceElement ste) {
		return isCallNotWhitelisted(ste.getClassName(), ste.getMethodName());
	}",1
"@MediumTest
    @Test
    public void testNoAutoSpeakerphoneOnOutgoing() throws Exception {
        // Start an incoming video call.
        IdPair ids = startAndMakeActiveOutgoingCall(""650-555-1212"",
                mPhoneAccountA0.getAccountHandle(), mConnectionServiceFixtureA,
                VideoProfile.STATE_AUDIO_ONLY, null);

        verifyAudioRoute(CallAudioState.ROUTE_EARPIECE);
    }",1
"boolean dumpBinderProxiesCounts(PrintWriter pw, String header) {
        SparseIntArray counts = BinderInternal.nGetBinderProxyPerUidCounts();
        if(counts != null) {
            pw.println(header);
            for (int i = 0; i < counts.size(); i++) {
                final int uid = counts.keyAt(i);
                final int binderCount = counts.valueAt(i);
                pw.print(""    UID "");
                pw.print(uid);
                pw.print("", binder count = "");
                pw.print(binderCount);
                pw.print("", package(s)= "");
                final String[] pkgNames = mContext.getPackageManager().getPackagesForUid(uid);
                if (pkgNames != null) {
                    for (int j = 0; j < pkgNames.length; j++) {
                        pw.print(pkgNames[j]);
                        pw.print(""; "");
                    }
                } else {
                    pw.print(""NO PACKAGE NAME FOUND"");
                }
                pw.println();
            }
            return true;
        }
        return false;
    }",0
"private static long getLongSafe(byte[] bytes, int offset) {
        if (BIG_ENDIAN_NATIVE_ORDER) {
            return (long) bytes[offset] << 56 |
                    ((long) bytes[offset + 1] & 0xff) << 48 |
                    ((long) bytes[offset + 2] & 0xff) << 40 |
                    ((long) bytes[offset + 3] & 0xff) << 32 |
                    ((long) bytes[offset + 4] & 0xff) << 24 |
                    ((long) bytes[offset + 5] & 0xff) << 16 |
                    ((long) bytes[offset + 6] & 0xff) <<  8 |
                    (long) bytes[offset + 7] & 0xff;
        }
        return (long) bytes[offset] & 0xff |
                ((long) bytes[offset + 1] & 0xff) << 8 |
                ((long) bytes[offset + 2] & 0xff) << 16 |
                ((long) bytes[offset + 3] & 0xff) << 24 |
                ((long) bytes[offset + 4] & 0xff) << 32 |
                ((long) bytes[offset + 5] & 0xff) << 40 |
                ((long) bytes[offset + 6] & 0xff) << 48 |
                (long) bytes[offset + 7] << 56;
    }",0
"void checkUserAutohide(View v, MotionEvent event) {
        if ((mSystemUiVisibility & STATUS_OR_NAV_TRANSIENT) != 0  // a transient bar is revealed
                && event.getAction() == MotionEvent.ACTION_OUTSIDE // touch outside the source bar
                && event.getX() == 0 && event.getY() == 0  // a touch outside both bars
                && !mRemoteInputController.isRemoteInputActive()) { // not due to typing in IME
            userAutohide();
        }
    }",0
"protected void endOfEntryReached(InputStream inputStream, int numberOfBytesPushedBack) throws IOException {
    // is optional but useful for AES
  }",1
"public String getUrl() {
        if (mNativeContentViewCore != 0) return nativeGetURL(mNativeContentViewCore);
        return null;
    }",0
"protected PostMethod executePost(String uri, String string, String mediaType, String userName, String password)
        throws Exception
    {
        return executePost(uri, string, mediaType, userName, password, getFormToken(userName, password));
    }",1
"@Override
    protected void build() throws SVGException
    {
        super.build();

        StyleAttribute sty = new StyleAttribute();

        if (getPres(sty.setName(""x"")))
        {
            x = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""y"")))
        {
            y = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""width"")))
        {
            width = sty.getFloatValueWithUnits();
        }

        if (getPres(sty.setName(""height"")))
        {
            height = sty.getFloatValueWithUnits();
        }

        try
        {
            if (getPres(sty.setName(""xlink:href"")))
            {
                URI src = sty.getURIValue(getXMLBase());
                if (""data"".equals(src.getScheme()))
                {
                    imageSrc = new URL(null, src.toASCIIString(), new Handler());
                }
                else if (!diagram.getUniverse().isImageDataInlineOnly())
                {
                    try
                    {
                        imageSrc = src.toURL();
                    } catch (Exception e)
                    {
                        Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                            ""Could not parse xlink:href "" + src, e);
                        imageSrc = null;
                    }
                }
            }
        } catch (Exception e)
        {
            throw new SVGException(e);
        }

        if (imageSrc != null)
        {
            diagram.getUniverse().registerImage(imageSrc);

            //Set widths if not set
            BufferedImage img = diagram.getUniverse().getImage(imageSrc);
            if (img == null)
            {
                xform = new AffineTransform();
                bounds = new Rectangle2D.Float();
                return;
            }

            if (width == 0)
            {
                width = img.getWidth();
            }
            if (height == 0)
            {
                height = img.getHeight();
            }

            //Determine image xform
            xform = new AffineTransform();
            xform.translate(this.x, this.y);
            xform.scale(this.width / img.getWidth(), this.height / img.getHeight());
        }

        bounds = new Rectangle2D.Float(this.x, this.y, this.width, this.height);
    }",1
"@Override
    public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId,
            int targetUserId) {
        mContext.enforceCallingOrSelfPermission(
                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, null);
        List<CrossProfileIntentFilter> matches =
                getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
        if (matches != null) {
            int size = matches.size();
            for (int i = 0; i < size; i++) {
                if (matches.get(i).getTargetUserId() == targetUserId) return true;
            }
        }
        if (hasWebURI(intent)) {
            // cross-profile app linking works only towards the parent.
            final UserInfo parent = getProfileParent(sourceUserId);
            synchronized(mPackages) {
                CrossProfileDomainInfo xpDomainInfo = getCrossProfileDomainPreferredLpr(
                        intent, resolvedType, 0, sourceUserId, parent.id);
                return xpDomainInfo != null;
            }
        }
        return false;
    }",0
"public String search(String forename, String surname, String contactemail) throws SQLException {

        String query;
        if (forename.isEmpty() && surname.isEmpty()) {
            query = """";
        } else if (forename.isEmpty()) {
            query = ""familyname LIKE '%"" + surname + ""' and"";
        } else if (surname.isEmpty()) {
            query = ""forename LIKE '%"" + forename + ""' and "";
        } else {
            query = ""forename LIKE '%"" + forename + ""' and familyname LIKE '%"" + surname + ""' and"";
        }

        PreparedStatement ps = conn.prepareStatement(""SELECT * FROM contactinfo WHERE ? contactemailaddress = ?"");
        ps.setString(1, query);
        ps.setString(2, contactemail);
        ResultSet rs = ps.executeQuery();
        StringBuilder result = new StringBuilder(""<h3>Search results...</h3><table class=\""result-table\"">"" +
                ""<tr>"" +
                ""<th>Forename</th> <th>Surname</th> <th>Email</th>"" +
                ""</tr>"");
        while (rs.next())
        {
            result.append(""<tr><td>"");
            result.append(rs.getString(2));
            result.append(""</td><td>"" + rs.getString(3));
            result.append(""</td><td>"" + rs.getString(4) + ""</td></tr>"");
        }

        result.append(""</table"");
        conn.close();
        return result.toString();
    }",1
"@Nullable String[] getResourceStringArray(@ArrayRes int resId) {
        synchronized (this) {
            ensureValidLocked();
            return nativeGetResourceStringArray(mObject, resId);
        }
    }",0
"protected String getExecutionPreamble()
    {
        if ( getWorkingDirectoryAsString() == null )
        {
            return null;
        }

        String dir = getWorkingDirectoryAsString();

        return ""cd "" + quoteOneItem( dir, false ) + "" && "";
    }",1
"@Override
	public void onTurnEnded(TurnEndedEvent event) {
		super.onTurnEnded(event);

		final String out = event.getTurnSnapshot().getRobots()[0].getOutputStreamSnapshot();

		if (out.contains(""java.lang.SecurityException:"")) {
			securityExceptionOccurred = true;	
		}	
	}",1
"public String getGenericSignature() {
        StringBuilder sb = new StringBuilder(40);
        getGenericSignature(sb);
        return sb.toString();        
    }",0
"@Override
    public XDOM getXDOM()
    {
        if (this.xdomCache == null) {
            try {
                this.xdomCache = parseContent(getContent());
            } catch (XWikiException e) {
                ErrorBlockGenerator errorBlockGenerator = Utils.getComponent(ErrorBlockGenerator.class);
                return new XDOM(errorBlockGenerator.generateErrorBlocks(false, TM_FAILEDDOCUMENTPARSE,
                    ""Failed to parse document content"", null, e));
            }
        }

        return this.xdomCache.clone();
    }",0
"private void elide(int start, int end) {
    if (sanitizedJson == null) {
      sanitizedJson = new StringBuilder(jsonish.length() + 16);
    }
    sanitizedJson.append(jsonish, cleaned, start);
    cleaned = end;
  }",0
"private VersionInfo getSettingsVersionForPackage(PackageParser.Package pkg) {
        if (isExternal(pkg)) {
            if (TextUtils.isEmpty(pkg.volumeUuid)) {
                return mSettings.getExternalVersion();
            } else {
                return mSettings.findOrCreateVersion(pkg.volumeUuid);
            }
        } else {
            return mSettings.getInternalVersion();
        }
    }",0
"boolean supportsMultiWindowInDisplayArea(@Nullable TaskDisplayArea tda) {
        if (isActivityTypeHome()) {
            return false;
        }
        if (!mAtmService.mSupportsMultiWindow) {
            return false;
        }
        if (tda == null) {
            return false;
        }

        if (!isResizeable() && !tda.supportsNonResizableMultiWindow()) {
            // Not support non-resizable in multi window.
            return false;
        }

        final ActivityInfo.WindowLayout windowLayout = info.windowLayout;
        return windowLayout == null
                || tda.supportsActivityMinWidthHeightMultiWindow(windowLayout.minWidth,
                windowLayout.minHeight, info);
    }",0
"private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, Node desc) {
        // NOTE: NamedNodeMap does not have any particular order...
        NamedNodeMap attributes = desc.getAttributes();

        for (Node attr : asIterable(attributes)) {
            if (!XMP.ELEMENTS.contains(attr.getNamespaceURI())) {
                continue;
            }

            List<Entry> dir = subdirs.get(attr.getNamespaceURI());

            if (dir == null) {
                dir = new ArrayList<>();
                subdirs.put(attr.getNamespaceURI(), dir);
            }

            dir.add(new XMPEntry(attr.getNamespaceURI() + attr.getLocalName(), attr.getLocalName(), attr.getNodeValue()));
        }
    }",1
"@Override
    public void setKeyguardDisabledFeatures(
            ComponentName who, String callerPackageName, int which, boolean parent) {
        if (!mHasFeature) {
            return;
        }

        CallerIdentity caller;
        if (isUnicornFlagEnabled()) {
            caller = getCallerIdentity(who, callerPackageName);
        } else {
            caller = getCallerIdentity(who);
            Objects.requireNonNull(who, ""ComponentName is null"");
        }

        final int userHandle = caller.getUserId();
        int affectedUserId = parent ? getProfileParentId(userHandle) : userHandle;
        synchronized (getLockObject()) {
            if (isUnicornFlagEnabled()) {
                // SUPPORT USES_POLICY_DISABLE_KEYGUARD_FEATURES
                EnforcingAdmin admin = enforcePermissionAndGetEnforcingAdmin(
                        who, MANAGE_DEVICE_POLICY_KEYGUARD, caller.getPackageName(),
                        affectedUserId);
                if (which == 0) {
                    mDevicePolicyEngine.removeLocalPolicy(
                            PolicyDefinition.KEYGUARD_DISABLED_FEATURES, admin, affectedUserId);
                } else {
                    // TODO(b/273723433): revisit silent masking of features
                    if (isManagedProfile(userHandle)) {
                        if (parent) {
                            if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {
                                which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;
                            } else {
                                which = which
                                        & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;
                            }
                        } else {
                            which = which & PROFILE_KEYGUARD_FEATURES;
                        }
                    }
                    mDevicePolicyEngine.setLocalPolicy(PolicyDefinition.KEYGUARD_DISABLED_FEATURES,
                            admin, new IntegerPolicyValue(which), affectedUserId);
                }
                invalidateBinderCaches();
            } else {
                ActiveAdmin ap = getActiveAdminForCallerLocked(
                        who, DeviceAdminInfo.USES_POLICY_DISABLE_KEYGUARD_FEATURES, parent);
                if (isManagedProfile(userHandle)) {
                    if (parent) {
                        if (isProfileOwnerOfOrganizationOwnedDevice(caller)) {
                            which = which & PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;
                        } else {
                            which = which & NON_ORG_OWNED_PROFILE_KEYGUARD_FEATURES_AFFECT_OWNER;
                        }
                    } else {
                        which = which & PROFILE_KEYGUARD_FEATURES;
                    }
                }
                if (ap.disabledKeyguardFeatures != which) {
                    ap.disabledKeyguardFeatures = which;
                    saveSettingsLocked(userHandle);
                }
            }
        }
        if (SecurityLog.isLoggingEnabled()) {
            SecurityLog.writeEvent(SecurityLog.TAG_KEYGUARD_DISABLED_FEATURES_SET,
                    caller.getPackageName(), userHandle, affectedUserId, which);
        }
        DevicePolicyEventLogger
                .createEvent(DevicePolicyEnums.SET_KEYGUARD_DISABLED_FEATURES)
                .setAdmin(caller.getPackageName())
                .setInt(which)
                .setStrings(parent ? CALLED_FROM_PARENT : NOT_CALLED_FROM_PARENT)
                .write();
    }",0
"@Override
    @SuppressWarnings({""PMD.AvoidCatchingThrowable"", ""PMD.AvoidInstanceofChecksInCatchClause""})
    public void handle(HttpExchange pExchange) throws IOException {
        if (requestHandler == null) {
            throw new IllegalStateException(""Handler not yet started"");
        }

        JSONAware json = null;
        URI uri = pExchange.getRequestURI();
        ParsedUri parsedUri = new ParsedUri(uri,context);
        try {
            // Check access policy
            InetSocketAddress address = pExchange.getRemoteAddress();
            requestHandler.checkAccess(address.getHostName(), address.getAddress().getHostAddress(),
                                       extractOriginOrReferer(pExchange));
            String method = pExchange.getRequestMethod();

            // Dispatch for the proper HTTP request method
            if (""GET"".equalsIgnoreCase(method)) {
                setHeaders(pExchange);
                json = executeGetRequest(parsedUri);
            } else if (""POST"".equalsIgnoreCase(method)) {
                setHeaders(pExchange);
                json = executePostRequest(pExchange, parsedUri);
            } else if (""OPTIONS"".equalsIgnoreCase(method)) {
                performCorsPreflightCheck(pExchange);
            } else {
                throw new IllegalArgumentException(""HTTP Method "" + method + "" is not supported."");
            }
        } catch (Throwable exp) {
            json = requestHandler.handleThrowable(
                    exp instanceof RuntimeMBeanException ? ((RuntimeMBeanException) exp).getTargetException() : exp);
        } finally {
            sendResponse(pExchange,parsedUri,json);
        }
    }",1
"public static void appendEscapedSQLString(StringBuilder sb, String sqlString) {
        sb.append('\'');
        int length = sqlString.length();
        for (int i = 0; i < length; i++) {
            char c = sqlString.charAt(i);
            if (Character.isHighSurrogate(c)) {
                if (i == length - 1) {
                    continue;
                }
                if (Character.isLowSurrogate(sqlString.charAt(i + 1))) {
                    // add them both
                    sb.append(c);
                    sb.append(sqlString.charAt(i + 1));
                    continue;
                } else {
                    // this is a lone surrogate, skip it
                    continue;
                }
            }
            if (Character.isLowSurrogate(c)) {
                continue;
            }
            if (c == '\'') {
                sb.append('\'');
            }
            sb.append(c);
        }
        sb.append('\'');
    }",1
"@Override
    public void setLongSupportMessage(@NonNull ComponentName who, CharSequence message) {
        if (!mHasFeature) {
            return;
        }

        message = truncateIfLonger(message, MAX_LONG_SUPPORT_MESSAGE_LENGTH);

        Objects.requireNonNull(who, ""ComponentName is null"");
        final CallerIdentity caller = getCallerIdentity(who);
        synchronized (getLockObject()) {
            ActiveAdmin admin = getActiveAdminForUidLocked(who, caller.getUid());
            if (!TextUtils.equals(admin.longSupportMessage, message)) {
                admin.longSupportMessage = message;
                saveSettingsLocked(caller.getUserId());
            }
        }
        DevicePolicyEventLogger
                .createEvent(DevicePolicyEnums.SET_LONG_SUPPORT_MESSAGE)
                .setAdmin(who)
                .write();
    }",1
"private void cancelNotificationFromListenerLocked(ManagedServiceInfo info,
                int callingUid, int callingPid, String pkg, String tag, int id, int userId) {
            cancelNotification(callingUid, callingPid, pkg, tag, id, 0,
                    Notification.FLAG_ONGOING_EVENT | Notification.FLAG_FOREGROUND_SERVICE,
                    true,
                    userId, REASON_LISTENER_CANCEL, info);
        }",0
"public Map<String, Object> loadExport(Owner owner, File exportFile,
        ConflictOverrides overrides)
        throws ImporterException {
        File tmpDir = null;
        InputStream exportStream = null;
        Map<String, Object> result = new HashMap<String, Object>();
        try {
            tmpDir = new SyncUtils(config).makeTempDir(""import"");
            extractArchive(tmpDir, exportFile);

            File signature = new File(tmpDir, ""signature"");
            if (signature.length() == 0) {
                throw new ImportExtractionException(i18n.tr(""The archive does not "" +
                                          ""contain the required signature file""));
            }

            exportStream = new FileInputStream(new File(tmpDir, ""consumer_export.zip""));
            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(
                exportStream,
                loadSignature(new File(tmpDir, ""signature"")));
            if (!verifiedSignature) {
                log.warn(""Archive signature check failed."");
                if (!overrides
                    .isForced(Conflict.SIGNATURE_CONFLICT)) {

                    /*
                     * Normally for import conflicts that can be overridden, we try to
                     * report them all the first time so if the user intends to override,
                     * they can do so with just one more request. However in the case of
                     * a bad signature, we're going to report immediately due to the nature
                     * of what this might mean.
                     */
                    throw new ImportConflictException(
                        i18n.tr(""Archive failed signature check""),
                        Conflict.SIGNATURE_CONFLICT);
                }
                else {
                    log.warn(""Ignoring signature check failure."");
                }
            }

            File consumerExport = new File(tmpDir, ""consumer_export.zip"");
            File exportDir = extractArchive(tmpDir, consumerExport);

            Map<String, File> importFiles = new HashMap<String, File>();
            File[] listFiles = exportDir.listFiles();
            if (listFiles == null || listFiles.length == 0) {
                throw new ImportExtractionException(i18n.tr(""The consumer_export "" +
                    ""archive has no contents""));
            }
            for (File file : listFiles) {
                importFiles.put(file.getName(), file);
            }

            ConsumerDto consumer = importObjects(owner, importFiles, overrides);
            Meta m = mapper.readValue(importFiles.get(ImportFile.META.fileName()),
                Meta.class);
            result.put(""consumer"", consumer);
            result.put(""meta"", m);
            return result;
        }
        catch (FileNotFoundException fnfe) {
            log.error(""Archive file does not contain consumer_export.zip"", fnfe);
            throw new ImportExtractionException(i18n.tr(""The archive does not contain "" +
                                           ""the required consumer_export.zip file""));
        }
        catch (ConstraintViolationException cve) {
            log.error(""Failed to import archive"", cve);
            throw new ImporterException(i18n.tr(""Failed to import archive""),
                cve);
        }
        catch (PersistenceException pe) {
            log.error(""Failed to import archive"", pe);
            throw new ImporterException(i18n.tr(""Failed to import archive""),
                pe);
        }
        catch (IOException e) {
            log.error(""Exception caught importing archive"", e);
            throw new ImportExtractionException(""unable to extract export archive"", e);
        }
        catch (CertificateException e) {
            log.error(""Certificate exception checking archive signature"", e);
            throw new ImportExtractionException(
                ""Certificate exception checking archive signature"", e);
        }
        finally {
            if (tmpDir != null) {
                try {
                    FileUtils.deleteDirectory(tmpDir);
                }
                catch (IOException e) {
                    log.error(""Failed to delete extracted export"", e);
                }
            }
            if (exportStream != null) {
                try {
                    exportStream.close();
                }
                catch (Exception e) {
                    // nothing we can do.
                }
            }
        }
    }",1
"public void addSynchronously(MediaPackage mediaPackage)
      throws SearchException, IllegalArgumentException, UnauthorizedException, NotFoundException,
      SearchServiceDatabaseException {
    if (mediaPackage == null) {
      throw new IllegalArgumentException(""Unable to add a null mediapackage"");
    }
    final String mediaPackageId = mediaPackage.getIdentifier().toString();
    logger.debug(""Attempting to add media package {} to search index"", mediaPackageId);
    AccessControlList acl = authorizationService.getActiveAcl(mediaPackage).getA();

    AccessControlList seriesAcl = persistence.getAccessControlLists(mediaPackage.getSeries(), mediaPackageId).stream()
        .reduce(new AccessControlList(acl.getEntries()), AccessControlList::mergeActions);
    logger.debug(""Updating series with merged access control list: {}"", seriesAcl);

    Date now = new Date();

    try {
      if (indexManager.add(mediaPackage, acl, seriesAcl, now)) {
        logger.info(""Added media package `{}` to the search index, using ACL `{}`"", mediaPackageId, acl);
      } else {
        logger.warn(""Failed to add media package {} to the search index"", mediaPackageId);
      }
    } catch (SolrServerException e) {
      throw new SearchException(e);
    }

    try {
      persistence.storeMediaPackage(mediaPackage, acl, now);
    } catch (SearchServiceDatabaseException e) {
      throw new SearchException(
          String.format(""Could not store media package to search database %s"", mediaPackageId), e);
    }
  }",1
"@Override
    public BigInteger bigIntegerValue() {
        BigDecimal bd = bigDecimalValue();
        if (Math.abs(bd.scale()) <= bigIntegerScaleLimit) {
            return bd.toBigInteger();
        }
        throw new UnsupportedOperationException(
                String.format(SCALE_LIMIT_EXCEPTION_MESSAGE, bd.scale(), bigIntegerScaleLimit));
    }",1
"private boolean isInProgressMarkerFile(File file) {
        return hasExtension(file, IN_PROGRESS_MARKER_FILE_SUFFIX);
    }",0
"public boolean importWiki(File file, String filename, File targetDirectory) {
		try {
			Path path = FileResource.getResource(file, filename);
			if(path == null) {
				return false;
			}
			
			Path destDir = targetDirectory.toPath();
			Files.walkFileTree(path, EnumSet.noneOf(FileVisitOption.class), 16, new ImportVisitor(destDir));
			PathUtils.closeSubsequentFS(path);
			return true;
		} catch (IOException e) {
			log.error("""", e);
			return false;
		}
	}",1
"public NioParams getNioParams() {
        return nioParams;
    }",0
"public boolean print() {
        assert mNativeTabAndroid != 0;
        return nativePrint(mNativeTabAndroid);
    }",0
"public void changeRecvCipher(BlockCipher bc, MAC mac)
	{
		tc.changeRecvCipher(bc, mac);
		if (km.isStrictKex())
			tc.resetReceiveSequenceNumber();
	}",1
"void updateTapExcludeRegion(Region region) {
        final DisplayContent currentDisplay = getDisplayContent();
        if (currentDisplay == null) {
            throw new IllegalStateException(""Trying to update window not attached to any display."");
        }

        // Clear the tap excluded region if the region passed in is null or empty.
        if (region == null || region.isEmpty()) {
            mTapExcludeRegion.setEmpty();
            // Remove this window from mTapExcludeProvidingWindows since it won't be providing
            // tap exclude regions.
            currentDisplay.mTapExcludeProvidingWindows.remove(this);
        } else {
            mTapExcludeRegion.set(region);
            // Make sure that this window is registered as one that provides a tap exclude region
            // for its containing display.
            currentDisplay.mTapExcludeProvidingWindows.add(this);
        }

        // Trigger touch exclude region update on current display.
        currentDisplay.updateTouchExcludeRegion();
        // Trigger touchable region update for this window.
        currentDisplay.getInputMonitor().updateInputWindowsLw(true /* force */);
    }",0
"private String ms2ZentaoDescription(String msDescription) {
        String imgUrlRegex = ""!\\[.*?]\\(/resource/md/get(.*?\\..*?)\\)"";
        String zentaoSteps = msDescription.replaceAll(imgUrlRegex, zentaoClient.requestUrl.getReplaceImgUrl());
        Matcher matcher = zentaoClient.requestUrl.getImgPattern().matcher(zentaoSteps);
        while (matcher.find()) {
            // get file name
            String originSubUrl = matcher.group(1);
            if (originSubUrl.contains(""/url?url="") || originSubUrl.contains(""/path?"")) {
                String path = URLDecoder.decode(originSubUrl, StandardCharsets.UTF_8);
                String fileName;
                if (path.indexOf(""fileID"") > 0) {
                    fileName = path.substring(path.indexOf(""fileID"") + 7);
                } else {
                    fileName = path.substring(path.indexOf(""file-read-"") + 10);
                }
                zentaoSteps = zentaoSteps.replaceAll(Pattern.quote(originSubUrl), fileName);
            } else {
                String fileName = originSubUrl.substring(10);
                // get file
                ResponseEntity<FileSystemResource> mdImage = resourceService.getMdImage(fileName);
                // upload zentao
                String id = uploadFile(mdImage.getBody());
                // todo delete local file
                int index = fileName.lastIndexOf(""."");
                String suffix = """";
                if (index != -1) {
                    suffix = fileName.substring(index);
                }
                // replace id
                zentaoSteps = zentaoSteps.replaceAll(Pattern.quote(originSubUrl), id + suffix);
            }
        }
        // image link
        String netImgRegex = ""!\\[(.*?)]\\((http.*?)\\)"";
        return zentaoSteps.replaceAll(netImgRegex, ""<img src=\""$2\"" alt=\""$1\""/>"");
    }",1
"public void unmuteConversation(final Conversation conversation) {
        conversation.setMutedTill(0);
        this.activity.xmppConnectionService.updateConversation(conversation);
        this.activity.onConversationsListItemUpdated();
        refresh();
        getActivity().invalidateOptionsMenu();
    }",0
"public Path getEditorTreeModelPath() {
			return editorTreeModelPath;
		}",0
"private static boolean isAbleToLogin(String username, String password, String serverURL,
	                                     String tenantDomain) throws APIManagementException {

		boolean loginStatus = false;
		//String serverURL = config.getFirstProperty(APIConstants.AUTH_MANAGER_URL);
		if (serverURL == null) {
			handleException(""API key manager URL unspecified"");
		}

		try {
			AuthenticationAdminStub authAdminStub =
					new AuthenticationAdminStub(null, serverURL + ""AuthenticationAdmin"");
			//String tenantDomain = MultitenantUtils.getTenantDomain(username);
			//update permission cache before validate user
			int tenantId = ServiceReferenceHolder.getInstance().getRealmService().getTenantManager()
			                                     .getTenantId(tenantDomain);
			PermissionUpdateUtil.updatePermissionTree(tenantId);
			String host = new URL(serverURL).getHost();
			if (authAdminStub.login(username, password, host)) {
				loginStatus = true;
			}
		} catch (AxisFault axisFault) {
			log.error(""Error while checking the ability to login"", axisFault );
		} catch (org.wso2.carbon.user.api.UserStoreException e) {
			log.error(""Error while checking the ability to login"", e );
		} catch (MalformedURLException e) {
			log.error(""Error while checking the ability to login"", e);
		} catch (RemoteException e) {
			log.error(""Error while checking the ability to login"", e);
		} catch (LoginAuthenticationExceptionException e) {
			log.error(""Error while checking the ability to login"", e );
		}
		return loginStatus;
	}",0
"@Override
    public boolean isUsbDataSignalingEnabled(String packageName) {
        final CallerIdentity caller = getCallerIdentity(packageName);
        synchronized (getLockObject()) {
            // If the caller is an admin, return the policy set by itself. Otherwise
            // return the device-wide policy.
            if (isDefaultDeviceOwner(caller) || isProfileOwnerOfOrganizationOwnedDevice(caller)) {
                return getProfileOwnerOrDeviceOwnerLocked(
                        caller.getUserId()).mUsbDataSignalingEnabled;
            } else {
                return isUsbDataSignalingEnabledInternalLocked();
            }
        }
    }",0
"@VisibleForTesting
        @Nullable
        public static Integer getFullLengthSpanColor(CharSequence charSequence) {
            // NOTE: this method preserves the functionality that for a CharSequence with multiple
            // full-length spans, the color of the last one is used.
            Integer result = null;
            if (charSequence instanceof Spanned) {
                Spanned ss = (Spanned) charSequence;
                Object[] spans = ss.getSpans(0, ss.length(), Object.class);
                // First read through all full-length spans to get the button fill color, which will
                //  be used as the background color for ensuring contrast of non-full-length spans.
                for (Object span : spans) {
                    int spanStart = ss.getSpanStart(span);
                    int spanEnd = ss.getSpanEnd(span);
                    boolean fullLength = (spanEnd - spanStart) == charSequence.length();
                    if (!fullLength) {
                        continue;
                    }
                    if (span instanceof TextAppearanceSpan) {
                        TextAppearanceSpan originalSpan = (TextAppearanceSpan) span;
                        ColorStateList textColor = originalSpan.getTextColor();
                        if (textColor != null) {
                            result = textColor.getDefaultColor();
                        }
                    } else if (span instanceof ForegroundColorSpan) {
                        ForegroundColorSpan originalSpan = (ForegroundColorSpan) span;
                        result = originalSpan.getForegroundColor();
                    }
                }
            }
            return result;
        }",0
"private void purgeUserData(int userId) {
        UserAccounts accounts;
        synchronized (mUsers) {
            accounts = mUsers.get(userId);
            mUsers.remove(userId);
            mLocalUnlockedUsers.delete(userId);
            AccountManager.invalidateLocalAccountsDataCaches();
        }
        if (accounts != null) {
            synchronized (accounts.dbLock) {
                synchronized (accounts.cacheLock) {
                    accounts.accountsDb.closeDebugStatement();
                    accounts.accountsDb.close();
                }
            }
        }
    }",0
"private final void handleAppDiedLocked(ProcessRecord app,
            boolean restarting, boolean allowRestart) {
        int pid = app.pid;
        boolean kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1,
                false /*replacingPid*/);
        if (!kept && !restarting) {
            removeLruProcessLocked(app);
            if (pid > 0) {
                ProcessList.remove(pid);
            }
        }

        if (mProfileProc == app) {
            clearProfilerLocked();
        }

        // Remove this application's activities from active lists.
        boolean hasVisibleActivities = mStackSupervisor.handleAppDiedLocked(app);

        app.activities.clear();

        if (app.instrumentationClass != null) {
            Slog.w(TAG, ""Crash of app "" + app.processName
                  + "" running instrumentation "" + app.instrumentationClass);
            Bundle info = new Bundle();
            info.putString(""shortMsg"", ""Process crashed."");
            finishInstrumentationLocked(app, Activity.RESULT_CANCELED, info);
        }

        if (!restarting && hasVisibleActivities
                && !mStackSupervisor.resumeFocusedStackTopActivityLocked()) {
            // If there was nothing to resume, and we are not already restarting this process, but
            // there is a visible activity that is hosted by the process...  then make sure all
            // visible activities are running, taking care of restarting this process.
            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
        }
    }",1
"public void registerConverter(SingleValueConverter converter, int priority) {
        if (converterRegistry != null) {
            converterRegistry.registerConverter(new SingleValueConverterWrapper(converter), priority);
        }
    }",0
"@Override
    public ComponentName getDeviceOwnerComponent(boolean callingUserOnly) {
        if (!mHasFeature) {
            return null;
        }
        if (!callingUserOnly) {
            Preconditions.checkCallAuthorization(canManageUsers(getCallerIdentity())
                    || hasCallingOrSelfPermission(MANAGE_PROFILE_AND_DEVICE_OWNERS));
        }
        synchronized (getLockObject()) {
            if (!mOwners.hasDeviceOwner()) {
                return null;
            }
            if (callingUserOnly && mInjector.userHandleGetCallingUserId() !=
                    mOwners.getDeviceOwnerUserId()) {
                return null;
            }
            return mOwners.getDeviceOwnerComponent();
        }
    }",0
"private boolean isOpenQsEvent(MotionEvent event) {
        final int pointerCount = event.getPointerCount();
        final int action = event.getActionMasked();

        final boolean twoFingerDrag = action == MotionEvent.ACTION_POINTER_DOWN
                && pointerCount == 2;

        final boolean stylusButtonClickDrag = action == MotionEvent.ACTION_DOWN
                && (event.isButtonPressed(MotionEvent.BUTTON_STYLUS_PRIMARY)
                        || event.isButtonPressed(MotionEvent.BUTTON_STYLUS_SECONDARY));

        final boolean mouseButtonClickDrag = action == MotionEvent.ACTION_DOWN
                && (event.isButtonPressed(MotionEvent.BUTTON_SECONDARY)
                        || event.isButtonPressed(MotionEvent.BUTTON_TERTIARY));

        return twoFingerDrag || stylusButtonClickDrag || mouseButtonClickDrag;
    }",0
"public static boolean isValidCompressedBuffer(byte[] input, int offset, int length)
            throws IOException
    {
        if (input == null) {
            throw new NullPointerException(""input is null"");
        }
        return impl.isValidCompressedBuffer(input, offset, length);
    }",0
"@Override
            public void onCommand(Object o) {
                serviceLock.readLock().lock();
                try {
                    if (!(o instanceof Command)) {
                        throw new RuntimeException(""Protocol violation - Command corrupted: "" + o.toString());
                    }
                    Command command = (Command) o;
                    if (!brokerService.isStopping()) {
                        Response response = service(command);
                        if (response != null && !brokerService.isStopping()) {
                            dispatchSync(response);
                        }
                    } else {
                        throw new BrokerStoppedException(""Broker "" + brokerService + "" is being stopped"");
                    }
                } finally {
                    serviceLock.readLock().unlock();
                }
            }",0
"int getResult() {
                return mResult;
            }",0
"@RequiresPermissions(""comment:list"")
    @GetMapping(""/list"")
    public String list(@RequestParam(defaultValue = ""1"") Integer pageNo, String startDate, String endDate, String username, Model model) {
        if (username != null) username = username.replace(""\"""", """").replace(""'"", """");
//        startDate= SecurityUtil.sanitizeInput(startDate);
//        endDate= SecurityUtil.sanitizeInput(endDate);
//        username=SecurityUtil.sanitizeInput(username);
        if (StringUtils.isEmpty(startDate)) startDate = null;
        if (StringUtils.isEmpty(endDate)) endDate = null;
        if (StringUtils.isEmpty(username)) username = null;
        MyPage<Map<String, Object>> page = commentService.selectAllForAdmin(pageNo, startDate, endDate, username);
        model.addAttribute(""page"", page);
        model.addAttribute(""startDate"", startDate);
        model.addAttribute(""endDate"", endDate);
        model.addAttribute(""username"", username);
        return ""admin/comment/list"";
    }",1
"public void updateStackScrollerState(boolean goingToFullShade, boolean fromShadeLocked) {
        if (mStackScroller == null) return;
        boolean onKeyguard = mState == StatusBarState.KEYGUARD;
        boolean publicMode = isAnyProfilePublicMode();
        mStackScroller.setHideSensitive(publicMode, goingToFullShade);
        mStackScroller.setDimmed(onKeyguard, fromShadeLocked /* animate */);
        mStackScroller.setExpandingEnabled(!onKeyguard);
        ActivatableNotificationView activatedChild = mStackScroller.getActivatedChild();
        mStackScroller.setActivatedChild(null);
        if (activatedChild != null) {
            activatedChild.makeInactive(false /* animate */);
        }
    }",0
"@RequestMapping(""/module/htmlformentry/htmlFormFromFile.form"")
	public void handleRequest(Model model, @RequestParam(value = ""filePath"", required = false) String filePath,
	        @RequestParam(value = ""patientId"", required = false) Integer pId,
	        @RequestParam(value = ""isFileUpload"", required = false) boolean isFileUpload, HttpServletRequest request)
	        throws Exception {
		
		Context.requirePrivilege(""Manage Forms"");
		
		if (log.isDebugEnabled())
			log.debug(""In reference data..."");
		
		model.addAttribute(""previewHtml"", """");
		String message;
		File f = null;
		try {
			if (isFileUpload) {
				MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;
				MultipartFile multipartFile = multipartRequest.getFile(""htmlFormFile"");
				if (multipartFile != null) {
					// use an unpredictable file name
					f = File.createTempFile(TEMP_HTML_FORM_FILE_PREFIX, "".tmp"");
					f.deleteOnExit();
					
					filePath = f.getAbsolutePath();
					FileOutputStream fileOut = new FileOutputStream(f);
					IOUtils.copy(multipartFile.getInputStream(), fileOut);
					fileOut.close();
				}
			} else {
				if (StringUtils.hasText(filePath)) {
					f = new File(filePath);
					// prevent reading  a file via an absolute path or path traversal
					if (f.isAbsolute() || !FilenameUtils.normalize(filePath).equals(filePath)) {
						f = null;
					}
				}
			}
			
			if (f != null && f.exists() && f.canRead()) {
				model.addAttribute(""filePath"", filePath);
				
				StringWriter writer = new StringWriter();
				IOUtils.copy(new FileInputStream(f), writer, ""UTF-8"");
				String xml = writer.toString();
				
				// validate file is actually xml
				HtmlFormEntryUtil.stringToDocument(xml);
				
				Patient p;
				if (pId != null) {
					p = Context.getPatientService().getPatient(pId);
				} else {
					p = HtmlFormEntryUtil.getFakePerson();
				}
				HtmlForm fakeForm = new HtmlForm();
				fakeForm.setXmlData(xml);
				FormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());
				String html = fes.getHtmlToDisplay();
				if (fes.getFieldAccessorJavascript() != null) {
					html += ""<script>"" + fes.getFieldAccessorJavascript() + ""</script>"";
				}
				model.addAttribute(""previewHtml"", html);
				//clear the error message
				message = """";
			} else {
				message = ""Please specify a valid file path or select a valid file."";
			}
		}
		catch (Exception e) {
			log.error(""An error occurred while loading the html."", e);
			message = ""An error occurred while loading the html. "" + e.getMessage();
		}
		
		model.addAttribute(""message"", message);
		model.addAttribute(""isFileUpload"", isFileUpload);
	}",1
"public static Locale findLocale(VaadinSession session,
            VaadinRequest request) {

        if (session == null) {
            session = VaadinSession.getCurrent();
        }
        if (session != null) {
            Locale locale = session.getLocale();
            if (locale != null) {
                return locale;
            }
        }

        if (request == null) {
            request = VaadinService.getCurrentRequest();
        }
        if (request != null) {
            Locale locale = request.getLocale();
            if (locale != null) {
                return locale;
            }
        }

        return Locale.getDefault();
    }",0
"protected void removeFromHttpSession(WrappedSession wrappedSession) {
        wrappedSession.removeAttribute(getSessionAttributeName());

    }",0
"protected final double _parseDoublePrimitive(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        String text;
        switch (p.currentTokenId()) {
        case JsonTokenId.ID_STRING:
            text = p.getText();
            break;
        case JsonTokenId.ID_NUMBER_INT:
            final CoercionAction act = _checkIntToFloatCoercion(p, ctxt, Double.TYPE);
            if (act == CoercionAction.AsNull) {
                return 0.0d;
            }
            if (act == CoercionAction.AsEmpty) {
                return 0.0d;
            }
            // fall through to coerce
        case JsonTokenId.ID_NUMBER_FLOAT:
            return p.getDoubleValue();
        case JsonTokenId.ID_NULL:
            _verifyNullForPrimitive(ctxt);
            return 0.0;
        // 29-Jun-2020, tatu: New! ""Scalar from Object"" (mostly for XML)
        case JsonTokenId.ID_START_OBJECT:
            text = ctxt.extractScalarFromObject(p, this, Double.TYPE);
            break;
        case JsonTokenId.ID_START_ARRAY:
            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
                if (p.nextToken() == JsonToken.START_ARRAY) {
                    return (double) handleNestedArrayForSingle(p, ctxt);
                }
                final double parsed = _parseDoublePrimitive(p, ctxt);
                _verifyEndArrayForSingle(p, ctxt);
                return parsed;
            }
            // fall through
        default:
            return ((Number) ctxt.handleUnexpectedToken(Double.TYPE, p)).doubleValue();
        }

        // 18-Nov-2020, tatu: Special case, Not-a-Numbers as String need to be
        //     considered ""native"" representation as JSON does not allow as numbers,
        //     and hence not bound by coercion rules
        {
            Double nan = this._checkDoubleSpecialValue(text);
            if (nan != null) {
                return nan.doubleValue();
            }
        }

        final CoercionAction act = _checkFromStringCoercion(ctxt, text,
                LogicalType.Integer, Double.TYPE);
        if (act == CoercionAction.AsNull) {
            // 03-May-2021, tatu: Might not be allowed (should we do ""empty"" check?)
            _verifyNullForPrimitive(ctxt);
            return  0.0;
        }
        if (act == CoercionAction.AsEmpty) {
            return  0.0;
        }
        text = text.trim();
        if (_hasTextualNull(text)) {
            _verifyNullForPrimitiveCoercion(ctxt, text);
            return  0.0;
        }
        return _parseDoublePrimitive(p, ctxt, text);
    }",1
"private void initialAuthenticationLayout(View decor, FillResponse response) {
        RemoteViews presentation = Helper.sanitizeRemoteView(
                response.getDialogPresentation());
        if (presentation == null) {
            presentation = Helper.sanitizeRemoteView(response.getPresentation());
        }
        if (presentation == null) {
            throw new RuntimeException(""No presentation for fill dialog authentication"");
        }

        // insert authentication item under autofill_dialog_container
        final ViewGroup container = decor.findViewById(R.id.autofill_dialog_container);
        final RemoteViews.InteractionHandler interceptionHandler = (view, pendingIntent, r) -> {
            if (pendingIntent != null) {
                mCallback.startIntentSender(pendingIntent.getIntentSender());
            }
            return true;
        };
        final View content = presentation.applyWithTheme(
                mContext, (ViewGroup) decor, interceptionHandler, mThemeId);
        container.addView(content);
        container.setVisibility(View.VISIBLE);
        container.setFocusable(true);
        container.setOnClickListener(v -> mCallback.onResponsePicked(response));
        // just single item, set up continue button
        setContinueButton(decor, v -> mCallback.onResponsePicked(response));
    }",1
"@Override
    public boolean havePattern(int userId) throws RemoteException {
        // Do we need a permissions check here?

        return mStorage.hasPattern(userId);
    }",0
"@Override
	public void removeByUuid(String uuid) {
		for (KBTemplate kbTemplate : findByUuid(uuid, QueryUtil.ALL_POS,
				QueryUtil.ALL_POS, null)) {
			remove(kbTemplate);
		}
	}",0
"public void readDescriptor(InputStream stream) throws XarException, IOException
    {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();

        DocumentBuilder dBuilder;
        try {
            // Prevent XXE attack
            dbFactory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
            dBuilder = dbFactory.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            throw new XarException(""Failed to create a new Document builder"", e);
        }

        Document doc;
        try {
            // DocumentBuilder#parse close the passed stream which is not what we want
            doc = dBuilder.parse(new CloseShieldInputStream(stream));
        } catch (SAXException e) {
            throw new XarException(""Failed to parse XML document"", e);
        }

        // Normalize the document
        doc.getDocumentElement().normalize();

        // Read the document
        NodeList children = doc.getChildNodes();
        for (int i = 0; i < children.getLength(); ++i) {
            Node node = children.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element element = (Element) node;
                if (element.getTagName().equals(XarModel.ELEMENT_PACKAGE)) {
                    readDescriptorPackage(element);
                    break;
                }
            }
        }
    }",1
"private String getTableName(String str) {
        String[] arr = str.split(""\\s+(?i)where\\s+"");
        // sys_user , (sys_user), sys_user%20, %60sys_user%60  issues/4393
        String reg = ""\\s+|\\(|\\)|`"";
        return arr[0].replaceAll(reg, """");
    }",1
"public static @CheckForNull <T extends Descriptor> T find(Collection<? extends T> list, String className) {
        for (T d : list) {
            if(d.getClass().getName().equals(className))
                return d;
        }
        // Since we introduced Descriptor.getId(), it is a preferred method of identifying descriptor by a string.
        // To make that migration easier without breaking compatibility, let's also match up with the id.
        for (T d : list) {
            if(d.getId().equals(className))
                return d;
        }
        return null;
    }",1
"boolean securityLogGetLoggingEnabledProperty() {
            return SecurityLog.getLoggingEnabledProperty();
        }",0
"@Test
  public void setFormatParams() throws Exception {
    assertPlotParam(""yformat"", ""%25.2f"");
    assertPlotParam(""y2format"", ""%25.2f"");
    assertPlotParam(""xformat"", ""%25.2f"");
    assertPlotParam(""yformat"", ""%253.0em"");
    assertPlotParam(""yformat"", ""%253.0em%25%25"");
    assertPlotParam(""yformat"", ""%25.2f seconds"");
    assertPlotParam(""yformat"", ""%25.0f ms"");
    assertInvalidPlotParam(""yformat"", ""%252.system(%20"");
    assertInvalidPlotParam(""yformat"", ""%252.%0asystem(%20"");
  }",1
"public void error(SAXParseException e) {
            sb.append(""ERROR: "");
            sb.append(e.getMessage());
            sb.append(""\n"");
        }",0
"@Override
        public int getServerPort() {
            return 80;
        }",0
"private SearchResult lookupUser(String accountName) throws NamingException {
        InitialDirContext context = initContext();

        String searchString = searchFilter.replace("":login"", encodeForLdap(accountName));

        SearchControls searchControls = new SearchControls();
        String[] attributeFilter = {idAttribute, nameAttribute, mailAttribute};
        searchControls.setReturningAttributes(attributeFilter);
        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);

        NamingEnumeration<SearchResult> results = context.search(searchBase, searchString, searchControls);

        SearchResult searchResult = null;
        if (results.hasMoreElements()) {
            searchResult = results.nextElement();
            if (results.hasMoreElements()) {
                LOGGER.warn(""Matched multiple users for the accountName: "" + accountName);
                return null;
            }
        }

        return searchResult;
    }",1
"void logBackupComplete(String packageName) {
        if (packageName.equals(PACKAGE_MANAGER_SENTINEL)) return;

        synchronized (mEverStoredApps) {
            if (!mEverStoredApps.add(packageName)) return;

            RandomAccessFile out = null;
            try {
                out = new RandomAccessFile(mEverStored, ""rws"");
                out.seek(out.length());
                out.writeUTF(packageName);
            } catch (IOException e) {
                Slog.e(TAG, ""Can't log backup of "" + packageName + "" to "" + mEverStored);
            } finally {
                try { if (out != null) out.close(); } catch (IOException e) {}
            }
        }
    }",0
"@Deprecated
        public int getHintScreenTimeout() {
            return mHintScreenTimeout;
        }",0
"private OnmsUser hashPassword(final OnmsUser user) {
        final String password = m_userManager.encryptedPassword(user.getPassword(), true);
        user.setPassword(password);
        user.setPasswordSalted(true);
        return user;
    }",0
"protected queryData queryLastApp(SQLiteDatabase db,
                String app_id, String content_type) {
            if (LOCAL_LOGV) Log.v(LOG_TAG, ""queryLastApp app_id: "" + app_id
                    + "" content_type: "" +  content_type);

            Cursor cur = db.query(APPID_TABLE_NAME,
                    new String[] {""install_order"", ""package_name"", ""class_name"",
                    ""app_type"", ""need_signature"", ""further_processing""},
                    ""x_wap_application=? and content_type=?"",
                    new String[] {app_id, content_type},
                    null /* groupBy */,
                    null /* having */,
                    ""install_order desc"" /* orderBy */);

            queryData ret = null;

            if (cur.moveToNext()) {
                ret = new queryData();
                ret.installOrder = cur.getInt(cur.getColumnIndex(""install_order""));
                ret.packageName = cur.getString(cur.getColumnIndex(""package_name""));
                ret.className = cur.getString(cur.getColumnIndex(""class_name""));
                ret.appType = cur.getInt(cur.getColumnIndex(""app_type""));
                ret.needSignature = cur.getInt(cur.getColumnIndex(""need_signature""));
                ret.furtherProcessing = cur.getInt(cur.getColumnIndex(""further_processing""));
            }
            cur.close();
            return ret;
        }",1
"public static void setRequestMethod(HttpsURLConnection conn, RequestMethod method) {
        try {
            conn.setRequestMethod(getRequestMethodAsString(method));
        } catch (ProtocolException e) {
            throw ErrorUtil.createCommandException(e.getMessage());
        }
    }",1
"private void initClassMethod(Class<?> clazz) {
        RequestMapping requestMapping = clazz.getAnnotation(RequestMapping.class);
        for (String classPath : requestMapping.value()) {
            for (Method method : clazz.getMethods()) {
                if (!method.isAnnotationPresent(RequestMapping.class)) {
                    parseSubAnnotations(method, classPath);
                    continue;
                }
                requestMapping = method.getAnnotation(RequestMapping.class);
                RequestMethod[] requestMethods = requestMapping.method();
                if (requestMethods.length == 0) {
                    requestMethods = new RequestMethod[1];
                    requestMethods[0] = RequestMethod.GET;
                }
                for (String methodPath : requestMapping.value()) {
                    String urlKey = requestMethods[0].name() + REQUEST_PATH_SEPARATOR + classPath + methodPath;
                    addUrlAndMethodRelation(urlKey, requestMapping.params(), method);
                }
            }
        }
    }",0
"public void setClosed(boolean closed) {
		this.closed = closed;
	}",0
"private Locale getLocale(EntityReference reference)
        {
            if (reference instanceof AbstractLocalizedEntityReference) {
                return ((AbstractLocalizedEntityReference) reference).getLocale();
            }

            return null;
        }",0
"public boolean isManagedProfile(@NonNull ComponentName admin) {
        throwIfParentInstance(""isManagedProfile"");
        try {
            return mService.isManagedProfile(admin);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }",0
"@Override
	protected void configure() {
		super.configure();
		
		bind(JettyRunner.class).to(DefaultJettyRunner.class);
		bind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);
		
		bind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);
		
		bind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {

			@Override
			public ValidatorFactory get() {
				Configuration<?> configuration = Validation
						.byDefaultProvider()
						.configure()
						.messageInterpolator(new ParameterMessageInterpolator());
				return configuration.buildValidatorFactory();
			}
			
		}).in(Singleton.class);
		
		bind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);

		// configure markdown
		bind(MarkdownManager.class).to(DefaultMarkdownManager.class);		
		
		configurePersistence();
		configureRestServices();
		configureWeb();
		configureBuild();
		
		bind(GitConfig.class).toProvider(GitConfigProvider.class);

		/*
		 * Declare bindings explicitly instead of using ImplementedBy annotation as
		 * HK2 to guice bridge can only search in explicit bindings in Guice   
		 */
		bind(StorageManager.class).to(DefaultStorageManager.class);
		bind(SettingManager.class).to(DefaultSettingManager.class);
		bind(DataManager.class).to(DefaultDataManager.class);
		bind(TaskScheduler.class).to(DefaultTaskScheduler.class);
		bind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);
		bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);
		bind(PullRequestManager.class).to(DefaultPullRequestManager.class);
		bind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);
		bind(ProjectManager.class).to(DefaultProjectManager.class);
		bind(UserManager.class).to(DefaultUserManager.class);
		bind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);
		bind(BuildManager.class).to(DefaultBuildManager.class);
		bind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);
		bind(JobManager.class).to(DefaultJobManager.class);
		bind(LogManager.class).to(DefaultLogManager.class);
		bind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);
		bind(MailManager.class).to(DefaultMailManager.class);
		bind(IssueManager.class).to(DefaultIssueManager.class);
		bind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);
		bind(BuildParamManager.class).to(DefaultBuildParamManager.class);
		bind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);
		bind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);
		bind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);
		bind(RoleManager.class).to(DefaultRoleManager.class);
		bind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);
		bind(UserInfoManager.class).to(DefaultUserInfoManager.class);
		bind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);
		bind(GroupManager.class).to(DefaultGroupManager.class);
		bind(MembershipManager.class).to(DefaultMembershipManager.class);
		bind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);
		bind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);
		bind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);
		bind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);
		bind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);
		bind(WorkExecutor.class).to(DefaultWorkExecutor.class);
		bind(PullRequestNotificationManager.class);
		bind(CommitNotificationManager.class);
		bind(BuildNotificationManager.class);
		bind(IssueNotificationManager.class);
		bind(EntityReferenceManager.class);
		bind(CodeCommentNotificationManager.class);
		bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);
		bind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);
		bind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);
		bind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);
		bind(MilestoneManager.class).to(DefaultMilestoneManager.class);
		bind(Session.class).toProvider(SessionProvider.class);
		bind(EntityManager.class).toProvider(SessionProvider.class);
		bind(SessionFactory.class).toProvider(SessionFactoryProvider.class);
		bind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);
		bind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);
		bind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);
		bind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);
		bind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);
		bind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);
		bind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);
		bind(WebHookManager.class);

		contribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);
	    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);
	    
		bind(Realm.class).to(OneAuthorizingRealm.class);
		bind(RememberMeManager.class).to(OneRememberMeManager.class);
		bind(WebSecurityManager.class).to(OneWebSecurityManager.class);
		bind(FilterChainResolver.class).to(OneFilterChainResolver.class);
		bind(BasicAuthenticationFilter.class);
		bind(PasswordService.class).to(OnePasswordService.class);
		bind(ShiroFilter.class);
		install(new ShiroAopModule());
        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {

            @Override
            public void configure(FilterChainManager filterChainManager) {
                filterChainManager.createChain(""/**/info/refs"", ""noSessionCreation, authcBasic"");
                filterChainManager.createChain(""/**/git-upload-pack"", ""noSessionCreation, authcBasic"");
                filterChainManager.createChain(""/**/git-receive-pack"", ""noSessionCreation, authcBasic"");
            }
            
        });
        contributeFromPackage(Authenticator.class, Authenticator.class);
        
		contribute(ImplementationProvider.class, new ImplementationProvider() {

			@Override
			public Class<?> getAbstractClass() {
				return JobExecutor.class;
			}

			@Override
			public Collection<Class<?>> getImplementations() {
				return Sets.newHashSet(AutoDiscoveredJobExecutor.class);
			}
			
		});
		
		contribute(CodePullAuthorizationSource.class, DefaultJobManager.class);
        
		bind(IndexManager.class).to(DefaultIndexManager.class);
		bind(SearchManager.class).to(DefaultSearchManager.class);
		
		bind(EntityValidator.class).to(DefaultEntityValidator.class);
		
		bind(GitFilter.class);
		bind(GitPreReceiveCallback.class);
		bind(GitPostReceiveCallback.class);
		
	    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {

			@Override
			public ExecutorService get() {
		        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, 
		        		new SynchronousQueue<Runnable>()) {

					@Override
					public void execute(Runnable command) {
						try {
							super.execute(SecurityUtils.inheritSubject(command));
						} catch (RejectedExecutionException e) {
							if (!isShutdown())
								throw ExceptionUtils.unchecked(e);
						}
					}

		        };
			}
	    	
	    }).in(Singleton.class);
	    
	    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {

			@Override
			public ForkJoinTask<?> submit(Runnable task) {
				return super.submit(SecurityUtils.inheritSubject(task));
			}

			@Override
			public void execute(Runnable task) {
				super.execute(SecurityUtils.inheritSubject(task));
			}

			@Override
			public <T> ForkJoinTask<T> submit(Callable<T> task) {
				return super.submit(SecurityUtils.inheritSubject(task));
			}

			@Override
			public <T> ForkJoinTask<T> submit(Runnable task, T result) {
				return super.submit(SecurityUtils.inheritSubject(task), result);
			}

			@Override
			public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
					throws InterruptedException, ExecutionException {
				return super.invokeAny(SecurityUtils.inheritSubject(tasks));
			}

			@Override
			public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
					throws InterruptedException, ExecutionException, TimeoutException {
				return super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);
			}

			@Override
			public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, 
					long timeout, TimeUnit unit) throws InterruptedException {
				return super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);
			}

			@Override
			public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {
				return super.invokeAll(SecurityUtils.inheritSubject(tasks));
			}

	    });
	}",1
"private static boolean hasEditRights(SecurityContext securityContext) {
        if (securityContext.isUserInRole(Authentication.ROLE_ADMIN)) {
            return true;
        } else {
            return false;
        }
    }",1
"public String getEmail()
    {
        XWikiDocument userDoc;
        try {
            userDoc = getXWikiContext().getWiki().getDocument(this.user.getUser(), getXWikiContext());
            BaseObject obj = userDoc.getObject(""XWiki.XWikiUsers"");
            return obj.getStringValue(""email"");
        } catch (Exception e) {
            // APIs should never throw errors, as velocity cannot catch them, and scripts should be
            // as robust as possible. Instead, the code using this should know that null means there
            // was an error, if it really needs to report these exceptions.
            return null;
        }
    }",0
"@Override
    public boolean processLogin(String username, String password, String rememberme, SecurityRequestWrapper request,
        HttpServletResponse response, XWikiContext context) throws Exception
    {
        Principal principal = authenticate(username, password, context);
        AuthenticationFailureManager authenticationFailureManager =
            Utils.getComponent(AuthenticationFailureManager.class);
        if (principal != null && authenticationFailureManager.validateForm(username, request)) {
            // login successful
            if (LOGGER.isInfoEnabled()) {
                LOGGER.info(""User "" + principal.getName() + "" has been logged-in"");
            }

            authenticationFailureManager.resetAuthenticationFailureCounter(username);

            // invalidate old session if the user was already authenticated, and they logged in as a different user
            if (request.getUserPrincipal() != null && !username.equals(request.getRemoteUser())) {
                request.getSession().invalidate();
            }

            // manage persistent login info, if persistent login management is enabled
            if (this.persistentLoginManager != null) {
                // did the user request that their login be persistent?
                if (rememberme != null) {
                    // remember login
                    this.persistentLoginManager.rememberLogin(request, response, username, password);
                } else {
                    // forget login
                    this.persistentLoginManager.forgetLogin(request, response);
                }
            }

            // make sure the Principal contains wiki name information
            if (!StringUtils.contains(principal.getName(), ':')) {
                principal = new SimplePrincipal(context.getWikiId() + "":"" + principal.getName());
            }

            request.setUserPrincipal(principal);

            this.getUserAuthenticatedEventNotifier().notify(principal.getName());

            Boolean bAjax = (Boolean) context.get(""ajax"");
            if ((bAjax == null) || (!bAjax.booleanValue())) {
                // This is the url that the user was initially accessing before being prompted for login.
                String continueToURL = getContinueToURL(request);
                response.sendRedirect(response.encodeRedirectURL(continueToURL));
            }
        } else {
            // login failed
            // set response status and forward to error page
            if (LOGGER.isInfoEnabled()) {
                LOGGER.info(""User "" + username + "" login has failed"");
            }

            authenticationFailureManager.recordAuthenticationFailure(username, request);

            String returnCode = context.getWiki().Param(""xwiki.authentication.unauthorized_code"");
            int rCode = HttpServletResponse.SC_UNAUTHORIZED;
            if ((returnCode != null) && (!returnCode.equals(""""))) {
                try {
                    rCode = Integer.parseInt(returnCode);
                } catch (Exception e) {
                    rCode = HttpServletResponse.SC_UNAUTHORIZED;
                }
            }
            response.setStatus(rCode); // TODO: Does this work? (200 in case of error)
        }

        return true;
    }",1
"public TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,
			Map<String, TValue> named) throws EaterException, EaterExceptionLocated {
		// ::comment when __CORE__
		final String path = values.get(0).toString();
		return TValue.fromBoolean(new SFile(path).exists());
		// ::done

		// ::uncomment when __CORE__
		// return TValue.fromBoolean(false);
		// ::done
	}",1
"private void reset() {
            aad = null;
            final int lastBufSize = lastGlobalMessageSize;
            if (buf == null) {
                buf = new byte[lastBufSize];
            } else if (bufCount > 0 && bufCount != lastBufSize) {
                lastGlobalMessageSize = bufCount;
                if (buf.length != bufCount) {
                    buf = new byte[bufCount];
                }
            }
            bufCount = 0;
        }",1
"public static String determineReturnLabel(String returnLabel, Patient patient, UiUtils ui) {
		
		if (org.apache.commons.lang.StringUtils.isNotBlank(returnLabel)) {
			return ui.message(returnLabel);
		} else {
			return ui.encodeJavaScript(ui.format(patient));
		}
		
	}",1
"public boolean isAssistDataAllowedOnCurrentActivity() throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        mRemote.transact(IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION, data, reply, 0);
        reply.readException();
        boolean res = reply.readInt() != 0;
        data.recycle();
        reply.recycle();
        return res;
    }",0
"public void updateNClob(@Positive int columnIndex, @Nullable Reader reader) throws SQLException {
    throw org.postgresql.Driver.notImplemented(this.getClass(), ""updateNClob(int, Reader)"");
  }",0
"@SuppressWarnings(""unchecked"")
  protected final Object readResolve() throws ObjectStreamException {
    /* Second run */
    if (this.userBean != null && this.userBeanBytes.length == 0) {
      return this.userBean;
    }

    SerialFilterChecker.check();

    /* First run */
    try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(this.userBeanBytes))) {
      this.userBean = in.readObject();
      this.unloadedProperties = (Map<String, ResultLoaderMap.LoadPair>) in.readObject();
      this.objectFactory = (ObjectFactory) in.readObject();
      this.constructorArgTypes = (Class<?>[]) in.readObject();
      this.constructorArgs = (Object[]) in.readObject();
    } catch (final IOException ex) {
      throw (ObjectStreamException) new StreamCorruptedException().initCause(ex);
    } catch (final ClassNotFoundException ex) {
      throw (ObjectStreamException) new InvalidClassException(ex.getLocalizedMessage()).initCause(ex);
    }

    final Map<String, ResultLoaderMap.LoadPair> arrayProps = new HashMap<>(this.unloadedProperties);
    final List<Class<?>> arrayTypes = Arrays.asList(this.constructorArgTypes);
    final List<Object> arrayValues = Arrays.asList(this.constructorArgs);

    return this.createDeserializationProxy(userBean, arrayProps, objectFactory, arrayTypes, arrayValues);
  }",1
"private void setNativeController(final boolean nativeController) {
            if (nativeController != this.nativeController) {
                this.nativeController = nativeController;
                if (nativeVideo != null) {
                    Activity activity = getActivity();
                    if (activity != null) {
                        activity.runOnUiThread(new Runnable() {

                            @Override
                            public void run() {
                                if (nativeVideo != null) {
                                    MediaController mc = new AndroidImplementation.CN1MediaController();
                                    nativeVideo.setMediaController(mc);
                                    if (!nativeController) mc.setVisibility(View.GONE);
                                    else mc.setVisibility(View.VISIBLE);

                                }
                            }

                        });
                    }

                }
            }
        }",0
"@Override
    public boolean serveStaticResource(HttpServletRequest request,
            HttpServletResponse response) throws IOException {

        String filenameWithPath = getRequestFilename(request);
        if (HandlerHelper.isPathUnsafe(filenameWithPath)) {
            getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,
                    filenameWithPath);
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return true;
        }

        URL resourceUrl = null;
        if (isAllowedVAADINBuildUrl(filenameWithPath)) {
            resourceUrl = servletService.getClassLoader()
                    .getResource(""META-INF"" + filenameWithPath);
        }
        if (resourceUrl == null) {
            resourceUrl = servletService.getStaticResource(filenameWithPath);
        }
        if (resourceUrl == null && shouldFixIncorrectWebjarPaths()
                && isIncorrectWebjarPath(filenameWithPath)) {
            // Flow issue #4601
            resourceUrl = servletService.getStaticResource(
                    fixIncorrectWebjarPath(filenameWithPath));
        }

        if (resourceUrl == null) {
            // Not found in webcontent or in META-INF/resources in some JAR
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return true;
        }

        // There is a resource!

        // Intentionally writing cache headers also for 304 responses
        writeCacheHeaders(filenameWithPath, response);

        long timestamp = writeModificationTimestamp(resourceUrl, request,
                response);
        if (browserHasNewestVersion(request, timestamp)) {
            // Browser is up to date, nothing further to do than set the
            // response code
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            return true;
        }
        responseWriter.writeResponseContents(filenameWithPath, resourceUrl,
                request, response);
        return true;
    }",1
"@Override
        public void reject(String callId, Session.Info info) throws RemoteException {
            rejectedCallIds.add(callId);
        }",0
"public XmlGraphMLReader relType(String name) {
        this.defaultRelType = RelationshipType.withName(name);
        return this;
    }",0
"static void setAttribute(TransformerFactory transformerFactory, String attributeName) {
        try {
            transformerFactory.setAttribute(attributeName, """");
        } catch (IllegalArgumentException iae) {
            printWarningAndRethrowEventually(iae, TransformerFactory.class, ""attribute "" + attributeName);
        }
    }",1
"@Override
    public void destroy() {

    }",1
"private void parseCustomHtmlTag(HtmlCleaner htmlCleaner, Map<String, String> plugin, TagNode tag, String tagName) throws IOException {
        if (""plugin"".equals(tagName) && tag.hasAttribute(""name"")) {
            tag.setForeignMarkup(true);
            Map<String, String> tmp = new LinkedHashMap<>(tag.getAttributes());
            tmp.put(""_tmp"", System.currentTimeMillis() + """");
            tag.setAttributes(tmp);
            SimpleHtmlSerializer serializer = new SimpleHtmlSerializer(htmlCleaner.getProperties());
            StringWriter stringWriter = new StringWriter();
            tag.serialize(serializer, stringWriter);
            String content = stringWriter.toString();
            try {
                String url = ""/"" + tag.getAttributeByName(""name"") + ""/"" + tag.getAttributeByName(""view"");
                if (tag.hasAttribute(""param"")) {
                    url += ""?"" + tag.getAttributeByName(""param"");
                }
                CloseResponseHandle handle = PluginHelper.getContext(url, ""GET"", request, false, adminTokenVO);
                byte[] bytes = IOUtil.getByteByInputStream(handle.getT().getEntity().getContent());
                plugin.put(content, new String(bytes, StandardCharsets.UTF_8));
            } catch (Exception e) {
                LOGGER.error("""", e);
            }
        }
    }",0
"@Override
        public boolean equals(@Nullable Object o) {
            if (this == o) {
                return true;
            }

            if (!(o instanceof Map.Entry)) {
                return false;
            }

            final Map.Entry<?, ?> that = (Map.Entry<?, ?>) o;
            final Object thatKey = that.getKey();
            return thatKey instanceof AsciiString &&
                   keyEquals(key, (CharSequence) thatKey) &&
                   Objects.equals(value, that.getValue());
        }",0
"public String getRealAssetPath(String inode) {
        String _inode = inode;
        String path = """";

        String realPath = Config.getStringProperty(""ASSET_REAL_PATH"", null);
        if (UtilMethods.isSet(realPath) && !realPath.endsWith(java.io.File.separator))
            realPath = realPath + java.io.File.separator;

        String assetPath = Config.getStringProperty(""ASSET_PATH"", ""/assets"");
        if (UtilMethods.isSet(assetPath) && !assetPath.endsWith(java.io.File.separator))
            assetPath = assetPath + java.io.File.separator;

        path = ((!UtilMethods.isSet(realPath)) ? assetPath : realPath)
                + _inode.charAt(0) + java.io.File.separator + _inode.charAt(1)
                + java.io.File.separator + _inode+ java.io.File.separator + ""fileAsset"" + java.io.File.separator;

        if (!UtilMethods.isSet(realPath))
            return FileUtil.getRealPath(path);
        else
            return path;

    }",1
"private void printRequestAndResponse(Source sourceResponse, boolean buildResponseDocumentEnvelope,
            boolean buildResponseDocumentBody,
            Document responseDocumentEnvelope, Document responseDocumentBody) {
        try {
            getTransformer().transform(sourceResponse, new StreamResult(System.err));
            if (buildResponseDocumentEnvelope) {
                getTransformer().transform(new DOMSource(responseDocumentEnvelope), new StreamResult(System.err));
            } else if (buildResponseDocumentBody) {
                getTransformer().transform(new DOMSource(responseDocumentEnvelope), new StreamResult(System.err));
                getTransformer().transform(new DOMSource(responseDocumentBody), new StreamResult(System.err));
            }
        } catch (final TransformerException e) {
            logger.severe(e.getMessage());
        }
    }",1
"@Override
    public void onPerform(CommandEvent commandEvent) {

        if (commandEvent.getMember().hasPermission(Permission.ADMINISTRATOR) && commandEvent.getMember().hasPermission(Permission.MANAGE_SERVER)) {

            EmbedBuilder embedBuilder = new EmbedBuilder()
                    .setTitle(""Setup Menu"")
                    .setFooter(commandEvent.getGuild().getName() + "" - "" + Data.ADVERTISEMENT, commandEvent.getGuild().getIconUrl())
                    .setColor(Color.cyan)
                    .setDescription(""Which configuration do you want to check out?"");

            List<SelectOption> optionList = new ArrayList<>();
            optionList.add(SelectOption.of(""Audit-Logging"", ""log""));
            optionList.add(SelectOption.of(""Welcome-channel"", ""welcome""));
            optionList.add(SelectOption.of(""Autorole"", ""autorole""));
            optionList.add(SelectOption.of(""Temporal-Voice"", ""tempvoice""));
            optionList.add(SelectOption.of(""Statistics"", ""statistics""));

            SelectMenu selectMenu = new SelectMenuImpl(""setupActionMenu"", ""Select a configuration Step!"", 1, 1, false, optionList);

            if (commandEvent.isSlashCommand()) {
                commandEvent.getInteractionHook().sendMessageEmbeds(embedBuilder.build())
                        .addActionRow(selectMenu).queue();
            } else {
                commandEvent.getChannel().sendMessageEmbeds(embedBuilder.build())
                        .addActionRow(selectMenu).queue();
            }
        } else {
            Main.getInstance().getCommandManager().sendMessage(""You dont have the Permission for this Command!"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
        }
        Main.getInstance().getCommandManager().deleteMessage(commandEvent.getMessage(), commandEvent.getInteractionHook());
    }",1
"private void registerTranslationBundle(XWikiDocument document) throws TranslationBundleDoesNotExistsException,
        ComponentRepositoryException, AccessDeniedException
    {
        Scope scope = getScope(document);

        if (scope != null && scope != Scope.ON_DEMAND) {
            checkRegistrationAuthorization(document, scope);

            ComponentDescriptor<TranslationBundle> descriptor =
                createComponentDescriptor(document.getDocumentReference());

            ComponentDocumentTranslationBundle bundle = createComponentDocumentBundle(document, descriptor);

            getComponentManager(document, scope, true).registerComponent(descriptor, bundle);
        }
    }",0
"private int readPlaintextData(final ByteBuffer dst) {
        final int sslRead;
        if (dst.isDirect()) {
            final int pos = dst.position();
            final long addr = Buffer.address(dst) + pos;
            final int len = dst.limit() - pos;
            sslRead = SSL.readFromSSL(ssl, addr, len);
            if (sslRead > 0) {
                dst.position(pos + sslRead);
            }
        } else {
            final int pos = dst.position();
            final int limit = dst.limit();
            final int len = Math.min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);
            final ByteBuf buf = alloc.directBuffer(len);
            try {
                final long addr = memoryAddress(buf);

                sslRead = SSL.readFromSSL(ssl, addr, len);
                if (sslRead > 0) {
                    dst.limit(pos + sslRead);
                    buf.getBytes(0, dst);
                    dst.limit(limit);
                }
            } finally {
                buf.release();
            }
        }

        return sslRead;
    }",0
"protected Record checkoutRecord(Cell[] row, ID defaultOwning) {
        Record recordHub = EntityHelper.forNew(rule.getToEntity().getEntityCode(), defaultOwning);

        // 解析数据
        RecordCheckout recordCheckout = new RecordCheckout(rule.getFiledsMapping());
        Record checkout = recordCheckout.checkout(recordHub, row);

        if (recordCheckout.getTraceLogs().isEmpty()) {
            cellTraces = null;
        } else {
            cellTraces = StringUtils.join(recordCheckout.getTraceLogs(), "", "");
        }

        // 检查重复
        if (rule.getRepeatOpt() < ImportRule.REPEAT_OPT_IGNORE) {
            final ID repeat = findRepeatedRecordId(rule.getRepeatFields(), recordHub);

            if (repeat != null && rule.getRepeatOpt() == ImportRule.REPEAT_OPT_SKIP) {
                return null;
            }

            if (repeat != null && rule.getRepeatOpt() == ImportRule.REPEAT_OPT_UPDATE) {
                // 更新
                checkout = EntityHelper.forUpdate(repeat, defaultOwning);
                for (Iterator<String> iter = recordHub.getAvailableFieldIterator(); iter.hasNext(); ) {
                    String field = iter.next();
                    if (MetadataHelper.isCommonsField(field)) continue;

                    checkout.setObjectValue(field, recordHub.getObjectValue(field));
                }
            }
        }

        // Verify new record
        // Throws DataSpecificationException
        if (checkout.getPrimary() == null) {
            new EntityRecordCreator(rule.getToEntity(), JSONUtils.EMPTY_OBJECT, null, Boolean.FALSE)
                    .verify(checkout);
        }

        return checkout;
    }",1
"protected int addFileNames(String[] file) { // This appears to only be used by unit tests
        for (String f : file) {
            addWorkUnit(new WorkUnit(f));
        }
        return size();
    }",1
"@Override
    public byte readByte() throws JMSException {
        return (Byte)this.readPrimitiveType(Byte.class);
    }",0
"@Override
    public void disconnect() {
        disconnect(DisconnectReason.BY_APPLICATION);
    }",0
"private void generateEntries(Block parentBlock, SyndFeed feed, RssMacroParameters parameters)
        throws MacroExecutionException
    {
        int maxElements = parameters.getCount();
        int count = 0;

        for (Object item : feed.getEntries()) {
            ++count;
            if (count > maxElements) {
                break;
            }
            SyndEntry entry = (SyndEntry) item;

            ResourceReference titleResourceReference = new ResourceReference(entry.getLink(), ResourceType.URL);
            Block titleBlock = new LinkBlock(parsePlainText(entry.getTitle()), titleResourceReference, true);
            ParagraphBlock paragraphTitleBlock = new ParagraphBlock(Collections.singletonList(titleBlock));
            paragraphTitleBlock.setParameter(CLASS_ATTRIBUTE, ""rssitemtitle"");
            parentBlock.addChild(paragraphTitleBlock);

            if (parameters.isContent() && entry.getDescription() != null) {
                // We are wrapping the feed entry content in a HTML macro, not considering what the declared content
                // is, because some feed will declare text while they actually contain HTML.
                // See http://stuffthathappens.com/blog/2007/10/29/i-hate-rss/
                // A case where doing this might hurt is if a feed declares ""text"" and has any XML inside it does
                // not want to be interpreted as such, but displayed as is instead. But this certainly is too rare
                // compared to mis-formed feeds that say text while they want to say HTML.
                Block html = new RawBlock(cleanHTML(entry.getDescription().getValue()), Syntax.HTML_5_0);
                parentBlock.addChild(new GroupBlock(Arrays.asList(html), Collections.singletonMap(CLASS_ATTRIBUTE,
                    ""rssitemdescription"")));
            }
        }
    }",1
"private void enforceWriteSettingsPermission(String func) {
        int uid = Binder.getCallingUid();
        if (uid == ROOT_UID) {
            return;
        }

        if (Settings.checkAndNoteWriteSettingsOperation(mContext, uid,
                Settings.getPackageNameForUid(mContext, uid), false)) {
            return;
        }

        String msg = ""Permission Denial: "" + func + "" from pid=""
                + Binder.getCallingPid()
                + "", uid="" + uid
                + "" requires "" + android.Manifest.permission.WRITE_SETTINGS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }",0
"public Map<String, Long> getQueueSizePerType()
    {
        return this.taskManager.getQueueSizePerType(this.wikiDescriptorManager.getCurrentWikiId());
    }",1
"private DomNode getNextElementUpwards(final DomNode startingNode) {
            if (startingNode == DomNode.this) {
                return null;
            }

            DomNode parent = startingNode.getParentNode();
            while (parent != null && parent != DomNode.this) {
                DomNode next = parent.getNextSibling();
                while (next != null && !isAccepted(next)) {
                    next = next.getNextSibling();
                }
                if (next != null) {
                    return next;
                }
                parent = parent.getParentNode();
            }
            return null;
        }",1
"public void setSubscriptionCreationTimeInMillis(long subscriptionCreationTimeInMillis) {
        mSubscriptionCreationTimeInMillis = subscriptionCreationTimeInMillis;
    }",0
"public TMap readMapBegin() throws TException {
    int size = readVarint32();
    byte keyAndValueType = size == 0 ? 0 : readByte();
    byte keyType = getTType((byte) (keyAndValueType >> 4));
    byte valueType = getTType((byte) (keyAndValueType & 0xf));
    if (size > 0) {
      ensureMapHasEnough(size, keyType, valueType);
    }
    return new TMap(keyType, valueType, size);
  }",1
"@VisibleForTesting
  public static boolean isPermitted(
      final Optional<AuthenticationService> authenticationService,
      final Optional<User> optionalUser,
      final JsonRpcMethod jsonRpcMethod) {

    AtomicBoolean foundMatchingPermission = new AtomicBoolean();

    if (authenticationService.isEmpty()) {
      // no auth provider configured thus anything is permitted
      return true;
    }

    if (optionalUser.isPresent()) {
      User user = optionalUser.get();
      for (String perm : jsonRpcMethod.getPermissions()) {
        user.isAuthorized(
            perm,
            (authed) -> {
              if (authed.result()) {
                LOG.trace(
                    ""user {} authorized : {} via permission {}"",
                    user,
                    jsonRpcMethod.getName(),
                    perm);
                foundMatchingPermission.set(true);
              }
            });
        // exit if a matching permission was found, no need to keep checking
        if (foundMatchingPermission.get()) {
          return foundMatchingPermission.get();
        }
      }
    }

    if (!foundMatchingPermission.get()) {
      LOG.trace(""user NOT authorized : {}"", jsonRpcMethod.getName());
    }
    return foundMatchingPermission.get();
  }",1
"boolean checkAuthorityGrants(int callingUid, ProviderInfo cpi, int userId, boolean checkUser) {
        final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.get(callingUid);
        if (perms != null) {
            for (int i=perms.size()-1; i>=0; i--) {
                GrantUri grantUri = perms.keyAt(i);
                if (grantUri.sourceUserId == userId || !checkUser) {
                    if (matchesProvider(grantUri.uri, cpi)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }",0
"@PostMapping(""/save"")
    public ResultDTO<Void> saveAppInfo(@RequestBody ModifyAppInfoRequest req) {

        req.valid();
        AppInfoDO appInfoDO;

        Long id = req.getId();
        if (id == null) {
            appInfoDO = new AppInfoDO();
            appInfoDO.setGmtCreate(new Date());
        }else {
            appInfoDO = appInfoRepository.findById(id).orElseThrow(() -> new IllegalArgumentException(""can't find appInfo by id:"" + id));

            // 对比密码
            if (!Objects.equals(req.getOldPassword(), appInfoDO.getPassword())) {
                throw new PowerJobException(""The password is incorrect."");
            }
        }
        BeanUtils.copyProperties(req, appInfoDO);
        appInfoDO.setGmtModified(new Date());

        appInfoRepository.saveAndFlush(appInfoDO);
        return ResultDTO.success(null);
    }",1
"public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getNodeProperties() {
    	return nodeProperties;
    }",0
"private static void applyUserRestriction(Context context, int userId, String key,
            boolean newValue) {
        if (UserManagerService.DBG) {
            Log.d(TAG, ""Applying user restriction: userId="" + userId
                    + "" key="" + key + "" value="" + newValue);
        }
        // When certain restrictions are cleared, we don't update the system settings,
        // because these settings are changeable on the Settings UI and we don't know the original
        // value -- for example LOCATION_MODE might have been off already when the restriction was
        // set, and in that case even if the restriction is lifted, changing it to ON would be
        // wrong.  So just don't do anything in such a case.  If the user hopes to enable location
        // later, they can do it on the Settings UI.
        // WARNING: Remember that Settings.Global and Settings.Secure are changeable via adb.
        // To prevent this from happening for a given user restriction, you have to add a check to
        // SettingsProvider.isGlobalOrSecureSettingRestrictedForUser.

        final ContentResolver cr = context.getContentResolver();
        final long id = Binder.clearCallingIdentity();
        try {
            switch (key) {
                case UserManager.DISALLOW_CONFIG_WIFI:
                    if (newValue) {
                        android.provider.Settings.Secure.putIntForUser(cr,
                                android.provider.Settings.Global
                                        .WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, 0, userId);
                    }
                    break;
                case UserManager.DISALLOW_DATA_ROAMING:
                    if (newValue) {
                        // DISALLOW_DATA_ROAMING user restriction is set.

                        // Multi sim device.
                        SubscriptionManager subscriptionManager = new SubscriptionManager(context);
                        final List<SubscriptionInfo> subscriptionInfoList =
                            subscriptionManager.getActiveSubscriptionInfoList();
                        if (subscriptionInfoList != null) {
                            for (SubscriptionInfo subInfo : subscriptionInfoList) {
                                android.provider.Settings.Global.putStringForUser(cr,
                                    android.provider.Settings.Global.DATA_ROAMING
                                    + subInfo.getSubscriptionId(), ""0"", userId);
                            }
                        }

                        // Single sim device.
                        android.provider.Settings.Global.putStringForUser(cr,
                            android.provider.Settings.Global.DATA_ROAMING, ""0"", userId);
                    }
                    break;
                case UserManager.DISALLOW_SHARE_LOCATION:
                    if (newValue) {
                        android.provider.Settings.Secure.putIntForUser(cr,
                                android.provider.Settings.Secure.LOCATION_MODE,
                                android.provider.Settings.Secure.LOCATION_MODE_OFF,
                                userId);
                    }
                    break;
                case UserManager.DISALLOW_DEBUGGING_FEATURES:
                    if (newValue) {
                        // Only disable adb if changing for system user, since it is global
                        // TODO: should this be admin user?
                        if (userId == UserHandle.USER_SYSTEM) {
                            android.provider.Settings.Global.putStringForUser(cr,
                                    android.provider.Settings.Global.ADB_ENABLED, ""0"",
                                    userId);
                        }
                    }
                    break;
                case UserManager.ENSURE_VERIFY_APPS:
                    if (newValue) {
                        android.provider.Settings.Global.putStringForUser(
                                context.getContentResolver(),
                                android.provider.Settings.Global.PACKAGE_VERIFIER_ENABLE, ""1"",
                                userId);
                        android.provider.Settings.Global.putStringForUser(
                                context.getContentResolver(),
                                android.provider.Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, ""1"",
                                userId);
                    }
                    break;
                case UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES:
                    if (newValue) {
                        android.provider.Settings.Secure.putIntForUser(cr,
                                android.provider.Settings.Secure.INSTALL_NON_MARKET_APPS, 0,
                                userId);
                    }
                    break;
                case UserManager.DISALLOW_RUN_IN_BACKGROUND:
                    if (newValue) {
                        int currentUser = ActivityManager.getCurrentUser();
                        if (currentUser != userId && userId != UserHandle.USER_SYSTEM) {
                            try {
                                ActivityManagerNative.getDefault().stopUser(userId, false, null);
                            } catch (RemoteException e) {
                                throw e.rethrowAsRuntimeException();
                            }
                        }
                    }
                    break;
                case UserManager.DISALLOW_SAFE_BOOT:
                    // Unlike with the other restrictions, we want to propagate the new value to
                    // the system settings even if it is false. The other restrictions modify
                    // settings which could be manually changed by the user from the Settings app
                    // after the policies enforcing these restrictions have been revoked, so we
                    // leave re-setting of those settings to the user.
                    android.provider.Settings.Global.putInt(
                            context.getContentResolver(),
                            android.provider.Settings.Global.SAFE_BOOT_DISALLOWED,
                            newValue ? 1 : 0);
                    break;
            }
        } finally {
            Binder.restoreCallingIdentity(id);
        }
    }",1
"public static boolean deleteQuietly(File file) {
		return org.apache.commons.io.FileUtils.deleteQuietly(file);
	}",0
"public String check(Method method, HttpServletRequest request) {
        if (request.getUserPrincipal() != null) {
            return verifyAuthenticatedUser(method, request);
        } else {
            return verifyAnonymousUser(method, request);
        }
    }",0
"@Deprecated
            public WearableExtender setInProgressLabel(CharSequence label) {
                mInProgressLabel = label;
                return this;
            }",0
"protected void initDocumentParser() throws ParserConfigurationException  {

        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();

        docBuilderFactory.setNamespaceAware(true);
        docBuilderFactory.setValidating(true);
        
        docBuilderFactory.setAttribute(""http://java.sun.com/xml/jaxp/properties/schemaLanguage"", ""http://www.w3.org/2001/XMLSchema"");
        
        docBuilderFactory.setAttribute(""http://java.sun.com/xml/jaxp/properties/schemaSource"", resolveSchemaSource());
        
        docBuilderFactory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        docBuilderFactory.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false);
        docBuilderFactory.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
        docBuilderFactory.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
        docBuilderFactory.setXIncludeAware(false);
        docBuilderFactory.setExpandEntityReferences(false);

        docBuilder = docBuilderFactory.newDocumentBuilder();
        
        docBuilder.setErrorHandler(this);
        
        NamespaceContext nsContext = new NamespaceContext()
        {
          public String getNamespaceURI(String prefix)
          {
              if (prefix == null)
                  throw new IllegalArgumentException(""Null prefix"");
              if (XMLConstants.XML_NS_PREFIX.equals(prefix))
                  return XMLConstants.XML_NS_URI;
              if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix))
                  return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;
        
              if (""q"".equals(prefix))
                  return QUARTZ_NS;
        
              return XMLConstants.NULL_NS_URI;
          }
        
          public Iterator<?> getPrefixes(String namespaceURI)
          {
              // This method isn't necessary for XPath processing.
              throw new UnsupportedOperationException();
          }
        
          public String getPrefix(String namespaceURI)
          {
              // This method isn't necessary for XPath processing.
              throw new UnsupportedOperationException();
          }
        
        }; 
        
        xpath = XPathFactory.newInstance().newXPath();
        xpath.setNamespaceContext(nsContext);
    }",1
"private void updateInputRestrictedLocked() {
        boolean inputRestricted = isInputRestricted();
        if (mInputRestricted != inputRestricted) {
            mInputRestricted = inputRestricted;
            int size = mKeyguardStateCallbacks.size();
            for (int i = size - 1; i >= 0; i--) {
                final IKeyguardStateCallback callback = mKeyguardStateCallbacks.get(i);
                try {
                    callback.onInputRestrictedStateChanged(inputRestricted);
                } catch (RemoteException e) {
                    Slog.w(TAG, ""Failed to call onDeviceProvisioned"", e);
                    if (e instanceof DeadObjectException) {
                        mKeyguardStateCallbacks.remove(callback);
                    }
                }
            }
        }
    }",0
"public boolean installCaCert(@Nullable ComponentName admin, byte[] certBuffer) {
        throwIfParentInstance(""installCaCert"");
        if (mService != null) {
            try {
                return mService.installCaCert(admin, mContext.getPackageName(), certBuffer);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return false;
    }",0
"public static void specialFilterContentForOnlineReport(String value) {
		String specialXssStr = "" exec |extractvalue|updatexml|geohash|gtid_subset|gtid_subtract| insert | delete | update | drop | chr | mid | master | truncate | char | declare |user()"";
		String[] xssArr = specialXssStr.split(""\\|"");
		if (value == null || """".equals(value)) {
			return;
		}
		// 校验sql注释 不允许有sql注释
		checkSqlAnnotation(value);
		// 统一转为小写
		value = value.toLowerCase();
		//SQL注入检测存在绕过风险 https://gitee.com/jeecg/jeecg-boot/issues/I4NZGE
		//value = value.replaceAll(""/\\*.*\\*/"","" "");

		for (int i = 0; i < xssArr.length; i++) {
			if (value.indexOf(xssArr[i]) > -1 || value.startsWith(xssArr[i].trim())) {
				log.error(""请注意，存在SQL注入关键词---> {}"", xssArr[i]);
				log.error(""请注意，值可能存在SQL注入风险!---> {}"", value);
				throw new RuntimeException(""请注意，值可能存在SQL注入风险!--->"" + value);
			}
		}

		if(Pattern.matches(SHOW_TABLES, value) || Pattern.matches(REGULAR_EXPRE_USER, value)){
			throw new RuntimeException(""请注意，值可能存在SQL注入风险!--->"" + value);
		}
		return;
	}",1
"@Override
    public BigInteger bigIntegerValue() {
        BigDecimal bd = bigDecimalValue();
        if (Math.abs(bd.scale()) <= bigIntegerScaleLimit) {
            return bd.toBigInteger();
        }
        throw new UnsupportedOperationException(
                JsonMessages.NUMBER_SCALE_LIMIT_EXCEPTION(bd.scale(), bigIntegerScaleLimit));
    }",1
"public static String toXMLName(final String name) {
        final StringBuilder builder = new StringBuilder();
        boolean firstWord = true;
        for (int i = 0; i < name.length(); i++) {
            final char c = name.charAt(i);

            if (i == 0) {
                builder.append(Character.toLowerCase(c));
            } else {
                if (firstWord) {
                    if (i + 2 < name.length() && Character.isLowerCase(name.charAt(i + 2))) {
                        firstWord = false;
                    }
                    builder.append(Character.toLowerCase(c));
                } else {
                    builder.append(c);
                }
            }
        }

        return builder.toString();
    }",1
"public static void unzip(String zipFilePath, String targetPath, boolean overwrite) throws IOException {
        ZipFile zipFile = new ZipFile(zipFilePath, ENCODING);
        Enumeration<? extends ZipEntry> entryEnum = zipFile.getEntries();
        if (null != entryEnum) {
            while (entryEnum.hasMoreElements()) {
                ZipEntry zipEntry = entryEnum.nextElement();
                String filePath = zipEntry.getName();
                if (filePath.contains("".."")) {
                    filePath = filePath.replace("".."", Constants.BLANK);
                }
                if (zipEntry.isDirectory()) {
                    File dir = new File(targetPath + File.separator + filePath);
                    dir.mkdirs();
                } else {
                    File targetFile = new File(targetPath + File.separator + filePath);
                    if (!targetFile.exists() || overwrite) {
                        targetFile.getParentFile().mkdirs();
                        try (InputStream inputStream = zipFile.getInputStream(zipEntry);
                                FileOutputStream outputStream = new FileOutputStream(targetFile);
                                FileLock fileLock = outputStream.getChannel().tryLock();) {
                            if (null != fileLock) {
                                StreamUtils.copy(inputStream, outputStream);
                            }
                        }
                    }
                }
            }
        }
        zipFile.close();
    }",1
"@Override
    public Stream<UserSessionModel> loadUserSessionsStream(RealmModel realm, ClientModel client, boolean offline, Integer firstResult, Integer maxResults) {

        String offlineStr = offlineToString(offline);
        TypedQuery<PersistentUserSessionEntity> query;
        StorageId clientStorageId = new StorageId(client.getId());
        if (clientStorageId.isLocal()) {
            query = paginateQuery(
                    em.createNamedQuery(""findUserSessionsByClientId"", PersistentUserSessionEntity.class),
                    firstResult, maxResults);
            query.setParameter(""clientId"", client.getId());
        } else {
            query = paginateQuery(
                    em.createNamedQuery(""findUserSessionsByExternalClientId"", PersistentUserSessionEntity.class),
                    firstResult, maxResults);
            query.setParameter(""clientStorageProvider"", clientStorageId.getProviderId());
            query.setParameter(""externalClientId"", clientStorageId.getExternalId());
        }

        query.setParameter(""offline"", offlineStr);
        query.setParameter(""realmId"", realm.getId());

        return loadUserSessionsWithClientSessions(query, offlineStr, true);
    }",1
"@Transactional
    @Override
    public void delete(Project project) {
    	for (Project child: project.getChildren())
    		delete(child);
    	
    	Usage usage = new Usage();
    	usage.add(settingManager.onDeleteProject(project.getPath()));
    	
		for (LinkSpec link: linkSpecManager.query()) {
			for (IssueQueryUpdater updater: link.getQueryUpdaters())
				usage.add(updater.onDeleteProject(project.getPath()).prefix(""issue setting"").prefix(""administration""));
		}
    	
    	usage.checkInUse(""Project '"" + project.getPath() + ""'"");

    	for (Project fork: project.getForks()) {
    		Collection<Project> descendants = fork.getForkChildren();
    		descendants.add(fork);
    		for (Project descendant: descendants) {
            	Query<?> query = getSession().createQuery(String.format(""update Issue set %s=:fork where %s=:descendant"", 
            			Issue.PROP_NUMBER_SCOPE, Issue.PROP_PROJECT));
            	query.setParameter(""fork"", fork);
            	query.setParameter(""descendant"", descendant);
            	query.executeUpdate();
            	
            	query = getSession().createQuery(String.format(""update Build set %s=:fork where %s=:descendant"", 
            			Build.PROP_NUMBER_SCOPE, Build.PROP_PROJECT));
            	query.setParameter(""fork"", fork);
            	query.setParameter(""descendant"", descendant);
            	query.executeUpdate();
            	
            	query = getSession().createQuery(String.format(""update PullRequest set %s=:fork where %s=:descendant"", 
            			PullRequest.PROP_NUMBER_SCOPE, PullRequest.PROP_TARGET_PROJECT));
            	query.setParameter(""fork"", fork);
            	query.setParameter(""descendant"", descendant);
            	query.executeUpdate();
    		}
    	}
    	
    	Query<?> query = getSession().createQuery(String.format(""update Project set %s=null where %s=:forkedFrom"", 
    			Project.PROP_FORKED_FROM, Project.PROP_FORKED_FROM));
    	query.setParameter(""forkedFrom"", project);
    	query.executeUpdate();

    	query = getSession().createQuery(String.format(""update PullRequest set %s=null where %s=:sourceProject"", 
    			PullRequest.PROP_SOURCE_PROJECT, PullRequest.PROP_SOURCE_PROJECT));
    	query.setParameter(""sourceProject"", project);
    	query.executeUpdate();

    	for (Build build: project.getBuilds()) 
    		buildManager.delete(build);
    	
    	dao.remove(project);
    	
    	synchronized (repositoryCache) {
			Repository repository = repositoryCache.remove(project.getId());
			if (repository != null) 
				repository.close();
		}
    }",0
"@Override
    public void onDestroy() {
        Log_OC.v(TAG, ""Destroying service"");
        mBinder = null;
        mServiceHandler = null;
        mServiceLooper.quit();
        mServiceLooper = null;
        if (mNotificationManager != null) {
            mNotificationManager.cancel(FOREGROUND_SERVICE_ID);
        }
        // remove AccountsUpdatedListener
        AccountManager am = AccountManager.get(getApplicationContext());
        am.removeOnAccountsUpdatedListener(this);
        super.onDestroy();
    }",0
"public String getProjectId(String projectId, Function<Project, String> getProjectKeyFuc) {
        return getProjectKeyFuc.apply(getProject(projectId, getProjectKeyFuc));
    }",0
"@Override
        public String toString() {
            return ""QueryTable{"" +
                    ""name='"" + name + '\'' +
                    "", alias='"" + alias + '\'' +
                    "", fields="" + fields +
                    "", all="" + all +
                    '}';
        }",0
"@Override
    public void configInterceptor(Interceptors interceptors) {
        interceptors.add(new InitDataInterceptor());
        interceptors.add(new MyI18nInterceptor());
        interceptors.add(new BlackListInterceptor());
        interceptors.add(new RouterInterceptor());
    }",0
"public Aluno getAluno(String ra)throws Exception{
		String comSql = ""select * from ACI_Aluno where ra='""+ra.replace(""'"", """")+""'"";
		ResultSet result = this.bancoConec.execConsulta(comSql);
		if(result.first()){
			Aluno aluno = new Aluno(result.getString(""RA""),
					result.getString(""nome""),result.getString(""Email""), result.getString(""telefone"")
					, result.getString(""Endereco""),result.getString(""Responsavel""));
			result.close();
			return aluno;
		}else{
			result.close();
			return null;
		}
	}",1
"protected String createRequestString(String query, int start)
            throws UnsupportedEncodingException {
        String encoded_query = URLEncoder.encode(query, ""utf8"");
        StringBuffer buffer = new StringBuffer();

        buffer.append(""https://www.googleapis.com/customsearch/v1?"");
        buffer.append(""key="").append(API_KEY);
        buffer.append(""&cx="").append(CUSTOM_SEARCH_ENGINE_ID);
        buffer.append(""&q="").append(encoded_query);
        buffer.append(""&alt=atom"");
        buffer.append(""&start="").append(start);

        return buffer.toString();
    }",0
"public int addAppTask(IBinder activityToken, Intent intent,
            ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(activityToken);
        intent.writeToParcel(data, 0);
        description.writeToParcel(data, 0);
        thumbnail.writeToParcel(data, 0);
        mRemote.transact(ADD_APP_TASK_TRANSACTION, data, reply, 0);
        reply.readException();
        int res = reply.readInt();
        data.recycle();
        reply.recycle();
        return res;
    }",0
"public static byte[] shuffle(float[] input) throws IOException {
        if (input.length * 4 < input.length) {
            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, ""input array size is too large: "" + input.length);
        }
        byte[] output = new byte[input.length * 4];
        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);
        assert(numProcessed == input.length * 4);
        return output;
    }",1
"public void setRecentsComponentCallback(RecentsComponent.Callbacks cb) {
        sRecentsComponentCallbacks = cb;
    }",0
"@Override
        protected void engineInitInternal(byte[] encodedKey, AlgorithmParameterSpec params,
                SecureRandom random) throws InvalidKeyException,
                InvalidAlgorithmParameterException {
            byte[] iv;
            final int tagLenBits;
            if (params == null) {
                iv = null;
                tagLenBits = 0;
            } else {
                Class<?> gcmSpecClass;
                try {
                    gcmSpecClass = Class.forName(""javax.crypto.spec.GCMParameterSpec"");
                } catch (ClassNotFoundException e) {
                    gcmSpecClass = null;
                }

                if (gcmSpecClass != null && gcmSpecClass.isAssignableFrom(params.getClass())) {
                    try {
                        Method getTLenMethod = gcmSpecClass.getMethod(""getTLen"");
                        Method getIVMethod = gcmSpecClass.getMethod(""getIV"");
                        tagLenBits = (int) getTLenMethod.invoke(params);
                        iv = (byte[]) getIVMethod.invoke(params);
                    } catch (NoSuchMethodException | IllegalAccessException e) {
                        throw new RuntimeException(""GCMParameterSpec lacks expected methods"", e);
                    } catch (InvocationTargetException e) {
                        throw new RuntimeException(""Could not fetch GCM parameters"",
                                e.getTargetException());
                    }
                } else if (params instanceof IvParameterSpec) {
                    IvParameterSpec ivParams = (IvParameterSpec) params;
                    iv = ivParams.getIV();
                    tagLenBits = 0;
                } else {
                    iv = null;
                    tagLenBits = 0;
                }
            }

            if (tagLenBits % 8 != 0) {
                throw new InvalidAlgorithmParameterException(
                        ""Tag length must be a multiple of 8; was "" + tagLen);
            }

            tagLen = tagLenBits / 8;

            final boolean encrypting = isEncrypting();

            evpAead = getEVP_AEAD(encodedKey.length);

            final int expectedIvLength = NativeCrypto.EVP_AEAD_nonce_length(evpAead);
            if (iv == null && expectedIvLength != 0) {
                if (!encrypting) {
                    throw new InvalidAlgorithmParameterException(""IV must be specified in "" + mode
                            + "" mode"");
                }

                iv = new byte[expectedIvLength];
                if (random == null) {
                    random = new SecureRandom();
                }
                random.nextBytes(iv);
            } else if (expectedIvLength == 0 && iv != null) {
                throw new InvalidAlgorithmParameterException(""IV not used in "" + mode + "" mode"");
            } else if (iv != null && iv.length != expectedIvLength) {
                throw new InvalidAlgorithmParameterException(""Expected IV length of ""
                        + expectedIvLength + "" but was "" + iv.length);
            }

            this.iv = iv;
            reset();
        }",0
"private Bundle getAppRestrictionsSetByAnyAdmin(String packageName, UserHandle userHandle) {
        LinkedHashMap<EnforcingAdmin, PolicyValue<Bundle>> policies =
                mDevicePolicyEngine.getLocalPoliciesSetByAdmins(
                        PolicyDefinition.APPLICATION_RESTRICTIONS(packageName),
                        userHandle.getIdentifier());
        return policies.isEmpty()
                ? null : policies.entrySet().stream().findAny().get().getValue().getValue();
    }",0
"private static VerifiedSigner verify(
            RandomAccessFile apk,
            SignatureInfo signatureInfo,
            boolean doVerifyIntegrity) throws SecurityException, IOException {
        int signerCount = 0;
        Map<Integer, byte[]> contentDigests = new ArrayMap<>();
        List<X509Certificate[]> signerCerts = new ArrayList<>();
        CertificateFactory certFactory;
        try {
            certFactory = CertificateFactory.getInstance(""X.509"");
        } catch (CertificateException e) {
            throw new RuntimeException(""Failed to obtain X.509 CertificateFactory"", e);
        }
        ByteBuffer signers;
        try {
            signers = getLengthPrefixedSlice(signatureInfo.signatureBlock);
        } catch (IOException e) {
            throw new SecurityException(""Failed to read list of signers"", e);
        }
        while (signers.hasRemaining()) {
            signerCount++;
            if (signerCount > MAX_V2_SIGNERS) {
                throw new SecurityException(
                        ""APK Signature Scheme v2 only supports a maximum of "" + MAX_V2_SIGNERS
                                + "" signers"");
            }
            try {
                ByteBuffer signer = getLengthPrefixedSlice(signers);
                X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);
                signerCerts.add(certs);
            } catch (IOException | BufferUnderflowException | SecurityException e) {
                throw new SecurityException(
                        ""Failed to parse/verify signer #"" + signerCount + "" block"",
                        e);
            }
        }

        if (signerCount < 1) {
            throw new SecurityException(""No signers found"");
        }

        if (contentDigests.isEmpty()) {
            throw new SecurityException(""No content digests found"");
        }

        if (doVerifyIntegrity) {
            ApkSigningBlockUtils.verifyIntegrity(contentDigests, apk, signatureInfo);
        }

        byte[] verityRootHash = null;
        if (contentDigests.containsKey(CONTENT_DIGEST_VERITY_CHUNKED_SHA256)) {
            byte[] verityDigest = contentDigests.get(CONTENT_DIGEST_VERITY_CHUNKED_SHA256);
            verityRootHash = ApkSigningBlockUtils.parseVerityDigestAndVerifySourceLength(
                    verityDigest, apk.getChannel().size(), signatureInfo);
        }

        return new VerifiedSigner(
                signerCerts.toArray(new X509Certificate[signerCerts.size()][]),
                verityRootHash, contentDigests);
    }",1
"@SuppressWarnings(""unchecked"")
    @Override
    public <T extends Source> T getSource(Class<T> sourceClass) throws SQLException {
        try {
            if (isDebugEnabled()) {
                debugCode(
                        ""getSource("" + (sourceClass != null ? sourceClass.getSimpleName() + "".class"" : ""null"") + ')');
            }
            checkReadable();
            // According to https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html
            if (sourceClass == null || sourceClass == DOMSource.class) {
                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
                for (Map.Entry<String,Boolean> entry : secureFeatureMap.entrySet()) {
                    try {
                        dbf.setFeature(entry.getKey(), entry.getValue());
                    } catch (Exception ignore) {/**/}
                }
                dbf.setXIncludeAware(false);
                dbf.setExpandEntityReferences(false);
                dbf.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, """");
                DocumentBuilder db = dbf.newDocumentBuilder();
                db.setEntityResolver(NOOP_ENTITY_RESOLVER);
                return (T) new DOMSource(db.parse(new InputSource(value.getInputStream())));
            } else if (sourceClass == SAXSource.class) {
                XMLReader reader = XMLReaderFactory.createXMLReader();
                for (Map.Entry<String,Boolean> entry : secureFeatureMap.entrySet()) {
                    try {
                        reader.setFeature(entry.getKey(), entry.getValue());
                    } catch (Exception ignore) {/**/}
                }
                reader.setEntityResolver(NOOP_ENTITY_RESOLVER);
                return (T) new SAXSource(reader, new InputSource(value.getInputStream()));
            } else if (sourceClass == StAXSource.class) {
                XMLInputFactory xif = XMLInputFactory.newInstance();
                xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
                xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, """");
                xif.setProperty(""javax.xml.stream.isSupportingExternalEntities"", false);
                return (T) new StAXSource(xif.createXMLStreamReader(value.getInputStream()));
            } else if (sourceClass == StreamSource.class) {
                TransformerFactory tf = TransformerFactory.newInstance();
                tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, """");
                tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, """");
                tf.setURIResolver(NOOP_URI_RESOLVER);
                tf.newTransformer().transform(new StreamSource(value.getInputStream()), new SAXResult(new DefaultHandler()));
                return (T) new StreamSource(value.getInputStream());
            }
            throw unsupported(sourceClass.getName());
        } catch (Exception e) {
            throw logAndConvert(e);
        }
    }",1
"@Override
    public void render(HtmlRenderer renderer) {
        if (isArtifactsDeleted || isEmpty()) {
            HtmlElement element = p().unsafecontent(""Artifacts for this job instance are unavailable as they may have been <a href='"" +
                    CurrentGoCDVersion.docsUrl(""configuration/delete_artifacts.html"") +
                    ""' target='blank'>purged by Go</a> or deleted externally. ""
                    + ""Re-run the stage or job to generate them again."");
            element.render(renderer);
        }
        for (DirectoryEntry entry : this) {
            entry.toHtml().render(renderer);
        }
    }",1
"private List<ActiveAdmin> getActiveAdminsForLockscreenPoliciesLocked(int userHandle) {
        if (isSeparateProfileChallengeEnabled(userHandle)) {
            // If this user has a separate challenge, only return its restrictions.
            return getUserDataUnchecked(userHandle).mAdminList;
        }
        // If isSeparateProfileChallengeEnabled is false and userHandle points to a managed profile
        // we need to query the parent user who owns the credential.
        return getActiveAdminsForUserAndItsManagedProfilesLocked(getProfileParentId(userHandle),
                (user) -> !mLockPatternUtils.isSeparateProfileChallengeEnabled(user.id));
    }",0
"@Override
    public int getNearbyAppStreamingPolicy(final int userId) {
        if (!mHasFeature) {
            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
        }

        final CallerIdentity caller = getCallerIdentity();
        Preconditions.checkCallAuthorization(
                isProfileOwner(caller) || isDefaultDeviceOwner(caller)
                        || hasCallingOrSelfPermission(permission.READ_NEARBY_STREAMING_POLICY));

        synchronized (getLockObject()) {
            if (mOwners.hasProfileOwner(userId) || mOwners.hasDeviceOwner()) {
                final ActiveAdmin admin = getDeviceOrProfileOwnerAdminLocked(userId);
                return admin.mNearbyAppStreamingPolicy;
            }
        }

        return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
    }",0
"public static String makeQueryString(final HttpServletRequest request, final Map<String,Object> additions, final String[] ignores, final IgnoreType ignoreType) {
        if (request == null || additions == null || ignores == null || ignoreType == null) {
            throw new IllegalArgumentException(""Cannot take null parameters."");
        }

        final StringBuilder buffer = new StringBuilder();

        final List<String> ignoreList = Arrays.asList(ignores);

        final Enumeration<String> names = request.getParameterNames();

        while (names.hasMoreElements()) {
        	final String name = (String) names.nextElement();
        	final String[] values = request.getParameterValues(name);

            if ((ignoreType == IgnoreType.ADDITIONS_ONLY || !ignoreList.contains(name)) && values != null) {
                for (int i = 0; i < values.length; i++) {
                    buffer.append(""&"");
                    buffer.append(Util.encode(name));
                    buffer.append(""="");
                    buffer.append(Util.encode(values[i]));
                }
            }
        }

        for (final Entry<String,Object> entry : additions.entrySet()) {
            final String name = entry.getKey();
            // handle both a String value or a String[] value
            final Object tmp = entry.getValue();
            final String[] values;
            if (tmp instanceof String[]) {
                values = (String[]) tmp;
            } else if (tmp instanceof String) {
                values = new String[] { (String) tmp };
            } else {
                throw new IllegalArgumentException(""addition \"""" + name + ""\"" is not of type String or String[], but is of type: "" + tmp.getClass().getName());
            }

            if ((ignoreType == IgnoreType.REQUEST_ONLY || !ignoreList.contains(name)) && values != null) {
                for (int i = 0; i < values.length; i++) {
                    buffer.append(""&"");
                    buffer.append(name);
                    buffer.append(""="");
                    buffer.append(Util.encode(values[i]));
                }
            }
        }

        // removes the first & from the buffer
        if (buffer.length() > 0 && buffer.charAt(0) == '&') {
            buffer.deleteCharAt(0);
        }

        return buffer.toString();
    }",1
"public int process(Callback[] callbacks, int state) 
        throws AuthLoginException {
        if (!hasInitialized) {
            throw  new AuthLoginException(amAuthNT, ""NTSMB"", null);
        }
        if (host == null || host.length() == 0) {
            debug.message (""NT Host cannot be null "");
            throw new AuthLoginException(amAuthNT, ""Hosterror"", null);
        }
        if (domain == null || domain.length() == 0) {
            debug.message (""NT Domain cannot be null "");   
            throw new AuthLoginException(amAuthNT, ""Domainerror"", null);
        }
        try {
            if (!host.equals(new String(host.getBytes(""ASCII""), ""ASCII""))) {
                throw new AuthLoginException(amAuthNT, 
                        ""NTHostnameNotASCII"", null);
            }
            if (!domain.equals(new String(domain.getBytes(""ASCII""), ""ASCII""))) {
                throw new AuthLoginException(amAuthNT, 
                        ""NTDomainnameNotASCII"", null);
            }
        } catch (UnsupportedEncodingException ueex) {
            throw new AuthLoginException(amAuthNT, ""NTInputNotASCII"", null);
        }

        String userPassword = null;
        if (callbacks !=null && callbacks.length == 0) {                
            userName = (String) sharedState.get(getUserKey());
            userPassword = (String) sharedState.get(getPwdKey());
            if (userName == null || userPassword == null) {
                return ISAuthConstants.LOGIN_START;
            }
            getCredentialsFromSharedState = true;
        } else { 
        
            userName =  ((NameCallback)callbacks[0]).getName();
            userPassword = 
                charToString(((PasswordCallback)callbacks[1]).getPassword(),
                             callbacks[1]);
            if (userName == null || userName.length() == 0) {
                debug.message (""UserId cannot be null"");
                throw new AuthLoginException(amAuthNT, ""UserIderror"", null);
            }
            if (userPassword == null || userPassword.length() == 0) {
                debug.message (""Password cannot be null"");
                setFailureID(userName);
                throw new AuthLoginException(amAuthNT, ""Passworderror"", null);
            }
        }
        //prevent replace samba username attack
        userPassword = escapeSpecial(userPassword);

        // store username, password both in success and failure case        
        storeUsernamePasswd(userName, userPassword);

        try {
            if (!userName.equals(new String(userName.getBytes(""ASCII""),
                ""ASCII""))) {
               if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                    getCredentialsFromSharedState = false;
                    return ISAuthConstants.LOGIN_START;
               }
                throw new AuthLoginException(amAuthNT, 
                        ""NTUsernameNotASCII"", null);
            }
            if (!userPassword.equals(new String(userPassword.getBytes(""UTF-8""), 
            ""UTF-8""))) {
               if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                    getCredentialsFromSharedState = false;
                    return ISAuthConstants.LOGIN_START;
               }
                setFailureID(userName);
                throw new AuthLoginException(amAuthNT, 
                        ""NTPasswordNotASCII"", null);
            }
        } catch (UnsupportedEncodingException ueex) {
           if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                getCredentialsFromSharedState = false;
                return ISAuthConstants.LOGIN_START;
           }
            throw new AuthLoginException(amAuthNT, ""NTInputNotASCII"", null);
        }
        
        if (debug.messageEnabled()) {
            debug.message (""userName='""+ userName + ""' host='"" + host + ""'"");
            debug.message (""domain='"" + domain + ""'"");
        }
        File tmpFile = null;
        try {
            // Create the tmpFile
            tmpFile = File.createTempFile(userName,""pwd"");
            FileOutputStream fw = new FileOutputStream(tmpFile);
            OutputStreamWriter dos = new OutputStreamWriter(fw, ""UTF-8"");
            dos.write(""username = "" + userName + ""\n"");
            dos.write(""password = "" + userPassword);
            dos.flush();
            dos.close();
            fw.close();
            
            Runtime rt = Runtime.getRuntime();
            int c;
            StringBuilder buftxt = new StringBuilder(80);

            String[] progarr = null;
            if ((smbConfFileName != null) && (smbConfFileName.length() > 0)) {
                    progarr = new String[9];
                progarr[7] = ""-s"";
                progarr[8] = smbConfFileName; 
            } else {
                progarr = new String[7];
            }
            progarr[0] = smbPath;
            progarr[1] = ""-W"";
            progarr[2] = domain;
            progarr[3] = ""-L"";
            progarr[4] = host;
            progarr[5] = ""-A"";
            progarr[6] = tmpFile.getAbsolutePath();

            Process smbconn = rt.exec(progarr);

            BufferedReader smbout = new BufferedReader(
                new InputStreamReader(smbconn.getInputStream(), charSet));
            while ((c= smbout.read()) > -1) {
                char chtxt = ((char)c);
                buftxt.append(chtxt);
            }
            smbout.close();
            String out = buftxt.toString();

            if (out.indexOf (""Usage:"") != -1) {
                   if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                    getCredentialsFromSharedState = false;
                           return ISAuthConstants.LOGIN_START;
                   }
                if (debug.messageEnabled()) {
                    debug.message(""smbclient usage error"");
                }
                setFailureID(userName);
                throw new AuthLoginException(amAuthNT, ""NTSMBUsage"", null);
            } else if(out.indexOf(""failed"") != -1) {
                   if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                    getCredentialsFromSharedState = false;
                           return ISAuthConstants.LOGIN_START;
                   }
                if (debug.messageEnabled()) {
                    debug.message(""NT authentication failed"" + out);
                }
                setFailureID(userName);
                throw new AuthLoginException(amAuthNT, ""NTLoginFailed"", null);
            } else if (out.indexOf (""timeout"") != -1) {
                   if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                    getCredentialsFromSharedState = false;
                           return ISAuthConstants.LOGIN_START;
                   }
                if (debug.messageEnabled()) {
                    debug.message(""smbclient timeout error"");
                }
                setFailureID(userName);
                throw new AuthLoginException(amAuthNT, ""NTSMBTimeout"", null);
            } else {
                int exitValue = smbconn.waitFor();
                if (debug.messageEnabled()) {
                    debug.message(""Exit value of samba client: "" + exitValue);
                }
                if (exitValue != 0) {
                       if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                        getCredentialsFromSharedState = false;
                               return ISAuthConstants.LOGIN_START;
                       }
                    setFailureID(userName);
                    throw new AuthLoginException(
                        amAuthNT, ""NTAuthFailed"", null);
                }
                userTokenId = userName;
                return ISAuthConstants.LOGIN_SUCCEED;
            }
        } catch (Exception ex) {
           if (getCredentialsFromSharedState && !isUseFirstPassEnabled()) {
                getCredentialsFromSharedState = false;
                return ISAuthConstants.LOGIN_START;
           }

            if (debug.messageEnabled()) {
                debug.message(""NT authentication failed"" + ex.getMessage());
            }
            setFailureID(userName);
            throw new AuthLoginException(amAuthNT, ""NTAuthFailed"", null, ex);
        }
        finally {
            //Deletes the password file in any situation
            if(tmpFile !=null) {
                try {
                    tmpFile.delete();
                } catch(Exception e){}
            } 
       }
    }",1
"@Override
    public int adjustSystemUiVisibilityLw(int visibility) {
        mStatusBarController.adjustSystemUiVisibilityLw(mLastSystemUiFlags, visibility);
        mNavigationBarController.adjustSystemUiVisibilityLw(mLastSystemUiFlags, visibility);
        mRecentsVisible = (visibility & View.RECENT_APPS_VISIBLE) > 0;

        // Reset any bits in mForceClearingStatusBarVisibility that
        // are now clear.
        mResettingSystemUiFlags &= visibility;
        // Clear any bits in the new visibility that are currently being
        // force cleared, before reporting it.
        return visibility & ~mResettingSystemUiFlags
                & ~mForceClearedSystemUiFlags;
    }",0
"private static String subtag(String full, String attribute) {
        int start = full.indexOf(attribute);
        if (start < 0) {
            return null;
        }

        start += attribute.length();
        int end = full.indexOf(';', start);

        if (end < 0) {
            return full.substring(start);
        } else {
            return full.substring(start, end);
        }
    }",0
"@Override
    public Syntax getSyntax()
    {
        // Can't be initialized in the XWikiDocument constructor because #getDefaultDocumentSyntax() need to create a
        // XWikiDocument object to get preferences from wiki preferences pages and would thus generate an infinite loop
        if (isNew() && this.syntax == null) {
            this.syntax = getDefaultDocumentSyntax();
        }

        return this.syntax;
    }",0
"public String getSelectedDownloadOptionLabel() {
        return selectedDownloadOptionLabel;
    }",0
"@Override
        public void resetConnectionTime(String callId, Session.Info sessionInfo) {
            Log.startSession(sessionInfo, ""CSW.rCCT"", mPackageAbbreviation);
            long token = Binder.clearCallingIdentity();
            try {
                synchronized (mLock) {
                    logIncoming(""resetConnectionTime %s"", callId);
                    Call call = mCallIdMapper.getCall(callId);
                    if (call != null) {
                        mCallsManager.resetConnectionTime(call);
                    } else {
                        // Log.w(this, ""resetConnectionTime, unknown call id: %s"", msg.obj);
                    }
                }
            } finally {
                Binder.restoreCallingIdentity(token);
                Log.endSession();
            }
        }",0
"@Override
    public Group createSubmitters(Context context, Collection collection) throws SQLException, AuthorizeException {
        // Check authorisation - Must be an Admin to create Submitters Group
        AuthorizeUtil.authorizeManageSubmittersGroup(context, collection);

        Group submitters = collection.getSubmitters();
        if (submitters == null) {
            //turn off authorization so that Collection Admins can create Collection Submitters
            context.turnOffAuthorisationSystem();
            submitters = groupService.create(context);
            context.restoreAuthSystemState();

            groupService.setName(submitters,
                                 ""COLLECTION_"" + collection.getID() + ""_SUBMIT"");
            groupService.update(context, submitters);
        }

        // register this as the submitter group
        collection.setSubmitters(submitters);

        authorizeService.addPolicy(context, collection, Constants.ADD, submitters);

        return submitters;
    }",0
"private static int findNonWhitespace(AppendableCharSequence sb, int offset) {
        for (int result = offset; result < sb.length(); ++result) {
            char c = sb.charAtUnsafe(result);
            if (!Character.isWhitespace(c)) {
                return result;
            } else if (!isOWS(c)) {
                // Only OWS is supported for whitespace
                throw new IllegalArgumentException(""Invalid separator, only a single space or horizontal tab allowed,"" +
                        "" but received a '"" + c + ""' (0x"" + Integer.toHexString(c) + "")"");
            }
        }
        return sb.length();
    }",1
"@Override
    public Response processBeginTransaction(TransactionInfo info) throws Exception {
        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
        context = null;
        if (cs != null) {
            context = cs.getContext();
        }
        if (cs == null) {
            throw new NullPointerException(""Context is null"");
        }
        // Avoid replaying dup commands
        if (cs.getTransactionState(info.getTransactionId()) == null) {
            cs.addTransactionState(info.getTransactionId());
            broker.beginTransaction(context, info.getTransactionId());
        }
        return null;
    }",0
"int deleteLogicDeleted(@Param(""userIds"") List<String> userIds);",1
"private void ensureCorrectTheme(Intent data) {
        String oldListLayout = data.getStringExtra(SettingsActivity.AI_FEED_LIST_LAYOUT);
		String newListLayout = mPrefs.getString(SettingsActivity.SP_FEED_LIST_LAYOUT, ""0"");

        if (ThemeChooser.themeRequiresRestartOfUI() || !newListLayout.equals(oldListLayout)) {
            NewsReaderListActivity.this.recreate();
        } else if (data.hasExtra(SettingsActivity.CACHE_CLEARED)) {
            resetUiAndStartSync();
        }
    }",1
"@Override
    public void displayView(StringBuffer buffer, String name, String prefix, BaseCollection object, boolean isolated,
        XWikiContext context)
    {
        String contentTypeString = getContentType();
        ContentType contentType = ContentType.getByValue(contentTypeString);

        if (contentType == ContentType.PURE_TEXT) {
            super.displayView(buffer, name, prefix, object, context);
        } else if (contentType == ContentType.VELOCITY_CODE) {
            displayVelocityCode(buffer, name, prefix, object, context);
        } else {
            BaseProperty<?> property = (BaseProperty<?>) object.safeget(name);
            if (property != null) {
                String content = property.toText();
                XWikiDocument sdoc = getObjectDocument(object, context);

                if (contentType == ContentType.VELOCITYWIKI) {
                    content = maybeEvaluateContent(name, isolated, content, sdoc);
                }

                if (sdoc != null) {
                    sdoc = ensureContentAuthorIsMetadataAuthor(sdoc);

                    buffer.append(
                        context.getDoc().getRenderedContent(content, sdoc.getSyntax(), isRestricted(), sdoc,
                            isolated, context));
                } else {
                    buffer.append(XMLUtils.escapeElementText(content));
                }
            }
        }
    }",1
"protected CellState getCellState() {
                return cellState;
            }",0
"private void start() {
        removeAllProcessGroups();
        mProcessCpuThread.start();

        mBatteryStatsService.publish();
        mAppOpsService.publish(mContext);
        Slog.d(""AppOps"", ""AppOpsService published"");
        LocalServices.addService(ActivityManagerInternal.class, new LocalService());
        // Wait for the synchronized block started in mProcessCpuThread,
        // so that any other acccess to mProcessCpuTracker from main thread
        // will be blocked during mProcessCpuTracker initialization.
        try {
            mProcessCpuInitLatch.await();
        } catch (InterruptedException e) {
            Slog.wtf(TAG, ""Interrupted wait during start"", e);
            Thread.currentThread().interrupt();
            throw new IllegalStateException(""Interrupted wait during start"");
        }
    }",0
"void grantUriPermissionUncheckedLocked(int targetUid, String targetPkg, GrantUri grantUri,
            final int modeFlags, UriPermissionOwner owner) {
        if (!Intent.isAccessUriMode(modeFlags)) {
            return;
        }

        // So here we are: the caller has the assumed permission
        // to the uri, and the target doesn't.  Let's now give this to
        // the target.

        if (DEBUG_URI_PERMISSION) Slog.v(TAG, 
                ""Granting "" + targetPkg + ""/"" + targetUid + "" permission to "" + grantUri);

        final String authority = grantUri.uri.getAuthority();
        final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId);
        if (pi == null) {
            Slog.w(TAG, ""No content provider found for grant: "" + grantUri.toSafeString());
            return;
        }

        if ((modeFlags & Intent.FLAG_GRANT_PREFIX_URI_PERMISSION) != 0) {
            grantUri.prefix = true;
        }
        final UriPermission perm = findOrCreateUriPermissionLocked(
                pi.packageName, targetPkg, targetUid, grantUri);
        perm.grantModes(modeFlags, owner);
    }",0
"@Override
    public void validate() {
        final String filter = FilterEncoder.format(ldapConfiguration.getUserSearchFilter(), ""test"");
        ldapConnectionTemplate.searchFirst(ldapConfiguration.getSearchBases().get(0), filter, SearchScope.SUBTREE, entry -> entry);
    }",1
"private void onLocalVoiceInteractionStartedLocked(IBinder activity,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {
        ActivityRecord activityToCallback = ActivityRecord.forTokenLocked(activity);
        if (activityToCallback == null) return;
        activityToCallback.setVoiceSessionLocked(voiceSession);

        // Inform the activity
        try {
            activityToCallback.app.getThread().scheduleLocalVoiceInteractionStarted(activity,
                    voiceInteractor);
            final long token = Binder.clearCallingIdentity();
            try {
                startRunningVoiceLocked(voiceSession, activityToCallback.info.applicationInfo.uid);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
            // TODO: VI Should we cache the activity so that it's easier to find later
            // rather than scan through all the root tasks and activities?
        } catch (RemoteException re) {
            activityToCallback.clearVoiceSessionLocked();
            // TODO: VI Should this terminate the voice session?
        }
    }",0
"@Override
    public Argument<Session> argumentType() {
        return TYPE;
    }",1
"private static String translateLegacySystemId(String systemId) {

        String result = systemId;
        for (String[] translation : LEGACY_TRANSLATIONS) {
            if (systemId.startsWith(translation[0])) {
                // replace prefix with second component if it matches the first component
                result = translation[1] + systemId.substring(translation[0].length());
                break;
            }
        }
        if (OpenCms.getRepositoryManager() != null) {
            result = OpenCms.getResourceManager().getXsdTranslator().translateResource(result);
        }
        return result;
    }",0
"@Deprecated
  String compact();",1
"@Override
    public void overridePendingTransition(IBinder token, String packageName,
            int enterAnim, int exitAnim) {
        synchronized(this) {
            ActivityRecord self = ActivityRecord.isInStackLocked(token);
            if (self == null) {
                return;
            }

            final long origId = Binder.clearCallingIdentity();

            if (self.state == ActivityState.RESUMED
                    || self.state == ActivityState.PAUSING) {
                mWindowManager.overridePendingAppTransition(packageName,
                        enterAnim, exitAnim, null);
            }

            Binder.restoreCallingIdentity(origId);
        }
    }",0
"private String tryRewrite(String s) throws IOException, InvalidKeyException {
        if (s.length()<24)
            return s;   // Encrypting """" in Secret produces 24-letter characters, so this must be the minimum length
        if (!isBase64(s))
            return s;   // decode throws IOException if the input is not base64, and this is also a very quick way to filter

        byte[] in;
        try {
            in = Base64.decode(s.toCharArray());
        } catch (IOException e) {
            return s;   // not a valid base64
        }
        cipher.init(Cipher.DECRYPT_MODE, key);
        Secret sec = HistoricalSecrets.tryDecrypt(cipher, in);
        if(sec!=null) // matched
            return sec.getEncryptedValue(); // replace by the new encrypted value
        else // not encrypted with the legacy key. leave it unmodified
            return s;
    }",1
"public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException
    {
        try {
            XWikiRequest request = context.getRequest();
            // Get the user document
            String username = convertUsername(request.getParameter(""xwikiname""), context);
            if (username.indexOf('.') == -1) {
                username = ""XWiki."" + username;
            }
            XWikiDocument userDocument = getDocument(username, context);

            // Get the stored validation key
            BaseObject userObject = userDocument.getObject(""XWiki.XWikiUsers"", 0);
            String storedKey = userObject.getStringValue(""validkey"");

            // Get the validation key from the URL
            String validationKey = request.getParameter(""validkey"");
            PropertyInterface validationKeyClass = getClass(""XWiki.XWikiUsers"", context).get(""validkey"");
            if (validationKeyClass instanceof PasswordClass) {
                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);
            }

            // Compare the two keys
            if ((!storedKey.equals("""") && (storedKey.equals(validationKey)))) {
                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back
                // a disabled user.
                userObject.setStringValue(""validkey"", """");
                saveDocument(userDocument, context);

                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());
                xWikiUser.setDisabled(false, context);
                xWikiUser.setEmailChecked(true, context);

                if (withConfirmEmail) {
                    String email = userObject.getStringValue(""email"");
                    String password = userObject.getStringValue(""password"");
                    sendValidationEmail(username, password, email, request.getParameter(""validkey""),
                        ""confirmation_email_content"", context);
                }

                return 0;
            } else {
                return -1;
            }
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);

            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,
                ""Exception while validating user"", e, null);
        }
    }",1
"@Override
    public Integer getPriority() {
        return 100;
    }",0
"protected UploadPackageResultDto performUploadPackage(MultipartFile pluginPackageFile, File localFilePath) {
        String pluginPackageFileName = pluginPackageFile.getName();
        
        if(!validateUploadFilename(pluginPackageFileName)){
            log.info(""Invalid upload filename:{}"", pluginPackageFileName);
            throw new WecubeCoreException(""Invalid upload filename."");
        }
        
        if (!localFilePath.exists()) {
            if (localFilePath.mkdirs()) {
                log.info(""Create directory [{}] successful"", localFilePath.getAbsolutePath());
            } else {
                String errMsg = String.format(""Create directory [%s] failed."", localFilePath.getAbsolutePath());
                throw new WecubeCoreException(""3099"", errMsg, localFilePath.getAbsolutePath());
            }
        }

        //TODO
        File dest = new File(localFilePath, ""/"" + pluginPackageFileName);
        try {
            log.info(""new file location: {}, filename: {}, canonicalpath: {}, canonicalfilename: {}"",
                    dest.getAbsoluteFile(), dest.getName(), dest.getCanonicalPath(), dest.getCanonicalFile().getName());
            pluginPackageFile.transferTo(dest);
        } catch (IOException e) {
            log.error(""errors to transfer uploaded files."", e);
            throw new WecubeCoreException(""Failed to upload package,due to "" + e.getMessage());
        }

        UploadPackageResultDto result = null;
        try {
            result = parsePackageFile(dest, localFilePath);
            log.info(""Package uploaded successfully."");
        } catch (Exception e) {
            log.error(""Errors to parse uploaded package file."", e);
            throw new WecubeCoreException(""Failed to upload package due to "" + e.getMessage());
        }

        return result;
    }",1
"private static byte[] getCollationKeyInBytes(String name) {
        if (mColl == null) {
            mColl = Collator.getInstance();
            mColl.setStrength(Collator.PRIMARY);
        }
        return mColl.getCollationKey(name).toByteArray();
    }",0
"@JRubyMethod(meta=true, required=1, optional=1)
    public static IRubyObject read_memory(ThreadContext context, IRubyObject klazz, IRubyObject[] args) {
        IRubyObject content = args[0];
        IRubyObject parseOptions = null;
        if (args.length > 1) {
            parseOptions = args[1];
        }
        String data = content.convertToString().asJavaString();
        return getSchema(context, (RubyClass) klazz, new StreamSource(new StringReader(data)), parseOptions);
    }",1
"void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName,
            ApplicationErrorReport.CrashInfo crashInfo) {
        float loadingProgress = 1;
        IncrementalMetrics incrementalMetrics = null;
        // Obtain Incremental information if available
        if (r != null && r.info != null && r.info.packageName != null) {
            IncrementalStatesInfo incrementalStatesInfo =
                    mPackageManagerInt.getIncrementalStatesInfo(r.info.packageName, SYSTEM_UID,
                            r.userId);
            if (incrementalStatesInfo != null) {
                loadingProgress = incrementalStatesInfo.getProgress();
            }
            final String codePath = r.info.getCodePath();
            if (codePath != null && !codePath.isEmpty()
                    && IncrementalManager.isIncrementalPath(codePath)) {
                // Report in the main log about the incremental package
                Slog.e(TAG, ""App crashed on incremental package "" + r.info.packageName
                        + "" which is "" + ((int) (loadingProgress * 100)) + ""% loaded."");
                final IBinder incrementalService = ServiceManager.getService(
                        Context.INCREMENTAL_SERVICE);
                if (incrementalService != null) {
                    final IncrementalManager incrementalManager = new IncrementalManager(
                            IIncrementalService.Stub.asInterface(incrementalService));
                    incrementalMetrics = incrementalManager.getMetrics(codePath);
                }
            }
        }

        EventLogTags.writeAmCrash(Binder.getCallingPid(),
                UserHandle.getUserId(Binder.getCallingUid()), processName,
                r == null ? -1 : r.info.flags,
                crashInfo.exceptionClassName,
                crashInfo.exceptionMessage,
                crashInfo.throwFileName,
                crashInfo.throwLineNumber);

        int processClassEnum = processName.equals(""system_server"") ? ServerProtoEnums.SYSTEM_SERVER
                : (r != null) ? r.getProcessClassEnum()
                        : ServerProtoEnums.ERROR_SOURCE_UNKNOWN;
        int uid = (r != null) ? r.uid : -1;
        int pid = (r != null) ? r.getPid() : -1;
        FrameworkStatsLog.write(FrameworkStatsLog.APP_CRASH_OCCURRED,
                uid,
                eventType,
                processName,
                pid,
                (r != null && r.info != null) ? r.info.packageName : """",
                (r != null && r.info != null) ? (r.info.isInstantApp()
                        ? FrameworkStatsLog.APP_CRASH_OCCURRED__IS_INSTANT_APP__TRUE
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__IS_INSTANT_APP__FALSE)
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__IS_INSTANT_APP__UNAVAILABLE,
                r != null ? (r.isInterestingToUserLocked()
                        ? FrameworkStatsLog.APP_CRASH_OCCURRED__FOREGROUND_STATE__FOREGROUND
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__FOREGROUND_STATE__BACKGROUND)
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__FOREGROUND_STATE__UNKNOWN,
                processClassEnum,
                incrementalMetrics != null /* isIncremental */, loadingProgress,
                incrementalMetrics != null ? incrementalMetrics.getMillisSinceOldestPendingRead()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getStorageHealthStatusCode()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getDataLoaderStatusCode()
                        : -1,
                incrementalMetrics != null && incrementalMetrics.getReadLogsEnabled(),
                incrementalMetrics != null ? incrementalMetrics.getMillisSinceLastDataLoaderBind()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getDataLoaderBindDelayMillis()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getTotalDelayedReads()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getTotalFailedReads()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getLastReadErrorUid()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getMillisSinceLastReadError()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getLastReadErrorNumber()
                        : 0,
                incrementalMetrics != null ? incrementalMetrics.getTotalDelayedReadsDurationMillis()
                        : -1
        );

        if (eventType.equals(""native_crash"")) {
            CriticalEventLog.getInstance().logNativeCrash(processClassEnum, processName, uid, pid);
        } else if (eventType.equals(""crash"")) {
            CriticalEventLog.getInstance().logJavaCrash(crashInfo.exceptionClassName,
                    processClassEnum, processName, uid, pid);
        }

        final int relaunchReason = r == null ? RELAUNCH_REASON_NONE
                        : r.getWindowProcessController().computeRelaunchReason();
        final String relaunchReasonString = relaunchReasonToString(relaunchReason);
        if (crashInfo.crashTag == null) {
            crashInfo.crashTag = relaunchReasonString;
        } else {
            crashInfo.crashTag = crashInfo.crashTag + "" "" + relaunchReasonString;
        }

        addErrorToDropBox(
                eventType, r, processName, null, null, null, null, null, null, crashInfo,
                new Float(loadingProgress), incrementalMetrics, null);

        mAppErrors.crashApplication(r, crashInfo);
    }",0
"private void maybeDeleteLegacyPendingInfoLocked(File syncDir) {
        File file = new File(syncDir, ""pending.bin"");
        if (!file.exists()) {
            return;
        } else {
            file.delete();
        }
    }",0
"@Override
    public void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (!mFirstDrawComplete) {
            mFirstDrawComplete = true;

            // We have now avoided the first draw problem (see the comment in
            // the constructor) so we want to make the URL bar focusable so that
            // touches etc. activate it.
            setFocusable(mAllowFocus);
            setFocusableInTouchMode(mAllowFocus);

            // The URL bar will now react correctly to a focus change event
            if (mOmniboxLivenessListener != null) {
                mOmniboxLivenessListener.onOmniboxInteractive();
            }
        }

        // Notify listeners if the URL's direction has changed.
        updateUrlDirection();
    }",0
"protected ID checkoutReferenceValue(Field field, Cell cell) {
        final String val = cell.asString();
        final Entity refEntity = field.getReferenceEntity();

        // 支持ID
        ID vla2id = MetadataHelper.checkSpecEntityId(val, refEntity.getEntityCode());
        if (vla2id != null) {
            if (QueryHelper.exists(vla2id)) return vla2id;

            log.warn(""Reference ID `{}` not exists"", vla2id);
            return null;
        }

        Object val2Text = checkoutFieldValue(refEntity.getNameField(), cell, false);
        if (val2Text == null) return null;

        Query query;
        // 用户特殊处理
        if (refEntity.getEntityCode() == EntityHelper.User) {
            String sql = MessageFormat.format(
                    ""select userId from User where loginName = ''{0}'' or email = ''{0}'' or fullName = ''{0}''"",
                    CommonsUtils.escapeSql(val2Text.toString()));
            query = Application.createQueryNoFilter(sql);
        } else {
            // 查找引用实体的名称字段和自动编号字段
            Set<String> queryFields = new HashSet<>();
            queryFields.add(refEntity.getNameField().getName());
            // 名称字段又是引用字段
            if (!(val2Text instanceof ID)) {
                for (Field s : MetadataSorter.sortFields(refEntity, DisplayType.SERIES)) {
                    queryFields.add(s.getName());
                }
            }

            StringBuilder sql = new StringBuilder(
                    String.format(""select %s from %s where "", refEntity.getPrimaryField().getName(), refEntity.getName()));
            for (String qf : queryFields) {
                sql.append(
                        String.format(""%s = '%s' or "", qf, CommonsUtils.escapeSql(val2Text.toString())));
            }
            sql = new StringBuilder(sql.substring(0, sql.length() - 4));

            query = Application.createQueryNoFilter(sql.toString());
        }

        Object[] found = query.unique();
        return found != null ? (ID) found[0] : null;
    }",1
"private void initDbCommands(Environment env) {
        String schemaSuffix = env.getProperty(DB_SCHEMA_SUFFIX, EMPTY);

        DB_COMMANDS.put(""POSTGRESQL"", ""SET search_path TO %s"" + schemaSuffix);
        DB_COMMANDS.put(""ORACLE"", ""ALTER SESSION SET CURRENT_SCHEMA = %s"" + schemaSuffix);
        DB_COMMANDS.put(""H2"", DEFAULT_COMMAND + schemaSuffix);

        DB_SQL_COMMANDS.put(""POSTGRESQL"", ""SET search_path TO ?"" + schemaSuffix);
        DB_SQL_COMMANDS.put(""ORACLE"", ""ALTER SESSION SET CURRENT_SCHEMA = ?"" + schemaSuffix);
        DB_SQL_COMMANDS.put(""H2"", DEFAULT_COMMAND_SQL_COMMAND + schemaSuffix);
    }",1
"@Override
    public boolean isInfinite() {
        return (flags & INFINITY_FLAG) != 0;
    }",0
"void registerContentObserver(Uri uri, boolean notifyForDescendents,
                ContentObserver observer, int userHandle) {
            mContext.getContentResolver().registerContentObserver(uri, notifyForDescendents,
                    observer, userHandle);
        }",0
"private static void initRvisByGene(String geneName) throws Exception {
        String sql = ""SELECT * FROM rvis WHERE gene_name=?"";

        PreparedStatement stmt = DBManager.prepareStatement(sql);
        stmt.setString(1, geneName);
        ResultSet rset = stmt.executeQuery();

        if (rset.next()) {
            float f = FormatManager.getFloat(rset.getObject(""rvis_percent""));

            String value = FormatManager.getString(f);

            if (value.equals(""-"")) {
                Output.rvisPercentile = ""NA"";
            }

            Output.rvisPercentile = value + ""%"";
        }

        rset.close();
    }",1
"@Override
    public boolean isOnLoadPath(final File file) {
        if (file == null) {
            throw new IllegalArgumentException(""A file must not be null"");
        }
        else if (unlimitedAccess) {
            return true;
        }
        else {
            final File f = canonical(file);
            final File dir = f.getParentFile();

            // check load paths
            for(File p : paths) {
                if (p.isDirectory()) {
                    if (dir.equals(p)) return true;
                }
                else if (p.isFile()) {
                    if (f.equals(p)) return true;
                }
            }

            return false;
        }
    }",0
"private boolean accessPlugin(String uri, HttpServletRequest request, HttpServletResponse response) throws IOException, InstantiationException {
        CloseResponseHandle handle = getContext(uri, request.getMethod(), request, true);
        try {
            if (handle.getT() != null && handle.getT().getEntity() != null) {
                response.setStatus(handle.getT().getStatusLine().getStatusCode());
                //防止多次被Transfer-Encoding
                handle.getT().removeHeaders(""Transfer-Encoding"");
                for (Header header : handle.getT().getAllHeaders()) {
                    response.addHeader(header.getName(), header.getValue());
                }
                //将插件服务的HTTP的body返回给调用者
                byte[] bytes = IOUtil.getByteByInputStream(handle.getT().getEntity().getContent());
                response.addHeader(""Content-Length"", Integer.valueOf(bytes.length).toString());
                response.getOutputStream().write(bytes);
                response.getOutputStream().close();
                return true;
            } else {
                return false;
            }
        } finally {
            handle.close();
        }
    }",0
"@Override
    public Rect getTaskBounds(int taskId) {
        enforceCallingPermission(MANAGE_ACTIVITY_STACKS, ""getTaskBounds()"");
        long ident = Binder.clearCallingIdentity();
        Rect rect = new Rect();
        try {
            synchronized (this) {
                final TaskRecord task = mStackSupervisor.anyTaskForIdLocked(
                        taskId, !RESTORE_FROM_RECENTS, INVALID_STACK_ID);
                if (task == null) {
                    Slog.w(TAG, ""getTaskBounds: taskId="" + taskId + "" not found"");
                    return rect;
                }
                if (task.stack != null) {
                    // Return the bounds from window manager since it will be adjusted for various
                    // things like the presense of a docked stack for tasks that aren't resizeable.
                    mWindowManager.getTaskBounds(task.taskId, rect);
                } else {
                    // Task isn't in window manager yet since it isn't associated with a stack.
                    // Return the persist value from activity manager
                    if (task.mBounds != null) {
                        rect.set(task.mBounds);
                    } else if (task.mLastNonFullscreenBounds != null) {
                        rect.set(task.mLastNonFullscreenBounds);
                    }
                }
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        return rect;
    }",0
"@VisibleForTesting
    Supplier<ActionTransition> createEditAction(Context context, Resources r, Uri uri) {
        return () -> {
            ActionTransition transition = mSharedElementTransition.get();
            // Note: Both the share and edit actions are proxied through ActionProxyReceiver in
            // order to do some common work like dismissing the keyguard and sending
            // closeSystemWindows

            // Create an edit intent, if a specific package is provided as the editor, then
            // launch that directly
            String editorPackage = context.getString(R.string.config_screenshotEditor);
            Intent editIntent = new Intent(Intent.ACTION_EDIT);
            if (!TextUtils.isEmpty(editorPackage)) {
                editIntent.setComponent(ComponentName.unflattenFromString(editorPackage));
            }
            editIntent.setDataAndType(uri, ""image/png"");
            editIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            editIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
            editIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);

            PendingIntent pendingIntent = PendingIntent.getActivityAsUser(
                    context, 0, editIntent, PendingIntent.FLAG_IMMUTABLE,
                    transition.bundle, UserHandle.CURRENT);

            // Make sure pending intents for the system user are still unique across users
            // by setting the (otherwise unused) request code to the current user id.
            int requestCode = mContext.getUserId();

            // Create a edit action
            PendingIntent editAction = PendingIntent.getBroadcastAsUser(context, requestCode,
                    new Intent(context, ActionProxyReceiver.class)
                            .putExtra(ScreenshotController.EXTRA_ACTION_INTENT, pendingIntent)
                            .putExtra(ScreenshotController.EXTRA_ID, mScreenshotId)
                            .putExtra(ScreenshotController.EXTRA_SMART_ACTIONS_ENABLED,
                                    mSmartActionsEnabled)
                            .putExtra(ScreenshotController.EXTRA_OVERRIDE_TRANSITION, true)
                            .setAction(Intent.ACTION_EDIT)
                            .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),
                    PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,
                    UserHandle.SYSTEM);
            Notification.Action.Builder editActionBuilder = new Notification.Action.Builder(
                    Icon.createWithResource(r, R.drawable.ic_screenshot_edit),
                    r.getString(com.android.internal.R.string.screenshot_edit), editAction);

            transition.action = editActionBuilder.build();
            return transition;
        };
    }",0
"@SuppressWarnings(""unchecked"")
    public void testSimpleViaObjectMapper()
        throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
        // also need tree mapper to construct tree to serialize
        ObjectNode n = mapper.getNodeFactory().objectNode();
        n.put(""number"", 15);
        n.put(""string"", ""abc"");
        ObjectNode n2 = n.putObject(""ob"");
        n2.putArray(""arr"");
        StringWriter sw = new StringWriter();
        JsonGenerator jg = mapper.createGenerator(sw);
        mapper.writeTree(jg, n);

        Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);
        assertEquals(3, result.size());
        assertEquals(""abc"", result.get(""string""));
        assertEquals(Integer.valueOf(15), result.get(""number""));
        Map<String,Object> ob = (Map<String,Object>) result.get(""ob"");
        assertEquals(1, ob.size());
        List<Object> list = (List<Object>) ob.get(""arr"");
        if (list == null) {
            fail(""Missing entry 'arr': ""+ob);
        }
        assertEquals(0, list.size());
        jg.close();
    }",1
"public String getPasswordValue(Object o) {
        if (o==null)    return null;
        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();
        if (getIsUnitTest()) {
            throw new SecurityException(""attempted to render plaintext ‘"" + o + ""’ in password field; use a getter of type Secret instead"");
        }
        return o.toString();
    }",1
"public String getPlainText(String messageId) {
        return getPlainText(messageId, (Object[])null);
    }",0
"@Override
  public RequestParameter isValid(String value) throws ValidationException {
    try {
      DocumentBuilder parser = createDocumentBuilderFactoryInstance().newDocumentBuilder();
      Document document = parser.parse(value);
      this.schemaValidator.validate(new DOMSource(document));
      return RequestParameter.create(document);
    } catch (Exception e) {
      throw ValidationException.ValidationExceptionFactory.generateInvalidXMLBodyException(e.getMessage());
    }
  }",1
"public void deleteSubscription(ServiceRequest service) throws UaException {
        DeleteSubscriptionsRequest request = (DeleteSubscriptionsRequest) service.getRequest();

        List<UInteger> subscriptionIds = l(request.getSubscriptionIds());

        if (subscriptionIds.isEmpty()) {
            throw new UaException(StatusCodes.Bad_NothingToDo);
        }

        StatusCode[] results = new StatusCode[subscriptionIds.size()];

        for (int i = 0; i < subscriptionIds.size(); i++) {
            UInteger subscriptionId = subscriptionIds.get(i);
            Subscription subscription = subscriptions.remove(subscriptionId);

            if (subscription != null) {
                server.getSubscriptions().remove(subscription.getId());
                server.getEventBus().post(new SubscriptionDeletedEvent(subscription));

                List<BaseMonitoredItem<?>> deletedItems = subscription.deleteSubscription();

                /*
                 * Notify AddressSpaces of the items we just deleted.
                 */

                byMonitoredItemType(
                    deletedItems,
                    dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),
                    eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)
                );

                results[i] = StatusCode.GOOD;

                monitoredItemCount.getAndUpdate(count -> count - deletedItems.size());
                server.getMonitoredItemCount().getAndUpdate(count -> count - deletedItems.size());
            } else {
                results[i] = new StatusCode(StatusCodes.Bad_SubscriptionIdInvalid);
            }
        }

        ResponseHeader header = service.createResponseHeader();

        DeleteSubscriptionsResponse response = new DeleteSubscriptionsResponse(
            header,
            results,
            new DiagnosticInfo[0]
        );

        service.setResponse(response);

        while (subscriptions.isEmpty() && publishQueue.isNotEmpty()) {
            ServiceRequest publishService = publishQueue.poll();
            if (publishService != null) {
                publishService.setServiceFault(StatusCodes.Bad_NoSubscription);
            }
        }
    }",1
"public void setUpdateTime(Date updateTime) {
        this.updateTime = updateTime;
    }",1
"public void setCertTypeInUse(boolean certTypeInUse) {
        this.certTypeInUse = certTypeInUse;
    }",0
"private Object read(InputStream in, ClassLoader classLoader) throws IOException {
            try {
                ObjectInputStream objectInputStream = newObjectInputStream(classLoader, classFilter, in);
                if (shared) {
                    return objectInputStream.readObject();
                }
                return objectInputStream.readUnshared();
            } catch (ClassNotFoundException e) {
                throw new HazelcastSerializationException(e);
            }
        }",1
"@Contract(value = ""-> new"", pure = true)
	public @NotNull Dragonfly build() {
		try {
			return new Dragonfly(timeout, classLoader, directory, repositories, deleteOnRelocate, statusHandler);
		} catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}",1
"private String getDestinationBaseDirectoryName(String state) {
        return getDestinationBaseDirectoryName(state, false);
    }",0
"public void setRows(int rows)
    {
        setIntValue(""rows"", rows);
    }",0
"public String getAttributeValue(String namespace, String name) {
            int idx = nativeGetAttributeIndex(mParseState, namespace, name);
            if (idx >= 0) {
                if (DEBUG) System.out.println(""getAttributeName of ""
                        + namespace + "":"" + name + "" index = "" + idx);
                if (DEBUG) System.out.println(
                        ""Namespace="" + getAttributeNamespace(idx)
                        + ""Name="" + getAttributeName(idx)
                        + "", Value="" + getAttributeValue(idx));
                return getAttributeValue(idx);
            }
            return null;
        }",0
"static Html4SaxParserContext
  newInstance(final Ruby runtime, final RubyClass klazz)
  {
    Html4SaxParserContext instance = new Html4SaxParserContext(runtime, klazz);
    instance.initialize(runtime);
    return instance;
  }",0
"public int doFinal(byte[] out, int outOff)
                throws DataLengthException, IllegalStateException
            {
                try
                {
                    return ccm.doFinal(out, 0);
                }
                catch (InvalidCipherTextException e)
                {
                    throw new IllegalStateException(""exception on doFinal(): "" + e.toString());
                }
            }",1
"public Controller execute(FolderComponent folderComponent, UserRequest ureq, WindowControl wControl, Translator translator) {
		VFSContainer currentContainer = folderComponent.getCurrentContainer();
		VFSContainer rootContainer = folderComponent.getRootContainer();

		if (!VFSManager.exists(currentContainer)) {
			status = FolderCommandStatus.STATUS_FAILED;
			showError(translator.translate(""FileDoesNotExist""));
			return null;
		}
		status = FolderCommandHelper.sanityCheck(wControl, folderComponent);
		if (status == FolderCommandStatus.STATUS_FAILED) {
			return null;
		}
		FileSelection selection = new FileSelection(ureq, folderComponent.getCurrentContainer(), folderComponent.getCurrentContainerPath());
		status = FolderCommandHelper.sanityCheck3(wControl, folderComponent, selection);
		if (status == FolderCommandStatus.STATUS_FAILED) {
			return null;
		}

		boolean selectionWithContainer = false;
		List<String> filenames = selection.getFiles();
		List<VFSLeaf> leafs = new ArrayList<>();
		for (String file : filenames) {
			VFSItem item = currentContainer.resolve(file);
			if (item instanceof VFSContainer) {
				selectionWithContainer = true;
			} else if (item instanceof VFSLeaf) {
				leafs.add((VFSLeaf) item);
			}
		}
		if (selectionWithContainer) {
			if (leafs.isEmpty()) {
				wControl.setError(getTranslator().translate(""send.mail.noFileSelected""));
				return null;
			} else {
				setFormWarning(getTranslator().translate(""send.mail.selectionContainsFolder""));
			}
		}
		setFiles(rootContainer, leafs);
		return this;
	}",1
"private final String _decodeShortName(int len) throws IOException
    {
        // note: caller ensures we have enough bytes available
        int outPtr = 0;
        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
        if (outBuf.length < len) { // one minor complication
            outBuf = _textBuffer.expandCurrentSegment(len);
        }
        int inPtr = _inputPtr;
        _inputPtr += len;
        final int[] codes = UTF8_UNIT_CODES;
        final byte[] inBuf = _inputBuffer;

        // First a tight loop for Ascii
        final int end = inPtr + len;
        while (true) {
            int i = inBuf[inPtr] & 0xFF;
            int code = codes[i];
            if (code != 0) {
                break;
            }
            outBuf[outPtr++] = (char) i;
            if (++inPtr == end) {
                return _textBuffer.setCurrentAndReturn(outPtr);
            }
        }

        // But in case there's multi-byte char, use a full loop
        while (inPtr < end) {
            int i = inBuf[inPtr++] & 0xFF;
            int code = codes[i];
            if (code != 0) {
                // trickiest one, need surrogate handling
                switch (code) {
                case 1:
                    i = ((i & 0x1F) << 6) | (inBuf[inPtr++] & 0x3F);
                    break;
                case 2:
                    i = ((i & 0x0F) << 12)
                    | ((inBuf[inPtr++] & 0x3F) << 6)
                    | (inBuf[inPtr++] & 0x3F);
                    break;
                case 3:
                    i = ((i & 0x07) << 18)
                    | ((inBuf[inPtr++] & 0x3F) << 12)
                    | ((inBuf[inPtr++] & 0x3F) << 6)
                    | (inBuf[inPtr++] & 0x3F);
                    // note: this is the codepoint value; need to split, too
                    i -= 0x10000;
                    outBuf[outPtr++] = (char) (0xD800 | (i >> 10));
                    i = 0xDC00 | (i & 0x3FF);
                    break;
                default: // invalid
                    _reportError(""Invalid byte ""+Integer.toHexString(i)+"" in Object name"");
                }
            }
            outBuf[outPtr++] = (char) i;
        }
        return _textBuffer.setCurrentAndReturn(outPtr);
    }",0
"public static byte[] compress(int[] input)
            throws IOException
    {
        int byteSize = input.length * 4;
        if (byteSize < input.length) {
            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, ""input array size is too large: "" + input.length);
        }
        return rawCompress(input, byteSize); // int uses 4 bytes
    }",1
"@Override
    public void updateApplicationByResourceId(String resourceId, ServiceProvider updatedApp, String tenantDomain,
                                              String username) throws IdentityApplicationManagementException {

        validateApplicationConfigurations(updatedApp, tenantDomain, username);

        updatedApp.setApplicationResourceId(resourceId);
        setDisplayNamesOfLocalAuthenticators(updatedApp, tenantDomain);
        Collection<ApplicationResourceManagementListener> listeners =
                ApplicationMgtListenerServiceComponent.getApplicationResourceMgtListeners();
        for (ApplicationResourceManagementListener listener : listeners) {
            if (listener.isEnabled() &&
                    !listener.doPreUpdateApplicationByResourceId(updatedApp, resourceId, tenantDomain, username)) {

                throw buildServerException(""Pre Update application operation of listener: "" + getName(listener) +
                        "" failed for application with resourceId: "" + resourceId);
            }
        }

        try {
            startTenantFlow(tenantDomain);

            ApplicationBasicInfo storedAppInfo = getApplicationBasicInfo(resourceId, tenantDomain);
            if (storedAppInfo == null) {
                String msg = ""Cannot find an application for "" + ""resourceId: "" + resourceId + "" in tenantDomain: ""
                        + tenantDomain;
                throw buildClientException(APPLICATION_NOT_FOUND, msg);
            }

            String updatedAppName = updatedApp.getApplicationName();
            String storedAppName = storedAppInfo.getApplicationName();

            doPreUpdateChecks(storedAppName, updatedApp, tenantDomain, username);

            ApplicationDAO appDAO = ApplicationMgtSystemConfig.getInstance().getApplicationDAO();
            appDAO.updateApplicationByResourceId(resourceId, tenantDomain, updatedApp);

            if (isOwnerUpdateRequest(storedAppInfo.getAppOwner(), updatedApp.getOwner())) {
                // User existence check is already done in appDAO.updateApplicationByResourceId() method.
                assignApplicationRole(updatedApp.getApplicationName(), updatedApp.getOwner().getUserName());
            }

            updateApplicationPermissions(updatedApp, updatedAppName, storedAppName);
        } catch (RegistryException e) {
            String message = ""Error while updating application with resourceId: "" + resourceId + "" in tenantDomain: ""
                    + tenantDomain;
            throw buildServerException(message, e);
        } finally {
            endTenantFlow();
        }

        for (ApplicationResourceManagementListener listener : listeners) {
            if (listener.isEnabled()
                    && !listener.doPostUpdateApplicationByResourceId(updatedApp, resourceId, tenantDomain, username)) {
                log.error(""Post Update application operation of listener: "" + getName(listener) + "" failed for "" +
                        ""application with resourceId: "" + resourceId);
                return;
            }
        }
    }",0
"public void decodeResources(File outDir) throws AndrolibException {
        if (!mApkInfo.hasResources()) {
            return;
        }

        mResTable.loadMainPkg(mApkInfo.getApkFile());

        ResStreamDecoderContainer decoders = new ResStreamDecoderContainer();
        decoders.setDecoder(""raw"", new ResRawStreamDecoder());
        decoders.setDecoder(""9patch"", new Res9patchStreamDecoder());

        AXmlResourceParser axmlParser = new AXmlResourceParser(mResTable);
        decoders.setDecoder(""xml"", new XmlPullStreamDecoder(axmlParser, getResXmlSerializer()));

        ResFileDecoder fileDecoder = new ResFileDecoder(decoders);
        Directory in, out, outRes;

        try {
            out = new FileDirectory(outDir);
            in = mApkInfo.getApkFile().getDirectory();
            outRes = out.createDir(""res"");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }

        ExtMXSerializer xmlSerializer = getResXmlSerializer();
        for (ResPackage pkg : mResTable.listMainPackages()) {

            LOGGER.info(""Decoding file-resources..."");
            for (ResResource res : pkg.listFiles()) {
                fileDecoder.decode(res, in, outRes, mResFileMapping);
            }

            LOGGER.info(""Decoding values */* XMLs..."");
            for (ResValuesFile valuesFile : pkg.listValuesFiles()) {
                generateValuesFile(valuesFile, outRes, xmlSerializer);
            }
            generatePublicXml(pkg, outRes, xmlSerializer);
        }

        AndrolibException decodeError = axmlParser.getFirstError();
        if (decodeError != null) {
            throw decodeError;
        }
    }",1
"public static byte[] shuffle(double[] input) throws IOException {
        if (input.length * 8 < input.length) {
            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, ""input array size is too large: "" + input.length);
        }
        byte[] output = new byte[input.length * 8];
        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);
        assert(numProcessed == input.length * 8);
        return output;
    }",1
"@Override
    public void setOrganizationName(@NonNull ComponentName who, CharSequence text) {
        if (!mHasFeature) {
            return;
        }
        Objects.requireNonNull(who, ""ComponentName is null"");
        final CallerIdentity caller = getCallerIdentity(who);

        text = truncateIfLonger(text, MAX_ORG_NAME_LENGTH);

        synchronized (getLockObject()) {
            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller);
            if (!TextUtils.equals(admin.organizationName, text)) {
                admin.organizationName = (text == null || text.length() == 0)
                        ? null : text.toString();
                saveSettingsLocked(caller.getUserId());
            }
        }
    }",1
"@Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (DBG) {
            log(""onActivityResult: requestCode: "" + requestCode
                    + "", resultCode: "" + resultCode
                    + "", data: "" + data);
        }

        // there are cases where the contact picker may end up sending us more than one
        // request.  We want to ignore the request if we're not in the correct state.
        if (requestCode == VOICEMAIL_PROVIDER_CFG_ID) {
            boolean failure = false;

            // No matter how the processing of result goes lets clear the flag
            if (DBG) log(""mVMProviderSettingsForced: "" + mVMProviderSettingsForced);
            final boolean isVMProviderSettingsForced = mVMProviderSettingsForced;
            mVMProviderSettingsForced = false;

            String vmNum = null;
            if (resultCode != RESULT_OK) {
                if (DBG) log(""onActivityResult: vm provider cfg result not OK."");
                failure = true;
            } else {
                if (data == null) {
                    if (DBG) log(""onActivityResult: vm provider cfg result has no data"");
                    failure = true;
                } else {
                    if (data.getBooleanExtra(SIGNOUT_EXTRA, false)) {
                        if (DBG) log(""Provider requested signout"");
                        if (isVMProviderSettingsForced) {
                            if (DBG) log(""Going back to previous provider on signout"");
                            switchToPreviousVoicemailProvider();
                        } else {
                            final String victim = mVoicemailProviders.getKey();
                            if (DBG) log(""Relaunching activity and ignoring "" + victim);
                            Intent i = new Intent(ACTION_ADD_VOICEMAIL);
                            i.putExtra(IGNORE_PROVIDER_EXTRA, victim);
                            i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                            this.startActivity(i);
                        }
                        return;
                    }
                    vmNum = data.getStringExtra(VM_NUMBER_EXTRA);
                    if (vmNum == null || vmNum.length() == 0) {
                        if (DBG) log(""onActivityResult: vm provider cfg result has no vmnum"");
                        failure = true;
                    }
                }
            }
            if (failure) {
                if (DBG) log(""Failure in return from voicemail provider."");
                if (isVMProviderSettingsForced) {
                    switchToPreviousVoicemailProvider();
                }

                return;
            }
            mChangingVMorFwdDueToProviderChange = isVMProviderSettingsForced;
            final String fwdNum = data.getStringExtra(FWD_NUMBER_EXTRA);

            // TODO: It would be nice to load the current network setting for this and
            // send it to the provider when it's config is invoked so it can use this as default
            final int fwdNumTime = data.getIntExtra(FWD_NUMBER_TIME_EXTRA, 20);

            if (DBG) log(""onActivityResult: cfg result has forwarding number "" + fwdNum);
            saveVoiceMailAndForwardingNumber(mVoicemailProviders.getKey(),
                    new VoicemailProviderSettings(vmNum, fwdNum, fwdNumTime));
            return;
        }

        if (requestCode == VOICEMAIL_PREF_ID) {
            if (resultCode != RESULT_OK) {
                if (DBG) log(""onActivityResult: contact picker result not OK."");
                return;
            }

            Cursor cursor = null;
            try {
                // check if the URI returned by the user belongs to the user
                final int currentUser = UserHandle.getUserId(Process.myUid());
                if (currentUser
                        != ContentProvider.getUserIdFromUri(data.getData(), currentUser)) {

                    if (DBG) {
                        log(""onActivityResult: Contact data of different user, ""
                                + ""cannot access"");
                    }
                    return;
                }
                cursor = getContentResolver().query(data.getData(),
                    new String[] { CommonDataKinds.Phone.NUMBER }, null, null, null);
                if ((cursor == null) || (!cursor.moveToFirst())) {
                    if (DBG) log(""onActivityResult: bad contact data, no results found."");
                    return;
                }
                if (mSubMenuVoicemailSettings != null) {
                    mSubMenuVoicemailSettings.onPickActivityResult(cursor.getString(0));
                } else {
                    Log.w(LOG_TAG, ""VoicemailSettingsActivity destroyed while setting contacts."");
                }
                return;
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
        }

        super.onActivityResult(requestCode, resultCode, data);
    }",1
"@JRubyMethod(name = ""io"", meta = true)
  public static IRubyObject
  parse_io(ThreadContext context,
           IRubyObject klazz,
           IRubyObject data,
           IRubyObject encoding)
  {
    // check the type of the unused encoding to match behavior of CRuby
    if (!(encoding instanceof RubyFixnum)) {
      throw context.getRuntime().newTypeError(""encoding must be kind_of String"");
    }
    final Ruby runtime = context.runtime;
    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);
    ctx.initialize(runtime);
    ctx.setIOInputSource(context, data, runtime.getNil());
    return ctx;
  }",1
"@Override
	public String getRequestPath() {
		return ApplicationInfo.cutPathPrefix(request.getRequestURI());
	}",1
"private void killAllBackgroundProcessesExcept(int minTargetSdk, int maxProcState) {
        if (checkCallingPermission(android.Manifest.permission.KILL_BACKGROUND_PROCESSES)
                != PackageManager.PERMISSION_GRANTED) {
            final String msg = ""Permission Denial: killAllBackgroundProcessesExcept() from pid=""
                    + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid()
                    + "" requires "" + android.Manifest.permission.KILL_BACKGROUND_PROCESSES;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }

        final long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                final ArrayList<ProcessRecord> procs = new ArrayList<>();
                final int NP = mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    final SparseArray<ProcessRecord> apps = mProcessNames.getMap().valueAt(ip);
                    final int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        final ProcessRecord app = apps.valueAt(ia);
                        if (app.removed) {
                            procs.add(app);
                        } else if ((minTargetSdk < 0 || app.info.targetSdkVersion < minTargetSdk)
                                && (maxProcState < 0 || app.setProcState > maxProcState)) {
                            app.removed = true;
                            procs.add(app);
                        }
                    }
                }

                final int N = procs.size();
                for (int i = 0; i < N; i++) {
                    removeProcessLocked(procs.get(i), false, true, ""kill all background except"");
                }
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }",0
"@Override
  public synchronized void close() throws IOException {
    out.close();
  }",0
"public boolean restrictToAdmin(XWikiDocument document)
    {
        boolean updated = false;
        List<Right> rights = List.of(VIEW, EDIT, DELETE);

        if (fixBadlyInitializedRights(document, rights)) {
            updated = true;
        }

        // If some rights have already been set on the document, we consider that it has already been protected 
        // manually.
        if (document.getXObjects(LOCAL_CLASS_REFERENCE).isEmpty()) {
            updated = updated || initializeRights(document, rights);
        }

        return updated;
    }",1
"@Override
    public String getWhereSQL(Select select) {
        StringBuilder sql = new StringBuilder();
        List<Condition> wheres = select.getWheres();
        boolean first = true;
        for (Condition condition : wheres) {
            if (first) {
                sql.append(getWhereStatement(select)).append("" "");
            } else {
                sql.append(AND);
            }
            String str = getConditionSQL(condition);
            sql.append(str);
            first = false;
        }
        return sql.toString();
    }",0
"void initializeHdmiState() {
        boolean plugged = false;
        // watch for HDMI plug messages if the hdmi switch exists
        if (new File(""/sys/devices/virtual/switch/hdmi/state"").exists()) {
            mHDMIObserver.startObserving(""DEVPATH=/devices/virtual/switch/hdmi"");

            final String filename = ""/sys/class/switch/hdmi/state"";
            FileReader reader = null;
            try {
                reader = new FileReader(filename);
                char[] buf = new char[15];
                int n = reader.read(buf);
                if (n > 1) {
                    plugged = 0 != Integer.parseInt(new String(buf, 0, n-1));
                }
            } catch (IOException ex) {
                Slog.w(TAG, ""Couldn't read hdmi state from "" + filename + "": "" + ex);
            } catch (NumberFormatException ex) {
                Slog.w(TAG, ""Couldn't read hdmi state from "" + filename + "": "" + ex);
            } finally {
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException ex) {
                    }
                }
            }
        }
        // This dance forces the code in setHdmiPlugged to run.
        // Always do this so the sticky intent is stuck (to false) if there is no hdmi.
        mHdmiPlugged = !plugged;
        setHdmiPlugged(!mHdmiPlugged);
    }",0
"@Test
  public void setLabelParams() throws Exception {
    assertPlotParam(""ylabel"", ""This is good"");
    assertPlotParam(""ylabel"", "" and so Is this - _ yay"");
    assertInvalidPlotParam(""ylabel"", ""system(%20no%0anewlines"");
    assertInvalidPlotParam(""title"", ""system(%20no%0anewlines"");
    assertInvalidPlotParam(""y2label"", ""system(%20no%0anewlines"");
  }",1
"@Nullable
    private Class<?> classFromName(String className) {
        try {
            return chainingClassLoader.loadClassSafely(className);
        } catch (ClassNotFoundException e) {
            return null;
        } catch (UnsafeClassLoadingAttemptException e) {
            throw new BadRequestException(e.getLocalizedMessage());
        }
    }",1
"@Override
    protected void submit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {
        super.submit(req,rsp);
        JSONObject json = req.getSubmittedForm();

        makeDisabled(req.getParameter(""disable"")!=null);

        jdk = req.getParameter(""jdk"");
        if(req.getParameter(""hasCustomQuietPeriod"")!=null) {
            quietPeriod = Integer.parseInt(req.getParameter(""quiet_period""));
        } else {
            quietPeriod = null;
        }
        if(req.getParameter(""hasCustomScmCheckoutRetryCount"")!=null) {
            scmCheckoutRetryCount = Integer.parseInt(req.getParameter(""scmCheckoutRetryCount""));
        } else {
            scmCheckoutRetryCount = null;
        }
        blockBuildWhenDownstreamBuilding = req.getParameter(""blockBuildWhenDownstreamBuilding"")!=null;
        blockBuildWhenUpstreamBuilding = req.getParameter(""blockBuildWhenUpstreamBuilding"")!=null;

        if(req.hasParameter(""customWorkspace"")) {
            customWorkspace = Util.fixEmptyAndTrim(req.getParameter(""customWorkspace.directory""));
        } else {
            customWorkspace = null;
        }

        if (json.has(""scmCheckoutStrategy""))
            scmCheckoutStrategy = req.bindJSON(SCMCheckoutStrategy.class,
                json.getJSONObject(""scmCheckoutStrategy""));
        else
            scmCheckoutStrategy = null;

        
        if(req.getParameter(""hasSlaveAffinity"")!=null) {
            assignedNode = Util.fixEmptyAndTrim(req.getParameter(""_.assignedLabelString""));
        } else {
            assignedNode = null;
        }
        canRoam = assignedNode==null;

        concurrentBuild = req.getSubmittedForm().has(""concurrentBuild"");

        authToken = BuildAuthorizationToken.create(req);

        setScm(SCMS.parseSCM(req,this));

        for (Trigger t : triggers())
            t.stop();
        triggers = buildDescribable(req, Trigger.for_(this));
        for (Trigger t : triggers)
            t.start(this,true);

        for (Publisher _t : Descriptor.newInstancesFromHeteroList(req, json, ""publisher"", Jenkins.getInstance().getExtensionList(BuildTrigger.DescriptorImpl.class))) {
            BuildTrigger t = (BuildTrigger) _t;
            for (AbstractProject downstream : t.getChildProjects(this)) {
                downstream.checkPermission(BUILD);
            }
        }
    }",1
"public boolean same(XWikiDocument document)
    {
        return document == this.doc || document == this.initialDoc;
    }",0
"private void logSetCrossProfilePackages(ComponentName who, List<String> packageNames) {
        DevicePolicyEventLogger
                .createEvent(DevicePolicyEnums.SET_CROSS_PROFILE_PACKAGES)
                .setAdmin(who)
                .setStrings(packageNames.toArray(new String[packageNames.size()]))
                .write();
    }",0
"private Response attachToPost(Message mess, String filename, InputStream file,  HttpServletRequest request) {
		Identity identity = getIdentity(request);
		if(identity == null) {
			return Response.serverError().status(Status.UNAUTHORIZED).build();
		} else if (!identity.equalsByPersistableKey(mess.getCreator())) {
			if(mess.getModifier() == null || !identity.equalsByPersistableKey(mess.getModifier())) {
				return Response.serverError().status(Status.UNAUTHORIZED).build();
			}
		}

		VFSContainer container = fom.getMessageContainer(mess.getForum().getKey(), mess.getKey());
		VFSItem item = container.resolve(filename);
		VFSLeaf attachment = null;
		if(item == null) {
			attachment = container.createChildLeaf(filename);
		} else {
			filename = VFSManager.rename(container, filename);
			if(filename == null) {
				return Response.serverError().status(Status.NOT_ACCEPTABLE).build();
			}
			attachment = container.createChildLeaf(filename);
		}
		

		try(OutputStream out = attachment.getOutputStream(false)) {
			IOUtils.copy(file, out);
		} catch (IOException e) {
			return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();
		} finally {
			FileUtils.closeSafely(file);
		}
		return Response.ok().build();
	}",1
"public void setCreateUserId(Long createUserId) {
        this.createUserId = createUserId;
    }",1
"@Bean
	public TesterConfig testerConfig() {
		TesterConfig retVal = new TesterConfig();
		retVal
			.addServer()
				.withId(""internal"")
				.withFhirVersion(FhirVersionEnum.DSTU2)
				.withBaseUrl(""http://localhost:8888/fhir"")
				.withName(""Localhost Server"")
				.allowsApiKey()
			.addServer()
				.withId(""hapi"")
				.withFhirVersion(FhirVersionEnum.DSTU2)
				.withBaseUrl(""http://hapi.fhir.org/baseDstu2"")
				.withName(""Public HAPI Test Server"")
				.allowsApiKey()
			.addServer()
				.withId(""home3"")
				.withFhirVersion(FhirVersionEnum.DSTU3)
				.withBaseUrl(""http://hapi.fhir.org/baseDstu3"")
				.withName(""Public HAPI Test Server (STU3)"")
			.addServer()
				.withId(""home"")
				.withFhirVersion(FhirVersionEnum.DSTU2)
				.withBaseUrl(""${serverBase}/baseDstu2"")
				.withName(""Local Tester"");
		return retVal;
	}",1
"private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,
            JavaType type)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        Class<?> enumClass = type.getRawClass();

        BeanDescription beanDesc = config.introspect(type);
        // 24-Sep-2015, bim: a key deserializer is the preferred thing.
        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
        if (des != null) {
            return des;
        } else {
            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.
            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);
            if (custom != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);
            }
            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
            if (valueDesForKey != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);
            }
        }
        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());
        // May have @JsonCreator for static factory method:
        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {
            if (_hasCreatorAnnotation(ctxt, factory)) {
                int argCount = factory.getParameterCount();
                if (argCount == 1) {
                    Class<?> returnType = factory.getRawReturnType();
                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)
                    if (returnType.isAssignableFrom(enumClass)) {
                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'
                        if (factory.getRawParameterType(0) != String.class) {
                            throw new IllegalArgumentException(""Parameter #0 type for factory method (""+factory+"") not suitable, must be java.lang.String"");
                        }
                        if (config.canOverrideAccessModifiers()) {
                            ClassUtil.checkAndFixAccess(factory.getMember(),
                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
                        }
                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);
                    }
                }
                throw new IllegalArgumentException(""Unsuitable method (""+factory+"") decorated with @JsonCreator (for Enum type ""
                        +enumClass.getName()+"")"");
            }
        }
        // Also, need to consider @JsonValue, if one found
        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);
    }",0
"@Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        if (isUserRestricted()) {
            Log.e(TAG, ""This setting isn't available due to user restriction."");
            finish();
            return;
        }

        setLifecycleForAllControllers();

        final Intent intent = getIntent();
        final String action = intent.getAction();
        if (TextUtils.isEmpty(action)) {
            finish();
            return;
        }
        mSubId = intent.getIntExtra(ApnSettings.SUB_ID,
                SubscriptionManager.INVALID_SUBSCRIPTION_ID);

        initApnEditorUi();
        getCarrierCustomizedConfig();

        Uri uri = null;
        if (action.equals(Intent.ACTION_EDIT)) {
            uri = intent.getData();
            if (!uri.isPathPrefixMatch(Telephony.Carriers.CONTENT_URI)) {
                Log.e(TAG, ""Edit request not for carrier table. Uri: "" + uri);
                finish();
                return;
            }
        } else if (action.equals(Intent.ACTION_INSERT)) {
            mCarrierUri = intent.getData();
            if (!mCarrierUri.isPathPrefixMatch(Telephony.Carriers.CONTENT_URI)) {
                Log.e(TAG, ""Insert request not for carrier table. Uri: "" + mCarrierUri);
                finish();
                return;
            }
            mNewApn = true;
            mMvnoTypeStr = intent.getStringExtra(ApnSettings.MVNO_TYPE);
            mMvnoMatchDataStr = intent.getStringExtra(ApnSettings.MVNO_MATCH_DATA);
        } else {
            finish();
            return;
        }

        // Creates an ApnData to store the apn data temporary, so that we don't need the cursor to
        // get the apn data. The uri is null if the action is ACTION_INSERT, that mean there is no
        // record in the database, so create a empty ApnData to represent a empty row of database.
        if (uri != null) {
            mApnData = getApnDataFromUri(uri);
        } else {
            mApnData = new ApnData(sProjection.length);
        }
        final int carrierId = mApnData.getInteger(CARRIER_ID_INDEX,
                TelephonyManager.UNKNOWN_CARRIER_ID);
        mIsCarrierIdApn = (carrierId > TelephonyManager.UNKNOWN_CARRIER_ID);

        final boolean isUserEdited = mApnData.getInteger(EDITED_INDEX,
                Telephony.Carriers.USER_EDITED) == Telephony.Carriers.USER_EDITED;

        Log.d(TAG, ""onCreate: EDITED "" + isUserEdited);
        // if it's not a USER_EDITED apn, check if it's read-only
        if (!isUserEdited && (mApnData.getInteger(USER_EDITABLE_INDEX, 1) == 0
                || apnTypesMatch(mReadOnlyApnTypes, mApnData.getString(TYPE_INDEX)))) {
            Log.d(TAG, ""onCreate: apnTypesMatch; read-only APN"");
            mReadOnlyApn = true;
            disableAllFields();
        } else if (!ArrayUtils.isEmpty(mReadOnlyApnFields)) {
            disableFields(mReadOnlyApnFields);
        }
        // Make sure that a user cannot break carrier id APN matching
        if (mIsCarrierIdApn) {
            disableFieldsForCarrieridApn();
        }

        for (int i = 0; i < getPreferenceScreen().getPreferenceCount(); i++) {
            getPreferenceScreen().getPreference(i).setOnPreferenceChangeListener(this);
        }
    }",1
"private void migrate46(File dataDir, Stack<Integer> versions) {
		for (File file: dataDir.listFiles()) {
			if (file.getName().startsWith(""Settings.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					if (element.elementTextTrim(""key"").equals(""JOB_EXECUTORS"")) {
						Element valueElement = element.element(""value"");
						for (Element executorElement: valueElement.elements()) {
							if (executorElement.getName().contains(""KubernetesExecutor"")) {
								Element serviceAccountElement = executorElement.element(""serviceAccount"");
								if (serviceAccountElement != null)
									serviceAccountElement.detach();
							}
						}
					}
				}
				dom.writeToFile(file, false);
			}
		}
	}",0
"private boolean isDenied() throws IOException {
		SFile securityPath = SecurityUtils.getSecurityPath();
		if (securityPath == null)
			return false;
		return getSanitizedPath().startsWith(securityPath.getSanitizedPath());
	}",0
"@Override
    public boolean inputMethodClientHasFocus(IInputMethodClient client) {
        synchronized (mWindowMap) {
            // The focus for the client is the window immediately below
            // where we would place the input method window.
            int idx = findDesiredInputMethodWindowIndexLocked(false);
            if (idx > 0) {
                // TODO(multidisplay): IMEs are only supported on the default display.
                WindowState imFocus = getDefaultWindowListLocked().get(idx-1);
                if (DEBUG_INPUT_METHOD) {
                    Slog.i(TAG, ""Desired input method target: "" + imFocus);
                    Slog.i(TAG, ""Current focus: "" + mCurrentFocus);
                    Slog.i(TAG, ""Last focus: "" + mLastFocus);
                }
                if (imFocus != null) {
                    // This may be a starting window, in which case we still want
                    // to count it as okay.
                    if (imFocus.mAttrs.type == LayoutParams.TYPE_APPLICATION_STARTING
                            && imFocus.mAppToken != null) {
                        // The client has definitely started, so it really should
                        // have a window in this app token.  Let's look for it.
                        for (int i=0; i<imFocus.mAppToken.windows.size(); i++) {
                            WindowState w = imFocus.mAppToken.windows.get(i);
                            if (w != imFocus) {
                                Log.i(TAG, ""Switching to real app window: "" + w);
                                imFocus = w;
                                break;
                            }
                        }
                    }
                    if (DEBUG_INPUT_METHOD) {
                        Slog.i(TAG, ""IM target client: "" + imFocus.mSession.mClient);
                        if (imFocus.mSession.mClient != null) {
                            Slog.i(TAG, ""IM target client binder: ""
                                    + imFocus.mSession.mClient.asBinder());
                            Slog.i(TAG, ""Requesting client binder: "" + client.asBinder());
                        }
                    }
                    if (imFocus.mSession.mClient != null &&
                            imFocus.mSession.mClient.asBinder() == client.asBinder()) {
                        return true;
                    }
                }
            }

            // Okay, how about this...  what is the current focus?
            // It seems in some cases we may not have moved the IM
            // target window, such as when it was in a pop-up window,
            // so let's also look at the current focus.  (An example:
            // go to Gmail, start searching so the keyboard goes up,
            // press home.  Sometimes the IME won't go down.)
            // Would be nice to fix this more correctly, but it's
            // way at the end of a release, and this should be good enough.
            if (mCurrentFocus != null && mCurrentFocus.mSession.mClient != null
                    && mCurrentFocus.mSession.mClient.asBinder() == client.asBinder()) {
                return true;
            }
        }
        return false;
    }",0
"public String getRealAssetPath(String inode) {
        String _inode = inode;
        String path = """";

        String realPath = Config.getStringProperty(""ASSET_REAL_PATH"", null);
        if (UtilMethods.isSet(realPath) && !realPath.endsWith(java.io.File.separator))
            realPath = realPath + java.io.File.separator;

        String assetPath = Config.getStringProperty(""ASSET_PATH"", DEFAULT_RELATIVE_ASSET_PATH);
        if (UtilMethods.isSet(assetPath) && !assetPath.endsWith(java.io.File.separator))
            assetPath = assetPath + java.io.File.separator;

        path = ((!UtilMethods.isSet(realPath)) ? assetPath : realPath)
                + _inode.charAt(0) + java.io.File.separator + _inode.charAt(1)
                + java.io.File.separator + _inode+ java.io.File.separator + ""fileAsset"" + java.io.File.separator;

        if (!UtilMethods.isSet(realPath))
            return FileUtil.getRealPath(path);
        else
            return path;

    }",1
"public static void extract(ZipFile zipFile, File destDir) throws IOException {
		assert destDir.isDirectory();

		Enumeration<? extends ZipEntry> entries = zipFile.entries();
		while (entries.hasMoreElements()) {
			ZipEntry entry = entries.nextElement();
			writeEntry(zipFile, entry, destDir);
		}
	}",1
"@Override
    public void onPerform(CommandEvent commandEvent) {
        if (!commandEvent.getGuild().getSelfMember().hasPermission(Permission.MANAGE_WEBHOOKS)) {
            Main.getInstance().getCommandManager().sendMessage(""I need the permission `Manage Webhooks` to use this command!"", commandEvent.getChannel(), commandEvent.getInteractionHook());
        }

        if (commandEvent.isSlashCommand()) {
            Main.getInstance().getCommandManager().sendMessage(""This Command doesn't support slash commands yet."", commandEvent.getChannel(), commandEvent.getInteractionHook());
            return;
        }

        if(commandEvent.getArguments().length == 1) {
            if(commandEvent.getArguments()[0].equalsIgnoreCase(""list"")) {
                StringBuilder end = new StringBuilder(""```\n"");

                for(String users : Main.getInstance().getSqlConnector().getSqlWorker().getAllInstagramUsers(commandEvent.getGuild().getId())) {
                    end.append(users).append(""\n"");
                }

                end.append(""```"");

                Main.getInstance().getCommandManager().sendMessage(end.toString(), 10, commandEvent.getChannel(), commandEvent.getInteractionHook());

            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""instagramnotifier list/add/remove"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else if(commandEvent.getArguments().length == 3) {

            if (commandEvent.getMessage().getMentions().getChannels(TextChannel.class).isEmpty() ||
                    !commandEvent.getMessage().getMentions().getChannels(TextChannel.class).get(0).getGuild().getId().equals(commandEvent.getGuild().getId())) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""instagramnotifier add/remove InstagramName #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
                return;
            }

            String name = commandEvent.getArguments()[1];
            if (commandEvent.getArguments()[0].equalsIgnoreCase(""add"")) {
                commandEvent.getMessage().getMentions().getChannels(TextChannel.class).get(0).createWebhook(""Ree6-InstagramNotifier-"" + name).queue(w -> Main.getInstance().getSqlConnector().getSqlWorker().addInstagramWebhook(commandEvent.getGuild().getId(), w.getId(), w.getToken(), name.toLowerCase()));
                Main.getInstance().getCommandManager().sendMessage(""A Instagram Notifier has been created for the User "" + name + ""!"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());

                if (!Main.getInstance().getNotifier().isInstagramUserRegistered(name)) {
                    Main.getInstance().getNotifier().registerInstagramUser(name);
                }
            } else if (commandEvent.getArguments()[0].equalsIgnoreCase(""remove"")) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""instagramnotifier remove InstagramName"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""instagramnotifier add InstagramName #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else if(commandEvent.getArguments().length == 2) {
            String name = commandEvent.getArguments()[1];
            if(commandEvent.getArguments()[0].equalsIgnoreCase(""remove"")) {
                Main.getInstance().getSqlConnector().getSqlWorker().removeInstagramWebhook(commandEvent.getGuild().getId(), name);
                Main.getInstance().getCommandManager().sendMessage(""A Instagram Notifier has been removed from the User "" + name + ""!"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());

                if (Main.getInstance().getNotifier().isInstagramUserRegistered(name)) {
                    Main.getInstance().getNotifier().unregisterInstagramUser(name);
                }
            } else if (commandEvent.getArguments()[0].equalsIgnoreCase(""add"")) {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""instagramnotifier add InstagramName #Channel"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            } else {
                Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""instagramnotifier remove InstagramName"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
            }
        } else {
            Main.getInstance().getCommandManager().sendMessage(""Please use "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(commandEvent.getGuild().getId(), ""chatprefix"").getStringValue() + ""instagramnotifier list/add/remove"", 5, commandEvent.getChannel(), commandEvent.getInteractionHook());
        }
        Main.getInstance().getCommandManager().deleteMessage(commandEvent.getMessage(), commandEvent.getInteractionHook());
    }",1
"CharSequence toCharSequence() {
    return sanitizedJson != null ? sanitizedJson : jsonish;
  }",0
"public static void setThreadDefaultConfig(EngineConfiguration config)
    {
        threadDefaultConfig.set(config);
    }",0
"public static void main(String[] args) {

        // Will serve all static file are under ""/public"" in classpath if the route isn't consumed by others routes.
        staticFiles.location(""/public"");

        get(""/hello"", (request, response) -> {
            return ""Hello World!"";
        });
    }",1
"public char[] getTextCharacters(int[] holderForStartAndLength) {
            String txt = getText();
            char[] chars = null;
            if (txt != null) {
                holderForStartAndLength[0] = 0;
                holderForStartAndLength[1] = txt.length();
                chars = new char[txt.length()];
                txt.getChars(0, txt.length(), chars, 0);
            }
            return chars;
        }",0
"@Override
        public void onAuthenticationHelp(int helpMsgId, CharSequence helpString) {
            handleFingerprintHelp(helpMsgId, helpString.toString());
        }",0
"public static ResourceEvaluation evaluate(File file, String filename) {
		ResourceEvaluation eval = new ResourceEvaluation();
		try {
			ImsManifestFileFilter visitor = new ImsManifestFileFilter();
			Path fPath = PathUtils.visit(file, filename, visitor);
			if(visitor.isValid()) {
				Path realManifestPath = visitor.getManifestPath();
				Path manifestPath = fPath.resolve(realManifestPath);
				
				RootSearcher rootSearcher = new RootSearcher();
				Files.walkFileTree(fPath, EnumSet.noneOf(FileVisitOption.class), 16, rootSearcher);
				if(rootSearcher.foundRoot()) {
					manifestPath = rootSearcher.getRoot().resolve(IMS_MANIFEST);
				} else {
					manifestPath = fPath.resolve(IMS_MANIFEST);
				}
				
				QTI21ContentPackage	cp = new QTI21ContentPackage(manifestPath);
				if(validateImsManifest(cp, new PathResourceLocator(manifestPath.getParent()))) {
					eval.setValid(true);
				} else {
					eval.setValid(false);
				}
			} else {
				eval.setValid(false);
			}
			PathUtils.closeSubsequentFS(fPath);
		} catch (IOException | IllegalArgumentException e) {
			log.error("""", e);
			eval.setValid(false);
		}
		return eval;
	}",1
"@Override
    public IntValues getValues(String tableName, DownSampling downsampling, long startTB, long endTB, Where where,
                               String valueCName, Function function) throws IOException {
        List<KeyValues> whereKeyValues = where.getKeyValues();
        String op;
        switch (function) {
            case Avg:
                op = ""avg"";
                break;
            default:
                op = ""sum"";
        }
        List<String> ids = new ArrayList<>(20);
        StringBuilder whereSql = new StringBuilder();
        if (whereKeyValues.size() > 0) {
            whereSql.append(""("");
            for (int i = 0; i < whereKeyValues.size(); i++) {
                if (i != 0) {
                    whereSql.append("" or "");
                }
                KeyValues keyValues = whereKeyValues.get(i);

                StringBuilder valueCollection = new StringBuilder();
                List<String> values = keyValues.getValues();
                for (int valueIdx = 0; valueIdx < values.size(); valueIdx++) {
                    if (valueIdx != 0) {
                        valueCollection.append("","");
                    }
                    String id = values.get(valueIdx);
                    ids.add(id);
                    valueCollection.append(""'"").append(id).append(""'"");
                }
                whereSql.append(keyValues.getKey()).append("" in ("").append(valueCollection).append("")"");
            }
            whereSql.append("") and "");
        }

        IntValues intValues = new IntValues();
        try (Connection connection = h2Client.getConnection()) {
            try (ResultSet resultSet = h2Client.executeQuery(
                connection,
                ""select "" + Metrics.ENTITY_ID + "" id, "" + op + ""("" + valueCName + "") value from "" + tableName + "" where "" + whereSql + Metrics.TIME_BUCKET + "">= ? and "" + Metrics.TIME_BUCKET + ""<=?"" + "" group by "" + Metrics.ENTITY_ID,
                startTB, endTB
            )) {

                while (resultSet.next()) {
                    KVInt kv = new KVInt();
                    kv.setId(resultSet.getString(""id""));
                    kv.setValue(resultSet.getLong(""value""));
                    intValues.addKVInt(kv);
                }
            }
        } catch (SQLException e) {
            throw new IOException(e);
        }
        return intValues;
    }",0
"@Override
    protected String getWhatToString(int what) {
        switch (what) {
            case CMD_ACCEPT_UNVALIDATED:
                return ""CMD_ACCEPT_UNVALIDATED"";
            case CMD_ADD_KEEPALIVE_PACKET_FILTER_TO_APF:
                return ""CMD_ADD_KEEPALIVE_PACKET_FILTER_TO_APF"";
            case CMD_BLUETOOTH_CONNECTION_STATE_CHANGE:
                return ""CMD_BLUETOOTH_CONNECTION_STATE_CHANGE"";
            case CMD_CONFIG_ND_OFFLOAD:
                return ""CMD_CONFIG_ND_OFFLOAD"";
            case CMD_CONNECTING_WATCHDOG_TIMER:
                return ""CMD_CONNECTING_WATCHDOG_TIMER"";
            case CMD_CONNECT_NETWORK:
                return ""CMD_CONNECT_NETWORK"";
            case CMD_DIAGS_CONNECT_TIMEOUT:
                return ""CMD_DIAGS_CONNECT_TIMEOUT"";
            case CMD_DISCONNECT:
                return ""CMD_DISCONNECT"";
            case CMD_ENABLE_RSSI_POLL:
                return ""CMD_ENABLE_RSSI_POLL"";
            case CMD_INSTALL_PACKET_FILTER:
                return ""CMD_INSTALL_PACKET_FILTER"";
            case CMD_IP_CONFIGURATION_LOST:
                return ""CMD_IP_CONFIGURATION_LOST"";
            case CMD_IP_CONFIGURATION_SUCCESSFUL:
                return ""CMD_IP_CONFIGURATION_SUCCESSFUL"";
            case CMD_IP_REACHABILITY_LOST:
                return ""CMD_IP_REACHABILITY_LOST"";
            case CMD_IP_REACHABILITY_FAILURE:
                return ""CMD_IP_REACHABILITY_FAILURE"";
            case CMD_IPV4_PROVISIONING_FAILURE:
                return ""CMD_IPV4_PROVISIONING_FAILURE"";
            case CMD_IPV4_PROVISIONING_SUCCESS:
                return ""CMD_IPV4_PROVISIONING_SUCCESS"";
            case CMD_NETWORK_STATUS:
                return ""CMD_NETWORK_STATUS"";
            case CMD_ONESHOT_RSSI_POLL:
                return ""CMD_ONESHOT_RSSI_POLL"";
            case CMD_POST_DHCP_ACTION:
                return ""CMD_POST_DHCP_ACTION"";
            case CMD_PRE_DHCP_ACTION:
                return ""CMD_PRE_DHCP_ACTION"";
            case CMD_PRE_DHCP_ACTION_COMPLETE:
                return ""CMD_PRE_DHCP_ACTION_COMPLETE"";
            case CMD_READ_PACKET_FILTER:
                return ""CMD_READ_PACKET_FILTER"";
            case CMD_REASSOCIATE:
                return ""CMD_REASSOCIATE"";
            case CMD_RECONNECT:
                return ""CMD_RECONNECT"";
            case CMD_REMOVE_KEEPALIVE_PACKET_FILTER_FROM_APF:
                return ""CMD_REMOVE_KEEPALIVE_PACKET_FILTER_FROM_APF"";
            case CMD_RESET_SIM_NETWORKS:
                return ""CMD_RESET_SIM_NETWORKS"";
            case CMD_ROAM_WATCHDOG_TIMER:
                return ""CMD_ROAM_WATCHDOG_TIMER"";
            case CMD_RSSI_POLL:
                return ""CMD_RSSI_POLL"";
            case CMD_RSSI_THRESHOLD_BREACHED:
                return ""CMD_RSSI_THRESHOLD_BREACHED"";
            case CMD_SAVE_NETWORK:
                return ""CMD_SAVE_NETWORK"";
            case CMD_SCREEN_STATE_CHANGED:
                return ""CMD_SCREEN_STATE_CHANGED"";
            case CMD_SET_FALLBACK_PACKET_FILTERING:
                return ""CMD_SET_FALLBACK_PACKET_FILTERING"";
            case CMD_SET_SUSPEND_OPT_ENABLED:
                return ""CMD_SET_SUSPEND_OPT_ENABLED"";
            case CMD_START_CONNECT:
                return ""CMD_START_CONNECT"";
            case CMD_START_FILS_CONNECTION:
                return ""CMD_START_FILS_CONNECTION"";
            case CMD_START_IP_PACKET_OFFLOAD:
                return ""CMD_START_IP_PACKET_OFFLOAD"";
            case CMD_START_ROAM:
                return ""CMD_START_ROAM"";
            case CMD_START_RSSI_MONITORING_OFFLOAD:
                return ""CMD_START_RSSI_MONITORING_OFFLOAD"";
            case CMD_STOP_IP_PACKET_OFFLOAD:
                return ""CMD_STOP_IP_PACKET_OFFLOAD"";
            case CMD_STOP_RSSI_MONITORING_OFFLOAD:
                return ""CMD_STOP_RSSI_MONITORING_OFFLOAD"";
            case CMD_UNWANTED_NETWORK:
                return ""CMD_UNWANTED_NETWORK"";
            case CMD_UPDATE_LINKPROPERTIES:
                return ""CMD_UPDATE_LINKPROPERTIES"";
            case CMD_ACCEPT_EAP_SERVER_CERTIFICATE:
                return ""CMD_ACCEPT_EAP_SERVER_CERTIFICATE"";
            case CMD_REJECT_EAP_INSECURE_CONNECTION:
                return ""CMD_REJECT_EAP_SERVER_CERTIFICATE"";
            case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
                return ""SUPPLICANT_STATE_CHANGE_EVENT"";
            case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
                return ""AUTHENTICATION_FAILURE_EVENT"";
            case WifiMonitor.SUP_REQUEST_IDENTITY:
                return ""SUP_REQUEST_IDENTITY"";
            case WifiMonitor.NETWORK_CONNECTION_EVENT:
                return ""NETWORK_CONNECTION_EVENT"";
            case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
                return ""NETWORK_DISCONNECTION_EVENT"";
            case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
                return ""ASSOCIATION_REJECTION_EVENT"";
            case WifiMonitor.ANQP_DONE_EVENT:
                return ""ANQP_DONE_EVENT"";
            case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
                return ""RX_HS20_ANQP_ICON_EVENT"";
            case WifiMonitor.GAS_QUERY_DONE_EVENT:
                return ""GAS_QUERY_DONE_EVENT"";
            case WifiMonitor.HS20_REMEDIATION_EVENT:
                return ""HS20_REMEDIATION_EVENT"";
            case WifiMonitor.HS20_DEAUTH_IMMINENT_EVENT:
                return ""HS20_DEAUTH_IMMINENT_EVENT"";
            case WifiMonitor.HS20_TERMS_AND_CONDITIONS_ACCEPTANCE_REQUIRED_EVENT:
                return ""HS20_TERMS_AND_CONDITIONS_ACCEPTANCE_REQUIRED_EVENT"";
            case WifiMonitor.GAS_QUERY_START_EVENT:
                return ""GAS_QUERY_START_EVENT"";
            case WifiMonitor.MBO_OCE_BSS_TM_HANDLING_DONE:
                return ""MBO_OCE_BSS_TM_HANDLING_DONE"";
            case WifiMonitor.TRANSITION_DISABLE_INDICATION:
                return ""TRANSITION_DISABLE_INDICATION"";
            case WifiP2pServiceImpl.GROUP_CREATING_TIMED_OUT:
                return ""GROUP_CREATING_TIMED_OUT"";
            case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
                return ""P2P_CONNECTION_CHANGED"";
            case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
                return ""DISCONNECT_WIFI_REQUEST"";
            case WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE:
                return ""DISCONNECT_WIFI_RESPONSE"";
            case WifiP2pServiceImpl.SET_MIRACAST_MODE:
                return ""SET_MIRACAST_MODE"";
            case WifiP2pServiceImpl.BLOCK_DISCOVERY:
                return ""BLOCK_DISCOVERY"";
            case WifiMonitor.NETWORK_NOT_FOUND_EVENT:
                return ""NETWORK_NOT_FOUND_EVENT"";
            case WifiMonitor.TOFU_CERTIFICATE_EVENT:
                return ""TOFU_CERTIFICATE_EVENT"";
            default:
                return ""what:"" + what;
        }
    }",1
"private File download(String driverFileUrl, String parentDir) {
        Path parentDirPath = Paths.get(parentDir);
        try {
            Files.createDirectories(parentDirPath);
        } catch (IOException e) {
            log.error(""create directory for driver failed"", e);
            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e);
        }

        // download
        try {
            return restTemplate.execute(driverFileUrl, HttpMethod.GET, null, response -> {
                if (response.getStatusCode().is2xxSuccessful()) {
                    String prefix = System.currentTimeMillis() + """";
                    String originFileName = response.getHeaders().getContentDisposition().getFilename();
                    String filename;
                    if (originFileName == null) {
                        URL url = new URL(driverFileUrl);
                        String nameFromUrl = FilenameUtils.getName(url.getPath());
                        if (StringUtils.endsWith(nameFromUrl, "".jar"")) {
                            filename = prefix + ""-"" + nameFromUrl;
                        } else {
                            filename = prefix + "".jar"";
                        }
                    } else {
                        filename = prefix + ""-"" + originFileName;
                    }
                    File targetFile = Paths.get(parentDir, filename).toFile();
                    FileOutputStream out = new FileOutputStream(targetFile);
                    StreamUtils.copy(response.getBody(), out);
                    IOUtils.closeQuietly(out, ex -> log.error(""close file error"", ex));
                    log.info(""{} download success "", targetFile);
                    return targetFile;
                } else {
                    log.error(""{} download error from {}: {} "", parentDir, driverFileUrl, response);
                    throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(""驱动下载失败：""
                            + response.getStatusCode()
                            + "", ""
                            + response.getStatusText());
                }
            });
        } catch (RestClientException e) {
            String msg = String.format(""download driver from %s to %s failed"", driverFileUrl, parentDir);
            log.error(msg, e);
            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(msg);
        }
    }",1
"@Override
	    public String getHeader(String name) {
	        String value = super.getHeader(name);
	        if (value == null)
	            return null;
	        return cleanXSS(value);
	    }",1
"private boolean isGlobalOrSecureSettingRestrictedForUser(String setting, int userId,
            String value, int callingUid) {
        String restriction;
        switch (setting) {
            case Settings.Secure.LOCATION_MODE:
                // Note LOCATION_MODE will be converted into LOCATION_PROVIDERS_ALLOWED
                // in android.provider.Settings.Secure.putStringForUser(), so we shouldn't come
                // here normally, but we still protect it here from a direct provider write.
                if (String.valueOf(Settings.Secure.LOCATION_MODE_OFF).equals(value)) return false;
                restriction = UserManager.DISALLOW_SHARE_LOCATION;
                break;

            case Settings.Secure.LOCATION_PROVIDERS_ALLOWED:
                // See SettingsProvider.updateLocationProvidersAllowedLocked.  ""-"" is to disable
                // a provider, which should be allowed even if the user restriction is set.
                if (value != null && value.startsWith(""-"")) return false;
                restriction = UserManager.DISALLOW_SHARE_LOCATION;
                break;

            case Settings.Secure.INSTALL_NON_MARKET_APPS:
                if (""0"".equals(value)) return false;
                restriction = UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES;
                break;

            case Settings.Global.ADB_ENABLED:
                if (""0"".equals(value)) return false;
                restriction = UserManager.DISALLOW_DEBUGGING_FEATURES;
                break;

            case Settings.Global.PACKAGE_VERIFIER_ENABLE:
            case Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB:
                if (""1"".equals(value)) return false;
                restriction = UserManager.ENSURE_VERIFY_APPS;
                break;

            case Settings.Global.PREFERRED_NETWORK_MODE:
                restriction = UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS;
                break;

            case Settings.Secure.ALWAYS_ON_VPN_APP:
            case Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN:
                // Whitelist system uid (ConnectivityService) and root uid to change always-on vpn
                if (callingUid == Process.SYSTEM_UID || callingUid == Process.ROOT_UID) {
                    return false;
                }
                restriction = UserManager.DISALLOW_CONFIG_VPN;
                break;

            case Settings.Global.SAFE_BOOT_DISALLOWED:
                if (""1"".equals(value)) return false;
                restriction = UserManager.DISALLOW_SAFE_BOOT;
                break;

            default:
                if (setting != null && setting.startsWith(Settings.Global.DATA_ROAMING)) {
                    if (""0"".equals(value)) return false;
                    restriction = UserManager.DISALLOW_DATA_ROAMING;
                    break;
                }
                return false;
        }

        return mUserManager.hasUserRestriction(restriction, UserHandle.of(userId));
    }",1
"public boolean createCategoryFile(SysSite site, CmsCategory entity, Integer pageIndex, Integer totalPage) {
        if (entity.isOnlyUrl()) {
            categoryService.updateUrl(entity.getId(), entity.getPath(), false);
        } else if (CommonUtils.notEmpty(entity.getPath())) {
            try {
                if (site.isUseStatic() && CommonUtils.notEmpty(entity.getTemplatePath())) {
                    String filePath = createCategoryFile(site, entity, entity.getTemplatePath(), entity.getPath(), pageIndex, totalPage);
                    categoryService.updateUrl(entity.getId(), filePath, true);
                } else {
                    Map<String, Object> model = new HashMap<>();
                    initCategoryUrl(site, entity);
                    model.put(""category"", entity);
                    model.put(AbstractFreemarkerView.CONTEXT_SITE, site);
                    String filePath = FreeMarkerUtils.generateStringByString(entity.getPath(), webConfiguration, model);
                    categoryService.updateUrl(entity.getId(), filePath, false);
                }
            } catch (IOException | TemplateException e) {
                log.error(e.getMessage(), e);
                return false;
            }
            return true;
        }
        return false;

    }",1
"@Override
        public int broadcastIntent(Intent intent,
                IIntentReceiver resultTo,
                String[] requiredPermissions,
                boolean serialized, int userId, int[] appIdAllowList, @Nullable Bundle bOptions) {
            synchronized (ActivityManagerService.this) {
                intent = verifyBroadcastLocked(intent);

                final int callingPid = Binder.getCallingPid();
                final int callingUid = Binder.getCallingUid();
                final long origId = Binder.clearCallingIdentity();
                try {
                    return ActivityManagerService.this.broadcastIntentLocked(null /*callerApp*/,
                            null /*callerPackage*/, null /*callingFeatureId*/, intent,
                            null /*resolvedType*/, resultTo, 0 /*resultCode*/, null /*resultData*/,
                            null /*resultExtras*/, requiredPermissions,
                            null /*excludedPermissions*/, null /*excludedPackages*/,
                            AppOpsManager.OP_NONE, bOptions /*options*/, serialized,
                            false /*sticky*/, callingPid, callingUid, callingUid, callingPid,
                            userId, false /*allowBackgroundStarts*/,
                            null /*tokenNeededForBackgroundActivityStarts*/, appIdAllowList);
                } finally {
                    Binder.restoreCallingIdentity(origId);
                }
            }

        }",0
"public static ProfileParameter fromXML(String xml) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element profileParameterElement = document.getDocumentElement();
        return fromDOM(profileParameterElement);
    }",1
"public Set<ClassDefinition> getClassDefinitions() {
        if (classDefinitions == null) {
            classDefinitions = new HashSet<ClassDefinition>();
        }
        return classDefinitions;
    }",0
"public String[] getRequestingPackages() throws RemoteException {
            final ParceledListSlice list = AppGlobals.getPackageManager()
                    .getPackagesHoldingPermissions(PERM, 0 /*flags*/,
                            ActivityManager.getCurrentUser());
            final List<PackageInfo> pkgs = list.getList();
            if (pkgs == null || pkgs.isEmpty()) return new String[0];
            final int N = pkgs.size();
            final String[] rt = new String[N];
            for (int i = 0; i < N; i++) {
                rt[i] = pkgs.get(i).packageName;
            }
            return rt;
        }",0
"public String getParamFramename() {

        if ((m_paramFrameName != null) && !""null"".equals(m_paramFrameName)) {
            return m_paramFrameName;
        } else {
            return null;
        }
    }",0
"@Override
        public boolean onMediaButtonEvent(Intent mediaButtonEvent) {
            return super.onMediaButtonEvent(mediaButtonEvent);
        }",0
"public static DevModeHandlerImpl getDevModeHandler() {
        return atomicHandler.get();
    }",0
"protected String parseCategory(String entity, String value) {
        Entity rootEntity = MetadataHelper.getEntity(entity);
        Field categoryField = DataListCategory.instance.getFieldOfCategory(rootEntity);
        if (categoryField == null || StringUtils.isBlank(value)) return ""(9=9)"";

        DisplayType dt = EasyMetaFactory.getDisplayType(categoryField);
        value = CommonsUtils.escapeSql(value);

        if (dt == DisplayType.MULTISELECT) {
            return String.format(""%s && %d"", categoryField.getName(), ObjectUtils.toInt(value));
        } else if (dt == DisplayType.N2NREFERENCE) {
            return String.format(
                    ""exists (select recordId from NreferenceItem where ^%s = recordId and belongField = '%s' and referenceId = '%s')"",
                    rootEntity.getPrimaryField().getName(), categoryField.getName(), value);
        } else if (dt == DisplayType.DATETIME || dt == DisplayType.DATE) {
            String s = value + ""0000-01-01 00:00:00"".substring(value.length());
            String e = value + ""0000-12-31 23:59:59"".substring(value.length());
            if (dt == DisplayType.DATE) {
                s = s.split("" "")[0];
                e = e.split("" "")[0];
            }
            return MessageFormat.format(""({0} >= ''{1}'' and {0} <= ''{2}'')"", categoryField.getName(), s, e);
        }  else {
            return String.format(""%s = '%s'"", categoryField.getName(), value);
        }
    }",1
"@TestOnly
    public void submoduleAdd(String repoUrl, String submoduleNameToPutInGitSubmodules, String folder) {
        String[] addSubmoduleWithSameNameArgs = new String[]{""submodule"", ""add"", ""--"", repoUrl, folder};
        String[] changeSubmoduleNameInGitModules = new String[]{""config"", ""--file"", "".gitmodules"", ""--rename-section"", ""submodule."" + folder, ""submodule."" + submoduleNameToPutInGitSubmodules};
        String[] addGitModules = new String[]{""add"", "".gitmodules""};

        runOrBomb(gitWd().withArgs(addSubmoduleWithSameNameArgs));
        runOrBomb(gitWd().withArgs(changeSubmoduleNameInGitModules));
        runOrBomb(gitWd().withArgs(addGitModules));
    }",1
"public Map<OsuProvider, PasspointConfiguration> getMatchingPasspointConfigsForOsuProviders(
            List<OsuProvider> osuProviders) {
        Map<OsuProvider, PasspointConfiguration> matchingPasspointConfigs = new HashMap<>();

        for (OsuProvider osuProvider : osuProviders) {
            Map<String, String> friendlyNamesForOsuProvider = osuProvider.getFriendlyNameList();
            if (friendlyNamesForOsuProvider == null) continue;
            for (PasspointProvider provider : mProviders.values()) {
                PasspointConfiguration passpointConfiguration = provider.getConfig();
                Map<String, String> serviceFriendlyNamesForPpsMo =
                        passpointConfiguration.getServiceFriendlyNames();
                if (serviceFriendlyNamesForPpsMo == null) continue;

                for (Map.Entry<String, String> entry : serviceFriendlyNamesForPpsMo.entrySet()) {
                    String lang = entry.getKey();
                    String friendlyName = entry.getValue();
                    if (friendlyName == null) continue;
                    String osuFriendlyName = friendlyNamesForOsuProvider.get(lang);
                    if (osuFriendlyName == null) continue;
                    if (friendlyName.equals(osuFriendlyName)) {
                        matchingPasspointConfigs.put(osuProvider, passpointConfiguration);
                        break;
                    }
                }
            }
        }
        return matchingPasspointConfigs;
    }",0
"@PostMapping({""/upload/files""})
    @ResponseBody
    public Result uploadV2(HttpServletRequest httpServletRequest) throws URISyntaxException, IOException {
        List<MultipartFile> multipartFiles = new ArrayList<>(8);
        if (standardServletMultipartResolver.isMultipart(httpServletRequest)) {
            MultipartHttpServletRequest multiRequest = (MultipartHttpServletRequest) httpServletRequest;
            Iterator<String> iter = multiRequest.getFileNames();
            int total = 0;
            while (iter.hasNext()) {
                if (total > 5) {
                    return ResultGenerator.genFailResult(""最多上传5张图片"");
                }
                total += 1;
                MultipartFile file = multiRequest.getFile(iter.next());
                BufferedImage bufferedImage = ImageIO.read(file.getInputStream());
                // 只处理图片类型的文件
                if (bufferedImage != null) {
                    multipartFiles.add(file);
                }
            }
        }
        if (CollectionUtils.isEmpty(multipartFiles)) {
            return ResultGenerator.genFailResult(""请选择图片类型的文件上传"");
        }
        if (multipartFiles != null && multipartFiles.size() > 5) {
            return ResultGenerator.genFailResult(""最多上传5张图片"");
        }
        List<String> fileNames = new ArrayList(multipartFiles.size());
        for (int i = 0; i < multipartFiles.size(); i++) {
            String fileName = multipartFiles.get(i).getOriginalFilename();
            String suffixName = fileName.substring(fileName.lastIndexOf("".""));
            //生成文件名称通用方法
            SimpleDateFormat sdf = new SimpleDateFormat(""yyyyMMdd_HHmmss"");
            Random r = new Random();
            StringBuilder tempName = new StringBuilder();
            tempName.append(sdf.format(new Date())).append(r.nextInt(100)).append(suffixName);
            String newFileName = tempName.toString();
            File fileDirectory = new File(Constants.FILE_UPLOAD_DIC);
            //创建文件
            File destFile = new File(Constants.FILE_UPLOAD_DIC + newFileName);
            try {
                if (!fileDirectory.exists()) {
                    if (!fileDirectory.mkdir()) {
                        throw new IOException(""文件夹创建失败,路径为："" + fileDirectory);
                    }
                }
                multipartFiles.get(i).transferTo(destFile);
                fileNames.add(NewBeeMallUtils.getHost(new URI(httpServletRequest.getRequestURL() + """")) + ""/upload/"" + newFileName);
            } catch (IOException e) {
                e.printStackTrace();
                return ResultGenerator.genFailResult(""文件上传失败"");
            }
        }
        Result resultSuccess = ResultGenerator.genSuccessResult();
        resultSuccess.setData(fileNames);
        return resultSuccess;
    }",1
"private String extractLabel(JsonNode node) {
        if (node != null && node.has(LABEL)) {
            return node.get(LABEL).asText();
        }
        return null;
    }",0
"protected String getOnreset() {
		return this.onreset;
	}",0
"public static ObjectNode parse(
            final TomlFactory tomlFactory,
            final IOContext ioContext,
            final Reader reader
    ) throws IOException {
        final TomlFactory factory = tomlFactory == null ? new TomlFactory() : tomlFactory;
        Parser parser = new Parser(factory, ioContext,
                new TomlStreamReadException.ErrorContext(ioContext.contentReference(), null),
                factory.getFormatParserFeatures(), reader);
        try {
            final ObjectNode node = parser.parse();
            assert parser.getNestingDepth() == 0;
            return node;
        } finally {
            parser.lexer.releaseBuffers();
        }
    }",1
"public Column<T, ?> addColumn(String propertyName) {
        return addColumn(propertyName, new TextRenderer());
    }",0
"public void sendSetOnHold(String id) throws Exception {
        mConnectionById.get(id).state = Connection.STATE_HOLDING;
        for (IConnectionServiceAdapter a : mConnectionServiceAdapters) {
            a.setOnHold(id, null /*Session.Info*/);
        }
    }",0
"private void loginRender(Controller controller) throws MalformedURLException {
        HttpServletRequest request = controller.getRequest();
        String url = controller.getRequest().getRequestURL().toString();
        URL tUrl = new URL(url);
        previewField(controller.getRequest());
        controller.getRequest().setAttribute(""redirectFrom"", tUrl.getPath() + (request.getQueryString() != null ? ""?"" + request.getQueryString() : """"));
        controller.render(new FreeMarkerRender(""/admin/login.ftl""));

    }",1
"void setRequestedOrientation(int requestedOrientation) {
        setOrientation(requestedOrientation, this);

        // Push the new configuration to the requested app in case where it's not pushed, e.g. when
        // the request is handled at task level with letterbox.
        if (!getMergedOverrideConfiguration().equals(
                mLastReportedConfiguration.getMergedConfiguration())) {
            ensureActivityConfiguration(0 /* globalChanges */, false /* preserveWindow */);
        }

        mAtmService.getTaskChangeNotificationController().notifyActivityRequestedOrientationChanged(
                task.mTaskId, requestedOrientation);
    }",0
"private boolean isPathWhitelisted(Path pa, PathActionLevel pathActionLevel) {
		var pathWhitelist = configuration.whitelistedPaths();
		if (pathWhitelist.isEmpty())
			return pa.startsWith(configuration.executionPath());
		return pathWhitelist.get().stream().anyMatch(pm -> pm.matchesWithLevel(pa, pathActionLevel));
	}",0
"private Map<String, String> buildGitEnvs(Project project) {
		Map<String, String> environments = new HashMap<>();
		
		ServerConfig serverConfig = OneDev.getInstance(ServerConfig.class);
		String serverUrl;
        if (serverConfig.getHttpPort() != 0)
            serverUrl = ""http://localhost:"" + serverConfig.getHttpPort();
        else 
            serverUrl = ""https://localhost:"" + serverConfig.getHttpsPort();

        SettingManager settingManager = OneDev.getInstance(SettingManager.class);
        environments.put(""ONEDEV_CURL"", settingManager.getSystemSetting().getCurlConfig().getExecutable());
		environments.put(""ONEDEV_URL"", serverUrl);
		environments.put(""ONEDEV_HOOK_TOKEN"", GitUtils.HOOK_TOKEN);
		environments.put(""ONEDEV_USER_ID"", SecurityUtils.getUserId().toString());
		environments.put(""ONEDEV_REPOSITORY_ID"", project.getId().toString());
		return environments;
    }",1
"@Override
    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        if (rejectRMI()) {
            // yes, ideally, this should be short-circuited in the agent auth filter, but keeping this logic here has
            // some advantages:
            //   - it keeps all deprecated RMI logic in one place so it's easier to remove (just remove this class)
            //   - it's 100% reliable by virtue of its proximity to the RMI invocation code and can't be thwarted by
            //     some clever URI encoding to circumvent the uri path test that we would need to write at the filter
            //     level in order to selectively apply this logic to the RMI endpoint and not the JSON API endpoint
            reject(response, SC_GONE, ""This RMI endpoint is disabled."");
            return;
        }

        try {
            RemoteInvocation invocation = readRemoteInvocation(request);

            if (!authorized(request, response, invocation)) {
                return;
            }

            RemoteInvocationResult result = invokeAndCreateResult(invocation, getProxy());
            writeRemoteInvocationResult(request, response, result);
        } catch (ClassNotFoundException ex) {
            throw new NestedServletException(""Class not found during deserialization"", ex);
        }
    }",1
"@Override
        public Connection onCreateIncomingConnection(
                PhoneAccountHandle connectionManagerPhoneAccount, ConnectionRequest request) {
            FakeConnection fakeConnection =  new FakeConnection(
                    mVideoState == INVALID_VIDEO_STATE ? request.getVideoState() : mVideoState,
                    request.getAddress());
            mLatestConnection = fakeConnection;
            if (mCapabilities != NOT_SPECIFIED) {
                fakeConnection.setConnectionCapabilities(mCapabilities);
            }
            if (mProperties != NOT_SPECIFIED) {
                fakeConnection.setConnectionProperties(mProperties);
            }
            // Testing for StatusHints image icon cross user access
            if (request.getExtras() != null) {
                fakeConnection.setStatusHints(
                        request.getExtras().getParcelable(STATUS_HINTS_EXTRA));
            }

            return fakeConnection;
        }",1
"private void showUsingTemplate(
            final VariableHost exporter,
            final String uri,
            final String namespace,
            final boolean includeDoc,
            final Template template,
            final boolean withIndex,
            final PrintWriter out,
            final String... vars
    ) throws IOException {
        final String name = (namespace == null ? ""Global"" : namespace);

        final Map<String, Object> root = new HashMap<String, Object>();
        final DateFormat df = SimpleDateFormat.getDateTimeInstance();
        root.put(""urlPath"", uri);
        root.put(""name"", name);
        root.put(""date"", df.format(new Date()));
        root.put(""includeDoc"", includeDoc);

        final List<Variable> varList;
        if (vars != null && vars.length == 1) {
            final Variable v = exporter.getVariable(vars[0]);
            if (v != null) {
                varList = Lists.newArrayListWithExpectedSize(1);
                addVariable(v, varList);
            } else {
                varList = ImmutableList.of();
            }
        } else {
            varList = Lists.newArrayListWithExpectedSize(vars != null ? vars.length : 256);
            if (vars == null || vars.length == 0) {
                exporter.visitVariables(new VariableVisitor() {
                    public void visit(Variable var) {
                        addVariable(var, varList);
                    }
                });
            } else {
                for (String var : vars) {
                    Variable v = exporter.getVariable(var);
                    if (v != null) {
                        addVariable(v, varList);
                    }
                }
            }
        }
        root.put(""vars"", varList);
        if (withIndex) {
            root.put(""varsIndex"", alphanumericNGramIndexesJSON(varList));
        }

        try {
            template.process(root, out);
        } catch (Exception e) {
            throw new IOException(""template failure"", e);
        }
    }",1
"@Override
    public boolean updateTime(double curTime) throws SVGException
    {
//        if (trackManager.getNumTracks() == 0) return false;
        boolean changeState = super.updateTime(curTime);

        //Get current values for parameters
        StyleAttribute sty = new StyleAttribute();
        boolean shapeChange = false;

        if (getPres(sty.setName(""x"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != x)
            {
                x = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""y"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != y)
            {
                y = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""width"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != width)
            {
                width = newVal;
                shapeChange = true;
            }
        }

        if (getPres(sty.setName(""height"")))
        {
            float newVal = sty.getFloatValueWithUnits();
            if (newVal != height)
            {
                height = newVal;
                shapeChange = true;
            }
        }

        try
        {
            if (getPres(sty.setName(""xlink:href"")))
            {
                URI src = sty.getURIValue(getXMLBase());

                URL newVal = null;
                if (""data"".equals(src.getScheme()))
                {
                    newVal = new URL(null, src.toASCIIString(), new Handler());
                } else if (!diagram.getUniverse().isImageDataInlineOnly())
                {
                    newVal = src.toURL();
                }

                if (newVal != null && !newVal.equals(imageSrc))
                {
                    imageSrc = newVal;
                    shapeChange = true;
                }
            }
        } catch (IllegalArgumentException ie)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Image provided with illegal value for href: \""""
                + sty.getStringValue() + '""', ie);
        } catch (Exception e)
        {
            Logger.getLogger(SVGConst.SVG_LOGGER).log(Level.WARNING,
                ""Could not parse xlink:href"", e);
        }


        if (shapeChange)
        {
            build();
//            diagram.getUniverse().registerImage(imageSrc);
//
//            //Set widths if not set
//            BufferedImage img = diagram.getUniverse().getImage(imageSrc);
//            if (img == null)
//            {
//                xform = new AffineTransform();
//                bounds = new Rectangle2D.Float();
//            }
//            else
//            {
//                if (width == 0) width = img.getWidth();
//                if (height == 0) height = img.getHeight();
//
//                //Determine image xform
//                xform = new AffineTransform();
////                xform.setToScale(this.width / img.getWidth(), this.height / img.getHeight());
////                xform.translate(this.x, this.y);
//                xform.translate(this.x, this.y);
//                xform.scale(this.width / img.getWidth(), this.height / img.getHeight());
//
//                bounds = new Rectangle2D.Float(this.x, this.y, this.width, this.height);
//            }
//
//            return true;
        }

        return changeState || shapeChange;
    }",1
"@Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            LineCursor other = (LineCursor) obj;
            return Objects.equals(uri, other.uri)
                && lineNumber == other.lineNumber
                && Objects.equals(line, other.line)
                && Objects.equals(failure, other.failure);
        }",0
"private JiffleRuntime createRuntimeInstance(RuntimeModel model, Class<? extends JiffleRuntime> runtimeClass, boolean scriptInDocs) throws
            
            it.geosolutions.jaiext.jiffle.JiffleException {
        if (!isCompiled()) {
            throw new it.geosolutions.jaiext.jiffle.JiffleException(""The script has not been compiled"");
        }

        String runtimeSource = createRuntimeSource(model, runtimeClass.getName(), scriptInDocs);
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.log(Level.FINE, ""Jiffle script compiled to:\n\n"" + runtimeSource);    
        }
        try {
            SimpleCompiler compiler = new SimpleCompiler();
            compiler.cook(runtimeSource);

            StringBuilder sb = new StringBuilder();
            sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(
                    it.geosolutions.jaiext.jiffle.JiffleProperties.RUNTIME_PACKAGE_KEY)).append(""."");

            switch (model) {
                case DIRECT:
                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(
                            it.geosolutions.jaiext.jiffle.JiffleProperties.DIRECT_CLASS_KEY));
                    break;

                case INDIRECT:
                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(
                            it.geosolutions.jaiext.jiffle.JiffleProperties.INDIRECT_CLASS_KEY));
                    break;

                default:
                    throw new IllegalArgumentException(""Internal compiler error"");
            }

            Class<?> clazz = compiler.getClassLoader().loadClass(sb.toString());
            JiffleRuntime runtime = (JiffleRuntime) clazz.newInstance();
            runtime.setImageParams(imageParams);
            if (runtime instanceof JiffleIndirectRuntime) {
                ((JiffleIndirectRuntime) runtime).setDestinationBands(destinationBands);
            }
            return runtime;

        } catch (Exception ex) {
            // do not display the source code in indirect runtime exception messages
            if (model == RuntimeModel.INDIRECT) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine(""Runtime source error for source: "" + runtimeSource);
                }
                throw new JiffleException(""Runtime source error"", ex);
            }
            throw new JiffleException(""Runtime source error for source: "" + runtimeSource, ex);
        }
    }",1
"void disposeInputChannel() {
        if (mDeadWindowEventReceiver != null) {
            mDeadWindowEventReceiver.dispose();
            mDeadWindowEventReceiver = null;
        }
        if (mInputChannelToken != null) {
            // Unregister server channel first otherwise it complains about broken channel.
            mWmService.mInputManager.removeInputChannel(mInputChannelToken);
            mWmService.mKeyInterceptionInfoForToken.remove(mInputChannelToken);
            mWmService.mInputToWindowMap.remove(mInputChannelToken);
            mInputChannelToken = null;
        }

        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
        mInputWindowHandle.setToken(null);
    }",0
"@Override
    public void verify(Record record) {
        // 自动只读字段忽略非空检查
        final Set<String> autoReadonlyFields = EasyMetaFactory.getAutoReadonlyFields(entity.getName());

        List<String> notNulls = new ArrayList<>();  // 非空
        List<String> notWells = new ArrayList<>();  // 格式

        // 新建
        if (record.getPrimary() == null) {
            for (Field field : entity.getFields()) {
                if (MetadataHelper.isCommonsField(field)) continue;

                EasyField easyField = EasyMetaFactory.valueOf(field);
                if (easyField.getDisplayType() == DisplayType.SERIES
                        || easyField.getDisplayType() == DisplayType.BARCODE) {
                    continue;
                }

                Object hasVal = record.getObjectValue(field.getName());
                boolean canNull = field.isNullable() || autoReadonlyFields.contains(field.getName());

                if (NullValue.isNull(hasVal)) {
                    if (!canNull) {
                        notNulls.add(easyField.getLabel());
                    }
                } else {
                    if (field.isCreatable()) {
                        if (!patternMatches(easyField, hasVal)) {
                            notWells.add(easyField.getLabel());
                        }
                    } else {
                        if (!isForceCreateable(field)) {
                            log.warn(""Remove non-creatable field : {}"", field);
                            record.removeValue(field.getName());
                        }
                    }
                }
            }
        }
        // 更新
        else {
            for (String fieldName : record.getAvailableFields()) {
                Field field = entity.getField(fieldName);
                if (MetadataHelper.isCommonsField(field)) continue;

                Object hasVal = record.getObjectValue(field.getName());
                boolean canNull = field.isNullable() || autoReadonlyFields.contains(field.getName());

                EasyField easyField = EasyMetaFactory.valueOf(field);
                if (NullValue.isNull(hasVal)) {
                    if (!canNull) {
                        notNulls.add(easyField.getLabel());
                    }
                } else {
                    if (field.isUpdatable()) {
                        if (!patternMatches(easyField, hasVal)) {
                            notWells.add(easyField.getLabel());
                        }
                    } else {
                        log.warn(""Remove non-updatable field : {}"", field);
                        record.removeValue(fieldName);
                    }
                }
            }
        }

        if (!notNulls.isEmpty()) {
            throw new DataSpecificationException(
                    Language.L(""%s 不允许为空"", StringUtils.join(notNulls, "" / "")));
        }
        if (!notWells.isEmpty()) {
            throw new DataSpecificationException(
                    Language.L(""%s 格式不正确"", StringUtils.join(notWells, "" / "")));
        }

        if (safeCheck) removeFieldIfUnSafe(record);

        // TODO 检查引用字段的ID是否正确（是否是其他实体的ID）

    }",1
"@Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        resp.setContentType(""application/json"");
        final PrintWriter out = resp.getWriter();

        HttpSession session = req.getSession(false);

        if (session != null) {
            Subject subject = (Subject) session.getAttribute(""subject"");
            if (subject == null) {
                LOG.warn(""No security subject stored in existing session, invalidating"");
                session.invalidate();
                Helpers.doForbidden(resp);
                return;
            }
            sendResponse(session, subject, out);
            return;
        }

        AccessControlContext acc = AccessController.getContext();
        Subject subject = Subject.getSubject(acc);

        if (subject == null) {
            Helpers.doForbidden(resp);
            return;
        }
        Set<Principal> principals = subject.getPrincipals();

        String username = null;

        if (principals != null) {
            for (Principal principal : principals) {
                if (principal.getClass().getSimpleName().equals(""UserPrincipal"")) {
                    username = principal.getName();
                    LOG.debug(""Authorizing user {}"", username);
                }
            }
        }

        session = req.getSession(true);
        session.setAttribute(""subject"", subject);
        session.setAttribute(""user"", username);
        session.setAttribute(""org.osgi.service.http.authentication.remote.user"", username);
        session.setAttribute(""org.osgi.service.http.authentication.type"", HttpServletRequest.BASIC_AUTH);
        session.setAttribute(""loginTime"", GregorianCalendar.getInstance().getTimeInMillis());
        if (timeout != null) {
            session.setMaxInactiveInterval(timeout);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Http session timeout for user {} is {} sec."", username, session.getMaxInactiveInterval());
        }

        sendResponse(session, subject, out);
    }",1
"private void setOauthBasePath(String basePath) {
    for(Authentication auth : authentications.values()) {
      if (auth instanceof OAuth) {
        ((OAuth) auth).setBasePath(basePath);
      }
    }
  }",0
"@Override
    public State newTileState() {
        State state = new State();
        state.handlesLongClick = false;
        return state;
    }",0
"@Override
    public final boolean contains(CharSequence name, String value) {
        requireNonNull(name, ""name"");
        requireNonNull(value, ""value"");
        final int h = AsciiString.hashCode(name);
        final int i = index(h);
        HeaderEntry e = entries[i];
        while (e != null) {
            if (e.hash == h && keyEquals(e.key, name) &&
                AsciiString.contentEquals(e.value, value)) {
                return true;
            }
            e = e.next;
        }
        return false;
    }",0
"@Override
	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)
	throws IOException {
		Path relativeDir = source.relativize(dir);
		final Path dirToCreate = Paths.get(destDir.toString(), relativeDir.toString());
		checkPath(dirToCreate);
       
        if(!dirToCreate.toFile().exists()) {
        	Files.createDirectory(dirToCreate);
        }
        return FileVisitResult.CONTINUE;
	}",1
"@Override
    public int getLaunchedFromUid(IBinder activityToken) {
        return ActivityClient.getInstance().getLaunchedFromUid(activityToken);
    }",0
"@Override
    public void visit(Modification modification) {
        modifiedFilesJson = new ArrayList<>();

        Map<String, Object> jsonMap = new LinkedHashMap<>();
        jsonMap.put(""user"", modification.getUserDisplayName());
        jsonMap.put(""revision"", modification.getRevision());
        jsonMap.put(""date"", formatISO8601(modification.getModifiedTime()));
        String comment = modification.getComment();
        if (!revision.getMaterial().getMaterialType().equals(TYPE)) {
            comment = commentRenderer.render(comment);
        }
        jsonMap.put(""comment"", comment);
        jsonMap.put(""modifiedFiles"", modifiedFilesJson);

        modificationsJson.add(jsonMap);
    }",1
"@Override
    public int getFrontActivityScreenCompatMode() {
        enforceNotIsolatedCaller(""getFrontActivityScreenCompatMode"");
        synchronized (mGlobalLock) {
            final Task rootTask = getTopDisplayFocusedRootTask();
            final ActivityRecord r = rootTask != null ? rootTask.topRunningActivity() : null;
            if (r == null) {
                return ActivityManager.COMPAT_MODE_UNKNOWN;
            }
            return mCompatModePackages.computeCompatModeLocked(r.info.applicationInfo);
        }
    }",0
"@ApiOperation(value = ""delete Node Operation"")
	@RequestMapping(value = ""/deleteNode"", method = RequestMethod.POST)
	public String deleteNode(@RequestParam(value = ""userId"", required = true) String userId,
			@RequestParam(value = ""solutionId"", required = false) String solutionId,
			@RequestParam(value = ""version"", required = false) String version,
			@RequestParam(value = ""cid"", required = false) String cid,
			@RequestParam(value = ""nodeId"", required = true) String nodeId) {
		logger.debug(EELFLoggerDelegator.debugLogger, "" deleteNode() in SolutionController Begin "");
		String result = """";
		String resultTemplate = ""{\""success\"":\""%s\"", \""errorMessage\"":\""%s\""}"";
		if (null == userId && null == nodeId) {
			result = String.format(resultTemplate, false, ""Mandatory feild(s) missing"");
		} else {
			try {
				boolean deletedNode = solutionService.deleteNode(userId, SanitizeUtils.sanitize(solutionId), version, cid, nodeId);
				if (deletedNode) {
					result = String.format(resultTemplate, true, """");
				} else {
					result = String.format(resultTemplate, false, ""Invalid Node Id – not found"");
				}
			} catch (Exception e) {
				logger.error(EELFLoggerDelegator.errorLogger,
						"" Exception in deleteNode() in SolutionController "", e);
			}
		}
		logger.debug(EELFLoggerDelegator.debugLogger, "" deleteNode() in SolutionController Ends "");
		return result;
	}",1
"@Override
    public void removeChannelListener(ChannelListener listener) {
        if (listener == null) {
            return;
        }

        ChannelListener.validateListener(listener);
        if (this.channelListeners.remove(listener)) {
            if (log.isTraceEnabled()) {
                log.trace(""removeChannelListener({})[{}] removed"", this, listener);
            }
        } else {
            if (log.isTraceEnabled()) {
                log.trace(""removeChannelListener({})[{}] not registered"", this, listener);
            }
        }
    }",0
"private Optional<Style> tryLoadSLD(
            final byte[] bytes, final Integer styleIndex,
            final ClientHttpRequestFactory clientHttpRequestFactory) {
        Assert.isTrue(styleIndex == null || styleIndex > -1,
                      ""styleIndex must be > -1 but was: "" + styleIndex);

        final Style[] styles;
        try {

            // check if the XML is valid
            // this is only done in a separate step to avoid that fatal errors show up in the logs
            // by setting a custom error handler.
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setNamespaceAware(true);
            dbf.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
            DocumentBuilder db = dbf.newDocumentBuilder();
            db.setErrorHandler(new ErrorHandler());
            db.parse(new ByteArrayInputStream(bytes));

            // then read the styles
            final SLDParser sldParser = new SLDParser(CommonFactoryFinder.getStyleFactory());
            sldParser.setOnLineResourceLocator(new DefaultResourceLocator() {
                @Override
                public URL locateResource(final String uri) {
                    try {
                        final URL theUrl = super.locateResource(uri);
                        final URI theUri;
                        if (theUrl != null) {
                            theUri = theUrl.toURI();
                        } else {
                            theUri = URI.create(uri);
                        }
                        if (theUri.getScheme().startsWith(""http"")) {
                            final ClientHttpRequest request = clientHttpRequestFactory.createRequest(
                                    theUri, HttpMethod.GET);
                            return request.getURI().toURL();
                        }
                        return null;
                    } catch (IOException | URISyntaxException e) {
                        return null;
                    }
                }
            });
            sldParser.setInput(new ByteArrayInputStream(bytes));
            styles = sldParser.readXML();

        } catch (Throwable e) {
            return Optional.empty();
        }

        if (styleIndex != null) {
            Assert.isTrue(styleIndex < styles.length, String.format(""There where %s styles in file but "" +
                                                                            ""requested index was: %s"",
                                                                    styles.length, styleIndex + 1));
        } else {
            Assert.isTrue(styles.length < 2, String.format(""There are %s therefore the styleRef must "" +
                                                                   ""contain an index identifying the style."" +
                                                                   ""  The index starts at 1 for the first "" +
                                                                   ""style.\n"" +
                                                                   ""\tExample: thinline.sld##1"",
                                                           styles.length));
        }

        if (styleIndex == null) {
            return Optional.of(styles[0]);
        } else {
            return Optional.of(styles[styleIndex]);
        }
    }",1
"private static void processZipStream(File dir, InputStream inputStream) throws IOException
   {
      String canonicalDestinationDirPath = dir.getCanonicalPath();
      ZipInputStream zip = new ZipInputStream(inputStream);
      while (true)
      {
         ZipEntry entry = zip.getNextEntry();
         if (entry == null)
         {
            break;
         }

         File file = new File(dir, entry.getName());

         // https://snyk.io/research/zip-slip-vulnerability
         String canonicalDestinationFile = file.getCanonicalPath();
         if (!canonicalDestinationFile.startsWith(canonicalDestinationDirPath + File.separator))
         {
            throw new IOException(""Entry is outside of the target dir: "" + entry.getName());
         }

         if (entry.isDirectory())
         {
            FileHelper.mkdirsQuietly(file);
            continue;
         }

         File parent = file.getParentFile();
         if (parent != null)
         {
            FileHelper.mkdirsQuietly(parent);
         }

         FileOutputStream fos = new FileOutputStream(file);
         byte[] bytes = new byte[1024];
         int length;
         while ((length = zip.read(bytes)) >= 0)
         {
            fos.write(bytes, 0, length);
         }
         fos.close();
      }
   }",1
"@Override
    protected void internalSetDataProvider(DataProvider<T, ?> dataProvider) {
        super.internalSetDataProvider(dataProvider);
        for (Column<T, ?> column : getColumns()) {
            column.updateSortable();
        }
    }",0
"List<String> getRawCommandLine( String executableParameter, String... argumentsParameter )
    {
        List<String> commandLine = new ArrayList<String>();
        StringBuilder sb = new StringBuilder();

        if ( executableParameter != null )
        {
            String preamble = getExecutionPreamble();
            if ( preamble != null )
            {
                sb.append( preamble );
            }

            if ( isQuotedExecutableEnabled() )
            {
                sb.append( quoteOneItem( executableParameter, true ) );
            }
            else
            {
                sb.append( executableParameter );
            }
        }
        for ( String argument : argumentsParameter )
        {
            if ( sb.length() > 0 )
            {
                sb.append( ' ' );
            }

            if ( isQuotedArgumentsEnabled() )
            {
                sb.append( quoteOneItem( argument, false ) );
            }
            else
            {
                sb.append( argument );
            }
        }

        commandLine.add( sb.toString() );

        return commandLine;
    }",1
"public ChannelFuture getSSLEngineInboundCloseFuture() {
        return sslEngineCloseFuture;
    }",0
"private void parse(UserRequest ureq) {
		String[] sFiles = ureq.getHttpReq().getParameterValues(FORM_ID);
		if (sFiles == null || sFiles.length == 0) {
			return;
		}
		List<VFSItem> items = currentContainer.getItems();
		if(items != null && !items.isEmpty()) {
			Set<String> itemNames =  items.stream()
					.map(VFSItem::getName)
					.collect(Collectors.toSet());
			for(String sFile:sFiles) {
				if(itemNames.contains(sFile)) {
					files.add(sFile);
				}
			}
		}
	}",1
"@Override
    public String render(XWikiContext context) throws XWikiException
    {
        XWikiDocument doc = context.getDoc();

        synchronized (doc) {
            XWikiForm form = context.getForm();

            XWikiDocument cdoc = (XWikiDocument) context.get(""cdoc"");
            if (cdoc == null) {
                cdoc = doc;
            }

            EditForm peform = (EditForm) form;

            XWikiDocument doc2 = doc.clone();
            context.put(""doc"", doc2);

            String parent = peform.getParent();
            if (parent != null) {
                doc2.setParent(parent);
            }
            String creator = peform.getCreator();
            if (creator != null) {
                doc2.setCreator(creator);
            }
            String defaultLanguage = peform.getDefaultLanguage();
            if ((defaultLanguage != null) && !defaultLanguage.equals("""")) {
                doc2.setDefaultLanguage(defaultLanguage);
            }
            if (doc2.getDefaultLanguage().equals("""")) {
                doc2.setDefaultLanguage(context.getWiki().getLanguagePreference(context));
            }
            try {
                readFromTemplate(doc2, peform.getTemplate(), context);
            } catch (XWikiException e) {
                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {
                    return ""docalreadyexists"";
                }
            }

            if (doc == cdoc) {
                context.put(""cdoc"", doc2);
            } else {
                XWikiDocument cdoc2 = cdoc.clone();
                readFromTemplate(cdoc2, peform.getTemplate(), context);
                context.put(""cdoc"", cdoc2);
            }

            doc2.readFromForm((EditForm) form, context);

            // Set the current user as creator, author and contentAuthor when the edited document is newly created
            // to avoid using XWikiGuest instead (because those fields were not previously initialized).
            // This is needed for the script right, as guest doesn't have it and this would block the execution of
            // scripts in newly created documents even if the user creating the document has the right.
            if (doc2.isNew()) {
                doc2.setCreatorReference(context.getUserReference());
                doc2.setAuthorReference(context.getUserReference());
                doc2.setContentAuthorReference(context.getUserReference());
            }

            /* Setup a lock */
            try {
                XWikiLock lock = doc.getLock(context);
                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {
                    doc.setLock(context.getUser(), context);
                }
            } catch (Exception e) {
                // Lock should never make XWiki fail
                // But we should log any related information
                LOGGER.error(""Exception while setting up lock"", e);
            }
        }

        // Make sure object property fields are displayed in edit mode.
        // See XWikiDocument#display(String, BaseObject, XWikiContext)
        context.put(""display"", ""edit"");

        return ""inline"";
    }",1
"public Date getCreateTime() {
        return createTime;
    }",1
"public void addPermission(TypePermission permission) {
        if (securityMapper != null) {
            securityMapper.addPermission(permission);
        }
    }",0
"@Override
        public void onServiceConnected(ComponentName component, IBinder service) {
            if (component.equals(
                new ComponentName(AuthenticatorActivity.this, OperationsService.class)
            )) {
                mOperationsServiceBinder = (OperationsServiceBinder) service;

                Uri data = getIntent().getData();
                if (data != null && data.toString().startsWith(getString(R.string.login_data_own_scheme))) {
                    try {
                        String prefix = getString(R.string.login_data_own_scheme) + PROTOCOL_SUFFIX + ""login/"";
                        LoginUrlInfo loginUrlInfo = parseLoginDataUrl(prefix, data.toString());

                        mServerInfo.mBaseUrl = AuthenticatorUrlUtils.normalizeUrlSuffix(loginUrlInfo.serverAddress);
                        webViewUser = loginUrlInfo.username;
                        webViewPassword = loginUrlInfo.password;
                        doOnResumeAndBound();
                        checkOcServer();
                    } catch (Exception e) {
                        mServerStatusIcon = R.drawable.ic_alert;
                        mServerStatusText = getString(R.string.qr_could_not_be_read);
                        showServerStatus();
                    }
                } else {
                    doOnResumeAndBound();
                }
            }
        }",1
"@Override
    public ParcelFileDescriptor getLifeMonitor() {
        if (!isCallerShell()) {
            throw new SecurityException(""Only shell can call it"");
        }
        synchronized (mProcLock) {
            try {
                if (mLifeMonitorFds == null) {
                    mLifeMonitorFds = ParcelFileDescriptor.createPipe();
                }
                // The returned FD will be closed, but we want to keep our reader open,
                // so return a dup instead.
                return mLifeMonitorFds[0].dup();
            } catch (IOException e) {
                Slog.w(TAG, ""Unable to create pipe"", e);
                return null;
            }
        }
    }",0
"public UploadFileResponse getCloudUrl(String contextPath, String uri, String finalFilePath, HttpServletRequest request) {
        UploadFileResponse uploadFileResponse = new UploadFileResponse();
        // try push to cloud
        Map<String, String[]> map = new HashMap<>();
        map.put(""fileInfo"", new String[]{finalFilePath + "","" + uri});
        map.put(""name"", new String[]{""uploadService""});
        String url;
        try {
            List<Map> urls = HttpUtil.getInstance().sendGetRequest(Constants.pluginServer + ""/service"", map
                    , new HttpJsonArrayHandle<Map>(), PluginHelper.genHeaderMapByRequest(request, AdminTokenThreadLocal.getUser())).getT();
            if (urls != null && !urls.isEmpty()) {
                url = (String) urls.get(0).get(""url"");
                if (!url.startsWith(""https://"") && !url.startsWith(""http://"")) {
                    String tUrl = url;
                    if (!url.startsWith(""/"")) {
                        tUrl = ""/"" + url;
                    }
                    url = contextPath + tUrl;
                }
            } else {
                url = contextPath + uri;
            }
        } catch (Exception e) {
            url = contextPath + uri;
            LOGGER.error(e);
        }
        uploadFileResponse.setUrl(url);
        return uploadFileResponse;
    }",1
"private void fixUpIncomingShortcutInfo(@NonNull ShortcutInfo shortcut, boolean forUpdate) {
        fixUpIncomingShortcutInfo(shortcut, forUpdate, /*forPinRequest=*/ false);
    }",0
"private void sendForbidden(HttpExchange pExchange, SecurityException securityException) throws IOException {
        String response = ""403 (Forbidden)\n"";
        if (securityException != null && securityException.getMessage() != null) {
            response += ""\n"" + securityException.getMessage() + ""\n"";
        }
        pExchange.sendResponseHeaders(403, response.length());
        OutputStream os = pExchange.getResponseBody();
        os.write(response.getBytes());
        os.close();
    }",0
"@SuppressFBWarnings(""SQL_INJECTION_JPA"")
    // The only parameter is entityName(), which is limited to either the simple class name of the entity, or its annotation
    @Transactional
    @Override
    public <E extends KrailEntity<ID, VER>> long count(@Nonnull Class<E> entityClass) {
        checkNotNull(entityClass);
        EntityManager entityManager = entityManagerProvider.get();
        Query query = entityManager.createQuery(""SELECT COUNT(c) FROM "" + entityName(entityClass) + "" c"");
        return (long) query.getSingleResult();
    }",1
"public XWikiVersioningStoreInterface getVersioningStore(XWikiContext context)
    {
        return context.getWiki().getVersioningStore();
    }",0
"public static String getResourcePath() {
        return Jenkins.RESOURCE_PATH;
    }",0
"@Override
    public PropertiesRequest getRequestedFields( InputStream in ) {
		final Set<QName> set = new LinkedHashSet<QName>();
        try {
            ByteArrayOutputStream bout = new ByteArrayOutputStream();
            StreamUtils.readTo( in, bout, false, true );
            byte[] arr = bout.toByteArray();
            if( arr.length > 1 ) {
                ByteArrayInputStream bin = new ByteArrayInputStream( arr );
                XMLReader reader = XMLReaderFactory.createXMLReader();
				reader.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false);
				// https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing
				reader.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
				reader.setFeature(""http://xml.org/sax/features/external-general-entities"", false);
                PropFindSaxHandler handler = new PropFindSaxHandler();
                reader.setContentHandler( handler );
                try {
                    reader.parse( new InputSource( bin ) );
                    if( handler.isAllProp() ) {
                        return new PropertiesRequest();
                    } else {
                        set.addAll( handler.getAttributes().keySet() );
                    }
                } catch( IOException e ) {
                    log.warn( ""exception parsing request body"", e );
                    // ignore
                } catch( SAXException e ) {
                    log.warn( ""exception parsing request body"", e );
                    // ignore
                }
            }
        } catch( Exception ex ) {
			// There's a report of an exception being thrown here by IT Hit Webdav client
			// Perhaps we can just log the error and return an empty set. Usually this
			// class is wrapped by the MsPropFindRequestFieldParser which will use a default
			// set of properties if this returns an empty set
			log.warn(""Exception parsing PROPFIND request fields. Returning empty property set"", ex);
            //throw new RuntimeException( ex );
        }
		return PropertiesRequest.toProperties(set);
    }",1
"@Override // Binder call
        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (mContext.checkCallingOrSelfPermission(Manifest.permission.DUMP)
                    != PackageManager.PERMISSION_GRANTED) {
                pw.println(""Permission Denial: can't dump Fingerprint from from pid=""
                        + Binder.getCallingPid()
                        + "", uid="" + Binder.getCallingUid());
                return;
            }

            final long ident = Binder.clearCallingIdentity();
            try {
                dumpInternal(pw);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }",0
"protected void initialize() throws IOException {
		//name on a best-effort basis
		name = null;
		requestType = null;

		final HttpServletRequest request = (HttpServletRequest) getRequest();
		final String contentType = request.getContentType();
		if (contentType == null) {
			//don't know how to handle this content type
			return;
		}

		if (!""POST"".equalsIgnoreCase(request.getMethod())) {
			//no payload
			return;
		}

		//Try look for name in payload on a best-effort basis...
		try {
			if (contentType.startsWith(""text/x-gwt-rpc"")) {
				//parse GWT-RPC method name
				name = parseGwtRpcMethodName(getBufferedInputStream(), getCharacterEncoding());
				requestType = ""GWT-RPC"";
			} else if (contentType.startsWith(""application/soap+xml"") //SOAP 1.2
					|| contentType.startsWith(""text/xml"") //SOAP 1.1
							&& request.getHeader(""SOAPAction"") != null) {
				//parse SOAP method name
				name = parseSoapMethodName(getBufferedInputStream(), getCharacterEncoding());
				requestType = ""SOAP"";
			} else {
				//don't know how to name this request based on payload
				//(don't parse if text/xml for XML-RPC, because it is obsolete)
				name = null;
				requestType = null;
			}
		} catch (final Exception e) {
			LOG.debug(""Error trying to parse payload content for request name"", e);

			//best-effort - couldn't figure it out
			name = null;
			requestType = null;
		} finally {
			//reset stream so application is unaffected
			resetBufferedInputStream();
		}
	}",0
"public boolean hasPermissionForActivity(Intent intent, String srcPackage) {
        // b/270152142
        if (Intent.ACTION_CHOOSER.equals(intent.getAction())) {
            final Bundle extras = intent.getExtras();
            if (extras == null) {
                return true;
            }
            // If given intent is ACTION_CHOOSER, verify srcPackage has permission over EXTRA_INTENT
            intent = (Intent) extras.getParcelable(Intent.EXTRA_INTENT);
            if (intent == null) {
                return true;
            }
        }
        ResolveInfo target = mPm.resolveActivity(intent, 0);
        if (target == null) {
            // Not a valid target
            return false;
        }
        if (TextUtils.isEmpty(target.activityInfo.permission)) {
            // No permission is needed
            return true;
        }
        if (TextUtils.isEmpty(srcPackage)) {
            // The activity requires some permission but there is no source.
            return false;
        }

        // Source does not have sufficient permissions.
        if(mPm.checkPermission(target.activityInfo.permission, srcPackage) !=
                PackageManager.PERMISSION_GRANTED) {
            return false;
        }

        // On M and above also check AppOpsManager for compatibility mode permissions.
        if (TextUtils.isEmpty(AppOpsManager.permissionToOp(target.activityInfo.permission))) {
            // There is no app-op for this permission, which could have been disabled.
            return true;
        }

        // There is no direct way to check if the app-op is allowed for a particular app. Since
        // app-op is only enabled for apps running in compatibility mode, simply block such apps.

        try {
            return mPm.getApplicationInfo(srcPackage, 0).targetSdkVersion >= Build.VERSION_CODES.M;
        } catch (NameNotFoundException e) { }

        return false;
    }",1
"public AutoCloseTagResponse doTagComplete(DOMDocument xmlDocument, Position position) {
		return doTagComplete(xmlDocument, position, NULL_CHECKER);
	}",0
"private void validateNonPartitionTopicName(String topicName) {
        if (topicName.contains(TopicName.PARTITIONED_TOPIC_SUFFIX)) {
            try {
                // First check if what's after suffix ""-partition-"" is number or not, if not number then can create.
                int partitionIndex = topicName.indexOf(TopicName.PARTITIONED_TOPIC_SUFFIX);
                long suffix = Long.parseLong(topicName.substring(partitionIndex
                        + TopicName.PARTITIONED_TOPIC_SUFFIX.length()));
                TopicName partitionTopicName = TopicName.get(domain(),
                        namespaceName, topicName.substring(0, partitionIndex));
                PartitionedTopicMetadata metadata = getPartitionedTopicMetadata(partitionTopicName, false, false);

                // Partition topic index is 0 to (number of partition - 1)
                if (metadata.partitions > 0 && suffix >= (long) metadata.partitions) {
                    log.warn(""[{}] Can't create topic {} with \""-partition-\"" followed by""
                                    + "" a number smaller then number of partition of partitioned topic {}."",
                            clientAppId(), topicName, partitionTopicName.getLocalName());
                    throw new RestException(Status.PRECONDITION_FAILED,
                            ""Can't create topic "" + topicName + "" with \""-partition-\"" followed by""
                                    + "" a number smaller then number of partition of partitioned topic ""
                                    + partitionTopicName.getLocalName());
                } else if (metadata.partitions == 0) {
                    log.warn(""[{}] Can't create topic {} with \""-partition-\"" followed by""
                                    + "" numeric value if there isn't a partitioned topic {} created."",
                            clientAppId(), topicName, partitionTopicName.getLocalName());
                    throw new RestException(Status.PRECONDITION_FAILED,
                            ""Can't create topic "" + topicName + "" with \""-partition-\"" followed by""
                                    + "" numeric value if there isn't a partitioned topic ""
                                    + partitionTopicName.getLocalName() + "" created."");
                }
                // If there is a  partitioned topic with the same name and numeric suffix is smaller than the
                // number of partition for that partitioned topic, validation will pass.
            } catch (NumberFormatException e) {
                // Do nothing, if value after partition suffix is not pure numeric value,
                // as it can't conflict if user want to create partitioned topic with same
                // topic name prefix in the future.
            }
        }
    }",0
"private static void replaceLang(JSONObject item) {
        String text = item.getString(""text"");
        item.put(""text"", Language.L(text));
    }",0
"private void handleTrialConnectResult(Map<String, List<String>> requestHeader,
                                          ConnectTask connectTask,
                                          FileDownloadConnection connection)
            throws IOException, RetryDirectly, IllegalArgumentException,
            FileDownloadSecurityException {
        final int id = model.getId();
        final int code = connection.getResponseCode();

        acceptPartial = FileDownloadUtils.isAcceptRange(code, connection);
        final boolean onlyFromBeginning = (code == HttpURLConnection.HTTP_OK
                || code == HttpURLConnection.HTTP_CREATED
                || code == FileDownloadConnection.NO_RESPONSE_CODE);

        final String oldEtag = model.getETag();
        String newEtag = FileDownloadUtils.findEtag(id, connection);

        // handle whether need retry because of etag is overdue
        boolean isPreconditionFailed = false;
        do {
            if (code == HttpURLConnection.HTTP_PRECON_FAILED) {
                isPreconditionFailed = true;
                break;
            }

            if (oldEtag != null && !oldEtag.equals(newEtag)) {
                // etag changed.
                if (onlyFromBeginning || acceptPartial) {
                    // 200 or 206
                    isPreconditionFailed = true;
                    break;
                }
            }

            if (code == HttpURLConnection.HTTP_CREATED && connectTask.isRangeNotFromBeginning()) {
                // The request has been fulfilled and has resulted in one or more new resources
                // being created. mark this case is precondition failed for
                // 1. checkout whether accept partial
                // 2. 201 means new resources so range must be from beginning otherwise it can't
                // match local range.
                isPreconditionFailed = true;
                break;
            }

            if (code == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE) {
                if (model.getSoFar() > 0) {
                    // On the first connection range not satisfiable, there must something wrong,
                    // so have to retry.
                    isPreconditionFailed = true;
                    break;
                } else {
                    // range is right, but get 416
                    if (!isNeedForceDiscardRange) {
                        // if range is still added, but range is right with 416 response, so we
                        // discard range on header and try again
                        isNeedForceDiscardRange = true;
                        isPreconditionFailed = true;
                    }
                }
            }

        } while (false);


        if (isPreconditionFailed) {
            // the file on remote is changed
            if (isResumeAvailableOnDB) {
                FileDownloadLog.w(this, ""there is precondition failed on this request[%d] ""
                                + ""with old etag[%s]、new etag[%s]、response code is %d"",
                        id, oldEtag, newEtag, code);
            }

            database.removeConnections(model.getId());
            FileDownloadUtils.deleteTaskFiles(model.getTargetFilePath(), model.getTempFilePath());
            isResumeAvailableOnDB = false;

            if (oldEtag != null && oldEtag.equals(newEtag)) {
                FileDownloadLog.w(this, ""the old etag[%s] is the same to the new etag[%s], ""
                                + ""but the response status code is %d not Partial(206), so wo have""
                                + "" to start this task from very beginning for task[%d]!"",
                        oldEtag, newEtag, code, id);
                newEtag = null;
            }

            model.setSoFar(0);
            model.setTotal(0);
            model.setETag(newEtag);
            model.resetConnectionCount();

            database.updateOldEtagOverdue(id, model.getETag(), model.getSoFar(), model.getTotal(),
                    model.getConnectionCount());

            // retry to check whether support partial or not.
            throw new RetryDirectly();
        }

        redirectedUrl = connectTask.getFinalRedirectedUrl();
        if (acceptPartial || onlyFromBeginning) {
            final long totalLength = FileDownloadUtils.findInstanceLengthForTrial(connection);

            // update model
            String fileName = null;
            if (model.isPathAsDirectory()) {
                // filename
                fileName = FileDownloadUtils.findFilename(connection, model.getUrl());
            }
            isChunked = (totalLength == TOTAL_VALUE_IN_CHUNKED_RESOURCE);

            // callback
            statusCallback.onConnected(isResumeAvailableOnDB && acceptPartial,
                    totalLength, newEtag, fileName);

        } else {
            throw new FileDownloadHttpException(code,
                    requestHeader, connection.getResponseHeaderFields());
        }
    }",1
"public String getCssClass() {
			return cssClass;
		}",0
"public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,
            String accessToken, String orgName, String moduleName, String version, Path baloPath) {
        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,
                                                           proxyPassword);
        conn.setInstanceFollowRedirects(false);
        setRequestMethod(conn, Utils.RequestMethod.POST);

        // Set headers
        conn.setRequestProperty(HttpHeaders.AUTHORIZATION, ""Bearer "" + accessToken);
        conn.setRequestProperty(PUSH_ORGANIZATION, orgName);
        conn.setRequestProperty(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM);

        conn.setDoOutput(true);
        conn.setChunkedStreamingMode(BUFFER_SIZE);

        try (DataOutputStream outputStream = new DataOutputStream(conn.getOutputStream())) {
            // Send balo content by 1 kb chunks
            byte[] buffer = new byte[BUFFER_SIZE];
            int count;
            try (ProgressBar progressBar = new ProgressBar(
                    orgName + ""/"" + moduleName + "":"" + version + "" [project repo -> central]"",
                    getTotalFileSizeInKB(baloPath), 1000, outStream, ProgressBarStyle.ASCII, "" KB"", 1);
                    FileInputStream fis = new FileInputStream(baloPath.toFile())) {
                while ((count = fis.read(buffer)) > 0) {
                    outputStream.write(buffer, 0, count);
                    outputStream.flush();
                    progressBar.stepBy((long) NO_OF_BYTES);
                }
            }
        } catch (IOException e) {
            throw ErrorUtil.createCommandException(""error occurred while uploading balo to central: "" + e.getMessage());
        }

        handleResponse(conn, orgName, moduleName, version);
        Authenticator.setDefault(null);
    }",1
"@Override
    public String toString() {
        return name;
    }",0
"public URI addQueryParamsToURI(URI uri, List<Property> allQueryParams, boolean encodeParamsToggle) {
        UriComponentsBuilder uriBuilder = UriComponentsBuilder.newInstance();
        uriBuilder.uri(uri);

        if (allQueryParams != null) {
            for (Property queryParam : allQueryParams) {
                String key = queryParam.getKey();
                if (isNotEmpty(key)) {
                    if (encodeParamsToggle) {
                        uriBuilder.queryParam(
                                URLEncoder.encode(key, StandardCharsets.UTF_8),
                                URLEncoder.encode((String) queryParam.getValue(), StandardCharsets.UTF_8)
                        );
                    } else {
                        uriBuilder.queryParam(
                                key,
                                queryParam.getValue()
                        );
                    }
                }
            }
        }

        return uriBuilder.build(true).toUri();
    }",1
"@Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof ClassPathResource) {
            ClassPathResource otherRes = (ClassPathResource) obj;

            ClassLoader thisLoader = this.classLoader;
            ClassLoader otherLoader = otherRes.classLoader;

            return (this.path.equals(otherRes.path) &&
                    thisLoader.equals(otherLoader) &&
                    this.clazz.equals(otherRes.clazz));
        }
        return false;
    }",1
"@Override  // NotificationData.Environment
    public boolean isNotificationForCurrentProfiles(StatusBarNotification n) {
        final int thisUserId = mCurrentUserId;
        final int notificationUserId = n.getUserId();
        if (DEBUG && MULTIUSER_DEBUG) {
            Log.v(TAG, String.format(""%s: current userid: %d, notification userid: %d"",
                    n, thisUserId, notificationUserId));
        }
        return isCurrentProfile(notificationUserId);
    }",0
"private int getUserProvisioningState(int userHandle) {
        return getUserData(userHandle).mUserProvisioningState;
    }",0
"public void setFrozenColumnCount(int numberOfColumns) {
        if (numberOfColumns < -1 || numberOfColumns > columnSet.size()) {
            throw new IllegalArgumentException(
                    ""count must be between -1 and the current number of columns (""
                            + columnSet.size() + ""): "" + numberOfColumns);
        }
        int currentFrozenColumnState = getState(false).frozenColumnCount;
        /*
         * we remove the current value from the state so that setting frozen
         * columns will always happen after this call. This is so that the value
         * will be set also in the widget even if it happens to seem to be the
         * same as this current value we're setting.
         */
        if (currentFrozenColumnState != numberOfColumns) {
            final String diffStateKey = ""frozenColumnCount"";
            UI ui = getUI();
            if (ui != null) {
                JsonObject diffState = ui.getConnectorTracker()
                        .getDiffState(Grid.this);
                // if diffState is not present, there's nothing for us to clean
                if (diffState != null) {
                    diffState.remove(diffStateKey);
                }
            }
        }
        getState().frozenColumnCount = numberOfColumns;
    }",0
"@Override
  protected ServiceRegistry getServiceRegistry() {
    return serviceRegistry;
  }",0
"private String lockTaskModeToString() {
        switch (mLockTaskModeState) {
            case LOCK_TASK_MODE_LOCKED:
                return ""LOCKED"";
            case LOCK_TASK_MODE_PINNED:
                return ""PINNED"";
            case LOCK_TASK_MODE_NONE:
                return ""NONE"";
            default: return ""unknown="" + mLockTaskModeState;
        }
    }",0
"public static void putShort(long address, short value) {
        PlatformDependent0.putShort(address, value);
    }",0
"public void write(final InputStream inputStream, final RASegmentOutputStream segmentOutputStream) {
        write(inputStream, segmentOutputStream, true);
    }",0
